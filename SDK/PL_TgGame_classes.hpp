#pragma once

// Paladins (5.5) SDK

#ifdef _MSC_VER
	#pragma pack(push, 0x8)
#endif

#include "PL_TgGame_structs.hpp"

namespace SDK
{
//---------------------------------------------------------------------------
//Classes
//---------------------------------------------------------------------------

// Class TgGame.AlienFXManager
// 0x0022 (0x0082 - 0x0060)
class UAlienFXManager : public UObject
{
public:
	unsigned long                                      m_bGood : 1;                                              // 0x0060(0x0004)
	unsigned long                                      m_bLoaded : 1;                                            // 0x0060(0x0004)
	int                                                m_nChestRevealRarity;                                     // 0x0064(0x0004)
	float                                              m_fTransitionTimestamp;                                   // 0x0068(0x0004)
	float                                              m_fTimespan;                                              // 0x006C(0x0004)
	float                                              m_fFrequency;                                             // 0x0070(0x0004)
	struct Fdword                                      m_dwPrimaryColor;                                         // 0x0074(0x0004)
	float                                              m_fDecayLambda;                                           // 0x0078(0x0004)
	float                                              c_fUltHalflife;                                           // 0x007C(0x0004)
	TEnumAsByte<EFXOverlay>                            ePrevOverlay;                                             // 0x0080(0x0001)
	TEnumAsByte<EFXOverlay>                            eCurrOverlay;                                             // 0x0081(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.AlienFXManager");
		return ptr;
	}


	void Reset();
	float Decay(float fLevel, float fLambda);
	float Breathe(float fTime, float fFrequency);
	float STATIC_LongMorph(float fTime, float fFrequency);
	void Tick(float DeltaTime);
	void Start();
	void STATIC_UpdateOverlay(float DeltaTime);
	void SetOverlay(unsigned char Type, bool bAlwaysTimestamp);
	void OnChestOpened(int nRarity);
	void OnMatchConcluded(bool bVictorious);
	void OnMatchOvertime();
	void OnMatchPoint(bool bWon);
	void OnMatchSetup(float fTimeLeft);
	void OnMatchSoon(float fTimeLeft);
	void OnChestOpening();
	void OnChampionUnlocked();
	void STATIC_Close();
	void Initialize();
};


// Class TgGame.OcclusionBuilderVolume
// 0x003C (0x02F8 - 0x02BC)
class AOcclusionBuilderVolume : public AVolume
{
public:
	TArray<struct FOcclusionBuilderSample>             Samples;                                                  // 0x02BC(0x0010) (Transient, NeedCtorLink)
	int                                                ListenerIndex;                                            // 0x02CC(0x0004) (Transient)
	TArray<float>                                      CostGrid;                                                 // 0x02D0(0x0010) (Transient, NeedCtorLink)
	TArray<float>                                      RatioGrid;                                                // 0x02E0(0x0010) (Transient, NeedCtorLink)
	class UAudioLUT*                                   lut;                                                      // 0x02F0(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.OcclusionBuilderVolume");
		return ptr;
	}

};


// Class TgGame.TgAIDirector
// 0x0258 (0x04D8 - 0x0280)
class ATgAIDirector : public AActor
{
public:
	unsigned long                                      m_bActive : 1;                                            // 0x0280(0x0004)
	unsigned long                                      m_bCanAdjustNow : 1;                                      // 0x0280(0x0004)
	unsigned long                                      m_bDisparityDetected : 1;                                 // 0x0280(0x0004)
	unsigned long                                      m_bProlongedDisparityDetected : 1;                        // 0x0280(0x0004)
	unsigned long                                      m_bHasLoweredDifficultyAtTie : 1;                         // 0x0280(0x0004)
	unsigned long                                      m_bFreezeAIDifficulty : 1;                                // 0x0280(0x0004)
	float                                              m_fTimeSinceLastUpdate;                                   // 0x0284(0x0004)
	float                                              m_fLastSkillDisparity;                                    // 0x0288(0x0004)
	int                                                m_iIncreaseTF1Difficulty;                                 // 0x028C(0x0004)
	int                                                m_iIncreaseTF2Difficulty;                                 // 0x0290(0x0004)
	int                                                m_iDisparityDetectionTime;                                // 0x0294(0x0004)
	int                                                m_iTriggerTime;                                           // 0x0298(0x0004)
	int                                                m_iTaskForce1PlayerCount;                                 // 0x029C(0x0004)
	int                                                m_iTaskForce2PlayerCount;                                 // 0x02A0(0x0004)
	float                                              LockoutTime;                                              // 0x02A4(0x0004)
	float                                              SkillDisparityTrigger;                                    // 0x02A8(0x0004)
	float                                              UpdateRate;                                               // 0x02AC(0x0004)
	float                                              m_fLastPayloadPercent;                                    // 0x02B0(0x0004)
	float                                              m_fBaseUpperKillRatio;                                    // 0x02B4(0x0004)
	float                                              m_fBaseLowerKillRatio;                                    // 0x02B8(0x0004)
	float                                              m_fBaseUpperPayloadRate;                                  // 0x02BC(0x0004)
	float                                              m_fBaseLowerPayloadRate;                                  // 0x02C0(0x0004)
	float                                              NumDeaths_Weight;                                         // 0x02C4(0x0004)
	float                                              Damage_Weight;                                            // 0x02C8(0x0004)
	float                                              Kills_Weight;                                             // 0x02CC(0x0004)
	float                                              SoloKills_Weight;                                         // 0x02D0(0x0004)
	float                                              Assists_Weight;                                           // 0x02D4(0x0004)
	float                                              ObjectiveTime_Weight;                                     // 0x02D8(0x0004)
	float                                              Healing_Weight;                                           // 0x02DC(0x0004)
	float                                              Shielding_Weight;                                         // 0x02E0(0x0004)
	float                                              Credits_Weight;                                           // 0x02E4(0x0004)
	float                                              Accuracy_Weight;                                          // 0x02E8(0x0004)
	float                                              Killstreak_Multiplier;                                    // 0x02EC(0x0004)
	float                                              numDeathsBase0;                                           // 0x02F0(0x0004)
	float                                              numDeathsBase1;                                           // 0x02F4(0x0004)
	struct FSkillLevelRawData                          PlayerSkillData[0x2];                                     // 0x02F8(0x0028)
	struct FSkillLevelRawData                          TeamSkillData[0x2];                                       // 0x0348(0x0028)
	struct FSkillLevelRawData                          OldPlayerSkillData[0x2];                                  // 0x0398(0x0028)
	struct FSkillLevelRawData                          OldTeamSkillData[0x2];                                    // 0x03E8(0x0028)
	struct FSkillLevelPercentageData                   SkillPercentages[0x4];                                    // 0x0438(0x0028)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIDirector");
		return ptr;
	}


	void STATIC_UpdateDebugInfo();
	void ReallowAdjustment();
	void STATIC_UpdateBotDifficultyParameters(class ATgAIController_BehaviorGod* TgAI, TEnumAsByte<EBotDifficultyLevel> NewDifficulty);
	bool AdjustDifficulty();
	void CheckDisparity();
	bool CheckParticipation(int tf);
	bool CheckTeamStatsThreshold();
	void PullDataForBot(class ATgPawn* TgP);
	void PullDataForPlayer(class ATgPawn* TgP);
	void PullRawData();
	void STATIC_UpdateDifficulty();
	void STATIC_SetActive(bool NewActive);
	void Tick(float DeltaTime);
	void PostBeginPlay();
	float STATIC_GetDegreeMissedMagnitudeFromConfigSet(int ConfigSetID);
	float STATIC_GetMissLikelihoodFromConfigSet(int ConfigSetID);
	float STATIC_GetLeadAccuracyFromConfigSet(int ConfigSetID);
	int STATIC_GetShieldingForPawn(class ATgPawn* TgP);
	int STATIC_GetObjectiveTimeForPawn(class ATgPawn* TgP);
	int STATIC_GetDamageForPawn(class ATgPawn* TgP);
};


// Class TgGame.TgAimAccelerationCurves
// 0x00A0 (0x0100 - 0x0060)
class UTgAimAccelerationCurves : public UObject
{
public:
	struct FName                                       SettingsName;                                             // 0x0060(0x0008) (Edit)
	float                                              MaxAccelMultiplierX;                                      // 0x0068(0x0004) (Edit)
	float                                              MaxAccelMultiplierY;                                      // 0x006C(0x0004) (Edit)
	struct FRawDistributionFloat                       AimSpeedX;                                                // 0x0070(0x0024) (Edit, Component, NeedCtorLink)
	struct FRawDistributionFloat                       AimAccelX;                                                // 0x0094(0x0024) (Edit, Component, NeedCtorLink)
	struct FRawDistributionFloat                       AimSpeedY;                                                // 0x00B8(0x0024) (Edit, Component, NeedCtorLink)
	struct FRawDistributionFloat                       AimAccelY;                                                // 0x00DC(0x0024) (Edit, Component, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAimAccelerationCurves");
		return ptr;
	}

};


// Class TgGame.TgAimAssistKeyframe
// 0x0030 (0x0090 - 0x0060)
class UTgAimAssistKeyframe : public UObject
{
public:
	struct FName                                       KeyframeName;                                             // 0x0060(0x0008) (Edit)
	struct FRawDistributionFloat                       AimAssistCurve;                                           // 0x0068(0x0024) (Edit, Component, NeedCtorLink)
	unsigned long                                      bMirrored : 1;                                            // 0x008C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAimAssistKeyframe");
		return ptr;
	}

};


// Class TgGame.TgAITaskforceBlockingVolume
// 0x0008 (0x02C4 - 0x02BC)
class ATgAITaskforceBlockingVolume : public AVolume
{
public:
	int                                                BlockTaskforce;                                           // 0x02BC(0x0004) (Edit)
	unsigned long                                      m_bHasRegisteredObstacle : 1;                             // 0x02C0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAITaskforceBlockingVolume");
		return ptr;
	}


	void PostBeginPlay();
	void STATIC_UnRegisterObstacle();
	void STATIC_RegisterObstacle();
};


// Class TgGame.TgAIVolume
// 0x000C (0x02C8 - 0x02BC)
class ATgAIVolume : public AVolume
{
public:
	int                                                LaneIndex;                                                // 0x02BC(0x0004) (Edit)
	int                                                TaskforceIndex;                                           // 0x02C0(0x0004) (Edit)
	unsigned long                                      bEnabled : 1;                                             // 0x02C4(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIVolume");
		return ptr;
	}


	void PostBeginPlay();
	void STATIC_OnToggle(class USeqAct_Toggle* Action);
	struct FVector STATIC_GetRandomPointInAIVolume(float CollisionRadius);
};


// Class TgGame.TgAkActor
// 0x0004 (0x0284 - 0x0280)
class ATgAkActor : public AActor
{
public:
	unsigned long                                      m_bCanCheckOcclusion : 1;                                 // 0x0280(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAkActor");
		return ptr;
	}


	float CheckOcclusion();
};


// Class TgGame.TgAkActorUnoccluded
// 0x0000 (0x0284 - 0x0284)
class ATgAkActorUnoccluded : public ATgAkActor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAkActorUnoccluded");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeBlendByVerticalAim
// 0x0043 (0x0154 - 0x0111)
class UTgAnimNodeBlendByVerticalAim : public UAnimNodeBlendBase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0111(0x0003) MISSED OFFSET
	float                                              m_Aim;                                                    // 0x0114(0x0004) (Edit)
	struct FVector2D                                   m_Range;                                                  // 0x0118(0x0008) (Edit)
	float                                              m_AngleOffset;                                            // 0x0120(0x0004) (Edit)
	float                                              m_PreviousAim;                                            // 0x0124(0x0004) (Transient)
	unsigned long                                      bInitialized : 1;                                         // 0x0128(0x0004) (Transient)
	unsigned long                                      m_bLoopChildrenOnRelevant : 1;                            // 0x0128(0x0004) (Edit)
	unsigned long                                      m_bPlayChildrenOnRelevant : 1;                            // 0x0128(0x0004) (Edit)
	struct FName                                       m_AnimName_Up;                                            // 0x012C(0x0008) (Edit)
	struct FName                                       m_AnimName_Center;                                        // 0x0134(0x0008) (Edit)
	struct FName                                       m_AnimName_Down;                                          // 0x013C(0x0008) (Edit)
	class UAnimNodeSequence*                           m_SeqNode1;                                               // 0x0144(0x0008) (Transient)
	class UAnimNodeSequence*                           m_SeqNode2;                                               // 0x014C(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByVerticalAim");
		return ptr;
	}


	void OnBecomeRelevant();
	void STATIC_PlayAnim(bool bLoop, float Rate, float StartTime);
};


// Class TgGame.TgAnimNotify_CameraCut
// 0x003F (0x00A4 - 0x0065)
class UTgAnimNotify_CameraCut : public UAnimNotify
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0065(0x0003) MISSED OFFSET
	float                                              m_fTweenSpeed;                                            // 0x0068(0x0004) (Edit)
	struct FVector                                     m_vTweenDir;                                              // 0x006C(0x000C) (Edit)
	struct FVector                                     m_vLocationOffset;                                        // 0x0078(0x000C) (Edit)
	struct FRotator                                    m_rRotationOffset;                                        // 0x0084(0x000C) (Edit)
	struct FRotator                                    m_rRotationTarget;                                        // 0x0090(0x000C) (Edit)
	float                                              m_fRotationDuration;                                      // 0x009C(0x0004) (Edit)
	float                                              m_fRotationDelay;                                         // 0x00A0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotify_CameraCut");
		return ptr;
	}

};


// Class TgGame.TgAnimNotify_Disappear
// 0x0003 (0x0068 - 0x0065)
class UTgAnimNotify_Disappear : public UAnimNotify
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0065(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotify_Disappear");
		return ptr;
	}

};


// Class TgGame.TgAnimNotify_SpectatorSlomo
// 0x0003 (0x0068 - 0x0065)
class UTgAnimNotify_SpectatorSlomo : public UAnimNotify
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0065(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotify_SpectatorSlomo");
		return ptr;
	}

};


// Class TgGame.TgPlayerController
// 0x0E50 (0x1628 - 0x07D8)
class ATgPlayerController : public APComPlayerController
{
public:
	struct FPointer                                    VfTable_ITgPaladinsController;                            // 0x07D8(0x0008) (Const, Native, NoExport)
	struct FPointer                                    VfTable_ITgCallbackInterface;                             // 0x07E0(0x0008) (Const, Native, NoExport)
	struct FPointer                                    VfTable_ITgSoundNotifyActorInterface;                     // 0x07E8(0x0008) (Const, Native, NoExport)
	struct FSZombieInfo                                ZombieInfo;                                               // 0x07F0(0x0054)
	int                                                m_nAnnouncerSeriesStep[0x6];                              // 0x0844(0x0004)
	int                                                s_nPlayerId;                                              // 0x085C(0x0004)
	struct FQWord                                      s_qwNetAccessFlags;                                       // 0x0860(0x0008)
	int                                                r_nXp;                                                    // 0x0868(0x0004) (Net)
	int                                                r_nCurrency;                                              // 0x086C(0x0004) (Net)
	float                                              s_fCurrencyRemainder;                                     // 0x0870(0x0004)
	float                                              s_fXpRemainder;                                           // 0x0874(0x0004)
	float                                              s_fCurrencyMult;                                          // 0x0878(0x0004)
	unsigned long                                      r_bCanPurchaseItems : 1;                                  // 0x087C(0x0004) (Net)
	unsigned long                                      r_bAutoPurchase : 1;                                      // 0x087C(0x0004) (Net)
	unsigned long                                      r_bAutoSkillUp : 1;                                       // 0x087C(0x0004) (Net)
	unsigned long                                      r_bToggleZoom : 1;                                        // 0x087C(0x0004) (Net)
	unsigned long                                      s_bAutoBuyOnRespawn : 1;                                  // 0x087C(0x0004)
	unsigned long                                      m_bBlockVGS : 1;                                          // 0x087C(0x0004)
	unsigned long                                      s_bSentAutoKickAlert : 1;                                 // 0x087C(0x0004)
	unsigned long                                      s_bAddDeadTimeStatsTracker : 1;                           // 0x087C(0x0004) (Transient)
	unsigned long                                      c_bHUDHidden : 1;                                         // 0x087C(0x0004)
	unsigned long                                      r_bLockYawRotation : 1;                                   // 0x087C(0x0004) (Net)
	unsigned long                                      bPressingLeftMouseButton : 1;                             // 0x087C(0x0004)
	unsigned long                                      bPressingRightMouseButton : 1;                            // 0x087C(0x0004)
	unsigned long                                      bPressingMovementButton : 1;                              // 0x087C(0x0004)
	unsigned long                                      bPressingReloadButton : 1;                                // 0x087C(0x0004)
	unsigned long                                      m_bPendingReload : 1;                                     // 0x087C(0x0004)
	unsigned long                                      r_bRove : 1;                                              // 0x087C(0x0004) (Net)
	unsigned long                                      m_bNoSmoothedMovementCorrection : 1;                      // 0x087C(0x0004)
	unsigned long                                      c_bProcessedNoSmoothNotification : 1;                     // 0x087C(0x0004)
	unsigned long                                      s_bNoSmoothedMovementCorrectionRequested : 1;             // 0x087C(0x0004)
	unsigned long                                      s_bIsNoSmoothMovementCorrectionManaged : 1;               // 0x087C(0x0004)
	unsigned long                                      s_bClearAchievementIgnoreListsOnNextTick : 1;             // 0x087C(0x0004)
	unsigned long                                      bDebugProjectileLagCompensation : 1;                      // 0x087C(0x0004)
	unsigned long                                      bDebugClientProjectileImpactVerification : 1;             // 0x087C(0x0004)
	unsigned long                                      c_bAssistModeSublevelLoaded : 1;                          // 0x087C(0x0004)
	unsigned long                                      c_bAllowSpecialMaterialEffects : 1;                       // 0x087C(0x0004) (Config, GlobalConfig)
	unsigned long                                      m_bIgnoreSilhouettes : 1;                                 // 0x087C(0x0004) (Transient)
	unsigned long                                      c_bSilhouettesBlocked : 1;                                // 0x087C(0x0004)
	unsigned long                                      m_bForceSilhouettesOnVisibleGods : 1;                     // 0x087C(0x0004) (Transient)
	unsigned long                                      m_bDetailedViewEnabled : 1;                               // 0x087C(0x0004) (Transient)
	unsigned long                                      m_bShowPlayerCircles : 1;                                 // 0x087C(0x0004)
	unsigned long                                      m_bAllowUndrawnPurchase : 1;                              // 0x087C(0x0004)
	unsigned long                                      m_bCanHearStealthPawns : 1;                               // 0x087C(0x0004) (Const)
	unsigned long                                      c_bShowFootstepInfoDebug : 1;                             // 0x0880(0x0004)
	unsigned long                                      m_bDetailedDeviceLogging : 1;                             // 0x0880(0x0004)
	unsigned long                                      m_bOutlineEnemies : 1;                                    // 0x0880(0x0004) (Edit)
	unsigned long                                      m_bOutlineFriendlies : 1;                                 // 0x0880(0x0004) (Edit)
	unsigned long                                      c_bEnablePathfinderGuide : 1;                             // 0x0880(0x0004) (Config)
	unsigned long                                      m_fPathfinderEnabled : 1;                                 // 0x0880(0x0004)
	unsigned long                                      c_bIsPlayingFallWindSound : 1;                            // 0x0880(0x0004)
	unsigned long                                      m_bJustDidJumpDoubleTap : 1;                              // 0x0880(0x0004)
	unsigned long                                      m_bThreatSystemEnabled : 1;                               // 0x0880(0x0004)
	unsigned long                                      m_bOcclusionSystemEnabled : 1;                            // 0x0880(0x0004)
	unsigned long                                      m_bDebugThreatSystem : 1;                                 // 0x0880(0x0004)
	unsigned long                                      c_bMatchAlmostWonSwitchPrimed : 1;                        // 0x0880(0x0004)
	unsigned long                                      m_IsTimeDilationInterpolating : 1;                        // 0x0880(0x0004)
	unsigned long                                      m_IsDesaturationInterpolating : 1;                        // 0x0880(0x0004)
	unsigned long                                      m_bIsTrackingAimTowardTargetLocation : 1;                 // 0x0880(0x0004) (Transient)
	unsigned long                                      bForcedTimelapseRequested : 1;                            // 0x0880(0x0004)
	unsigned long                                      bForcedPlayOfGameRequested : 1;                           // 0x0880(0x0004)
	unsigned long                                      m_bRewindMoversForReplaySavedMoves : 1;                   // 0x0880(0x0004)
	unsigned long                                      m_bShowDebugRewindMovers : 1;                             // 0x0880(0x0004)
	unsigned long                                      c_bCaptureProgressAkEventPlaying : 1;                     // 0x0880(0x0004)
	unsigned long                                      m_bShowChampionOverviewTip : 1;                           // 0x0880(0x0004)
	unsigned long                                      m_bEnableUltimateAkEventUnocclusion : 1;                  // 0x0880(0x0004) (Config)
	unsigned long                                      c_bIsPlayOfTheGame : 1;                                   // 0x0880(0x0004)
	unsigned long                                      m_bHideReticle : 1;                                       // 0x0880(0x0004)
	unsigned long                                      m_bHideReticleAcc : 1;                                    // 0x0880(0x0004)
	unsigned long                                      m_bSupportsEffectSimulation : 1;                          // 0x0880(0x0004)
	unsigned long                                      m_bForced3pOption : 1;                                    // 0x0880(0x0004)
	unsigned long                                      c_bForced3pFreeCam : 1;                                   // 0x0880(0x0004)
	float                                              c_fLastGoldNagTime;                                       // 0x0884(0x0004)
	int                                                m_nReviveBuybackCost;                                     // 0x0888(0x0004)
	int                                                r_nStatPoints;                                            // 0x088C(0x0004) (Net)
	struct FFLOOD                                      s_VGSFlood;                                               // 0x0890(0x0008)
	struct FFLOOD                                      s_PingFlood;                                              // 0x0898(0x0008)
	class AActor*                                      c_aLastViewTarget;                                        // 0x08A0(0x0008)
	class UTgPlayerInput*                              m_CachedPlayerInput;                                      // 0x08A8(0x0008)
	class UTgSpectatorInput*                           m_CachedSpectatorInput;                                   // 0x08B0(0x0008)
	class AActor*                                      m_aHoverActor;                                            // 0x08B8(0x0008)
	struct FVector                                     m_vHoverLocation;                                         // 0x08C0(0x000C)
	float                                              m_fHoverActorActiveTime;                                  // 0x08CC(0x0004)
	struct FVector                                     m_vWorldMapLocation;                                      // 0x08D0(0x000C)
	TArray<class AReplicationInfo*>                    m_WorldMapTargetRepInfos;                                 // 0x08DC(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	struct FVector                                     m_vWorldMouseLocation;                                    // 0x08EC(0x000C) (Transient)
	struct FVector                                     m_vWorldMouseDirection;                                   // 0x08F8(0x000C) (Transient)
	float                                              c_fTimeTillAFK;                                           // 0x0904(0x0004)
	float                                              s_bAutoKickStartTime;                                     // 0x0908(0x0004)
	struct FTG_LAST_PURCHASE                           r_LastPurchasedItems[0x1A];                               // 0x090C(0x0008) (Net)
	class APawn*                                       s_LastPossessedPawn;                                      // 0x09DC(0x0008)
	float                                              m_fRecentLostHealth;                                      // 0x09E4(0x0004)
	float                                              m_fLastLostHealthTime;                                    // 0x09E8(0x0004)
	float                                              s_fWaitForSpawnSecs;                                      // 0x09EC(0x0004)
	float                                              c_fRespawnTime;                                           // 0x09F0(0x0004)
	float                                              m_fDeathTime;                                             // 0x09F4(0x0004)
	int                                                r_bInputEnabled[0x14];                                    // 0x09F8(0x0004) (Net)
	class UTgControlModule*                            ControlModule;                                            // 0x0A48(0x0008) (Edit, EditInline)
	class UClass*                                      DefaultControlModuleClass;                                // 0x0A50(0x0008)
	int                                                c_nCameraYawOffset;                                       // 0x0A58(0x0004)
	int                                                m_nDevicesLockingInput;                                   // 0x0A5C(0x0004)
	int                                                m_nDevicesLockingCamera;                                  // 0x0A60(0x0004)
	int                                                m_nDevicesLockingRotation;                                // 0x0A64(0x0004)
	float                                              m_fPendingReloadTime;                                     // 0x0A68(0x0004)
	float                                              m_fPendingReloadMaxTime;                                  // 0x0A6C(0x0004)
	class AActor*                                      m_EndGameFocus;                                           // 0x0A70(0x0008) (Transient)
	float                                              m_fLastVGS;                                               // 0x0A78(0x0004)
	struct FVector                                     m_vLastServerCorrectOrigPos;                              // 0x0A7C(0x000C)
	float                                              s_fLastConfirmedSentSmoothedMovementTimestamp;            // 0x0A88(0x0004)
	float                                              c_fLastRecievedNoSmoothTimestamp;                         // 0x0A8C(0x0004)
	unsigned char                                      m_byDesiredMoveSpeedReduction;                            // 0x0A90(0x0001)
	TEnumAsByte<ETG_CAMERAPOSTURE>                     c_eCameraPosture;                                         // 0x0A91(0x0001)
	TEnumAsByte<EWatchOtherPlayersMode>                r_WatchOtherPlayer;                                       // 0x0A92(0x0001) (Net)
	TEnumAsByte<EGAME_WIN_STATE>                       c_GameWinState;                                           // 0x0A93(0x0001)
	unsigned char                                      m_bOldbRun;                                               // 0x0A94(0x0001)
	TEnumAsByte<EHUDOverlay>                           c_eCurrentOverlay;                                        // 0x0A95(0x0001)
	TEnumAsByte<ETG_EQUIP_POINT>                       m_eDetailedDeviceEqp;                                     // 0x0A96(0x0001)
	TEnumAsByte<ETG_EQUIP_POINT>                       m_LastEquipPoint;                                         // 0x0A97(0x0001)
	unsigned char                                      c_LastSentClientRoll;                                     // 0x0A98(0x0001) (Transient)
	unsigned char                                      m_UltHeld;                                                // 0x0A99(0x0001) (Input)
	unsigned char                                      m_JumpHeld;                                               // 0x0A9A(0x0001) (Input)
	unsigned char                                      m_JumpHeldAlt;                                            // 0x0A9B(0x0001) (Input)
	unsigned char                                      m_PerCharacterAlt;                                        // 0x0A9C(0x0001) (Input)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0A9D(0x0003) MISSED OFFSET
	TArray<struct FCameraStackInfo>                    c_CameraStack;                                            // 0x0AA0(0x0010) (NeedCtorLink)
	int                                                c_nNextCameraStackId;                                     // 0x0AB0(0x0004)
	float                                              c_fDeathCamViewKillerDuration;                            // 0x0AB4(0x0004) (Const)
	float                                              m_fWatchOthersFadeToBlackCamTime;                         // 0x0AB8(0x0004) (Edit, Const)
	float                                              m_fWatchOthersFadeFromBlackCamTime;                       // 0x0ABC(0x0004) (Edit, Const)
	TArray<class UTgAchievement*>                      s_Achievements;                                           // 0x0AC0(0x0010) (NeedCtorLink)
	TArray<class UTgAchievement*>                      s_TickableAchievements;                                   // 0x0AD0(0x0010) (NeedCtorLink)
	class UTgAkAudioManagement*                        c_TgAkAudio;                                              // 0x0AE0(0x0008)
	int                                                r_nFlashProjectile[0x20];                                 // 0x0AE8(0x0004) (Net)
	struct FsSimProjectileFireInfo                     r_FlashProjectileEx[0x20];                                // 0x0B68(0x0040) (Net)
	int                                                r_nFirstValidProjIdx;                                     // 0x1368(0x0004) (Net)
	int                                                r_nFlashSimProjIdx;                                       // 0x136C(0x0004) (Net)
	int                                                c_nLastFlashSimProjIdx;                                   // 0x1370(0x0004)
	int                                                r_nPerkPointsAvail;                                       // 0x1374(0x0004) (Net)
	class ATgGameTipManager*                           c_GameTipManager;                                         // 0x1378(0x0008) (Transient)
	struct FPointer                                    s_pCombatMessages;                                        // 0x1380(0x0008) (Native)
	float                                              s_fLastCombatMessageProcess;                              // 0x1388(0x0004)
	int                                                c_nCurrentLevel;                                          // 0x138C(0x0004)
	class UTgTutorialAnnouncer*                        c_TutorialAnnouncer;                                      // 0x1390(0x0008)
	int                                                r_TutorialBlockedClientActions;                           // 0x1398(0x0004) (Net)
	class UTgSubtitledMessages*                        c_SubtitledMessages;                                      // 0x139C(0x0008)
	TArray<struct FDefaultAudioSwitch>                 c_DefaultSwitchValues;                                    // 0x13A4(0x0010) (Config, GlobalConfig, NeedCtorLink)
	class ATgRepInfo_Player*                           CachedPRI;                                                // 0x13B4(0x0008) (Transient)
	class UMaterialInstanceConstant*                   m_OverlayPathMaterial;                                    // 0x13BC(0x0008)
	TArray<class ATgPawn*>                             m_HiddenPawns;                                            // 0x13C4(0x0010) (NeedCtorLink)
	class UAudioComponent*                             c_AlertAudioComponent;                                    // 0x13D4(0x0008) (ExportObject, Component, EditInline)
	class UAkEvent*                                    c_AlertAkEvent;                                           // 0x13DC(0x0008)
	float                                              c_fDeathCamTurnToKillerInterpDuration;                    // 0x13E4(0x0004)
	float                                              c_fDeathCamDesaturationInterpDuration;                    // 0x13E8(0x0004)
	float                                              c_fDeathCamDesaturation;                                  // 0x13EC(0x0004)
	float                                              c_fDeathCamCanSkipDelay;                                  // 0x13F0(0x0004)
	TArray<class UTgObjectReferencer*>                 c_KismetLoadedDevices;                                    // 0x13F4(0x0010) (NeedCtorLink)
	class UTgCameraShake*                              m_PreviewCameraShake;                                     // 0x1404(0x0008) (Edit, EditInline)
	TArray<class ATgChaosCapturePoint*>                m_CapturePoints;                                          // 0x140C(0x0010) (NeedCtorLink)
	float                                              m_fPathfinderStreamTime;                                  // 0x141C(0x0004) (Edit)
	float                                              m_fPathfinderPulseTime;                                   // 0x1420(0x0004) (Edit)
	float                                              m_fPathfinderLifetime;                                    // 0x1424(0x0004) (Edit)
	float                                              m_fPathfinderSpeed;                                       // 0x1428(0x0004) (Edit)
	float                                              m_fPathfinderStartDist;                                   // 0x142C(0x0004) (Edit)
	float                                              c_LastSentMoveTimeStamp;                                  // 0x1430(0x0004) (Transient)
	struct FVector                                     c_LastSentMoveAcceleration;                               // 0x1434(0x000C) (Transient)
	int                                                c_LastSentMoveCompressedFlags;                            // 0x1440(0x0004) (Transient)
	struct FVector                                     c_LastSentClientLoc;                                      // 0x1444(0x000C) (Transient)
	int                                                c_LastSentView;                                           // 0x1450(0x0004) (Transient)
	class UAkEvent*                                    c_FallWindSoundPlay;                                      // 0x1454(0x0008)
	class UAkEvent*                                    c_FallWindSoundStop;                                      // 0x145C(0x0008)
	int                                                m_nKillCamTargetId;                                       // 0x1464(0x0004) (Transient)
	int                                                m_nKillCamTargetBackupId;                                 // 0x1468(0x0004) (Transient)
	float                                              r_fServerTimeStamp;                                       // 0x146C(0x0004) (Net)
	float                                              m_fLastJumpTapTime;                                       // 0x1470(0x0004)
	float                                              m_fMaxJumpDoubleTapTime;                                  // 0x1474(0x0004)
	TArray<class ATgPawn*>                             m_PawnsWithThreatLevels;                                  // 0x1478(0x0010) (NeedCtorLink)
	class ATgPathfinder*                               m_Pathfinder;                                             // 0x1488(0x0008)
	float                                              m_fThreatCoefficientProximity;                            // 0x1490(0x0004) (Config)
	float                                              m_fThreatCoefficientOcclusion;                            // 0x1494(0x0004) (Config)
	float                                              m_fThreatCoefficientBinnedOcclusion;                      // 0x1498(0x0004) (Config)
	float                                              m_fThreatCoefficientUlt;                                  // 0x149C(0x0004) (Config)
	float                                              m_fThreatCoefficientShotAt;                               // 0x14A0(0x0004) (Config)
	float                                              m_fThreatCoefficientSeenBy;                               // 0x14A4(0x0004) (Config)
	float                                              m_fThreatCoefficientDamaged;                              // 0x14A8(0x0004) (Config)
	float                                              m_fThreatCoefficientFocused;                              // 0x14AC(0x0004) (Config)
	float                                              m_fThreatCoefficientFocusTarget;                          // 0x14B0(0x0004) (Config)
	float                                              m_fThreatCoefficientBehind;                               // 0x14B4(0x0004) (Config)
	float                                              m_fThreatCoefficientInEffectiveRange;                     // 0x14B8(0x0004) (Config)
	float                                              m_fThreatDecayCoefficientShotAt;                          // 0x14BC(0x0004) (Config)
	float                                              m_fThreatDecayCoefficientSeenBy;                          // 0x14C0(0x0004) (Config)
	float                                              m_fThreatDecayCoefficientUlt;                             // 0x14C4(0x0004) (Config)
	struct FString                                     m_DebugThreatSystemChannel;                               // 0x14C8(0x0010) (NeedCtorLink)
	float                                              m_fFFBDamageFloor;                                        // 0x14D8(0x0004) (Config)
	float                                              m_fFFBDamageCeiling;                                      // 0x14DC(0x0004) (Config)
	float                                              m_fFFBIntensityFloor;                                     // 0x14E0(0x0004) (Config)
	float                                              m_fFFBIntensityCeiling;                                   // 0x14E4(0x0004) (Config)
	float                                              m_fFFBDurationFloor;                                      // 0x14E8(0x0004) (Config)
	float                                              m_fFFBDurationCeiling;                                    // 0x14EC(0x0004) (Config)
	class UForceFeedbackWaveform*                      m_TakeDamageWaveform;                                     // 0x14F0(0x0008)
	struct FString                                     m_CurrentMusicEventName;                                  // 0x14F8(0x0010) (NeedCtorLink)
	struct FName                                       m_nameBuyBurnCardsTimer;                                  // 0x1508(0x0008)
	struct FVector2D                                   m_TimeDilationFromTo;                                     // 0x1510(0x0008)
	float                                              m_TimeDilationInterpolateSeconds;                         // 0x1518(0x0004)
	float                                              m_TimeDilationUsedSeconds;                                // 0x151C(0x0004)
	struct FVector2D                                   m_DesaturationFromTo;                                     // 0x1520(0x0008)
	float                                              m_DesaturationInterpolateSeconds;                         // 0x1528(0x0004)
	float                                              m_DesaturationUsedSeconds;                                // 0x152C(0x0004)
	int                                                m_EnergyLastFrame;                                        // 0x1530(0x0004)
	struct FVector                                     m_TrackingTargetLocation;                                 // 0x1534(0x000C) (Transient)
	float                                              m_fTrackingTargetMaxAimDistDiff;                          // 0x1540(0x0004) (Transient)
	class UAkBaseSoundObject*                          m_RoundEndAlert;                                          // 0x1544(0x0008)
	TArray<struct FAnnouncerEvent>                     m_akAnnouncerQueue;                                       // 0x154C(0x0010) (NeedCtorLink)
	float                                              m_fTimeToPlayQueuedAnnouncer;                             // 0x155C(0x0004)
	class USeqAct_Interp*                              m_CurrentDirectorMatinee;                                 // 0x1560(0x0008)
	class UAkEvent*                                    m_CaptureProgressPlayAkEvent;                             // 0x1568(0x0008)
	class UAkEvent*                                    m_CaptureProgressStopAkEvent;                             // 0x1570(0x0008)
	float                                              m_fCachedCaptureProgress;                                 // 0x1578(0x0004)
	class UAkEvent*                                    m_PointGettingCapturedPlayAkEvent;                        // 0x157C(0x0008)
	int                                                m_nPointGettingCapturedPlayCount;                         // 0x1584(0x0004)
	float                                              m_fShowChampionOverviewTipDelay;                          // 0x1588(0x0004)
	int                                                s_nRoundsIdle;                                            // 0x158C(0x0004)
	float                                              s_fIdleTimeReduction;                                     // 0x1590(0x0004)
	int                                                c_nLeadingTeam;                                           // 0x1594(0x0004)
	int                                                c_nLeadingTeamTicketAmount;                               // 0x1598(0x0004)
	class UTgCallbackContainer*                        m_CallbackContainer;                                      // 0x159C(0x0008)
	int                                                m_nReticleColorOverride;                                  // 0x15A4(0x0004)
	struct FLinearColor                                m_cReticleColor;                                          // 0x15A8(0x0010)
	float                                              m_fAchievementPollRate;                                   // 0x15B8(0x0004)
	float                                              m_fAchievementPollElapsed;                                // 0x15BC(0x0004)
	int                                                s_nTeamMateHealMeVisibilityTest;                          // 0x15C0(0x0004)
	float                                              c_fForced3pFOV;                                           // 0x15C4(0x0004)
	float                                              c_fForced3pFreeCamEaseOutDuration;                        // 0x15C8(0x0004)
	float                                              c_fForced3pFreeCamEaseOutTimer;                           // 0x15CC(0x0004)
	struct FRotator                                    c_rForced3pFreeCamEaseOutStartRotation;                   // 0x15D0(0x000C)
	struct FVector                                     m_vLastPOVLocation;                                       // 0x15DC(0x000C)
	struct FRotator                                    m_rLastPOVRotation;                                       // 0x15E8(0x000C)
	class UTgChampionTickManager*                      c_ChampionTickManager;                                    // 0x15F4(0x0008)
	class UTgSoundEventsManager*                       c_SoundEventsManager;                                     // 0x15FC(0x0008)
	TArray<class ATgMapCalloutVolume*>                 c_OccupiedMapCalloutVolumes;                              // 0x1604(0x0010) (NeedCtorLink)
	struct FString                                     m_sLastSelectedStoreProductSKU;                           // 0x1614(0x0010) (NeedCtorLink)
	int                                                m_nLastSelectedStoreLootID;                               // 0x1624(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPlayerController");
		return ptr;
	}


	void STATIC_RemoveOccupiedMapCalloutVolume(class ATgMapCalloutVolume* MapCalloutVolume);
	void STATIC_SetOccupiedMapCalloutVolume(class ATgMapCalloutVolume* MapCalloutVolume);
	void PlayFogHorn();
	void ServerRequestRelease();
	void ServerRequestWaypoint(const struct FVector& vLocation);
	bool IsForceFeedbackAllowed();
	void SetPhysicsWeight(float Amount);
	void STATIC_EnablePhysics(bool bEnabled);
	void SetReticleRainbow(bool bSetActive);
	void SetReticleColor(float R, float G, float B, float A);
	void ClientDrawDebugSphere(float X, float Y, float Z, float Radius, int Segments, unsigned char R, unsigned char G, unsigned char B);
	void ClientDrawDebugBox(float X, float Y, float Z, float extX, float extY, float extZ, unsigned char R, unsigned char G, unsigned char B);
	void ClientDrawDebugLine(float X, float Y, float Z, float X2, float Y2, float z2, unsigned char R, unsigned char G, unsigned char B);
	void STATIC_Unfix(const struct FName& BoneName);
	void STATIC_FixAll();
	void ResetCaptureProgressRTPC();
	void STATIC_LogLocalPropertyValue(int nPropId);
	void SetServerCorrectionCameraInterpVars(float SnapDist, float MinBaseSpeed, float MaxBaseSpeed, float BaseSpeedMult, float NewInfoWeight, float MinCorrectionMod, float MaxCorrectionMod, float CorrectionModMult);
	void ToggleCaptureProgressAkEvent(bool bEnable);
	void ClientDeactivateDefendersSpawnGates();
	void ClientDeactivateAttackersSpawnGates();
	void ClientToggleSpawnGateTeamColors();
	void ClientDeactivateSpawnGates();
	void ClientActivateSpawnGates();
	void ResetUlt();
	void SetCredits(int nCreditsAmount);
	int STATIC_GetCredits();
	void ClientUpdateTF2Score(int nScore);
	void ClientUpdateTF1Score(int nScore);
	void OnBurnCardPurchased(class ATgDevice* BurnCard, int nEquipSlot, int nFilledCardSlots);
	void SetAllInputAllowed(bool bEnabled);
	void SendEnergyUpdatedEvent();
	void STATIC_HideMeshes(bool bHide1PMesh, bool bHide3PMesh);
	bool IsPlayerDead();
	void BuyBurnCards();
	void ClientStartBuyBurnCardsTimer();
	void StartBuyBurnCardsTimer();
	void STATIC_ExecSetViewportLocationAndScale(float OriginX, float OriginY, float SizeX, float SizeY);
	void SetViewportLocationAndScale(const struct FVector2D& InOrigin, const struct FVector2D& InSize);
	void STATIC_PlayCameraAnim(class UCameraAnim* CamAnim, float Rate, float Scale, float BlendInTime, float BlendOutTime, bool bLoop, bool bRandomStartTime, float Duration, bool bSingleInstance);
	void ClientAckGoodMove(float TimeStamp);
	void ClientAckGoodMoveNoInterp(float TimeStamp);
	void STATIC_VeryShortClientAdjustPosition(float TimeStamp, float NewLocX, float NewLocY, float NewLocZ, class AActor* NewBase);
	void STATIC_VeryShortClientAdjustPositionNoInterp(float TimeStamp, float NewLocX, float NewLocY, float NewLocZ, class AActor* NewBase);
	void STATIC_ShortClientAdjustPosition(float TimeStamp, const struct FName& NewState, TEnumAsByte<EPhysics> newPhysics, float NewLocX, float NewLocY, float NewLocZ, class AActor* NewBase);
	void STATIC_ShortClientAdjustPositionNoInterp(float TimeStamp, const struct FName& NewState, TEnumAsByte<EPhysics> newPhysics, float NewLocX, float NewLocY, float NewLocZ, class AActor* NewBase);
	void ClientAdjustPosition(float TimeStamp, const struct FName& NewState, TEnumAsByte<EPhysics> newPhysics, float NewLocX, float NewLocY, float NewLocZ, float NewVelX, float NewVelY, float NewVelZ, class AActor* NewBase);
	void ClientAdjustPositionNoInterp(float TimeStamp, const struct FName& NewState, TEnumAsByte<EPhysics> newPhysics, float NewLocX, float NewLocY, float NewLocZ, float NewVelX, float NewVelY, float NewVelZ, class AActor* NewBase);
	void LongClientAdjustPosition(float TimeStamp, const struct FName& NewState, TEnumAsByte<EPhysics> newPhysics, float NewLocX, float NewLocY, float NewLocZ, float NewVelX, float NewVelY, float NewVelZ, class AActor* NewBase, float NewFloorX, float NewFloorY, float NewFloorZ);
	void LongClientAdjustPositionNoInterp(float TimeStamp, const struct FName& NewState, TEnumAsByte<EPhysics> newPhysics, float NewLocX, float NewLocY, float NewLocZ, float NewVelX, float NewVelY, float NewVelZ, class AActor* NewBase, float NewFloorX, float NewFloorY, float NewFloorZ);
	void RecievedServerMovement(float TimeStamp, bool bNoInterp);
	void ServerAckNoSmoothCorrection(float TimeStamp);
	void SendClientAdjustment();
	void SetNoSmoothedMovementCorrection(bool bNoSmoothedCorrections, bool bManaged);
	bool STATIC_ShouldInterpolateMovementCorrections();
	void STATIC_SavePositionForSmoothServerCorrection();
	void UpdateClientFOV();
	void ClientSendPayloadMissionEvent(int nEventId, unsigned char nAttackingTaskForce, unsigned char nWinningTaskForce);
	void ShowHit(class AActor* Target, int nDeviceId, float DamageAmount, struct FExtraDamageInfo* ExtraInfo);
	void ClientOnScoredPoints(int nValue, TEnumAsByte<ERewardValueType> eType, int nPlayerId);
	void STATIC_FireDebugConsoleKismetTestNode();
	void DebugDisableAllAI();
	void DebugEnableAllAI();
	void DebugNextPlayerStart();
	void SetBlur(float TargetBlurAmount, float InterpSpeed, float BlurKernelSize);
	void TestHelpTip(int HelpTipId);
	void ClientRequestHelpText(int HelpTipId);
	class AActor* STATIC_GetPathfinderTarget();
	struct FVector STATIC_GetPathfinderStartLocation(float StartDist);
	void SpawnPathfinder();
	void ShowPathfinder(bool bEnabled, float interval);
	void STATIC_OnControllerChanged(int ControllerId, bool bIsConnected, bool bPauseGame);
	void ClientPlayTakeoverSecondPhaseInstructions(bool bFriendlyCapture);
	void ClientPlayPointCapturedEffects(class ATgChaosCapturePoint* CapturedPoint, bool bFriendlyCapture);
	void OpenUpgradeMenuTimer();
	void TorvaldCheck();
	void ClientOnRoundSetupStarted(bool bForceOpenCardMenu);
	void SetDesaturation(float DesiredDesaturation, float SecondsToInterpolate);
	void SetTimeDilation(float DesiredDilation, float SecondsToInterpolate);
	void ClientOnRoundObjectivesCompleted();
	void STATIC_ClientRoundEnding();
	void ClientOnRoundEnded();
	void ClientUpdateRoundSetupTimer(float SetupTimeRemaining);
	void ClientUpdateRoundEndedTimer(float RoundEndTimeRemaining, float RoundEndTotalTime);
	void ServerSetJumpZ(float NewJumpZ);
	void STATIC_SetJumpZ(float NewJumpZ);
	void SetOutlines(bool bFriendly, bool bEnemy);
	void FrontFacingCamera(bool bEnabled);
	void OnCardSelection(class ATgDevice* pDevice);
	void OnDeckUpdatedOnServer(int nBotId, int nDeckId);
	void ServerRequestDeckAndTalent(int nTalentId, int nDeckId, bool bTemplateDeck);
	void ClientChangedDeck(int nBotId, int nDeckId);
	void ClientChangedTalent(int nBotId, int nDeviceId);
	void ClientChangedPassive(int nBotId, int nDeviceId);
	void ServerRequestPassive(int nPassiveId);
	void ServerRequestCard(int nDeviceId, int nRank);
	void ServerAutoMelee(bool bEnabled);
	void AutoMelee(bool bEnabled);
	void ServerSetServerFlags(bool bSprint, bool bMinimapTeamVisibility, float DamageMultiplier, bool bForce3P, bool bForce1P, bool bOutOfCombatSprint);
	void SetServerFlags(bool bSprint, bool bMinimapTeamVisibility, float DamageMultiplier, bool bForce3P, bool bForce1P, bool bOutOfCombatSprint);
	void SSF(bool bSprint, bool bMinimapTeamVisibility, float DamageMultiplier, bool bForce3P, bool bForce1P, bool bOutOfCombatSprint);
	void ReloadWeaponWithFlourish();
	void ReloadWeapon();
	void STATIC_LetGoReloadWeapon();
	void ClientSetForced3p(bool b3pEnabled);
	void ServerNotifyClient3p(bool b3pEnabled);
	void SetForced3pFreeCam(bool bEnabled);
	void ToggleSprint();
	void OnJumpHeldAltPressed();
	void OnJumpRelease();
	void STATIC_HoldJump();
	void DoJump();
	void ClientPlayRoadkillNotify();
	void PlayEpicFatality(unsigned char TaskForceNumber, int MeshAsmId);
	void ToggleDetailedView();
	bool IsPawnWithin(class APawn* aPawn, float Distance);
	void SetCommandBindPC(bool bSpectator, bool bGamepad, int nAlternate, const struct FString& ExtendedBinding, const struct FString& Command);
	void SetBindPC(bool bSpectator, const struct FString& ExtendedBinding, const struct FString& Command);
	void STATIC_UnbindCommandAllPC(bool bSpectator, const struct FString& Command);
	void STATIC_UnbindCommandPC(bool bSpectator, bool bGamepad, int nAlternate, const struct FString& Command);
	class UTgSpectatorInput* GetSpectatorInputClass();
	class UTgPlayerInput* GetPlayerInputClass();
	void RemoveAdditionalPostProcess(class UPostProcessChain* PP, class ATgPawn* OtherDepthTarget);
	void STATIC_InsertAdditionalPostProcess(class UPostProcessChain* PP, bool bAlterMeshDepth, class ATgPawn* OtherDepthTarget);
	void STATIC_ToggleOverlays();
	void STATIC_IgnoreOverlays(bool bIgnore);
	void OnScoreChange(int nTeam);
	void ArenaCrowdEvent(unsigned char EventType);
	void ServerDropFlag();
	void DropFlag();
	void PlayTutorialAnnouncement(int SoundIndex, class USoundCue* OptionalCue, bool bPlayImmediately, bool bFlushOthers);
	void ServerToggleAIDebug(class AActor* Target);
	void ServerRequestScoreBoard();
	void ResetGameTips();
	void SuppressHelpText();
	void RequestScoreBoard();
	void UpdateLockedTarget(class AActor* LockedActor);
	void ServerSurrender(bool bSurrender);
	void ClientSurrender(bool bSurrender);
	void ClientPlayPing(float X, float Y, float Z, TEnumAsByte<EPING_TYPE> pingType);
	void ClientPlayVGS(int nId, int usedVPSetting);
	bool OnInstantCastOffhandSlotPressed(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	bool OnQuickCastOffhandSlotReleased(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	bool OnQuickCastOffhandSlotPressed(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	bool OnDefaultCastOffhandSlotReleased(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	bool OnDefaultCastOffhandSlotPressed(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	void OnPerCharacterAltPressed();
	void OnFlourish();
	void OnRespawnBeaconButtonReleased();
	void OnRespawnBeaconButtonPressed();
	void DeviceOnStopFire(class ATgDevice* Device, bool WasInterrupted);
	void DeviceOnStartFire(class ATgDevice* Device);
	void DeviceOnStopBuildup(class ATgDevice* Device, bool WasInterrupted);
	void DeviceOnStartBuildup(class ATgDevice* Device);
	void AllocateAbilitySkillPoint(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	void OnGiveFullVitals(class UTgSeqAct_GiveFullVitals* inAction);
	void ClientTutorialHighlighter(bool bShow, int highlightedElement);
	void ClientForceTutorialAction(int Action, int ActionElement);
	void OnTutorialHighlighter(class UTgSeqAct_TutorialHighlighter* inAction);
	void OnForceClientTutorialAction(class UTgSeqAct_ForceClientTutorialAction* inAction);
	void ClientNotifyTutorialUIEvent(int Evt, int evtData);
	void ServerNotifyTutorialUIEvent(int Evt, int evtData);
	void OnTutorialPlayerAction(class UTgSeqAct_LogTutorialAction* inAction);
	void TestShake(int Index);
	void StopTgCameraShake(class UTgCameraShake* CameraShake);
	void PlayTgCameraShake(class UTgCameraShake* CameraShake, const struct FVector& Epicenter, class AActor* ShakeInstigator);
	void TestTgCameraShake(class UTgCameraShake* CameraShake);
	void OnTgCameraShake(class UTgSeqAct_TgCameraShake* inAction);
	void Cloth(bool bEnabled);
	void STATIC_DoFade(bool bInToGameplay, float Time);
	void OnClientLoadDevices(class UTgSeqAct_ClientLoadDevices* Action);
	void ClientSetCameraMode(const struct FName& NewCamMode);
	void STATIC_ServerCamera(const struct FName& NewMode);
	void Camera(const struct FName& NewMode);
	void ClientCheatFly(bool bOn);
	void CheatFly(bool bOn);
	void ServerUpdateStats();
	bool CanCommunicate();
	void STATIC_SpeakTTS(const struct FString& S, class APlayerReplicationInfo* PRI);
	void STATIC_DumpClassInfo(const struct FString& sClassName);
	void TestCrash();
	bool CanPlayerMove(class APawn* P);
	class ATgRepInfo_TaskForce* STATIC_GetTFRI();
	void ServerCycleTeammateView(bool bForward);
	void STATIC_ViewPreviousTeammate();
	void STATIC_ViewNextTeammate();
	void SkipKillCam();
	void ServerSkipKillCam();
	void STATIC_ForceKillCamViewTargetChange(class AActor* ForceTarget);
	void ClearKillCamTarget();
	void ClientSetKillCamTarget(int KillCamTargetId, int BackupKillCamTargetId);
	void SetKillCamTarget(class ATgPawn* KillCamTarget);
	void ServerKillCurrentDirectorMatinee();
	void ClientKillCurrentDirectorMatinee();
	void NotifyDirectorControl(bool bNowControlling, class USeqAct_Interp* CurrentMatinee, float fFadeTime);
	void DestroySimulatedProjectiles();
	void ControllerPostTimeLapse();
	void ControllerPreTimeLapse();
	void StartPlayOfGamePlayback();
	void StartPlayOfTheGamePlaybackDelayed();
	void ServerStartTimelapse(float Begin, float End, bool bPlayOfGame, bool bForced);
	void StartTimelapse(float Begin, float End, bool bPlayOfGame, bool bForced);
	void ServerStorePlayOfGame(float Begin, float End);
	void StorePlayOfGame(float Begin, float End);
	void STATIC_GetServerValue(const struct FString& strObject, const struct FString& strVariable);
	void STATIC_GetClientValue(const struct FString& strObject, const struct FString& strVariable);
	void SetServerValue(const struct FString& strObject, const struct FString& strVariable, const struct FString& StrValue);
	void SetClientValue(const struct FString& strObject, const struct FString& strVariable, const struct FString& StrValue);
	void ServerGetValue(const struct FString& strObject, const struct FString& strVariable);
	void ClientGetValue(const struct FString& strObject, const struct FString& strVariable);
	void ServerSetValue(const struct FString& strObject, const struct FString& strVariable, const struct FString& StrValue);
	void ClientSetValue(const struct FString& strObject, const struct FString& strVariable, const struct FString& StrValue);
	void ServerKillPets();
	void STATIC_KillPets();
	void ServerGotoFly();
	void STATIC_GotoFly();
	void StunTypeChanged();
	void Stun(bool bStunController, TEnumAsByte<EStunType> eType);
	void ClientResetStunnedBehavior(bool bStunController, TEnumAsByte<EStunType> eType);
	bool ShouldStunChangePhysics();
	void OnRestartPlayers(class UTgSeqAct_RestartPlayers* inAction);
	bool ClientPerformedUseAction();
	bool ServerPerformedUseAction();
	void ClientUse();
	void STATIC_ServerUse();
	bool CanUseNow();
	void UpdateReviveTimeRemaining(float fTimeRemaining);
	void STATIC_ViewObjectiveCamerasTimer();
	struct FName GetStateNameEx();
	void ReplicatedEvent(const struct FName& VarName);
	void UpdateFirstValidProjIdx();
	void OnCanPurchaseItemChange();
	void PawnDied(class APawn* P);
	void ClientSetReadyState(bool bReadyToPlay);
	void ServerSetReadyToPlay();
	void SetReadyToPlay();
	void NotifyJumpApex();
	void STATIC_UpdateAssistModeSubLevel();
	void STATIC_EnableColorBlindEffect(bool bEnable, int Type, float Intensity);
	void OnSettingsChanged(class UTgClientSettings* Settings, int settingsType);
	void ReceivedPlayer();
	void OnCameraPostureChange();
	bool PopCameraPosture(int nStackId);
	int PushCameraPosture(TEnumAsByte<ETG_CAMERAPOSTURE> eCamPosture);
	void SwitchCamera(const struct FString& sCamera);
	void SwitchControl(class UClass* ControlModuleClass);
	void PostBeginPlay();
	void ShowChampionOverviewTip();
	void ServerToggleSceneCaptureState();
	int STATIC_GetCurrentDeviceType();
	TEnumAsByte<ETG_EQUIP_POINT> STATIC_GetCurrentEqPoint();
	class ATgDevice* STATIC_GetEqPointDevice(TEnumAsByte<ETG_EQUIP_POINT> eEqPoint);
	class UTgDeviceFire* STATIC_GetEqPointDevFire();
	bool STATIC_IsValidTarget(class AActor* HoverActor);
	bool STATIC_IsTargetDied(class AActor* TargetActor);
	bool STATIC_IsTargetInFrontOfPawn(const struct FVector& TargetLocation);
	struct FRotator GetAdjustedAimFor(class AWeapon* W, const struct FVector& StartFireLoc);
	struct FRotator ApplyAimVectorModification(class ATgDevice* Device, const struct FRotator& InRotation);
	void ClientSetOnlineStatus();
	void STATIC_DisplayHiddenActorsTimer();
	void STATIC_DisplayHiddenActors(float Time);
	bool CanAFK(class ATgPawn* ThePawn);
	void ServerToggleAFK(bool bEnabled);
	void STATIC_GoAFKTimer();
	void InitInputSystem();
	void STATIC_SetPlayerTeam(class ATeamInfo* NewTeam);
	void STATIC_TeamTalk();
	void STATIC_Talk();
	float STATIC_GetOutroTime();
	void ClientGameEnded(class AActor* EndGameFocus, bool bIsWinner);
	void GameHasEnded(class AActor* EndGameFocus, bool bIsWinner);
	void STATIC_EndIntro();
	void SetupIntro();
	void ResetPlayer();
	void STATIC_FinishIntro();
	void ClientFinishIntro();
	void ClientPlayIntro();
	void PlayIntro();
	void PrepareIntro();
	void ClientSetGameWinState(TEnumAsByte<EGAME_WIN_STATE> gameWinState);
	void SendClientSetGameWinState(TEnumAsByte<EGAME_WIN_STATE> gameWinState);
	void FindGoodView();
	void STATIC_GoSpectate();
	void ShowPathTo(class AActor* destActor);
	void ClientShowPathTo(class AActor* destActor);
	void TutorialMessage(int msgId, bool bTip);
	void OnPingMinimap(class UTgSeqAct_PingMinimap* Action);
	void OnNavIndicator(class UTgSeqAct_NavIndicator* Action);
	void ShowPathToNearestPOI();
	void ServerSetZoomFactor(float fZoom);
	void STATIC_ZoomOut();
	void STATIC_ZoomIn();
	void ServerViewPlayerByName(const struct FString& PlayerName);
	void DoSetViewTarget(class AActor* NewTarget);
	void STATIC_ViewPlayerByName(const struct FString& PlayerName);
	void ServerViewAPlayer(int Dir, bool bFriendlyOnly);
	void HandleViewTargetOnAdjustPosition();
	void STATIC_ServerViewPrevPlayer(bool bFriendlyOnly);
	void STATIC_ServerViewNextPlayer(bool bFriendlyOnly);
	int BlendRot(float DeltaTime, int BlendC, int NewC);
	void ClientEnterStartState();
	void EnterStartState();
	bool AllowVoiceMessage(const struct FName& MessageType);
	void AddPostRenderActors();
	void ClientSetHUD(class UClass* newHUDType);
	void GetPlayerViewPoint(struct FVector* POVLocation, struct FRotator* POVRotation);
	void GetAimingViewPoint(struct FVector* POVLocation, struct FRotator* POVRotation);
	bool STATIC_UsingFirstPersonCamera();
	void SetRadius(float NewRadius);
	void ClientReset();
	void Reset();
	void ClientSetCinematicMode(bool bInCinematicMode, bool bAffectsMovement, bool bAffectsTurning, bool bAffectsHUD);
	void STATIC_SetCinematicMode(bool bInCinematicMode, bool bHidePlayer, bool bAffectsHUD, bool bAffectsMovement, bool bAffectsTurning, bool bAffectsButtons);
	void STATIC_OnToggleCinematicMode(class USeqAct_ToggleCinematicMode* Action);
	void DisplayDebug(class AHUD* HUD, float* out_YL, float* out_YPos);
	void DisplayKillingBlowGameTip(const struct FCombatMessageInfo& Info);
	void STATIC_InDeathCam();
	void ReviveTimer();
	void LiveRespawn(bool bResetHealth, bool bResetDevices);
	void STATIC_PrepareForLiveRespawn();
	void Revive();
	void STATIC_LadderLetGo();
	void ServerLadderLetGo();
	void RestartPlayerOnTransfer();
	void CancelInBombRange();
	void NotifyInBombRange();
	void ClientNotifyBodyUnderAttack(unsigned char Damage);
	void NotifyBodyUnderAttack(unsigned char Damage);
	void ClientPlayTakeHit(const struct FRotator& HitDir, int Damage, class UClass* DamageType);
	void STATIC_NotifyChangedWeapon(class AWeapon* PreviousWeapon, class AWeapon* NewWeapon);
	void UnPossess();
	void Possess(class APawn* aPawn, bool bVehicleTransition);
	void ServerAcknowledgePossession(class APawn* P);
	void AcknowledgePossession(class APawn* P);
	void SetControlModuleOnPossess();
	void PreRender(class UCanvas* Canvas);
	void CopyPropertiesTo(class AController* C);
	void CleanupPRI();
	void InitPlayerReplicationInfo();
	void Destroyed();
	void ClientSellItem(int nInventoryId);
	void ClientPurchaseItem(int nLootTableId, int nLootTableItemId, int nItemCount);
	void STATIC_ResetViewOrientation();
	void PressJump(bool bOn);
	void ServerProfiling(const struct FString& Command);
	void ServerProfileScript(const struct FString& Command);
	void SelfAlert(int nPriority, float fDuration, int nMsgId);
	void ClientPingMap(const struct FVector& WorldLoc, TEnumAsByte<EPING_TYPE> pingType);
	void ClientSetRotationAndDesired(const struct FRotator& NewRotation, bool bResetCamera);
	void ServerRove(bool bOn);
	void ToggleRove();
	void STATIC_ServerViewSelf(const struct FViewTargetTransitionParams& TransitionParams);
	void ServerWatchOtherPlayer(TEnumAsByte<EWatchOtherPlayersMode> Mode);
	void StopWatchOthers();
	void StartWatchOthers(TEnumAsByte<EWatchOtherPlayersMode> Mode);
	void SetCorrectViewTarget();
	void ServerSetViewTarget(class AActor* me);
	bool PingMap(const struct FVector& WorldLocation, TEnumAsByte<EPING_TYPE> Type, TArray<class AReplicationInfo*>* worldActorRepInfos);
	void StopFireRightMouse();
	void TryFireRightMouse();
	bool ShouldSwapAltAndInhandInputs();
	void OnRightMouseReleased();
	void OnRightMousePressed();
	void StopFireLeftMouse();
	void TryFireLeftMouse();
	void OnLeftMouseReleased();
	void OnLeftMousePressed();
	void CCE(const struct FName& EventName);
	void CauseClientEvent(const struct FName& EventName);
	void RemoveScreenCapturePostProcess();
	void TestScreenCapturePostProcess();
	void STATIC_WhereAmI();
	void ClientLogServerMessage(const struct FString& sMessage);
	void ServerSetToggleZoom(bool bToggleZoom);
	void SetToggleZoom(bool bToggleZoom);
	void ServerSetAutoSkillUp(bool bAutoSkill);
	void SetAutoSkillUp(bool bAutoSkill);
	void ServerSetAutoPurchase(bool bAutoPurchase);
	void SetAutoPurchase(bool bAutoPurchase);
	void SetCanPurchaseFlag(bool bCanPurchase);
	void ShowBinoculars(bool bShow);
	void SetTaskforceLead(const struct FString& fsName);
	void ShowRespawnTimerExpired();
	void RequestShowRespawnBuyback();
	void ClientShowRespawnBuyback(int nCost);
	void ClientPlaySoundBase(class UAkBaseSoundObject* ASound);
	void ClientPlaySound(class USoundCue* ASound);
	void STATIC_ClientPlayNotifyRevive();
	void ClientShowHUD();
	void ClientHideHUD();
	void STATIC_Logoff(bool bForced);
	void AllocateDevicePoint(int nDeviceId);
	void CallServerMove(class USavedMove* NewMove, const struct FVector& ClientLoc, unsigned char ClientRoll, int View, class USavedMove* OldMove);
	void STATIC_ClientStartHandleClientPawnFunction(TEnumAsByte<EClientPawnFuncType> funcType, int nPawnId, const struct FCLIENT_PAWN_FUNCTION_ARGS& args);
	void StartHandleClientPawnFunction(TEnumAsByte<EClientPawnFuncType> funcType, int nPawnId, const struct FCLIENT_PAWN_FUNCTION_ARGS& args);
	void STATIC_HandleClientPawnFunction(TEnumAsByte<EClientPawnFuncType> funcType, int nPawnId, const struct FCLIENT_PAWN_FUNCTION_ARGS& args);
	class AActor* STATIC_GetDebugHoverActor();
	void SetFTZombieMode(bool bEnabled, TEnumAsByte<EZombieModex> Mode);
	void STATIC_FTPlayerInit();
	void STATIC_RefreshMapCalloutText();
	void OnRequestRelease();
	void SwitchChampion(int BotId, int BodySkinId, int WeaponSkinId, int VoicePackId);
	void STATIC_KillCurrentDirectorMatinee();
	void STATIC_InputReceived(TEnumAsByte<EPlayerInputType> InputType);
	void SetInputAllowed(TEnumAsByte<EPlayerInputType> InputType, bool bEnabled);
	bool STATIC_IsInputAllowed(TEnumAsByte<EPlayerInputType> InputType);
	TEnumAsByte<EPlayerInputType> STATIC_GetInputType(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	bool STATIC_IsDeviceLockingRotation();
	bool STATIC_IsDeviceLockingCamera();
	bool STATIC_IsDeviceLockingInput();
	void HandleWalking();
	void STATIC_PostServerMoveUpdate();
	void STATIC_PostMoveAutonomous(float DeltaTime, unsigned char CompressedFlags, const struct FVector& newAccel, const struct FRotator& DeltaRot);
	class ATgRepInfo_Player* STATIC_GetCurrentPRI();
	class ATgPawn* STATIC_GetTgPawn();
	class ATgPawn* STATIC_GetOwnedTgPawn();
	void SendProxyDamageMessage(class AActor* TargetActor, int nDeviceId, int DamageAmount, struct FExtraDamageInfo* ExtraInfo);
	bool STATIC_IsClient3pEnabled();
	bool CanToggleClient3p();
	void ToggleClient3p();
	void SetAllowAnimationFrameRateLOD(bool Value, float lLODDistanceFactor, int lLODFrameRate);
	void SetAllowParticleSystems(bool Value);
	void AllowRagdollUpdated();
	bool AllowRagdoll();
	bool OnOffhandSlotReleased(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	bool OnOffhandSlotPressed(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	void STATIC_GivePlayerFullVitals();
	void STATIC_EndTimelapsePlayback();
	void OnPostTimeLapse();
	void OnPreTimeLapse();
	void ClientDebugPlayPotg();
	void StartTimelapsePlayback(float BeginTimeOffset, float EndTimeOffset, bool bPlayOfGame);
	void SavePlayOfGame(float Begin, float End);
	void CheckJumpOrDuck();
	void SetClientAFK(bool bAFK);
	bool STATIC_IsForceFeedbackEnabled();
	void NativeClientSetGameWinState(TEnumAsByte<EGAME_WIN_STATE> gameWinState);
	void AddNavFailedAlert(bool bAlreadyThere);
	void PlayerRetrievedOSSInventory(TArray<struct FMarketplaceInventoryItem>* Items);
	void OnAllMarketplaceProductDetailsRead();
	void UpdatePartyUI();
	void TryOpenPartyUI();
	void BlockPartySceneInput(bool bBlockInput);
	bool TryAutoLogin();
	bool IsInGame();
	void ShowCustomGameDisallowedPopup();
	void ShowPackageNotInstalledForPartyInviteWarning();
	void ShowPartyNoLongerAvailableWarning();
	void ShowPartyFullWarning(bool bPartySession);
	void ShowUnableToReadFriendsListWarning();
	void ShowNoFriendsForPartyInviteWarning();
	void ShowCurrentUserChangeWarning(const struct FString& CurrentUser, const struct FString& LoggedInUser);
	void ShowControllerDisconnectedWarning();
	void STATIC_OnRemoteTalkerStatusChange(const struct FUniqueNetId& RemoteNetId, bool bIsTalking);
	void STATIC_OnCurrentUserChanged(unsigned char LocalUserNum, const struct FString& CurrentUser, const struct FString& LoggedInUser);
	void STATIC_OnConnectionStatusChange(TEnumAsByte<EOnlineServerConnectionStatus> ConnectionStatus);
	void STATIC_OnLoginStatusChange(TEnumAsByte<ELoginStatus> NewStatus, const struct FUniqueNetId& NewId);
	void RemoveAlertScript(int nMsgId);
	void AddAlertScript(TEnumAsByte<EAlertPriority> Priority, TEnumAsByte<EAlertType> Type, float fDuration, int nMsgId, bool bBlockDuplicates);
	void AddAutoKickAlert();
	void AddAssistAlert(const struct FString& KilledName, const struct FString& KillerName);
	void AddKillAlert(const struct FString& KilledName, const struct FString& KillerName, bool KillerWasPlayer);
	void ClientShowAlert(int nMessageId);
	void ServerMove(float TimeStamp, const struct FVector& InAccel, const struct FVector& ClientLoc, unsigned char MoveFlags, unsigned char ClientRoll, int View);
	void STATIC_UpdateRotation(float DeltaTime);
	void SetAudioFriendlyAndLocal();
	void ReloadKeybindsForPawn();
	void SetPlayerWard(int nWardSkinId);
	void SetPlayerProfile(int nProfileId, int nSkinId, int nWeaponSkinId, int nVoicePackId);
	void SetLevel(int nLevel);
	void AchievementOnPhysicsStateChange();
	void AchievementOnSiegeObjectiveCaptured();
	void AchievementOnSpray();
	void AchievementOnEmote();
	bool OnRespawnRuleChanged();
	float StartReviveTimer(bool bDoNotUpdateStatsTracker);
	void SetNWCondition(int nPktLoss, int nPktLag);
	void TestCrashReport();
	class UMaterialInstanceConstant* STATIC_GetMICResource(int nResourceId);
	void STATIC_UpdateCameraForServerCorrectionSmoothing();
	float STATIC_GetSetDefaultFOV();
	float GetFOVAngle();
	class UTgCameraModule* STATIC_GetCurrentCameraModule();
	void STATIC_NativePlayerTick(float DeltaTime);
	void STATIC_SetOnlineStatus(unsigned char LocalUserNum, const struct FString& StatusString);
	void OnAbilityModified(int nDeviceId);
	void ShowLoadoutMenu();
	void CloseBurnHUD();
	void STATIC_UpdateLineOfSight();
	void NotifyUpdatedInhandAmmoCount(int nAmmo, class ATgDevice* pDevice, int nDeviceId);
	void SetReticleVisibility(bool bShowReticle, bool bShowReticleAccessories);
	void NextScoreboardDisplayType();
	bool CanPlayKillCam(bool bPlayOfGame);
	bool STATIC_IsInDeathCam();
	void STATIC_UpdateMinimap(class ATgMapBoundsVolume* pMapBoundsVolume);
	void SetAkWorldTimeDilation();
	void CloseHUDMenus();
	bool STATIC_IsTopMenu(const struct FName& nmName);
	void ShowAutoPurchaseTip();
	void RefreshLastActiveTime();
	bool STATIC_Wants3P();
	bool ShouldHideUIWorldOverlay();
	bool STATIC_IsConfused();
	class AActor* STATIC_GetBestKillCamTarget();
	void OnScoredPoints(int nValue, TEnumAsByte<ERewardValueType> eType, int nPlayerId);
	void STATIC_UIFadeEndOfRound(bool bFade, float fTime, float fDelay, float FailSafeTime);
	void UIFade(bool bFade, float fTime, float fDelay, float FailSafeTime);
	void STATIC_OnRequestDeckAndTalent(int nTalentId, int nDeckId, bool bIsTemplate);
	bool OnRequestCard(int nDeviceId, int nRank);
	bool STATIC_OnRequestPassive(int nPassiveId);
	void SetRewardValues(int XP, int nCredits, class AActor* Source, TEnumAsByte<ERewardValueType> RewardType, bool bFlankKill);
	void SetSelectedDeck(int nBotId, int nDeckId);
	void SetSelectedTalent(int nBotId, int nDeviceIndex);
	void STATIC_SetSelectedPassive(int nBotId, int nDeviceId);
	void STATIC_LogAntiCheatPlayerState();
	void AchievementModifiedHealthProp(int nHealth, int nMaxHealth);
	void AchievementAchievedById(int nActivityId);
	void STATIC_NativeUnPossess();
	void STATIC_NativePossess(class APawn* aPawn);
	void ServerRequestGraphData();
	void ServerGiveCard(int nDeviceId);
	void ClientAddCheats();
	void CheckHealthFX(float fCurrent, float fMaximum, float fArmor);
	void PlayEventFX();
	void StartFX();
	bool STATIC_IsUsingGamePadInput();
	bool STATIC_IsGamepadAvailable();
	bool IsMouseAvailable();
	bool IsKeyboardAvailable();
	void STATIC_UpdateKeybindsUI();
	void STATIC_UpdateRuntimeInput(bool bSpectator);
	void ResetKeysToDefault(bool bSpectator);
	bool IsLocalPlayerController();
	void STATIC_LiveSpectateStop();
	void STATIC_LiveSpectate(const struct FString& sPlayerNameInstanceId);
	void SpectateStop();
	void Spectate(const struct FString& sPlayerName, const struct FString& sSpectatePassword);
	void SpectateGM(const struct FString& sPlayerName, const struct FString& sSpectatePassword);
	void KickWarning();
	void SendCombatMessage(const struct FCombatMessageInfo& msgInfo);
	void ShowRespawnBuyback(int nCost);
	void SetBinocularSettings(const struct FBinocularSettings& BinocSettings);
	void SetSniperChargedMeter(float fPercent);
	void SetHUDOverlay(TEnumAsByte<EHUDOverlay> eOverlay);
	void STATIC_UpdateTransitionUI();
	void STATIC_UpdatePlayerVitalsUI();
	void ToggleMiniMapPing(bool bStart);
	void OnSceneLoadChange(const struct FString& SceneName, bool bLoaded);
	bool STATIC_IsTutorialBlockingAction(TEnumAsByte<EeTutorialForceableElements> Action);
	bool STATIC_HandleTutorialActionOnServer(class UTgSeqAct_ForceClientTutorialAction* inAction);
	void STATIC_HandleTutorialHighlighter(bool bShow, int highlightedElement);
	void STATIC_HandleForcedClientTutorialAction(int nAction, int nActionElement);
	void TriggerTutorialEvent(int nTutEvent, int nInfoData);
	void STATIC_LogTutorialAction(int nPlayerAction, int nEventData);
	void ClientLogoff(bool bForced);
	void STATIC_FadeHud();
	void ServerPlayPing(float X, float Y, float Z, TEnumAsByte<EPING_TYPE> pingType);
	void ServerPlayVGS(int nVgsId, int usedVPSetting);
	void ServerSellItem(int nInventoryId);
	void ServerUpgradeItem(int nLootTableId, int nLootTableItemId, int nUpgradeInvId);
	void ServerPurchaseItem(int nLootTableId, int nLootTableItemId, int nItemCount);
	void STATIC_NeedsHealingOff();
	bool STATIC_IsFiringUlt();
	int STATIC_GetTaskForceNumber();
	void ClientUpdateTutorialBlockingActions();
	bool ClientUpdateUIDeviceState();
	void ServerAllocateDevicePoint(int nDeviceId);
	bool STATIC_HaveBasicAbilitiesBeenActivated();
	int STATIC_GetDevicePointsSpent();
	int STATIC_GetDevicePointsAvailable();
	bool CanAllocateDevicePoint(int nDeviceId, class ATgDevice* aDevice, bool ignorePause);
	int STATIC_GetPerkPointsSpent();
	int STATIC_GetPerkPointsAvailable();
	TEnumAsByte<EGiveGoldResult> ServerTransferGoldBetweenFriendlyPlayers(int ReceivingPlayerID, int GoldCount);
	TEnumAsByte<EGiveGoldResult> STATIC_GiveGoldToFriendlyPlayer(int PlayerID, int GoldCount);
	void PlayerReceivedTokenForLogin(bool bSuccess);
	void SetToggleZoomFlag(bool bOn, bool bForce);
	void SetAutoSkillUpFlag(bool bOn, bool bForce);
	void SetAutoPurchaseFlag(bool bOn, bool bForce);
	void ToggleZoom();
	void AutoSkillUp();
	void STATIC_ClientAutoPurchase();
	void AutoPurchase();
	void STATIC_GetDamageAngle(const struct FRotator& HitDir, float* PitchDegrees, float* YawDegrees);
	float STATIC_GetCurrencyMultiplier();
	void STATIC_SetCurrencyMultiplier(float fMult);
	void SendUICurrencyChange();
	void SendUIXpChange();
	void STATIC_HandleSimulatedProjectile();
	bool STATIC_PeekSimProjFlashEventsForExplosion(int nProjInstanceId);
	void STATIC_DumpLevelStatus();
	void DebugGetLangMsg(int nMsgId);
	void STATIC_SetSoundMode(const struct FName& NewSoundMode);
	void STATIC_DumpPerfTrackData();
	void TgPerfTrack(bool bStart);
	void SetPawnTickState(int nState);
	void ToggleTick(const struct FString& ClassName, bool bDisable);
	void STATIC_DoClientSidePerfTracking(int nLength);
	void OutputRelevantActors();
	void BlockVGS(bool bBlock);
	bool CheckMaxEffectDistance(class APlayerController* P, const struct FVector& SpawnLocation, float CullDistance);
	void ConvertTimeDisplay(int nMinutes, struct FString* sDisplay);
	class ATgPawn* STATIC_GetPlayerControlPawn();
	void SendGameOverEvent(TEnumAsByte<EGAME_WIN_STATE> gameWinState, bool bPlayerIsAttacker);
	void STATIC_DumpClassInfoToFile(const struct FString& sClassName);
	void ClientLoadDevices(class UTgSeqAct_ClientLoadDevices* Action);
	int STATIC_GetDeviceIdByName(const struct FString& sDeviceName);
	void SetValue(const struct FString& fsObject, const struct FString& fsVariable, const struct FString& fsValue);
	void GetValue(const struct FString& fsObject, const struct FString& fsValue);
	bool bIsEditor();
	void STATIC_ForceRelevant(class AActor* pActor, float fDuration);
	void STATIC_FinalSave();
	void ToggleCombatInfo();
	void SpectateOutlines(bool bShow);
	void SpectateXP(bool bShow);
	void SpectateGold(bool bShow);
	void SpectateCrits(bool bShow);
	void SpectateHeals(bool bShow);
	void SpectateDamage(bool bShow);
	void DisableProfanityFilter(bool bDisable);
	void ToggleInHandTargeting(bool bHide);
	void StopLogTo();
	void STATIC_LogTo(const struct FString& fsHost, int nPort);
	void _Crash();
	void Bug();
	class UTgClientSettings* STATIC_GetClientSettings();
	void MatchAccept(bool bAccepted);
	void MatchLeave(bool bAsTeam);
	void ConfirmMatchLeave(bool bLeave);
	void ServerSetTaskforceLead(const struct FString& fsName);
	bool CanCameraSeeActorCenter(class AActor* Other, float ZOffset);
	bool CanCameraSeePawnCenter(class ATgPawn* Other);
	class UClass* STATIC_GetHudClass(class UClass* pNewHudType);
	bool STATIC_HasInfiniteCharacterEnergy();
	void StoreOfflineData();
	void TestVGSPOTG(int nPackId, int nBotId, int nSkinId);
	void STATIC_LogPerfLeakData();
	void NativeAnnounceEOM(bool bVictory);
	bool SeesInViewFrustum(class AActor* aOther, float fViewDist);
	void STATIC_PlayNotifyRevive();
	void PlayNotifySound(TEnumAsByte<ENotifySound> eSound);
	void PlayNotifySound_Internal(TEnumAsByte<ENotifySound> eSound);
	void AnnouncerPlayFogLine();
	void PlayAnnouncerEvent(class UAkEvent* akSound, bool bForce);
	void PlayMessageAkEvent(const struct Fdword& dwMsgId);
	void PlayPointAlienFX(bool bPointWonLocal);
	bool AnnouncerPlaySeries(TEnumAsByte<EAnnouncerSeries> series, int Step);
	void AnnouncerReset();
	int AnnouncerGetStep(TEnumAsByte<EAnnouncerSeries> series);
	bool STATIC_IsInGameType(int nGameType);
	void SetMusicSwitchDefaults();
	void QueueReviveTimeChanged();
	bool STATIC_IsReadyForStart();
	void CanDoFullSellback();
	void SetViewTarget(class AActor* NewViewTarget, const struct FViewTargetTransitionParams& TransitionParams);
	void STATIC_PrepareForEndMission();
};


// Class TgGame.TgBattleCheatManager
// 0x0020 (0x00C0 - 0x00A0)
class UTgBattleCheatManager : public UPComCheatManager
{
public:
	class ATgDemoRecSpectator_Debug*                   m_DebugCameraController;                                  // 0x00A0(0x0008)
	TArray<class APlayerStart*>                        m_DebugPlayerStarts;                                      // 0x00A8(0x0010) (NeedCtorLink)
	int                                                m_nLastSlomoWindowId;                                     // 0x00B8(0x0004)
	unsigned long                                      m_bInfiniteEnergy : 1;                                    // 0x00BC(0x0004)
	unsigned long                                      m_bBaseAmmoRegenDisabled : 1;                             // 0x00BC(0x0004)
	unsigned long                                      m_bLogAmmoRegen : 1;                                      // 0x00BC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBattleCheatManager");
		return ptr;
	}


	void SetTickGroupCount(int nTickGroupCount);
	void SetGuaranteedTickDistance(float fDistance);
	void ToggleTickThrottling();
	void STATIC_StartAutofire(float fTime, bool bStart);
	void STATIC_Query(const struct FString& sType);
	void STATIC_TestWaveform(class UForceFeedbackWaveform* FFWaveform, float fScale, float fScaleDuration);
	void STATIC_KillAbyssalEcho();
	void ClearPayloadTimer();
	void ToggleFlagballPassing();
	void RespawnFlagball();
	void TraceDistanceAtReticle();
	void SetSpray(int nSlot, int nSprayId);
	void SetEmote(int nSlot, int nEmoteId);
	void BugItGo(float X, float Y, float Z, int Pitch, int Yaw, int Roll);
	void SetPawnLoc(float X, float Y, float Z);
	void STATIC_Log3pOffset();
	void Adjust3pOffset(int X, int Y, int Z);
	void STATIC_FTZombie(bool bEnabled);
	void STATIC_FTPlayerInit();
	void ResetDebugPropertyMods(const struct FString& sProperty);
	void ApplyDebugPropertyMod(const struct FString& sProperty, bool bPercent, float fModifier1, float fModifier2, float fModifier3, float fModifier4, float fModifier5, float fModifier6);
	struct FString GetBotNameFromAlias(const struct FString& sBot);
	void ToggleDiminishingReturns();
	void STATIC_DrawActorEncroachmentFire(bool bDraw);
	void STATIC_DAEF(bool bDraw);
	void STATIC_DisableEffectLagCompensation();
	void STATIC_EnableEffectLagCompensation();
	void SetVoicePreference(const struct FString& sPreference);
	void _SetMountSkin(int nSkinId);
	void SetMountSkin(int nSkinId);
	void PlayIntroAnim();
	void SetFogDistance(int Distance);
	void ResumeFog();
	void StopFog();
	void ToggleAIDifficultyAdjust();
	void STATIC_KillProjectiles();
	void STATIC_EnableAI(bool bEnabled);
	void STATIC_LockPotG(bool bLocked);
	void ResetPotG();
	void PlayPotGForAll();
	void PlayPotG();
	void AllowMount(bool bEnabled);
	void STATIC_TSHM(int nHeadMeshID);
	void TargetSetHeadMesh(int nHeadMeshID);
	void STATIC_TSBM(int nBodyMeshID);
	void TargetSetBodyMesh(int nBodyMeshID);
	void STATIC_TSM(int nBodyMeshID, int nHeadMeshID);
	void TargetSetMeshes(int nBodyMeshID, int nHeadMeshID);
	void ToggleHeadMesh();
	void STATIC_EnableHeadMesh(bool bEnabled);
	void decapitate();
	void rhm();
	void RemoveHeadMesh();
	void SHBN();
	void SetHeadMeshByName();
	void SHM(int nHeadMeshID);
	void SetHeadMesh(int nHeadMeshID);
	void SBMBN();
	void SetBodyMeshByName();
	void SBM(int nBodyMeshID);
	void SetBodyMesh(int nBodyMeshID);
	void STATIC_TheGoodStuff();
	void STATIC_FeistyInfo();
	void STATIC_DebugExtraChampionInfo();
	void STATIC_ForceShowAmmo();
	void LiveRespawn(bool bResetHealth, bool bResetDevices);
	void AllowHeadShots(bool bEnable);
	void CaptureDone();
	void ReadyCapture();
	void DBGKoga();
	void AllNoah(const struct FString& ChannelName);
	void ShowThreats(bool bEnabled, const struct FString& ChannelName);
	void STATIC_DisplayThreatParams();
	void STATIC_EnableOcclusion(bool bEnabled);
	void STATIC_EnableThreat(bool bEnabled);
	void SetAIAccuracy(float DegreeMissed, float MissLikelihood);
	void PayloadForever();
	void SetCAPOvertime(float overtimeDuration, float overtimeWarning);
	void CloseSpawnGates();
	void OpenSpawnGates();
	void STATIC_EndRound(int nTaskForce);
	void STATIC_GainTickets(int ticketsAmount);
	void STATIC_GainCredits(int creditsAmount);
	void STATIC_GainXP(int xpAmount);
	void Toggle3p();
	void Set3p(bool bForce3P);
	void Set1p(bool bForce1P);
	void STATIC_LevelAim();
	void NextPhase();
	void STATIC_FRSE();
	void STATIC_ForceRoundSetupEnd();
	void SetVisibilityRanges(float fNormal, float fInVolume);
	void SetVaultImmuneHealth(float fHealth);
	void ToggleSiegeEngineRequiresAllies();
	void SetAutoHealingMultiplier(float NewMult);
	void SetGroundSpeedMultiplier(float NewMult);
	void SetDamageMultiplier(float NewMult);
	void STATIC_DumpLastClientAims();
	void STATIC_DumpLastServerAims();
	void STATIC_DumpWeaponPredictionStats();
	void SetMaximumLagPrediction(float NewMaximum);
	void ToggleWeaponLagPrediction();
	void SetInstantFireMeshTrace(bool bEnabled);
	void TestSpawnPoints(float PauseTime);
	void SetFlyingFriction(float frictionAmt);
	void SetFallingFriction(float frictionAmt);
	void SetAirFriction(float frictionAmt);
	void SetGameMode(TEnumAsByte<EGameMode> Mode);
	void SetGameRespawnRule(TEnumAsByte<EGameRespawnRule> Rule);
	void SetGameEnvironmentRule(TEnumAsByte<EGameEnvironmentRule> Rule);
	void ReinforceSiege(int healthAmt);
	void ReinforceDoors(int healthAmt);
	void QuickSiege();
	void STATIC_HelpMe();
	void EndGame();
	void SetScore(int tf1Score, int tf2Score);
	void STATIC_DisableScoring();
	void STATIC_EnableScoring();
	void STATIC_ForceLanePusher();
	void STATIC_GiveCard(int nDeviceId);
	void STATIC_DisableProximity(bool bEnabled);
	void ShowProjectileDebug(bool bEnabled);
	void SkipSetup();
	void StopHP5();
	void ShieldTarget(int Amount);
	void STATIC_HealTarget(int HealAmount);
	void DamageTarget(int DamageAmount);
	void PossessTarget();
	void STATIC_Heal(int HealAmount);
	void DamageHealth(int DamageAmount);
	void SetMana(int mana);
	void SetHealth(int Health);
	void STATIC_ForceRespawnAll();
	void SetCardCooldownIncrease(float fIncrease);
	void SetRespawnCap(float fDuration);
	void SetAttackRespawn(float fDuration);
	void SetDefenseRespawn(float fDuration);
	void SetRespawnIncrease(float fIncrease);
	void SetSiegeSpeed(float fSpeed);
	void PickPoint(int Index);
	void ToggleCapturePointOvertime();
	void STATIC_EnemyCapturePoint();
	void CapturePoint();
	void STATIC_InvisMe(bool bInvis);
	void ToggleSpectatorCamera();
	void ShowPlayerCircles(bool bEnabled);
	void TestStun(TEnumAsByte<EStunType> Type);
	void TestStunEffect(float fDuration);
	void TestShowInventory();
	void SetEnergy(float Value);
	void rg();
	void ResetGame();
	void QEG(bool bWin);
	void QuickEndGame(bool bWin);
	void SL(int nLevel);
	void SetMeLevel(int nLevel);
	void Obama(int nCurrency);
	void AddGold(int nCurrency);
	void RemoveAllItems();
	void RemoveAllCards();
	void RemoveDeviceAt(int nDeviceId);
	void STATIC_UnequipDeviceAt(int nEquipPointId);
	void RemoveDevice(int nDeviceId);
	void STATIC_UD(int nDeviceId);
	void STATIC_UnequipDevice(int nDeviceId);
	void STATIC_ED(int nDeviceId, int nEquipPointId, int nLevel, int FireMode);
	void STATIC_EquipDevice(int nDeviceId, int nEquipPointId, int nLevel, int FireMode);
	void STATIC_EDBN(const struct FString& sDeviceName, int nEquipPointId, int nLevel, int FireMode);
	void STATIC_EquipDeviceByName(const struct FString& sDeviceName, int nEquipPointId, int nLevel, int FireMode);
	void TEDBN(const struct FString& sDeviceName, int nEquipPointId, int nLevel, int FireMode);
	void TargetEquipDeviceByName(const struct FString& sDeviceName, int nEquipPointId, int nLevel, int FireMode);
	void TED(int nDeviceId, int nEquipPointId, int nLevel, int FireMode);
	void TargetEquipDevice(int nDeviceId, int nEquipPointId, int nLevel, int FireMode);
	void STATIC_EquipDeviceOnPawn(class ATgPawn* TgP, int nDeviceId, int nEquipPointId, int nLevel, int FireMode);
	void RemoveDeviceFromPawnAt(class ATgPawn* TgP, int nEquipPointId);
	void ToggleTaskForce();
	void ct(unsigned char nTaskForce);
	void ChangeTaskForce(unsigned char nTaskForce);
	void SetMaxAmmo(int MaxAmmo);
	void RefillAmmo();
	void ResetAimAssistKeyframes(const struct FString& keyframeType);
	void AddAimAssistKeyframe(const struct FString& keyframeType, const struct FString& KeyframeName, float Distance);
	void SetAimAssistValues(float MagnetScaleX, float MagnetScaleY, float FrictionScaleX, float FrictionScaleY, float TrackingScaleX, float TrackingScaleY);
	void ResetAimAssistValues();
	void SetAimAssistTargetWeightVars(float CurrentTargetBonus, float NotCurrentTargetPenalty, float MinAccuracyBonus, float MaxAccuracyBonus, float MinInaccuracyPenalty, float MaxInaccuracyPenalty, float MaxWeight);
	void ToggleAimAssist();
	void ShowFootstepInfo();
	void BeTheBoss();
	void ApplyProp(int nPropId, float nValue, int nCategory);
	void SpectatorCamera(bool bOn);
	void botslevel(int nLevel);
	void STATIC_FreezeAI(bool bOn);
	void botsgod(bool bOn);
	void RequestRelease();
	void TestObstacleAvoidance(int TestType);
	void ToggleAIDebug(bool bAttachAIDebugger);
	void ToggleCustomPhysics();
	void ToggleDeviceLog(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	void STATIC_KillAllPawnsByClass(const struct FString& PawnClassName);
	void STATIC_KillAllPawnsHelper(class UClass* PawnClass);
	void STATIC_KillAllMinions();
	void _SpawnTemplatePlayer(int nProfileId, int nSkinId, int nWeaponSkinId);
	void DebugProjectileLagCompensationClient();
	void DebugProjectileLagCompensationServer();
	void STATIC_DebugClientProjectileImpactVerification();
	void ShowMoveErrors();
	void SetStealth(bool bOn);
	void SetGroundspeed(float val);
	void STATIC_GiveRecommendedItems();
	void STATIC_HookMeUp();
	void MaxPower();
	void STATIC_ForceToggleMount();
	void Cooldown();
	void STATIC_energy();
	void STATIC_LogAmmoRegen();
	void STATIC_DisableBaseAmmoRegen();
	void CharacterEnergy();
	void God();
	void CheatLog(const struct FString& cheatText, bool bOn);
	void SimNWCondition(int nPktLoss, int nPktLag);
	void ML();
	void MaxLevel();
	void TestSkinGallery(int nGallery);
	void PrecacheClass(const struct FString& godName, const struct FString& SkinName, const struct FString& weaponSkinName);
	void TestPrecache(int nBotId, int nSkinId, int nWeaponSkinId, bool bAll);
	void ServerSpawnEcho(int nBotId);
	void SpawnEcho(const struct FString& sName);
	void SpawnBot(const struct FString& sName, int nTaskForce, int nCount, int BotDifficulty, const struct FString& BehaviorTreeName, int nSkinId, int nWeaponId);
	void _SpawnBot(const struct FString& sName, int nTaskForce, int nCount);
	void stb(const struct FString& sName, const struct FString& sDeviceName, int nFireMode, int nTaskForce, int nCount);
	void SpawnEmoteTestBot(const struct FString& sName, int nTaskForce, int nCount);
	void SpawnStillBot(const struct FString& sName, int nTaskForce, int nCount, int nSkinId, int nWeaponId);
	void SpawnTestBot(const struct FString& sName, const struct FString& sDeviceName, int nFireMode, int nTaskForce, int nCount);
	class ATgPawn* SpawnBotByName(const struct FString& BotName, int nTaskForce, int nCount, int nBotDifficulty, const struct FString& BehaviorTreeName, int nSkinId, int nWeaponId);
	void ServerExec(const struct FString& FSCommand);
	void Loc();
	void STATIC_Echo(const struct FString& inputString);
	void STATIC_FillEnergyAll(float fPercent);
	void STATIC_Energize();
	void STATIC_Slomo(float T);
	void STATIC_TestServerRequestCard(int nDeviceId, int nLevel);
	void separator();
	void STATIC_ResetQuestsAnimation(int nReduce);
	void STATIC_AddNotification(int nQuantity, unsigned char eQuestOrigin, unsigned char eType, int dwLootId);
	void ToggleTransitionManifest();
	void STATIC_CrashGame();
	void ClearAllIconReferences();
	void STATIC_ListAllIconReferences(bool bIncludeManifests);
	void SetAILevel(class ATgAIController_BehaviorGod* aic, int nLevel);
	void STATIC_FillEnergy();
	void SpawnDeployable(int dep_id);
	void ToggleLoadFailureOutput();
	void SpawnBotAllSkins(int nBatch);
	void NativeMaxLevel();
	void TestLanguage(const struct FString& newLangExt);
	void TestPanningRule(const struct FString& sPanningRule);
	void TestDj();
	void STATIC_ListTickableActors(TEnumAsByte<ETickingGroup> checkgroup);
	void STATIC_JoinMatchQueue(int nQueueId, int god1, int god2, int god3, int god4, int god5);
	void AddBotsToCustomMatch();
	void PurchaseGod(const struct FString& godName);
	void SwitchWard(const struct FString& wardSkinName);
	void sc(const struct FString& godName, const struct FString& SkinName, const struct FString& weaponSkinName);
	void SwitchClass(const struct FString& godName, const struct FString& SkinName, const struct FString& weaponSkinName);
	int STATIC_GetBotIdByName(const struct FString& godName);
};


// Class TgGame.TgCharacterBuilderLight
// 0x0000 (0x028C - 0x028C)
class ATgCharacterBuilderLight : public ASpotLightToggleable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCharacterBuilderLight");
		return ptr;
	}

};


// Class TgGame.TgClientSettings
// 0x01DC (0x023C - 0x0060)
class UTgClientSettings : public UObject
{
public:
	float                                              MinimapScaling;                                           // 0x0060(0x0004) (Edit, Config, GlobalConfig)
	float                                              UIScaling;                                                // 0x0064(0x0004) (Edit, Config, GlobalConfig)
	float                                              HUDScaling;                                               // 0x0068(0x0004) (Edit, Config, GlobalConfig)
	float                                              CombatTextScaling;                                        // 0x006C(0x0004) (Edit, Config, GlobalConfig)
	float                                              ChatScaling;                                              // 0x0070(0x0004) (Edit, Config, GlobalConfig)
	float                                              ChatFadeout;                                              // 0x0074(0x0004) (Edit, Config, GlobalConfig)
	TEnumAsByte<ENamePlateName>                        OverlayGodName;                                           // 0x0078(0x0001) (Edit, Config, GlobalConfig)
	TEnumAsByte<EFriendStateNotifications>             ShowFriendStateNotifications;                             // 0x0079(0x0001) (Edit, Config, GlobalConfig)
	TEnumAsByte<ETargetingLineStyle>                   TargetingLineStyle;                                       // 0x007A(0x0001) (Edit, Config, GlobalConfig)
	TEnumAsByte<ETargetingPreviewStyle>                TargetingPreviewStyle;                                    // 0x007B(0x0001) (Edit, Config, GlobalConfig)
	TEnumAsByte<ETargetingReticleStyle>                TargetingReticleStyle;                                    // 0x007C(0x0001) (Edit, Config, GlobalConfig)
	TEnumAsByte<ETargetingHighlightStyle>              TargetingHighlightStyle;                                  // 0x007D(0x0001) (Edit, Config, GlobalConfig)
	TEnumAsByte<ECastMode>                             CastMode;                                                 // 0x007E(0x0001) (Edit, Config, GlobalConfig)
	TEnumAsByte<EMapPlacement>                         MapPlacement;                                             // 0x007F(0x0001) (Edit, Config, GlobalConfig)
	TEnumAsByte<EControlIconStyle>                     ControlIconStyle;                                         // 0x0080(0x0001) (Edit, Config, GlobalConfig)
	TEnumAsByte<EColorBlindOption>                     SelectedColorBlindOption;                                 // 0x0081(0x0001) (Edit, Config, GlobalConfig)
	TEnumAsByte<ECrossplayCombinedSetting>             CombinedCrossplayOption;                                  // 0x0082(0x0001) (Edit, Config, GlobalConfig)
	TEnumAsByte<ECrossInputMethod>                     CrossInputMethod;                                         // 0x0083(0x0001) (Edit, Config, GlobalConfig)
	TEnumAsByte<EAspectRatio>                          DesiredAspectRatio;                                       // 0x0084(0x0001) (Edit, Config, GlobalConfig)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0085(0x0003) MISSED OFFSET
	unsigned long                                      OverlayShowLocalPlayer : 1;                               // 0x0088(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      DisableHelpMessages : 1;                                  // 0x0088(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      ShowInHandTargeting : 1;                                  // 0x0088(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      DisableTargetingAid : 1;                                  // 0x0088(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      VerticalTargetingPreviews : 1;                            // 0x0088(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      DisableProfanityFilter : 1;                               // 0x0088(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      ShowTeamTags : 1;                                         // 0x0088(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      SpectateDamage : 1;                                       // 0x0088(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      SpectateHeals : 1;                                        // 0x0088(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      SpectateCrits : 1;                                        // 0x0088(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      SpectateGold : 1;                                         // 0x0088(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      SpectateXP : 1;                                           // 0x0088(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      SpectateOutlines : 1;                                     // 0x0088(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      ShowRentNotification : 1;                                 // 0x0088(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      ShowHUDScore : 1;                                         // 0x0088(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      ShowHUDEnemy : 1;                                         // 0x0088(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      ShowHUDStats : 1;                                         // 0x0088(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      ShowHUDItems : 1;                                         // 0x0088(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      ShowWardPings : 1;                                        // 0x0088(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      ShowCauterizeHealthBar : 1;                               // 0x0088(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      bShowCardCooldowns : 1;                                   // 0x0088(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      DoNotDisturb : 1;                                         // 0x0088(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      LoadAssistModeSubLevel : 1;                               // 0x0088(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      bTargetingAlwaysShowPreview : 1;                          // 0x0088(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      bUseCastQueueing : 1;                                     // 0x0088(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      bUseFixedPitchMode : 1;                                   // 0x0088(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      NewUserPromptTutorialMatch : 1;                           // 0x0088(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      NewUserFinished : 1;                                      // 0x0088(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      VendorStoreTopTier : 1;                                   // 0x0088(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      bEnableHelpPopups : 1;                                    // 0x0088(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      ColorBlindMode : 1;                                       // 0x0088(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      ColorBlindModeShader : 1;                                 // 0x0088(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      bCharacterVolume : 1;                                     // 0x008C(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      MasterMute : 1;                                           // 0x008C(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      SFXMute : 1;                                              // 0x008C(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      MusicMute : 1;                                            // 0x008C(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      VoiceMute : 1;                                            // 0x008C(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      MatchNotifierMute : 1;                                    // 0x008C(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      AllPlayerMute : 1;                                        // 0x008C(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      bEnableVoiceChat : 1;                                     // 0x008C(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      bUsePushToTalkForVoiceChat : 1;                           // 0x008C(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      QueueWaitRegion : 1;                                      // 0x008C(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      QueueWaitSolo : 1;                                        // 0x008C(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      DisableCrossplay : 1;                                     // 0x008C(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      AutoPurchase : 1;                                         // 0x008C(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      AutoSkill : 1;                                            // 0x008C(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      bToggleZoom : 1;                                          // 0x008C(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      DisableJoystickInput : 1;                                 // 0x008C(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      EnableControllerFeedback : 1;                             // 0x008C(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      EnableGyroInput : 1;                                      // 0x008C(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      bEnableHudTeams : 1;                                      // 0x008C(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      bEnableHudCombat : 1;                                     // 0x008C(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      bEnableHudHealth : 1;                                     // 0x008C(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      bEnableHudSkills : 1;                                     // 0x008C(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      bEnableHudTeamUI : 1;                                     // 0x008C(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      bEnableHudTeamDeathMarkers : 1;                           // 0x008C(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      bEnableHudMinimap : 1;                                    // 0x008C(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      bReticleBloom : 1;                                        // 0x008C(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      bChangeReticleOverEnemy : 1;                              // 0x008C(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      bEnableSpecatorPlayerIcons : 1;                           // 0x008C(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      bShowSpectatorItems : 1;                                  // 0x008C(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      bPublicParty : 1;                                         // 0x008C(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      bShownVaultTutorial : 1;                                  // 0x008C(0x0004) (Config, GlobalConfig)
	unsigned long                                      bEnableSpectate : 1;                                      // 0x008C(0x0004) (Config, GlobalConfig)
	unsigned long                                      blockNonFriendChat : 1;                                   // 0x0090(0x0004)
	unsigned long                                      newUserFinishedTutorial : 1;                              // 0x0090(0x0004)
	unsigned long                                      bShowLiveVideo : 1;                                       // 0x0090(0x0004)
	unsigned long                                      ShownBountyCoinLinkPrompt : 1;                            // 0x0090(0x0004) (Config, GlobalConfig)
	int                                                TeamTagFormat;                                            // 0x0094(0x0004) (Edit, Config, GlobalConfig)
	float                                              FogOfWarDimness;                                          // 0x0098(0x0004) (Edit, Config, GlobalConfig)
	float                                              MinimapOpacity;                                           // 0x009C(0x0004) (Edit, Config, GlobalConfig)
	int                                                DemoBotId;                                                // 0x00A0(0x0004) (Edit, Config, GlobalConfig)
	float                                              CastQueueTime;                                            // 0x00A4(0x0004) (Edit, Config, GlobalConfig)
	float                                              FixedPitchLowerBoundDegrees;                              // 0x00A8(0x0004) (Edit, Config, GlobalConfig)
	float                                              FixedPitchUpperBoundDegrees;                              // 0x00AC(0x0004) (Edit, Config, GlobalConfig)
	int                                                PlayNowTabId;                                             // 0x00B0(0x0004) (Edit, Config, GlobalConfig)
	int                                                VendorStoreTabId;                                         // 0x00B4(0x0004) (Edit, Config, GlobalConfig)
	int                                                VendorStoreTypeId;                                        // 0x00B8(0x0004) (Edit, Config, GlobalConfig)
	int                                                VendorStoreTypeRecId;                                     // 0x00BC(0x0004) (Edit, Config, GlobalConfig)
	int                                                LeagueSelection;                                          // 0x00C0(0x0004) (Edit, Config, GlobalConfig)
	int                                                VPSelection;                                              // 0x00C4(0x0004) (Edit, Config, GlobalConfig)
	int                                                ColorBlindModeShaderType;                                 // 0x00C8(0x0004) (Edit, Config, GlobalConfig)
	float                                              ColorBlindModeIntensity;                                  // 0x00CC(0x0004) (Edit, Config, GlobalConfig)
	float                                              MasterVolume;                                             // 0x00D0(0x0004) (Edit, Config, GlobalConfig)
	float                                              SFXVolume;                                                // 0x00D4(0x0004) (Edit, Config, GlobalConfig)
	float                                              MusicVolume;                                              // 0x00D8(0x0004) (Edit, Config, GlobalConfig)
	float                                              VoiceVolume;                                              // 0x00DC(0x0004) (Edit, Config, GlobalConfig)
	float                                              MatchNotifierVolume;                                      // 0x00E0(0x0004) (Edit, Config, GlobalConfig)
	float                                              VoiceChatVolume;                                          // 0x00E4(0x0004) (Edit, Config, GlobalConfig)
	float                                              VoiceChatMicVolume;                                       // 0x00E8(0x0004) (Edit, Config, GlobalConfig)
	int                                                nAudioPanning;                                            // 0x00EC(0x0004) (Edit, Config, GlobalConfig)
	float                                              DesiredFOV;                                               // 0x00F0(0x0004) (Edit, Config, GlobalConfig)
	float                                              fGamma;                                                   // 0x00F4(0x0004) (Edit, Config, GlobalConfig)
	float                                              fControllerFeedbackStrength;                              // 0x00F8(0x0004) (Edit, Config, GlobalConfig)
	int                                                nEnableHudDamage;                                         // 0x00FC(0x0004) (Edit, Config, GlobalConfig)
	int                                                nHudSkillsOrder;                                          // 0x0100(0x0004) (Edit, Config, GlobalConfig)
	int                                                nReticleColor;                                            // 0x0104(0x0004) (Edit, Config, GlobalConfig)
	int                                                nReticleType;                                             // 0x0108(0x0004) (Edit, Config, GlobalConfig)
	int                                                nHealFeedMode;                                            // 0x010C(0x0004) (Edit, Config, GlobalConfig)
	int                                                nVGSType;                                                 // 0x0110(0x0004) (Edit, Config, GlobalConfig)
	int                                                nScoreboardType;                                          // 0x0114(0x0004) (Edit, Config, GlobalConfig)
	int                                                nSpectatorBlueTeamSeriesScore;                            // 0x0118(0x0004) (Edit, Config, GlobalConfig)
	int                                                nSpectatorRedTeamSeriesScore;                             // 0x011C(0x0004) (Edit, Config, GlobalConfig)
	int                                                TwitchServer;                                             // 0x0120(0x0004) (Edit, Config, GlobalConfig)
	int                                                TwitchBitrate;                                            // 0x0124(0x0004) (Edit, Config, GlobalConfig)
	int                                                TwitchFramerate;                                          // 0x0128(0x0004) (Edit, Config, GlobalConfig)
	int                                                TwitchMicVolume;                                          // 0x012C(0x0004) (Edit, Config, GlobalConfig)
	int                                                TwitchGameVolume;                                         // 0x0130(0x0004) (Edit, Config, GlobalConfig)
	int                                                TwitchResolution;                                         // 0x0134(0x0004) (Edit, Config, GlobalConfig)
	int                                                TwitchMicMute;                                            // 0x0138(0x0004) (Edit, Config, GlobalConfig)
	int                                                TwitchGameMute;                                           // 0x013C(0x0004) (Edit, Config, GlobalConfig)
	int                                                TwitchSaveUsername;                                       // 0x0140(0x0004) (Edit, Config, GlobalConfig)
	struct FString                                     TwitchTitle;                                              // 0x0144(0x0010) (Edit, Config, GlobalConfig, NeedCtorLink)
	struct FString                                     TwitchUsername;                                           // 0x0154(0x0010) (Edit, Config, GlobalConfig, NeedCtorLink)
	struct FString                                     DemoVideo;                                                // 0x0164(0x0010) (Config, GlobalConfig, NeedCtorLink)
	TArray<struct FString>                             DemoResults;                                              // 0x0174(0x0010) (Config, GlobalConfig, NeedCtorLink)
	int                                                CustomGameQueueIndex;                                     // 0x0184(0x0004) (Config, GlobalConfig)
	TArray<int>                                        CurrentMultiQueues;                                       // 0x0188(0x0010) (Config, GlobalConfig, NeedCtorLink)
	TArray<int>                                        OptOutMultiQueues;                                        // 0x0198(0x0010) (Config, GlobalConfig, NeedCtorLink)
	int                                                loadingPortraitBanner;                                    // 0x01A8(0x0004)
	TArray<int>                                        newUserWatchedVideos;                                     // 0x01AC(0x0010) (AlwaysInit, NeedCtorLink)
	int                                                ChosenSkinId;                                             // 0x01BC(0x0004)
	int                                                ChosenClassId;                                            // 0x01C0(0x0004)
	int                                                ChosenWeaponId;                                           // 0x01C4(0x0004)
	int                                                ChosenWeaponSkinId;                                       // 0x01C8(0x0004)
	int                                                ChosenPedestalId;                                         // 0x01CC(0x0004)
	int                                                SelectedChampionSortIndex;                                // 0x01D0(0x0004) (Config, GlobalConfig)
	TArray<int>                                        m_CTAItemIds;                                             // 0x01D4(0x0010) (Config, GlobalConfig, NeedCtorLink)
	struct FString                                     m_PlayerCTAName;                                          // 0x01E4(0x0010) (Config, GlobalConfig, NeedCtorLink)
	TArray<int>                                        m_TransientItemsAcquired;                                 // 0x01F4(0x0010) (Config, GlobalConfig, NeedCtorLink)
	TArray<struct FString>                             m_JSONDisplayedIDs;                                       // 0x0204(0x0010) (Config, GlobalConfig, NeedCtorLink)
	struct FString                                     m_SavedLoginVersion;                                      // 0x0214(0x0010) (Config, GlobalConfig, NeedCtorLink)
	struct FString                                     m_LastLoginVersion;                                       // 0x0224(0x0010) (AlwaysInit, NeedCtorLink)
	int                                                m_SavedBattlePassLevel;                                   // 0x0234(0x0004) (Config, GlobalConfig)
	int                                                m_LastLoginBattlePassLevel;                               // 0x0238(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgClientSettings");
		return ptr;
	}


	bool UpdatePlayerMuteSetting(bool PlayerMuteSetting);
	void SetCastMode(TEnumAsByte<ECastMode> castModeVal, int nCharId, TEnumAsByte<ETG_EQUIP_POINT> EquipPoint);
	TEnumAsByte<ECastMode> STATIC_GetCastMode(int nCharId, TEnumAsByte<ETG_EQUIP_POINT> EquipPoint);
	void OverrideVoiceInGameSettings(bool bOverride);
	bool WriteSaveGameDataViaInterface(unsigned char LocalUserNum, const struct FString& Title, const struct FString& SubTitle, const struct FString& Description, struct FString* SaveFileName, TArray<unsigned char>* SaveGameData);
	bool GetSaveGameDataViaInterface(unsigned char LocalUserNum, struct FString* SaveFileName, unsigned char* bIsValid, TArray<unsigned char>* SaveGameData);
	bool ConditionalReadSaveGameData(int PlayerID, const struct FString& SaveFileName);
	void OnReadSaveGameData(bool bWasSuccessful, unsigned char LocalUserNum, const struct FString& SaveFileName);
	float STATIC_GetDesiredAspectRatio();
	void STATIC_UpdateLastLoginVersion();
	void SavePlayerSettings();
	void STATIC_LoadPlayerSettingsFromIni();
	void STATIC_LoadPlayerSettings();
	void STATIC_VerifySettingsAreValid();
	void ApplySpectatorSettings();
	void ApplyJoystickSettings();
	void ApplyAudioSettings();
	void OnSettingsChanged(int settingtype, bool bSkipSave);
	void STATIC_LoadSettingsOnStartup();
};


// Class TgGame.TgCollisionProxy
// 0x0034 (0x02B4 - 0x0280)
class ATgCollisionProxy : public AActor
{
public:
	TArray<class ATgPawn*>                             m_NearByPlayers;                                          // 0x0280(0x0010) (NeedCtorLink)
	unsigned long                                      m_bIgnoreStealthPlayers : 1;                              // 0x0290(0x0004)
	unsigned long                                      m_bIgnoreNonPlayers : 1;                                  // 0x0290(0x0004)
	unsigned long                                      m_bIgnoreInvulnerablePlayers : 1;                         // 0x0290(0x0004)
	unsigned long                                      m_bForwardOwnerOnly : 1;                                  // 0x0290(0x0004)
	struct FScriptDelegate                             __ProxyTouch__Delegate;                                   // 0x0294(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData00[0x4];                                       // 0x0294(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY
	struct FScriptDelegate                             __ProxyUnTouch__Delegate;                                 // 0x02A4(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData01[0x4];                                       // 0x02A4(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCollisionProxy");
		return ptr;
	}


	void STATIC_SetAux(const struct FName& AuxBusName, float Level);
	void ForceProximityScan(float Radius);
	void STATIC_GetNearByPlayersTaskforce(bool bEndWhenMultipleFound, TArray<int>* NearByPlayerTaskforces);
	int STATIC_GetNearByPlayers(bool bOnlyValid);
	void OnPlayerRemoved(class ATgPawn* aPawn);
	void OnPlayerAdded(class ATgPawn* aPawn);
	void CheckNearByPlayers(class ATgPawn* aPawn, bool bAdd);
	void Destroyed();
	void ForceClearNearByPlayersList();
	bool ShouldIgnoreActor(class ATgPawn* aPawn);
	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void TouchOther(class AActor* Other, class UPrimitiveComponent* OtherComp);
	void DelegatesUpdated();
	void STATIC_ForwardUnTouch(class AActor* Other);
	void STATIC_ForwardTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void ProxyUnTouch(class AActor* Other);
	void ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgCollisionProxy_Capture
// 0x0000 (0x02B4 - 0x02B4)
class ATgCollisionProxy_Capture : public ATgCollisionProxy
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCollisionProxy_Capture");
		return ptr;
	}


	void SetCaptureEnabled(bool bEnabled);
};


// Class TgGame.TgCollisionProxy_Cylinder
// 0x0008 (0x02BC - 0x02B4)
class ATgCollisionProxy_Cylinder : public ATgCollisionProxy
{
public:
	class UCylinderComponent*                          m_CollisionCylinder;                                      // 0x02B4(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCollisionProxy_Cylinder");
		return ptr;
	}

};


// Class TgGame.TgCollisionProxy_SpectatorActionListener
// 0x0010 (0x02CC - 0x02BC)
class ATgCollisionProxy_SpectatorActionListener : public ATgCollisionProxy_Cylinder
{
public:
	struct FScriptDelegate                             __ProxyDeviceOnStartFire__Delegate;                       // 0x02BC(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData00[0x4];                                       // 0x02BC(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCollisionProxy_SpectatorActionListener");
		return ptr;
	}


	void PostDemoRewind();
	bool STATIC_HasMixedTaskforcePlayersNearby();
	void STATIC_ForwardDeviceOnStartFire(class ATgPawn* FiringPawn, int nEquipSlot);
	void ProxyDeviceOnStartFire(class ATgPawn* FiringPawn, int nEquipSlot);
};


// Class TgGame.TgCollisionProxy_Mesh
// 0x0008 (0x02BC - 0x02B4)
class ATgCollisionProxy_Mesh : public ATgCollisionProxy
{
public:
	class UMeshComponent*                              m_MeshComponent;                                          // 0x02B4(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCollisionProxy_Mesh");
		return ptr;
	}


	void ScaleCollisionMesh(const struct FVector& NewScale);
	void SpawnMesh(int AssemblyID);
};


// Class TgGame.TgCollisionProxy_Objective
// 0x0000 (0x02B4 - 0x02B4)
class ATgCollisionProxy_Objective : public ATgCollisionProxy
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCollisionProxy_Objective");
		return ptr;
	}

};


// Class TgGame.TgCollisionProxy_Vortex
// 0x001C (0x02D0 - 0x02B4)
class ATgCollisionProxy_Vortex : public ATgCollisionProxy
{
public:
	float                                              m_fGroundSpeedStrafePct;                                  // 0x02B4(0x0004) (Edit)
	float                                              m_fGroundSpeedToVortex;                                   // 0x02B8(0x0004) (Edit)
	float                                              m_fGroundSpeedPctRetained;                                // 0x02BC(0x0004) (Edit)
	float                                              m_fInnerRadius;                                           // 0x02C0(0x0004) (Edit)
	unsigned long                                      m_bEnabled : 1;                                           // 0x02C4(0x0004) (Edit)
	unsigned long                                      m_bOnlyAffectCurrentTarget : 1;                           // 0x02C4(0x0004) (Edit)
	class APawn*                                       m_LastInstigator;                                         // 0x02C8(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCollisionProxy_Vortex");
		return ptr;
	}


	void OnPlayerRemoved(class ATgPawn* aPawn);
	void OnPlayerAdded(class ATgPawn* aPawn);
	bool ShouldIgnoreActor(class ATgPawn* aPawn);
	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void InstigatorChanged();
	void Tick(float DeltaTime);
};


// Class TgGame.TgCombinedPostProcessEffect
// 0x003B (0x00C0 - 0x0085)
class UTgCombinedPostProcessEffect : public UPostProcessEffect
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0085(0x0003) MISSED OFFSET
	struct FColor                                      HitEffectColor;                                           // 0x0088(0x0004) (Edit)
	struct FVector                                     SceneShadows;                                             // 0x008C(0x000C)
	struct FVector                                     SceneHighLights;                                          // 0x0098(0x000C)
	struct FVector                                     SceneMidTones;                                            // 0x00A4(0x000C)
	float                                              SceneDesaturation;                                        // 0x00B0(0x0004)
	struct FVector                                     SceneColorize;                                            // 0x00B4(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCombinedPostProcessEffect");
		return ptr;
	}

};


// Class TgGame.TgCustomCharacterComponent
// 0x004B (0x00D0 - 0x0085)
class UTgCustomCharacterComponent : public UActorComponent
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0085(0x0003) MISSED OFFSET
	TArray<class USkeletalMesh*>                       m_SourceMeshList;                                         // 0x0088(0x0010) (NeedCtorLink)
	TArray<struct FCompositeTextureType>               m_CompositeTextures;                                      // 0x0098(0x0010) (NeedCtorLink)
	int                                                m_nCompositeTextureSizeX;                                 // 0x00A8(0x0004)
	int                                                m_nCompositeTextureSizeY;                                 // 0x00AC(0x0004)
	TArray<struct FCompositePartInfo>                  m_CompositeParts;                                         // 0x00B0(0x0010) (Edit, NeedCtorLink)
	TArray<class UTgSpecialFx*>                        m_CompositeFxList;                                        // 0x00C0(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCustomCharacterComponent");
		return ptr;
	}


	void SetupCompositeRegion(int MeshAsmId, int DestOffsetX, int DestOffsetY, int SizeX, int SizeY);
	void ComposeCharacter(class USkeletalMeshComponent* Mesh);
	void MergeMeshParts(class USkeletalMeshComponent* Mesh);
};


// Class TgGame.TgDamageType
// 0x00C4 (0x0154 - 0x0090)
class UTgDamageType : public UDamageType
{
public:
	unsigned long                                      m_bImpulseMesh : 1;                                       // 0x0090(0x0004)
	unsigned long                                      m_bDisableRagdoll : 1;                                    // 0x0090(0x0004)
	unsigned long                                      m_bEnableMotors : 1;                                      // 0x0090(0x0004)
	unsigned long                                      m_bShouldRagdollAfterDeathAnim : 1;                       // 0x0090(0x0004)
	unsigned long                                      m_bCanPlayDeathSpecialFXOnDefaultDeath : 1;               // 0x0090(0x0004)
	unsigned long                                      m_bHarvestMaterialParameters : 1;                         // 0x0090(0x0004)
	unsigned long                                      m_bFreezeAnimsOnDeath : 1;                                // 0x0090(0x0004)
	unsigned long                                      m_bIgnorePersonalShields : 1;                             // 0x0090(0x0004)
	unsigned long                                      m_bIsLatent : 1;                                          // 0x0090(0x0004)
	unsigned long                                      m_bIsAOE : 1;                                             // 0x0090(0x0004)
	unsigned long                                      m_bDismountVictim : 1;                                    // 0x0090(0x0004)
	unsigned long                                      m_bPreventHitDirectionNotify : 1;                         // 0x0090(0x0004)
	float                                              m_bMinImpulse;                                            // 0x0094(0x0004)
	float                                              m_bMaxImpulse;                                            // 0x0098(0x0004)
	float                                              m_bMinUpKick;                                             // 0x009C(0x0004)
	float                                              m_bMaxUpKick;                                             // 0x00A0(0x0004)
	TArray<struct FName>                               m_nmDeathAnimNames;                                       // 0x00A4(0x0010) (NeedCtorLink)
	TArray<struct FName>                               m_nmDeathFlailAnimNames;                                  // 0x00B4(0x0010) (NeedCtorLink)
	float                                              m_fMinAngularVelocity;                                    // 0x00C4(0x0004)
	float                                              m_fMaxAngularVelocity;                                    // 0x00C8(0x0004)
	int                                                m_nDeathSpecialFXId;                                      // 0x00CC(0x0004)
	struct FName                                       m_nmDeathSpecialFXSocket;                                 // 0x00D0(0x0008)
	class UMaterialInstanceConstant*                   m_OverrideMaterial;                                       // 0x00D8(0x0008)
	float                                              m_fLifeAfterDeathSeconds;                                 // 0x00E0(0x0004)
	float                                              m_fHideAfterDeathSeconds;                                 // 0x00E4(0x0004)
	int                                                m_nFadeOutSpecialFXId;                                    // 0x00E8(0x0004)
	TArray<struct FName>                               ActivateSkelControlListOnDeath;                           // 0x00EC(0x0010) (NeedCtorLink)
	class UAkEvent*                                    m_TakeHitAkEvent;                                         // 0x00FC(0x0008)
	class UAkEvent*                                    m_TakeHeadShotAkEvent;                                    // 0x0104(0x0008)
	class UClass*                                      m_LatentDamageType;                                       // 0x010C(0x0008)
	class UTgCameraShake*                              m_LeftCameraShake;                                        // 0x0114(0x0008)
	class UTgCameraShake*                              m_RightCameraShake;                                       // 0x011C(0x0008)
	class UTgCameraShake*                              m_ForwardCameraShake;                                     // 0x0124(0x0008)
	class UTgCameraShake*                              m_BackwardCameraShake;                                    // 0x012C(0x0008)
	class UTgCameraShake*                              m_BackwardRightCameraShake;                               // 0x0134(0x0008)
	class UTgCameraShake*                              m_BackwardLeftCameraShake;                                // 0x013C(0x0008)
	class UTgCameraShake*                              m_ForwardRightCameraShake;                                // 0x0144(0x0008)
	class UTgCameraShake*                              m_ForwardLeftCameraShake;                                 // 0x014C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType");
		return ptr;
	}


	struct FName STATIC_GetRandomDeathAnimName();
	struct FName STATIC_GetRandomDeathFlailAnimName();
};


// Class TgGame.TgDamageType_AbilityCost
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_AbilityCost : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_AbilityCost");
		return ptr;
	}

};


// Class TgGame.TgDamageType_IgnoreShields
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_IgnoreShields : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_IgnoreShields");
		return ptr;
	}

};


// Class TgGame.TgDamageType_Latent
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_Latent : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_Latent");
		return ptr;
	}

};


// Class TgGame.TgDamageType_NoRagdoll
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_NoRagdoll : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_NoRagdoll");
		return ptr;
	}

};


// Class TgGame.TgDamageType_BattleByteWeaponSkin
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_BattleByteWeaponSkin : public UTgDamageType_NoRagdoll
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_BattleByteWeaponSkin");
		return ptr;
	}

};


// Class TgGame.TgDamageType_GoldenWeaponSkin
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_GoldenWeaponSkin : public UTgDamageType_NoRagdoll
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_GoldenWeaponSkin");
		return ptr;
	}

};


// Class TgGame.TgDamageType_LegendaryWeaponSkin
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_LegendaryWeaponSkin : public UTgDamageType_NoRagdoll
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_LegendaryWeaponSkin");
		return ptr;
	}

};


// Class TgGame.TgDamageType_PaladinsExecute
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_PaladinsExecute : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_PaladinsExecute");
		return ptr;
	}

};


// Class TgGame.TgDamageType_PaladinsRoyaleFog
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_PaladinsRoyaleFog : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_PaladinsRoyaleFog");
		return ptr;
	}

};


// Class TgGame.TgDamageType_PaladinsSniper
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_PaladinsSniper : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_PaladinsSniper");
		return ptr;
	}

};


// Class TgGame.TgDestructible
// 0x0020 (0x0308 - 0x02E8)
class ATgDestructible : public ASkeletalMeshActor
{
public:
	class ATgEffectManager*                            r_EffectManager;                                          // 0x02E8(0x0008) (Net)
	int                                                r_nMaxHealth;                                             // 0x02F0(0x0004) (Edit, Net)
	unsigned long                                      m_bDisplayHealth : 1;                                     // 0x02F4(0x0004) (Edit)
	unsigned long                                      m_bDestroyed : 1;                                         // 0x02F4(0x0004)
	unsigned long                                      m_bInitialized : 1;                                       // 0x02F4(0x0004) (Transient)
	unsigned long                                      m_bFogOfWarBlocker : 1;                                   // 0x02F4(0x0004) (Edit)
	unsigned long                                      m_bOneDirectional : 1;                                    // 0x02F4(0x0004) (Edit)
	int                                                m_nPhysicalType;                                          // 0x02F8(0x0004) (Edit)
	unsigned char                                      m_nTaskForce;                                             // 0x02FC(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x02FD(0x0003) MISSED OFFSET
	int                                                r_nHealth;                                                // 0x0300(0x0004) (Net)
	int                                                r_nActorInstanceId;                                       // 0x0304(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDestructible");
		return ptr;
	}


	bool CanApplyEffects();
	void Destroyed();
	void DestroyIt(bool bSkipFx);
	void TakeDamage(int Damage, class AController* EventInstigator, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void ReplicatedEvent(const struct FName& VarName);
	void PostBeginPlay();
	void ForceNetRelevant();
	bool IsFriendlyWithLocalPawn();
};


// Class TgGame.TgRespawnBeaconBase
// 0x0024 (0x032C - 0x0308)
class ATgRespawnBeaconBase : public ATgDestructible
{
public:
	int                                                m_nMeshAssemblyId;                                        // 0x0308(0x0004) (Edit, Const, EditConst)
	class UMeshComponent*                              m_ActualMeshComponent;                                    // 0x030C(0x0008) (ExportObject, Transient, Component, EditInline)
	TArray<class UTgAnimBlendByTeleportBeacon*>        m_BeaconNodes;                                            // 0x0314(0x0010) (Transient, NeedCtorLink)
	unsigned long                                      c_bEnemyMatLoaded : 1;                                    // 0x0324(0x0004) (Transient)
	unsigned long                                      m_bShouldShowSilhouetteToFriends : 1;                     // 0x0324(0x0004) (Const)
	float                                              m_fDeployTime;                                            // 0x0328(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRespawnBeaconBase");
		return ptr;
	}


	void STATIC_NotifyLocalPlayerTeamReceived();
	void PostInitAnimTree(class USkeletalMeshComponent* SkelComp);
	void STATIC_RecalculateMaterial(bool bIsFriendlyWithLocalPawn, bool bForce);
	void ForceRecalculateMaterial();
};


// Class TgGame.TgRespawnBeaconEntrance
// 0x0038 (0x0364 - 0x032C)
class ATgRespawnBeaconEntrance : public ATgRespawnBeaconBase
{
public:
	class ATgRespawnBeaconExit*                        ExitBeacon;                                               // 0x032C(0x0008) (Edit)
	unsigned long                                      r_bEntranceActive : 1;                                    // 0x0334(0x0004) (Edit, Net)
	unsigned char                                      r_nPendingTeleport;                                       // 0x0338(0x0001) (Net)
	TEnumAsByte<ERespawnBeaconChargingState>           c_LocalChargingState;                                     // 0x0339(0x0001) (Transient)
	TEnumAsByte<ERespawnBeaconChargingState>           r_ChargingState;                                          // 0x033A(0x0001) (Net)
	unsigned char                                      UnknownData00[0x1];                                       // 0x033B(0x0001) MISSED OFFSET
	class UTgParticleSystemComponent*                  m_TeleportPSC;                                            // 0x033C(0x0008) (ExportObject, Component, EditInline)
	float                                              m_fChargeDelay;                                           // 0x0344(0x0004)
	float                                              m_fTeleportDelay;                                         // 0x0348(0x0004)
	float                                              m_fPreTeleportFXTime;                                     // 0x034C(0x0004)
	float                                              s_fChargeStateTimeStamp;                                  // 0x0350(0x0004)
	TArray<struct FPendingTeleportInfo>                s_PendingTeleports;                                       // 0x0354(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRespawnBeaconEntrance");
		return ptr;
	}


	bool CanApplyEffects();
	void STATIC_DisableBeaconFX();
	void STATIC_EnableBeaconSetupFX();
	void BeaconSetActive();
	void SetChargingState(TEnumAsByte<ERespawnBeaconChargingState> chargeState);
	void ChargingStateChangedFX();
	void ClientFlashTeleportFX();
	void FlashTeleportFx(class ATgPawn* TgP);
	void UnTouch(class AActor* Other);
	void PostTouch(class AActor* Other);
	class AActor* STATIC_GetNextPendingTeleport();
	bool RemovePendingTeleport(class AActor* Other);
	bool AddPendingTeleport(class AActor* Other);
	bool STATIC_VerifyCanTeleport(class ATgPawn* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void OnBeaconEntranceSetActive(class UTgSeqAct_BeaconEntranceSetActive* inAction);
	void ConnectToExit();
	void PostBeginPlay();
	void ReplicatedEvent(const struct FName& VarName);
};


// Class TgGame.TgRespawnBeaconExit
// 0x00C4 (0x03F0 - 0x032C)
class ATgRespawnBeaconExit : public ATgRespawnBeaconBase
{
public:
	unsigned long                                      m_bChangesYaw : 1;                                        // 0x032C(0x0004) (Edit)
	unsigned long                                      c_bHiddenToLocalPlayer : 1;                               // 0x032C(0x0004)
	float                                              m_fPercHealthPerSec;                                      // 0x0330(0x0004) (Edit)
	float                                              m_fHealthRegenLockoutTime;                                // 0x0334(0x0004) (Edit)
	int                                                r_nRespawnTime;                                           // 0x0338(0x0004) (Net)
	float                                              m_fTimeUntilHealTick;                                     // 0x033C(0x0004)
	struct FRotator                                    m_rInitialRot;                                            // 0x0340(0x000C)
	struct FVector                                     m_vInitialPos;                                            // 0x034C(0x000C)
	class ATgRepInfo_Player*                           r_CarrierRepInfo;                                         // 0x0358(0x0008) (Net)
	class AActor*                                      m_SpawnPointOverride;                                     // 0x0360(0x0008)
	class ATgVisibilityVolume*                         r_CurrentVisibilityVolumes[0x2];                          // 0x0368(0x0008) (Net)
	TEnumAsByte<ERespawnBeaconActiveState>             c_LocalActiveState;                                       // 0x0378(0x0001)
	TEnumAsByte<ERespawnBeaconActiveState>             r_ActiveState;                                            // 0x0379(0x0001) (Net)
	unsigned char                                      r_nPlayTakeHit;                                           // 0x037A(0x0001) (Net)
	unsigned char                                      UnknownData00[0x1];                                       // 0x037B(0x0001) MISSED OFFSET
	TArray<class ATgRespawnBeaconEntrance*>            m_Entrances;                                              // 0x037C(0x0010) (Transient, NeedCtorLink)
	TArray<struct FScriptDelegate>                     m_CarriedDel;                                             // 0x038C(0x0010) (Transient, NeedCtorLink)
	TArray<struct FScriptDelegate>                     m_DestroyedDel;                                           // 0x039C(0x0010) (Transient, NeedCtorLink)
	TArray<struct FScriptDelegate>                     m_DeployingDel;                                           // 0x03AC(0x0010) (Transient, NeedCtorLink)
	TArray<struct FScriptDelegate>                     m_ActiveDel;                                              // 0x03BC(0x0010) (Transient, NeedCtorLink)
	struct FVector                                     r_nDeathLocation;                                         // 0x03CC(0x000C) (Net)
	class AController*                                 m_LastDamager;                                            // 0x03D8(0x0008)
	struct FScriptDelegate                             __BeaconStateChanged__Delegate;                           // 0x03E0(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData01[0x4];                                       // 0x03E0(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRespawnBeaconExit");
		return ptr;
	}


	void SetPendingTeleportFx(bool bIsPendingTeleport);
	void ClientFlashTeleportFX();
	void SetActiveState(TEnumAsByte<ERespawnBeaconActiveState> NewState);
	void TakeDamage(int Damage, class AController* EventInstigator, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void PlayTakeHitEffect();
	void STATIC_FXEndActive();
	void STATIC_FXEndDeploying();
	void STATIC_FXActive();
	void STATIC_FXDeploying();
	void STATIC_FXDestroyed();
	void STATIC_FXCarried();
	void STATIC_Respawn();
	void STATIC_UpdateRespawnTime();
	void BeginRespawnTimer();
	float STATIC_GetDesiredLifeSpan();
	void DestroyIt(bool bSkipFx);
	void Deployed();
	void PlaceAtLocation(const struct FVector& NewLocation, const struct FRotator& NewRotation);
	void PlaceFromDeploy(class ATgDeploy_RespawnBeacon* TgD);
	void Place(class ATgPawn* TgP);
	bool STATIC_Pickup(class ATgPawn* TgP);
	bool CanBePickedUp(class ATgPawn* TgP);
	bool STATIC_IsValidTarget(class ATgPawn* TgP);
	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void SetBeaconCollision(bool IsActive);
	bool AcceptTeleport(class ATgPawn* Incoming, class ATgRespawnBeaconEntrance* Source);
	void PostBeginPlay();
	void RemoveVisibilityVolume(class ATgVisibilityVolume* Vol);
	void AddVisibilityVolume(class ATgVisibilityVolume* Vol);
	void OnBeaconExitSetRespawn(class UTgSeqAct_BeaconExitSetRespawn* inAction);
	void ReplicatedEvent(const struct FName& VarName);
	bool STATIC_HasAnyEnabledEntrances();
	void OnBeaconReset();
	void BeaconStateChanged();
};


// Class TgGame.TgDeviceInterface_DismountModifier
// 0x0000 (0x0060 - 0x0060)
class UTgDeviceInterface_DismountModifier : public UInterface
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceInterface_DismountModifier");
		return ptr;
	}


	bool ShouldOverrideDismount(int DamageAmt);
};


// Class TgGame.TgDistributionFloatLitParticleBrightness
// 0x0000 (0x0080 - 0x0080)
class UTgDistributionFloatLitParticleBrightness : public UDistributionFloatConstant
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDistributionFloatLitParticleBrightness");
		return ptr;
	}

};


// Class TgGame.TgDistributionFloatSoundAttenuation
// 0x0040 (0x00BC - 0x007C)
class UTgDistributionFloatSoundAttenuation : public UDistributionFloat
{
public:
	TEnumAsByte<ESoundAttenuationType>                 AttenuationType;                                          // 0x007C(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x007D(0x0003) MISSED OFFSET
	float                                              Attenuation_Sm_foley;                                     // 0x0080(0x0004) (Config)
	float                                              Attenuation_Lg_foley;                                     // 0x0084(0x0004) (Config)
	float                                              Attenuation_Melee_hit;                                    // 0x0088(0x0004) (Config)
	float                                              Attenuation_Sm_gun;                                       // 0x008C(0x0004) (Config)
	float                                              Attenuation_Med_gun;                                      // 0x0090(0x0004) (Config)
	float                                              Attenuation_Lg_gun;                                       // 0x0094(0x0004) (Config)
	float                                              Attenuation_Sm_exp;                                       // 0x0098(0x0004) (Config)
	float                                              Attenuation_Med_exp;                                      // 0x009C(0x0004) (Config)
	float                                              Attenuation_Lg_exp;                                       // 0x00A0(0x0004) (Config)
	struct FName                                       GroupName;                                                // 0x00A4(0x0008) (Edit)
	TArray<struct FAttenuationGroup>                   AttenuationGroups;                                        // 0x00AC(0x0010) (Config, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDistributionFloatSoundAttenuation");
		return ptr;
	}

};


// Class TgGame.TgExplosionLight
// 0x0034 (0x0274 - 0x0240)
class UTgExplosionLight : public UPointLightComponent
{
public:
	unsigned long                                      bCheckFrameRate : 1;                                      // 0x0240(0x0004)
	unsigned long                                      bInitialized : 1;                                         // 0x0240(0x0004)
	unsigned long                                      bIsEnemy : 1;                                             // 0x0240(0x0004) (Edit)
	unsigned long                                      bIsLocal : 1;                                             // 0x0240(0x0004) (Edit)
	unsigned long                                      bIsLooping : 1;                                           // 0x0240(0x0004)
	float                                              HighDetailFrameTime;                                      // 0x0244(0x0004)
	float                                              Lifetime;                                                 // 0x0248(0x0004)
	int                                                TimeShiftIndex;                                           // 0x024C(0x0004)
	TArray<struct FLightValues>                        TimeShift;                                                // 0x0250(0x0010) (Edit, NeedCtorLink)
	int                                                LoopIndex;                                                // 0x0260(0x0004) (Edit)
	struct FScriptDelegate                             __OnLightFinished__Delegate;                              // 0x0264(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData00[0x4];                                       // 0x0264(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgExplosionLight");
		return ptr;
	}


	void OnLightFinished(class UTgExplosionLight* Light);
	void ResetLight();
};


// Class TgGame.TgFatalityMeshActor
// 0x000C (0x028C - 0x0280)
class ATgFatalityMeshActor : public AActor
{
public:
	int                                                m_nTaskForceId;                                           // 0x0280(0x0004) (Edit)
	class UTgSkeletalMeshComponent*                    m_Mesh;                                                   // 0x0284(0x0008) (Edit, ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgFatalityMeshActor");
		return ptr;
	}


	void Initialize(int MeshAssemblyId, int TaskForceId);
};


// Class TgGame.TgFlagContentData
// 0x0010 (0x0070 - 0x0060)
class UTgFlagContentData : public UObject
{
public:
	TArray<struct FFlagMeshData>                       m_MeshData;                                               // 0x0060(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgFlagContentData");
		return ptr;
	}


	void PreloadTextures(float ForceDuration);
	void GetMeshData(TEnumAsByte<EFlagContentDataType> ContentDataType, struct FFlagMeshData* Data);
	void Init();
};


// Class TgGame.TgFogOfWarBarrier
// 0x0008 (0x02AC - 0x02A4)
class ATgFogOfWarBarrier : public AStaticMeshActor
{
public:
	unsigned long                                      m_bOneDirectional : 1;                                    // 0x02A4(0x0004) (Edit)
	float                                              m_fBlockMinimumDistance;                                  // 0x02A8(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgFogOfWarBarrier");
		return ptr;
	}

};


// Class TgGame.TgFortressVolume
// 0x0004 (0x02C0 - 0x02BC)
class ATgFortressVolume : public AVolume
{
public:
	int                                                TaskforceIndex;                                           // 0x02BC(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgFortressVolume");
		return ptr;
	}


	void PostBeginPlay();
	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgGameEngine
// 0x0000 (0x0AB0 - 0x0AB0)
class UTgGameEngine : public UPComGameEngine
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameEngine");
		return ptr;
	}

};


// Class TgGame.TgHUD
// 0x0008 (0x05A8 - 0x05A0)
class ATgHUD : public AHUD
{
public:
	class ATgPlayerController*                         m_TgPlayerController;                                     // 0x05A0(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgHUD");
		return ptr;
	}


	bool STATIC_FinishIntro();
	void STATIC_UpdateRoundSetupTimer(float SetupTimeRemaining, float TimeStamp);
	void STATIC_UpdateRoundEndedTimer(float RoundEndTimeRemaining, float RoundEndTotalTime);
	void OnRoundSetupStarted();
	void PlayDeviceFailResponse(TEnumAsByte<EDeviceFailType> failType, bool IsAbility);
	void ShowTargetingMap(bool bShow);
	void CommitClassSelectionChange();
	void MapOutroFinished();
	void ShowHit(class AActor* Target, float fDamageAmount, bool bIsShieldHit, struct FExtraDamageInfo* ExtraInfo);
	void ShowCursor(bool bShow);
	void TutorialMessage(int msgId, bool bTips);
	void STATIC_HideGameTip(bool bNoSound);
	void ShowGameTip(int nTipId, bool bNoSound, bool bPopup);
	void PingWorldLocation(const struct FVector& PingLocation, TEnumAsByte<EPING_TYPE> Type);
	void OnPingInfoUpdate(class ATgRepInfo_Player* updatedPri);
	void STATIC_EndMission(bool bPlayerAttacker, TEnumAsByte<EGAME_WIN_STATE> finalWinState);
	bool STATIC_UpdateItemStoreItems(class ATgRepInfo_Player* PRI);
	void STATIC_UpdateScoreboard();
	void STATIC_UpdateReleaseTimeRemaining(float fTimeRemaining);
	void PlayTakeHit(const struct FRotator& HitDir, int nDamage, class UClass* DamageType);
	bool STATIC_UpdatePlayerStatUI(class ATgPawn* changedPawn);
	bool STATIC_UpdatePlayerVitalsUI(class ATgPlayerController* PC);
	bool STATIC_UpdatePlayerInfoUI(class ATgRepInfo_Player* PRI);
	bool STATIC_UpdateGameCapturePointsUI();
	bool STATIC_UpdateGameScoreUI();
	bool STATIC_UpdateGameClockUI();
	void DeviceChangeEvent(class ATgDevice* Dev, TEnumAsByte<EDeviceChangeEvent> Event);
};


// Class TgGame.TgInterface_YingIllusion
// 0x0000 (0x0060 - 0x0060)
class UTgInterface_YingIllusion : public UInterface
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInterface_YingIllusion");
		return ptr;
	}


	class ATgPawn_Ying* STATIC_GetOwningYing();
	class AActor* STATIC_GetActorFromInterface();
	bool STATIC_IsNotDestroyed();
	void PlayDimensionalLinkFX();
	void Shatter();
	void TriggerShatter(float fDelay);
	void AddOnDestroyDelegate(const struct FScriptDelegate& delDestroy);
	void DestroyedEvent(class AActor* destroyedActor);
};


// Class TgGame.TgKActorSpawnable
// 0x0000 (0x03B8 - 0x03B8)
class ATgKActorSpawnable : public AKActorSpawnable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgKActorSpawnable");
		return ptr;
	}

};


// Class TgGame.TgKAsset_ClientSideSim
// 0x0068 (0x0304 - 0x029C)
class ATgKAsset_ClientSideSim : public AKAsset
{
public:
	float                                              m_fDamageImpulse;                                         // 0x029C(0x0004) (Edit)
	class UArrowComponent*                             m_Arrow;                                                  // 0x02A0(0x0008) (ExportObject, Component, EditInline)
	class USpriteComponent*                            m_ForceSprite;                                            // 0x02A8(0x0008) (ExportObject, Component, EditInline)
	unsigned long                                      m_bEnableWind : 1;                                        // 0x02B0(0x0004) (Edit)
	unsigned long                                      m_bEnableGusts : 1;                                       // 0x02B0(0x0004) (Edit)
	unsigned long                                      bAnimates : 1;                                            // 0x02B0(0x0004) (Edit)
	float                                              m_fWindForceMin;                                          // 0x02B4(0x0004) (Edit)
	float                                              m_fWindForceMax;                                          // 0x02B8(0x0004) (Edit)
	float                                              m_fWindForceStrength;                                     // 0x02BC(0x0004)
	float                                              m_fWindForceTargetStrength;                               // 0x02C0(0x0004)
	float                                              m_fWindFrequency;                                         // 0x02C4(0x0004) (Edit)
	float                                              m_fWindForceRemainingTime;                                // 0x02C8(0x0004)
	struct FVector                                     m_vWindDirection;                                         // 0x02CC(0x000C) (Edit)
	float                                              m_fForceDistance;                                         // 0x02D8(0x0004) (Edit)
	float                                              m_fForceZOffsetMultiplier;                                // 0x02DC(0x0004) (Edit)
	float                                              m_fGustActiveTime;                                        // 0x02E0(0x0004) (Edit)
	struct FVector2D                                   m_vTimeBetweenGusts;                                      // 0x02E4(0x0008) (Edit)
	float                                              m_fGustActiveRemainingTime;                               // 0x02EC(0x0004)
	float                                              m_fTimeTillNextGust;                                      // 0x02F0(0x0004)
	struct FVector2D                                   m_WindFrequencyMultiplier;                                // 0x02F4(0x0008) (Edit)
	struct FVector2D                                   m_WindForceMultiplier;                                    // 0x02FC(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgKAsset_ClientSideSim");
		return ptr;
	}


	void OnHit(const struct FVector& HitLocation, const struct FVector& HitNormal, class AActor* SourceActor, const struct FTraceHitInfo& HitInfo);
};


// Class TgGame.TgKAssetSpawnable
// 0x0000 (0x029C - 0x029C)
class ATgKAssetSpawnable : public AKAssetSpawnable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgKAssetSpawnable");
		return ptr;
	}

};


// Class TgGame.TgLevelStreamingSpectator
// 0x0001 (0x0101 - 0x0100)
class UTgLevelStreamingSpectator : public ULevelStreaming
{
public:
	TEnumAsByte<ESpectatorStreamingMethod>             m_LoadingMethod;                                          // 0x0100(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgLevelStreamingSpectator");
		return ptr;
	}

};


// Class TgGame.TgLevelStreamingWorldDetail
// 0x0010 (0x0110 - 0x0100)
class UTgLevelStreamingWorldDetail : public ULevelStreaming
{
public:
	int                                                MinimumWorldDetailLevel;                                  // 0x0100(0x0004) (Edit)
	int                                                MaximumWorldDetailLevel;                                  // 0x0104(0x0004) (Edit)
	unsigned char                                      CachedDetailCheck;                                        // 0x0108(0x0001) (Transient)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0109(0x0003) MISSED OFFSET
	int                                                LastUpdateTime;                                           // 0x010C(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgLevelStreamingWorldDetail");
		return ptr;
	}

};


// Class TgGame.TgLocalPlayer
// 0x003D (0x04A9 - 0x046C)
class UTgLocalPlayer : public ULocalPlayer
{
public:
	float                                              m_fViewScale;                                             // 0x046C(0x0004)
	struct FVector                                     m_vViewPan;                                               // 0x0470(0x000C)
	unsigned long                                      m_bEnableOutlineEffect : 1;                               // 0x047C(0x0004)
	unsigned long                                      m_bEnableColorBlindEffect : 1;                            // 0x047C(0x0004)
	unsigned long                                      m_bBlurForeground : 1;                                    // 0x047C(0x0004)
	float                                              m_fHitOnlyAlpha;                                          // 0x0480(0x0004)
	float                                              m_fHealthOnlyAlpha;                                       // 0x0484(0x0004)
	float                                              m_fHealthPPAlpha;                                         // 0x0488(0x0004)
	float                                              m_fDeathDesatPPAlpha;                                     // 0x048C(0x0004)
	int                                                m_eColorBlindEffectType;                                  // 0x0490(0x0004)
	float                                              m_fColorBlindIntensity;                                   // 0x0494(0x0004)
	float                                              m_fTargetBlurAmount;                                      // 0x0498(0x0004)
	float                                              m_fBlurAmount;                                            // 0x049C(0x0004)
	float                                              m_fBlurInterpSpeed;                                       // 0x04A0(0x0004)
	float                                              m_fBlurKernelSize;                                        // 0x04A4(0x0004)
	TEnumAsByte<EDOFType>                              m_eCurrentDOFType;                                        // 0x04A8(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgLocalPlayer");
		return ptr;
	}


	class UPostProcessEffect* GetPostProcessEffect(const struct FName& EffectName);
	void SetBlurAmount(float TargetBlurAmount, float InterpSpeed, float BlurKernelSize, bool bForeground);
	void STATIC_UpdateLowHealthEffect(float DeltaSeconds, float fHealthPCT, float fHealthLostPCT, bool bDeathVision);
	void STATIC_EnableColorBlindEffect(bool bEnable, int Type, float Intensity);
	void STATIC_EnableOutlineEffect(bool bEnable);
	void STATIC_InitMaterialEffects();
};


// Class TgGame.TgManifestGroup
// 0x0048 (0x00A8 - 0x0060)
class UTgManifestGroup : public UObject
{
public:
	struct FPointer                                    VfTable_FCallbackEventDevice;                             // 0x0060(0x0008) (Const, Native, NoExport)
	TArray<struct FPointer>                            m_ManifestList;                                           // 0x0068(0x0010) (Native, AlwaysInit)
	TArray<class UTgObjectReferencer*>                 m_pObjectReferencers;                                     // 0x0078(0x0010) (AlwaysInit, NeedCtorLink)
	class UObject*                                     m_OwningObject;                                           // 0x0088(0x0008)
	unsigned long                                      m_bIsInCallback : 1;                                      // 0x0090(0x0004)
	unsigned long                                      m_bInitialized : 1;                                       // 0x0090(0x0004)
	unsigned long                                      m_bResetOnMapLoad : 1;                                    // 0x0090(0x0004)
	TEnumAsByte<EAsyncLoadPriority>                    m_AsyncLoadPriority;                                      // 0x0094(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	struct FScriptDelegate                             __OnAllManifestsLoaded__Delegate;                         // 0x0098(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData01[0x4];                                       // 0x0095(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgManifestGroup");
		return ptr;
	}


	void OnAllManifestsLoaded(int PassthroughData);
};


// Class TgGame.TgMapInfo
// 0x006C (0x00CC - 0x0060)
class UTgMapInfo : public UMapInfo
{
public:
	class AActor*                                      m_EndFocusActor_TF1;                                      // 0x0060(0x0008) (Edit)
	class AActor*                                      m_EndFocusActor_TF2;                                      // 0x0068(0x0008) (Edit)
	class ATgFatalityFactory*                          m_FatalityFactory_TF1_2;                                  // 0x0070(0x0008) (Edit)
	class ATgFatalityFactory*                          m_FatalityFactory_TF1_3;                                  // 0x0078(0x0008) (Edit)
	class ATgFatalityFactory*                          m_FatalityFactory_TF1_4;                                  // 0x0080(0x0008) (Edit)
	class ATgFatalityFactory*                          m_FatalityFactory_TF2_2;                                  // 0x0088(0x0008) (Edit)
	class ATgFatalityFactory*                          m_FatalityFactory_TF2_3;                                  // 0x0090(0x0008) (Edit)
	class ATgFatalityFactory*                          m_FatalityFactory_TF2_4;                                  // 0x0098(0x0008) (Edit)
	class AStaticMeshActor*                            m_OverlayPathMesh;                                        // 0x00A0(0x0008) (Edit)
	struct FVector2D                                   m_vMapCenter;                                             // 0x00A8(0x0008) (Edit)
	struct FVector2D                                   m_vTaskForce1BaseLocation;                                // 0x00B0(0x0008) (Edit)
	struct FVector2D                                   m_vTaskForce2BaseLocation;                                // 0x00B8(0x0008) (Edit)
	float                                              m_fLockViewBufferZoneSize;                                // 0x00C0(0x0004) (Edit)
	unsigned long                                      m_bSupportsGuardianThrone : 1;                            // 0x00C4(0x0004) (Edit)
	float                                              m_LitParticleBrightness;                                  // 0x00C8(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMapInfo");
		return ptr;
	}


	class ATgFatalityFactory* STATIC_GetEmptyFatalityFactory(unsigned char TaskForceNumber);
};


// Class TgGame.TgMarkComponent
// 0x0037 (0x00BC - 0x0085)
class UTgMarkComponent : public UActorComponent
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0085(0x0003) MISSED OFFSET
	TArray<struct FTargetMark>                         s_MarkList;                                               // 0x0088(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	TArray<class UTgEffectGroup*>                      s_MarkEffectGroup;                                        // 0x0098(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	int                                                m_nHostItemId;                                            // 0x00A8(0x0004) (Const)
	unsigned long                                      m_bStackEffects : 1;                                      // 0x00AC(0x0004) (Const)
	unsigned long                                      m_bRemoveMarksOnDeath : 1;                                // 0x00AC(0x0004) (Const)
	float                                              m_fMarkDuration;                                          // 0x00B0(0x0004) (Const)
	int                                                m_nMaxMarks;                                              // 0x00B4(0x0004) (Const)
	int                                                m_nPhysicalType;                                          // 0x00B8(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMarkComponent");
		return ptr;
	}


	int STATIC_GetNumMarksFor(class AActor* Target);
	void RemoveAllMarks();
	void RemoveMarkByIndex(int nIndex);
	void RemoveAllMarksByIndex(int nIndex);
	void RemoveMarkByActor(class AActor* Target);
	void RemoveAllMarksByActor(class AActor* Target);
	void AddMark(class AActor* Target);
};


// Class TgGame.TgMenuContentData
// 0x0010 (0x0070 - 0x0060)
class UTgMenuContentData : public UObject
{
public:
	TArray<struct FMeshData>                           m_MeshData;                                               // 0x0060(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMenuContentData");
		return ptr;
	}


	void PreloadTextures(float ForceDuration);
	void GetMeshData(TEnumAsByte<EMenuContentDataType> ContentDataType, int nIndex, struct FMeshData* Data);
	void Init();
};


// Class TgGame.TgMenuMeshInfo
// 0x0094 (0x00F4 - 0x0060)
class UTgMenuMeshInfo : public UObject
{
public:
	struct FLobbyMeshInfo                              MeshInfo;                                                 // 0x0060(0x006C) (Edit, NeedCtorLink)
	TArray<class UTgMenuMeshInfo*>                     Children;                                                 // 0x00CC(0x0010) (Edit, NeedCtorLink, EditInline)
	struct FName                                       ParentSocketName;                                         // 0x00DC(0x0008)
	TArray<struct FParticleSystemInfo>                 AttachedParticleSystems;                                  // 0x00E4(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMenuMeshInfo");
		return ptr;
	}


	void PreloadTextures(float ForceDuration);
	bool STATIC_IsFullyConfigured();
	void AddFxAttachments(class UTgSkeletalMeshComponent* SkelComp);
	void SetupMeshFromMeshInfo(class UTgSkeletalMeshComponent* SkelComp, class UTgSkeletalMeshComponent* Parent);
	void ConfigureMesh(class ATgSkeletalMeshActor_Loader* lobbyOwner, class UTgSkeletalMeshComponent* Parent);
};


// Class TgGame.TgMenuTransitionActor
// 0x001C (0x029C - 0x0280)
class ATgMenuTransitionActor : public AActor
{
public:
	class UParticleSystemComponent*                    m_IntroPSC;                                               // 0x0280(0x0008) (ExportObject, Component, EditInline)
	class UParticleSystemComponent*                    m_LoopPSC;                                                // 0x0288(0x0008) (ExportObject, Component, EditInline)
	class UParticleSystemComponent*                    m_OutroPSC;                                               // 0x0290(0x0008) (ExportObject, Component, EditInline)
	TEnumAsByte<ENotifySound>                          m_eIntroNotify;                                           // 0x0298(0x0001)
	TEnumAsByte<ENotifySound>                          m_eLoopStartNotify;                                       // 0x0299(0x0001)
	TEnumAsByte<ENotifySound>                          m_eLoopStopNotify;                                        // 0x029A(0x0001)
	TEnumAsByte<ENotifySound>                          m_eOutroNotify;                                           // 0x029B(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMenuTransitionActor");
		return ptr;
	}


	void STATIC_PlaySoundNotify(TEnumAsByte<ENotifySound> eNotity);
	void PlayOutro();
	void StopLoop();
	void PlayLoop();
	void PlayIntro();
};


// Class TgGame.TgMeshAssembly
// 0x0018 (0x0298 - 0x0280)
class ATgMeshAssembly : public AActor
{
public:
	int                                                m_nMeshAsmId;                                             // 0x0280(0x0004) (Edit)
	int                                                m_nTeam;                                                  // 0x0284(0x0004) (Edit)
	class UMeshComponent*                              m_Mesh;                                                   // 0x0288(0x0008) (ExportObject, Transient, Component, EditInline)
	class ULightEnvironmentComponent*                  m_LightEnvironment;                                       // 0x0290(0x0008) (Const, ExportObject, EditConst, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMeshAssembly");
		return ptr;
	}


	void STATIC_NotifyLocalPlayerTeamReceived();
	void PostBeginPlay();
	void RecalculateTeamColor();
	void STATIC_LoadMesh();
};


// Class TgGame.TgNamedPOIActor
// 0x0018 (0x0298 - 0x0280)
class ATgNamedPOIActor : public AActor
{
public:
	int                                                m_nMessageId;                                             // 0x0280(0x0004) (Edit)
	struct FString                                     m_PreviewText;                                            // 0x0284(0x0010) (Edit, EditConst, NeedCtorLink)
	unsigned long                                      m_bIsRegion : 1;                                          // 0x0294(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgNamedPOIActor");
		return ptr;
	}


	struct FString STATIC_GetPOINamedString();
};


// Class TgGame.TgNewUserSettings
// 0x0010 (0x0070 - 0x0060)
class UTgNewUserSettings : public UObject
{
public:
	TArray<int>                                        WatchedVideoIds;                                          // 0x0060(0x0010) (Edit, Config, GlobalConfig, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgNewUserSettings");
		return ptr;
	}

};


// Class TgGame.TgObject
// 0x0000 (0x0060 - 0x0060)
class UTgObject : public UObject
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgObject");
		return ptr;
	}


	void SetLocationAttached(class AActor* ActorToMove, const struct FVector& vLocation);
	void ScriptSetParticleFloatParamOnMesh(class UMeshComponent* MeshComp, const struct FName& nmName, float fValue, const struct FName& nmDisplayGroup, int nEqpSlot);
	void STATIC_ScriptSetMaterialParamStateOnMesh(class UMeshComponent* MeshComp, const struct FName& nmToStateName, const struct FName& nmFromStateName, float fInterpTime, int nMaterialIndex);
	void ScriptSetVectorMaterialParamOnMesh(class UMeshComponent* MeshComp, const struct FName& nmName, const struct FLinearColor& Value, int nMaterialIndex);
	void ScriptSetScalarMaterialParamOnMesh(class UMeshComponent* MeshComp, const struct FName& nmName, float fValue, int nMaterialIndex);
	float STATIC_GetPseudoRandomFractionFromSeed(int nSeed);
	class ATgPlayerController* ScriptGetLocalTGPlayerController();
	void StartFire();
	void SetTaskForceNumber();
	void InitializeDefaultProps();
	void SortDamageDisplay();
	void IsFriendlyWithLocalPawn();
};


// Class TgGame.TgObjectReferencer
// 0x0008 (0x007C - 0x0074)
class UTgObjectReferencer : public UObjectReferencer
{
public:
	struct FPointer                                    m_Manifest;                                               // 0x0074(0x0008) (Native)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgObjectReferencer");
		return ptr;
	}

};


// Class TgGame.TgParticleSystemComponent
// 0x000C (0x03D4 - 0x03C8)
class UTgParticleSystemComponent : public UParticleSystemComponent
{
public:
	class USkeletalMeshComponent*                      m_AttachedToSkelMesh;                                     // 0x03C8(0x0008) (Edit, ExportObject, Component, EditInline)
	unsigned long                                      m_bReenableAfterTeleport : 1;                             // 0x03D0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgParticleSystemComponent");
		return ptr;
	}

};


// Class TgGame.TgProperty
// 0x0000 (0x0060 - 0x0060)
class UTgProperty : public UObject
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProperty");
		return ptr;
	}


	int STATIC_GetPropIndexByName(const struct FString& propName);
	int STATIC_GetPropIndex(int propId);
	float STATIC_GetCurrentValue(struct FTgPropertyInstance* prop);
};


// Class TgGame.TgRecoilKeyframe
// 0x0028 (0x0088 - 0x0060)
class UTgRecoilKeyframe : public UObject
{
public:
	float                                              firingTime;                                               // 0x0060(0x0004) (Edit)
	struct FRawDistributionFloat                       RecoilPerShot;                                            // 0x0064(0x0024) (Edit, Component, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRecoilKeyframe");
		return ptr;
	}

};


// Class TgGame.TgSavedMove
// 0x0040 (0x0158 - 0x0118)
class UTgSavedMove : public USavedMove
{
public:
	unsigned long                                      m_bJumpHeld : 1;                                          // 0x0118(0x0004)
	unsigned long                                      m_bUltHeld : 1;                                           // 0x0118(0x0004)
	unsigned long                                      m_bJustForcedVelocity : 1;                                // 0x0118(0x0004)
	unsigned long                                      m_bOldWantsCharge : 1;                                    // 0x0118(0x0004)
	unsigned char                                      m_byMoveSpeed;                                            // 0x011C(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x011D(0x0003) MISSED OFFSET
	float                                              m_fSimulatedModifiedMovementSpeed;                        // 0x0120(0x0004)
	float                                              m_fSimulatedModifiedGravity;                              // 0x0124(0x0004)
	int                                                m_nBigTeleportCount;                                      // 0x0128(0x0004)
	struct FSavedChargeState                           m_SavedChargeState;                                       // 0x012C(0x002C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSavedMove");
		return ptr;
	}


	unsigned char CompressedFlags();
	void Clear();
};


// Class TgGame.TgScreenCapturePostEffect
// 0x000C (0x009C - 0x0090)
class UTgScreenCapturePostEffect : public UMaterialEffect
{
public:
	class UTextureRenderTarget2D*                      ScreenCapture;                                            // 0x0090(0x0008) (Transient)
	unsigned long                                      bIsScreenCaptureReady : 1;                                // 0x0098(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgScreenCapturePostEffect");
		return ptr;
	}


	void Cleanup(class UPostProcessChain* InPostProcessChain);
	void CleanupRenderTarget();
	void InitializeRenderTarget(class APlayerController* PlayerController);
};


// Class TgGame.TgSeqEvent_BotDied
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_BotDied : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_BotDied");
		return ptr;
	}


	void UpdateLinkedVars(class AActor* Killer);
};


// Class TgGame.TgSeqEvent_BotSpawned
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_BotSpawned : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_BotSpawned");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_BurnCardPurchased
// 0x0008 (0x0130 - 0x0128)
class UTgSeqEvent_BurnCardPurchased : public USequenceEvent
{
public:
	int                                                nFilledSlots;                                             // 0x0128(0x0004)
	unsigned long                                      bAllBurnSlotsFull : 1;                                    // 0x012C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_BurnCardPurchased");
		return ptr;
	}


	bool TriggerGlobal(class AActor* InInstigator, int InFilledSlotsCount, bool bInAllBurnSlotsFull);
};


// Class TgGame.TgSeqEvent_ChaosGameEvent
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_ChaosGameEvent : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_ChaosGameEvent");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_ClassSelected
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_ClassSelected : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_ClassSelected");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_DebugConsoleKismetTest
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_DebugConsoleKismetTest : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_DebugConsoleKismetTest");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_DoorStatusChanged
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_DoorStatusChanged : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_DoorStatusChanged");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_FactoryEmpty
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_FactoryEmpty : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_FactoryEmpty");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_InputReceived
// 0x0004 (0x012C - 0x0128)
class UTgSeqEvent_InputReceived : public USequenceEvent
{
public:
	unsigned long                                      bAllowInputDisabling : 1;                                 // 0x0128(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_InputReceived");
		return ptr;
	}


	bool TriggerGlobal(class AActor* InInstigator, TEnumAsByte<EPlayerInputType> InputType, bool bInputEnabled);
};


// Class TgGame.TgSeqEvent_LoadoutChanged
// 0x0004 (0x012C - 0x0128)
class UTgSeqEvent_LoadoutChanged : public USequenceEvent
{
public:
	int                                                DeckId;                                                   // 0x0128(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_LoadoutChanged");
		return ptr;
	}


	bool TriggerGlobal(class AActor* InInstigator, int InDeckId);
};


// Class TgGame.TgSeqEvent_LobbyEvents
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_LobbyEvents : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_LobbyEvents");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_LocalPlayerDied
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_LocalPlayerDied : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_LocalPlayerDied");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_LocalPlayerRecalled
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_LocalPlayerRecalled : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_LocalPlayerRecalled");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_LocalPlayerScoredKill
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_LocalPlayerScoredKill : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_LocalPlayerScoredKill");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_LocalPlayersTeamScoredPhoenixKill
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_LocalPlayersTeamScoredPhoenixKill : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_LocalPlayersTeamScoredPhoenixKill");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_LocalPlayersTeamScoredTowerKill
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_LocalPlayersTeamScoredTowerKill : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_LocalPlayersTeamScoredTowerKill");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_LookAtReceived
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_LookAtReceived : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_LookAtReceived");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_MICParameterEvent
// 0x0014 (0x013C - 0x0128)
class UTgSeqEvent_MICParameterEvent : public USequenceEvent
{
public:
	TEnumAsByte<EeMICEventType>                        MICEventType;                                             // 0x0128(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0129(0x0003) MISSED OFFSET
	TArray<class UMaterialInstanceConstant*>           AttachedMICs;                                             // 0x012C(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_MICParameterEvent");
		return ptr;
	}


	void STATIC_SetVectorParameterValue(const struct FName& ParamName, const struct FLinearColor& Value);
	void STATIC_SetScalarParameterValue(const struct FName& ParamName, float fValue);
};


// Class TgGame.TgSeqEvent_PayloadGameEvent
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_PayloadGameEvent : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_PayloadGameEvent");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_PlaceableDestroyed
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_PlaceableDestroyed : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_PlaceableDestroyed");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_PlayerCountHit
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_PlayerCountHit : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_PlayerCountHit");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_PlayerInitialized
// 0x0004 (0x012C - 0x0128)
class UTgSeqEvent_PlayerInitialized : public USequenceEvent
{
public:
	unsigned long                                      bLocalPlayerOnly : 1;                                     // 0x0128(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_PlayerInitialized");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_PlayOfTheGame
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_PlayOfTheGame : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_PlayOfTheGame");
		return ptr;
	}


	void UpdateLinkedVars(int MapLane);
};


// Class TgGame.TgSeqEvent_SurvivalGameEvent
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_SurvivalGameEvent : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_SurvivalGameEvent");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_TutorialEvent
// 0x0008 (0x0130 - 0x0128)
class UTgSeqEvent_TutorialEvent : public USequenceEvent
{
public:
	TEnumAsByte<ETUTORIAL_EVENT>                       TutEvent;                                                 // 0x0128(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0129(0x0003) MISSED OFFSET
	int                                                EventData;                                                // 0x012C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_TutorialEvent");
		return ptr;
	}


	int GetObjClassVersion();
};


// Class TgGame.TgSeqEvent_VaultLowHealth
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_VaultLowHealth : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_VaultLowHealth");
		return ptr;
	}

};


// Class TgGame.TgSkinnableInterface
// 0x0000 (0x0060 - 0x0060)
class UTgSkinnableInterface : public UInterface
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkinnableInterface");
		return ptr;
	}

};


// Class TgGame.TgSoundNodeAttenuation
// 0x0000 (0x0094 - 0x0094)
class UTgSoundNodeAttenuation : public USoundNodeAttenuation
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSoundNodeAttenuation");
		return ptr;
	}

};


// Class TgGame.TgSpectatorDirector
// 0x007C (0x02FC - 0x0280)
class ATgSpectatorDirector : public AInfo
{
public:
	unsigned long                                      m_bIsActive : 1;                                          // 0x0280(0x0004) (Transient)
	unsigned long                                      m_bIsPending : 1;                                         // 0x0280(0x0004) (Transient)
	unsigned long                                      m_bAutoSwitchCameraViews : 1;                             // 0x0280(0x0004) (Transient)
	unsigned long                                      m_bForceThirdPersonView : 1;                              // 0x0280(0x0004) (Transient)
	float                                              m_fRemainingAutoUpdateCheckTime;                          // 0x0284(0x0004)
	float                                              m_fTimeSinceViewSwitchedTeams;                            // 0x0288(0x0004)
	float                                              m_fTimeSinceViewSwitchedMode;                             // 0x028C(0x0004)
	float                                              m_fRemainingAutoReturnCheckTime;                          // 0x0290(0x0004)
	TEnumAsByte<ESpectatorCameraMode>                  m_CurrentCameraMode;                                      // 0x0294(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0295(0x0003) MISSED OFFSET
	struct FViewTargetInfo                             m_CurrentRatedViewTarget;                                 // 0x0298(0x002C)
	struct FViewTargetInfo                             m_DemoRewindViewTarget;                                   // 0x02C4(0x002C) (Transient)
	struct FVector2D                                   m_v2dForcedDirectorLocation;                              // 0x02F0(0x0008) (Transient)
	float                                              m_fForcedDirectorLocationTimestamp;                       // 0x02F8(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSpectatorDirector");
		return ptr;
	}


	void SetForcedDirectorLocation(const struct FVector2D& NewLocation);
	void ClearAssistModeTarget();
	void PostDemoRewind();
	void PreDemoRewind();
	bool STATIC_IsPending();
	bool STATIC_IsActive();
	void ResetCamera(class ATgSpectatorController* PC);
	void STATIC_SetActive(bool bIsActive);
	void SetCameraMode(TEnumAsByte<ESpectatorCameraMode> NewCameraMode);
	void SetViewTarget(const struct FViewTargetInfo& NewViewTarget);
	void STATIC_UpdateOverviewCamUI(bool bEnable);
	void OnPlayerMoved();
	bool STATIC_IsCurrentlyViewing();
};


// Class TgGame.TgSplineLoftActorSpawnable
// 0x0000 (0x0340 - 0x0340)
class ATgSplineLoftActorSpawnable : public ASplineLoftActorMovable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSplineLoftActorSpawnable");
		return ptr;
	}

};


// Class TgGame.TgStealthGrassActor
// 0x0080 (0x0300 - 0x0280)
class ATgStealthGrassActor : public AActor
{
public:
	struct FVector                                     c_vBaseOffset;                                            // 0x0280(0x000C)
	struct FVector                                     c_vGrassOffset;                                           // 0x028C(0x000C) (Edit)
	float                                              c_fGrassOffsetInterpSpeed;                                // 0x0298(0x0004) (Edit)
	unsigned long                                      c_bLowerGrass : 1;                                        // 0x029C(0x0004)
	unsigned long                                      m_bHasLoot : 1;                                           // 0x029C(0x0004)
	unsigned long                                      r_bCanHealNow : 1;                                        // 0x029C(0x0004) (Net)
	float                                              c_fLowerGrassAlpha;                                       // 0x02A0(0x0004)
	class UStaticMeshComponent*                        c_GrassMesh;                                              // 0x02A4(0x0008) (Edit, ExportObject, Component, EditInline)
	class UStaticMeshComponent*                        c_GroundMesh;                                             // 0x02AC(0x0008) (Edit, ExportObject, Component, EditInline)
	class UParticleSystemComponent*                    m_ParticleSystemComponent;                                // 0x02B4(0x0008) (Edit, Const, ExportObject, EditConst, Component, EditInline)
	class UParticleSystem*                             m_LootParticleSystem;                                     // 0x02BC(0x0008)
	class UParticleSystem*                             m_NoLootParticleSystem;                                   // 0x02C4(0x0008)
	class ATgDeployable*                               m_SpawnedDeployable;                                      // 0x02CC(0x0008)
	float                                              m_fDeployableSpawnTimer;                                  // 0x02D4(0x0004) (Edit)
	float                                              m_fDeployableSpawnChanceOnInit;                           // 0x02D8(0x0004) (Edit)
	float                                              m_fDeployableSpawnChanceOnTimer;                          // 0x02DC(0x0004) (Edit)
	int                                                m_nLootDeployableId;                                      // 0x02E0(0x0004)
	class ATgDevice*                                   m_HealingDevice;                                          // 0x02E4(0x0008)
	int                                                m_HealingDeviceId;                                        // 0x02EC(0x0004)
	float                                              m_fDisableHealingTime;                                    // 0x02F0(0x0004)
	float                                              m_fEnableHealingTime;                                     // 0x02F4(0x0004)
	float                                              AlwaysRelevantDistanceSquared;                            // 0x02F8(0x0004)
	float                                              MaxRelevantDistanceSquared;                               // 0x02FC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgStealthGrassActor");
		return ptr;
	}


	void OnTouchedHealthNugget(bool bTouched);
	void SetCanHealNow(bool bEnabled);
	void SpawnDeployableTimer();
	void STATIC_EnableHealingTimer();
	void STATIC_DisableHealingTimer();
	void ApplyHealingTimer();
	void CacheHealingDevice();
	void PostBeginPlay();
	void SpawnDeployable(float SpawnChance);
	void ReplicatedEvent(const struct FName& VarName);
};


// Class TgGame.TgTargetAimTrackingCurves
// 0x0098 (0x00F8 - 0x0060)
class UTgTargetAimTrackingCurves : public UObject
{
public:
	struct FName                                       SettingsName;                                             // 0x0060(0x0008) (Edit)
	struct FRawDistributionFloat                       StrengthByAccuracyX;                                      // 0x0068(0x0024) (Edit, Component, NeedCtorLink)
	struct FRawDistributionFloat                       StrengthByDesiredAngleX;                                  // 0x008C(0x0024) (Edit, Component, NeedCtorLink)
	struct FRawDistributionFloat                       StrengthByAccuracyY;                                      // 0x00B0(0x0024) (Edit, Component, NeedCtorLink)
	struct FRawDistributionFloat                       StrengthByDesiredAngleY;                                  // 0x00D4(0x0024) (Edit, Component, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgTargetAimTrackingCurves");
		return ptr;
	}

};


// Class TgGame.TgTimerManager
// 0x0054 (0x00B4 - 0x0060)
class UTgTimerManager : public UObject
{
public:
	struct FPointer                                    VfTable_FTickableObject;                                  // 0x0060(0x0008) (Const, Native, NoExport)
	unsigned char                                      UnknownData00[0x48];                                      // 0x0068(0x0048) UNKNOWN PROPERTY: MapProperty TgGame.TgTimerManager.m_TimerMap
	unsigned long                                      m_bActive : 1;                                            // 0x00B0(0x0004)
	unsigned long                                      m_bGameWasPaused : 1;                                     // 0x00B0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgTimerManager");
		return ptr;
	}


	void CloseAllTimers(bool bFireEvent);
	bool STATIC_IsActiveTimers();
	bool STATIC_UnRegisterForEvents(int byTimerIndex, class UObject* HostObject);
	bool RegisterForEvents(int byTimerIndex, class UObject* HostObject, const struct FName& nmFunc);
	void SetRate(int TimerIndex, float Rate);
	float STATIC_GetTimeInitial(int byTimerIndex);
	float STATIC_GetPercentRemaining(int byTimerIndex);
	float STATIC_GetTimeRemaining(int byTimerIndex);
	float STATIC_GetTimeElapsed(int byTimerIndex);
	bool IsPaused(int byTimerIndex);
	bool STATIC_IsSet(int byTimerIndex);
	bool STATIC_Close(int byTimerIndex, bool bFireEvent);
	bool Pause(int byTimerIndex, float fTime);
	bool Update(int byTimerIndex, float fTime, float fTimeInitial, float Rate);
	bool Start(int byTimerIndex, float fTime, bool bRepeat, bool bPausedByGame, float Rate);
};


// Class TgGame.TgVolumePathNode
// 0x001C (0x039C - 0x0380)
class ATgVolumePathNode : public AVolumePathNode
{
public:
	unsigned long                                      m_bIsAboveGround : 1;                                     // 0x0380(0x0004) (Edit, EditConst)
	struct FVector                                     m_vGroundHitLocation;                                     // 0x0384(0x000C) (Edit, EditConst)
	float                                              m_fGroundTraceDistance;                                   // 0x0390(0x0004) (Edit)
	class USpriteComponent*                            m_GroundSprite;                                           // 0x0394(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgVolumePathNode");
		return ptr;
	}

};


// Class TgGame.TgWeaponMeshActor
// 0x01D0 (0x0450 - 0x0280)
class ATgWeaponMeshActor : public AActor
{
public:
	class ATgPawn*                                     m_OwningPawn;                                             // 0x0280(0x0008)
	class UClass*                                      m_WeaponMesh1PClass;                                      // 0x0288(0x0008) (Const)
	class UTgSkeletalMeshComponent_Weapon*             m_WeaponMesh1P;                                           // 0x0290(0x0008) (ExportObject, Component, EditInline)
	class UClass*                                      m_WeaponMesh3PClass;                                      // 0x0298(0x0008) (Const)
	class UTgSkeletalMeshComponent_Weapon*             m_WeaponMesh3P;                                           // 0x02A0(0x0008) (ExportObject, Component, EditInline)
	TArray<class UTgAnimNodeSimpleTransitioner*>       m_SimpleTransitionerNodes1P;                              // 0x02A8(0x0010) (NeedCtorLink)
	TArray<class UTgAnimBlendByFireMode*>              m_DeviceModeBlendNodes;                                   // 0x02B8(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeFitToDuration*>            m_FitToDurationNodes;                                     // 0x02C8(0x0010) (NeedCtorLink)
	TArray<class UTgAnimBlendByPaladinsCharacter*>     m_PaladinsCharacterNodes;                                 // 0x02D8(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeTriggerCameraAnim*>        m_TriggerCameraAnimNodes;                                 // 0x02E8(0x0010) (NeedCtorLink)
	class UTgAnimNodeSlot*                             PoseTransitioner;                                         // 0x02F8(0x0008)
	TArray<class UTgAnimNodeSimpleTransitioner*>       m_PawnMeshSimpleTransitionerNodes;                        // 0x0300(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeFitToDuration*>            m_PawnMeshFitToDurationNodes;                             // 0x0310(0x0010) (NeedCtorLink)
	TArray<class UTgAnimBlendByPaladinsCharacter*>     m_PawnMeshPaladinsCharacterNodes;                         // 0x0320(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeTriggerCameraAnim*>        m_PawnMeshTriggerCameraAnimNodes;                         // 0x0330(0x0010) (NeedCtorLink)
	int                                                m_nNumTracersPerShot;                                     // 0x0340(0x0004)
	int                                                m_nEquipSlot;                                             // 0x0344(0x0004)
	int                                                m_nDeviceId;                                              // 0x0348(0x0004)
	int                                                m_MeshAsmId1P;                                            // 0x034C(0x0004)
	int                                                m_MeshAsmId3P;                                            // 0x0350(0x0004)
	class UClass*                                      m_WeaponClass;                                            // 0x0354(0x0008)
	TEnumAsByte<ETG_PLAY_FIRE_EFFECT_ON>               m_PlayFireEffectsOn[0x31];                                // 0x035C(0x0001)
	TEnumAsByte<ETG_EQUIP_POINT>                       m_ActiveEquipPoint;                                       // 0x038D(0x0001)
	TEnumAsByte<EFirstPersonWeaponAttachState>         Current1pAttachState;                                     // 0x038E(0x0001) (Transient)
	unsigned char                                      UnknownData00[0x1];                                       // 0x038F(0x0001) MISSED OFFSET
	unsigned long                                      m_bShouldLoopingMuzzleTrace : 1;                          // 0x0390(0x0004)
	unsigned long                                      m_bUseSocketForCameraAttach : 1;                          // 0x0390(0x0004)
	unsigned long                                      m_bProceduralBob : 1;                                     // 0x0390(0x0004)
	unsigned long                                      m_bIsFOVZoomed : 1;                                       // 0x0390(0x0004)
	unsigned long                                      m_bFlourishBlocked : 1;                                   // 0x0390(0x0004)
	unsigned long                                      m_bIsHoldingBeacon : 1;                                   // 0x0390(0x0004) (Transient)
	unsigned long                                      m_bWasViewTargetLastTick : 1;                             // 0x0390(0x0004)
	unsigned long                                      m_bUseCameraAnims : 1;                                    // 0x0390(0x0004)
	unsigned long                                      c_bEnemyMatLoaded : 1;                                    // 0x0390(0x0004)
	unsigned long                                      bUseEmitterPoolForTracers : 1;                            // 0x0390(0x0004)
	class UTgSkeletalMeshComponent*                    m_HandsMesh;                                              // 0x0394(0x0008) (ExportObject, Component, EditInline)
	class UTgSkeletalMeshComponent*                    m_HeadMesh1P;                                             // 0x039C(0x0008) (ExportObject, Component, EditInline)
	struct FVector2D                                   m_v2WeaponLagAimOffset;                                   // 0x03A4(0x0008)
	struct FVector2D                                   m_nMaxWeaponLag;                                          // 0x03AC(0x0008) (Edit)
	struct FVector2D                                   m_v2WeaponLagInterpSpeed;                                 // 0x03B4(0x0008) (Edit)
	struct FVector2D                                   m_v2WeaponLagSmoothingFactor;                             // 0x03BC(0x0008) (Edit)
	struct FRotator                                    m_rLastRotation;                                          // 0x03C4(0x000C)
	struct FVector2D                                   m_fSmoothedAimOffset;                                     // 0x03D0(0x0008)
	float                                              m_fSmoothAimFactor;                                       // 0x03D8(0x0004) (Edit)
	class UTgCameraShake*                              m_FireCameraShake;                                        // 0x03DC(0x0008) (Edit, EditInline)
	int                                                m_nTracerCounter;                                         // 0x03E4(0x0004)
	int                                                m_nTracerFrequency;                                       // 0x03E8(0x0004) (Edit)
	struct FName                                       m_TracerName;                                             // 0x03EC(0x0008)
	float                                              m_fTracerLifetime;                                        // 0x03F4(0x0004)
	struct FName                                       m_HitTargetName;                                          // 0x03F8(0x0008)
	struct FName                                       m_HitWallName;                                            // 0x0400(0x0008)
	struct FName                                       m_WhizbyName;                                             // 0x0408(0x0008)
	float                                              m_BeamEmitterEndPointOffset;                              // 0x0410(0x0004) (Edit)
	int                                                m_nBeaconMeshId;                                          // 0x0414(0x0004) (Const)
	TArray<class UTgSkelCon_HitReaction*>              m_HitReactionSkelControls;                                // 0x0418(0x0010) (NeedCtorLink)
	TArray<struct FQueuedImpactEffect>                 m_QueuedImpactEffects;                                    // 0x0428(0x0010) (NeedCtorLink)
	TArray<struct FQueuedImpactDecal>                  m_QueuedImpactDecals;                                     // 0x0438(0x0010) (NeedCtorLink)
	class UTgGameplayCurves*                           m_GameplayCurves;                                         // 0x0448(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgWeaponMeshActor");
		return ptr;
	}


	void PlayCharSpecificAnim(int nSlot, float fActivationTime);
	void PlayMeshTransitionAnimation(const struct FWeaponMeshSwapStrategy& SwapStrategy, TEnumAsByte<ETG_EQUIP_POINT> eqp, class ATgDevice* PreviousTargetingDevice, class ATgDevice* NextTargetingDevice);
	void STATIC_Unhide3PWeaponMesh();
	void STATIC_Hide3PWeaponMesh();
	void PlayHitReaction(TEnumAsByte<ERecoilHitDir> Dir, float DamageAmount);
	void CacheHitReactionSkelControls();
	void STATIC_NotifyLocalPlayerTeamReceived();
	void OnPolymorphChanged(bool bDead);
	void AddWeaponLeading(const struct FRotator& NewRotation, const struct FRotator& OldRotation, float DeltaTime);
	void ResetFireLoopDisplayGroup();
	void SetFireLoopDisplayGroup(const struct FName& FireLoop, const struct FName& FireLoopTailSound);
	void SetFOVZoomed(bool bEnabled);
	void BlockFlourish(bool bBlock);
	void ToggleWallClimb(bool bWallClimbing);
	void PlayFlourish();
	void PlayReload(int nEqpPoint, float reloadTime, int AmmoAmount, int ReloadType);
	void StopFireEffects(int nEquipSlot, int nFireMode);
	struct FVector STATIC_GetClampedEmitDirection(const struct FVector& vInput, const struct FVector& vReflect);
	void PlayInstantHitImpactEffects(const struct FVector& HitLocation, bool bSuccessfulHit, class AActor* HitActor, const struct FVector& HitNormal, const struct FVector& FireOrigin, int nEquipSlot);
	void PlayQueuedImpactDecals();
	void QueueImpactDecal(class UTgSpecialFx* ImpactFx, const struct FVector& HitLocation, const struct FVector& HitNormal);
	class UTgSpecialFx* STATIC_GetMeshFx(const struct FName& nmDisplayGroupName, int nEquipSlot);
	void STATIC_GetFiringSocketTransform(struct FVector* FireLoc, struct FRotator* FireRot);
	void PlayQueuedInstantHitImpactEffects();
	void QueueInstantHitImpactEffects(const struct FVector& HitLocation, bool bSuccessfulHit, class AActor* HitActor, const struct FVector& HitNormal, const struct FVector& FireOrigin, int nEquipSlot);
	void OverrideTracerEndLocation(const struct FVector& FireLoc, int nIndex, bool bSyntheticShot, struct FVector* endLocation);
	void OverrideTracerFireLoc(int nIndex, struct FVector* FireLoc);
	void PlayTracerEffects(const struct FVector& endLocation, int nEquipSlot, bool bSyntheticShot);
	class UTgSkeletalMeshComponent* STATIC_Get3PWeaponMesh();
	void Play3pFireAimedFX();
	void PlayDeviceFiredEffects(int nEquipSlot, float fRefireTime, int nFireMode);
	void PlayFireAnimation(int nEquipSlot, float fRefireTime);
	void PlayFireFx(int nEquipSlot, int nFireMode);
	void PlayFireEffects(int nEquipSlot, float fRefireTime, int nFireMode);
	bool ShowAsLocallyOwned();
	void SetLoopingMuzzleEffects(bool bSetActive, int nEquipSlot, int nFireMode);
	void AttackComboTimeout();
	void PlayBuildupEffects(int nEquipSlot);
	void PlayTargetingEffects(int nEquipSlot);
	bool STATIC_GetSimulatedBeamTarget(int nEquipSlot, struct FVector* HitLocation);
	bool STATIC_GetAccurateBeamTarget(int nEquipSlot, struct FVector* HitLocation);
	void STATIC_UpdateFireLoopBeamParams(bool bHasEndPoint, const struct FVector& HitLocation, int nEquipSlot);
	bool ShouldUpdateBeamEffects(int nEquipSlot);
	void STATIC_UpdateBeamEffects(int nEquipSlotToUpdate);
	void STATIC_GetAllFireLoopParticleSystemComponents(int nEquipSlot, TArray<class UParticleSystemComponent*>* FireLoopParticles);
	void STATIC_UpdateTransform(float DeltaTime, bool bFromCameraUpdate);
	void Tick(float DeltaTime);
	bool CanUseCameraBone();
	void ToggleHoldingBeacon(bool bHolding);
	void PlayWeaponQuickRetrieve();
	void Toggle1PVisibility(bool bVisible);
	void Set1PAttachState(TEnumAsByte<EFirstPersonWeaponAttachState> NewAttachState);
	void OnBehindViewUpdated(bool bNewBehindView);
	void PlayRetrieve(const struct FWeaponMeshSwapStrategy& SwapStrategy);
	void PlayPutaway(TEnumAsByte<ETG_EQUIP_POINT> eqp, int DeviceID, class UClass* WeaponClass);
	void SetActiveWeapon(unsigned char EquipPoint, int DeviceID, class UClass* WeaponClass, const struct FWeaponMeshSwapStrategy& SwapStrategy);
	void STATIC_Initialize3P(unsigned char EquipPoint, int DeviceID);
	void PostInitAnimTree(class USkeletalMeshComponent* SkelComp);
	void STATIC_Initialize1P(unsigned char EquipPoint, int DeviceID, int MeshAsmId1P);
	void STATIC_FixUpReferencesToPawnMesh(class USkeletalMeshComponent* PawnMesh);
	void STATIC_FixUpReferencesToWeaponMesh1P(class USkeletalMeshComponent* weaponMesh);
	void STATIC_InitializeForWeapon(unsigned char EquipPoint, int DeviceID, bool bClearEquipPoint);
	void ClearEquipPoint(unsigned char EquipPoint);
	void Destroyed();
	bool IsFirstPerson();
	void PostBeginPlay();
	bool STATIC_IsInWeaponInspect();
	int STATIC_GetFxOverrideFor(int nBaseFXID);
	float CheckOcclusion();
	void SetLocationForWeapon(const struct FVector& NewLocation, class AActor* OwningPawn);
	void STATIC_RecalculateMaterial(bool bIsFriendlyWithLocalPawn, bool bForce);
	void ForceRecalculateMaterial();
	bool IsFriendlyWithLocalPawn();
	class ATgDevice* STATIC_GetDefaultDevice();
	void NativeInit(unsigned char EquipPoint, int DeviceID);
	void STATIC_UpdateHeadMesh1P();
	void STATIC_UpdateHandsMesh();
	float STATIC_GetMaxWhizbyDistSqr();
	void STATIC_UpdateReticule();
	struct FString STATIC_GetWeaponClassById(int DeviceID);
	void STATIC_GetMeshAsmIds(int DeviceID, int* MeshId1P, int* MeshId3P);
};


// Class TgGame.TgWeaponMeshActor_ADS
// 0x0004 (0x0454 - 0x0450)
class ATgWeaponMeshActor_ADS : public ATgWeaponMeshActor
{
public:
	unsigned long                                      m_bPlayingADSFX : 1;                                      // 0x0450(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgWeaponMeshActor_ADS");
		return ptr;
	}


	void STATIC_UseADSFireSounds(bool bShouldUse);
	void SetFOVZoomed(bool bEnabled);
};


// Class TgGame.TgWeaponMeshActor_BombKingInhand
// 0x0004 (0x0454 - 0x0450)
class ATgWeaponMeshActor_BombKingInhand : public ATgWeaponMeshActor
{
public:
	unsigned long                                      m_bPlayPoppyDetonateAnimation : 1;                        // 0x0450(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgWeaponMeshActor_BombKingInhand");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByPosture_Player
// 0x0000 (0x01AC - 0x01AC)
class UTgAnimBlendByPosture_Player : public UAnimNodeSequence
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByPosture_Player");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByRecoilTime
// 0x001C (0x0140 - 0x0124)
class UTgAnimBlendByRecoilTime : public UAnimNodeBlend
{
public:
	class UTgDeviceForm*                               m_TgDeviceForm;                                           // 0x0124(0x0008)
	class ATgPawn*                                     m_TgPawn;                                                 // 0x012C(0x0008)
	float                                              m_PctBlend;                                               // 0x0134(0x0004)
	float                                              m_fBlendTime;                                             // 0x0138(0x0004) (Edit)
	float                                              m_fMaxRecoilTime;                                         // 0x013C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByRecoilTime");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendBySpeed
// 0x00A4 (0x021C - 0x0178)
class UTgAnimBlendBySpeed : public UAnimNodeBlendBySpeed
{
public:
	class ATgPawn*                                     m_TgPawn;                                                 // 0x0178(0x0008)
	TEnumAsByte<ESpeedType>                            m_SpeedType;                                              // 0x0180(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0181(0x0003) MISSED OFFSET
	TArray<struct FResetSynchGroup>                    ResetSynchGroups;                                         // 0x0184(0x0010) (Edit, NeedCtorLink)
	unsigned long                                      m_bIgnoreRootMotion : 1;                                  // 0x0194(0x0004) (Edit)
	unsigned long                                      m_bIgnoreZVelocity : 1;                                   // 0x0194(0x0004) (Edit)
	unsigned long                                      m_bNotifyOwnerOnChildChange : 1;                          // 0x0194(0x0004) (Edit)
	unsigned long                                      m_bEnableClassOverrides : 1;                              // 0x0194(0x0004) (Edit)
	TArray<int>                                        m_WalkChildren;                                           // 0x0198(0x0010) (Edit, NeedCtorLink)
	TArray<int>                                        m_SprintChildren;                                         // 0x01A8(0x0010) (Edit, NeedCtorLink)
	TArray<float>                                      m_BaseSpeed;                                              // 0x01B8(0x0010) (Edit, NeedCtorLink)
	TArray<TEnumAsByte<EPhysics>>                      m_IgnoredPhysics;                                         // 0x01C8(0x0010) (Edit, NeedCtorLink)
	int                                                m_nIndexToOverride;                                       // 0x01D8(0x0004) (Edit)
	float                                              m_fBaseSpeedRecon;                                        // 0x01DC(0x0004) (Edit)
	float                                              m_fBaseSpeedRobotics;                                     // 0x01E0(0x0004) (Edit)
	float                                              m_fBaseSpeedAssault;                                      // 0x01E4(0x0004) (Edit)
	float                                              m_fBaseSpeedMedic;                                        // 0x01E8(0x0004) (Edit)
	float                                              m_fBaseSpeedReconFemale;                                  // 0x01EC(0x0004) (Edit)
	float                                              m_fBaseSpeedRoboticsFemale;                               // 0x01F0(0x0004) (Edit)
	float                                              m_fBaseSpeedAssaultFemale;                                // 0x01F4(0x0004) (Edit)
	float                                              m_fBaseSpeedMedicFemale;                                  // 0x01F8(0x0004) (Edit)
	float                                              m_fBaseSpeedReconCity;                                    // 0x01FC(0x0004) (Edit)
	float                                              m_fBaseSpeedRoboticsCity;                                 // 0x0200(0x0004) (Edit)
	float                                              m_fBaseSpeedAssaultCity;                                  // 0x0204(0x0004) (Edit)
	float                                              m_fBaseSpeedMedicCity;                                    // 0x0208(0x0004) (Edit)
	float                                              m_fBaseSpeedReconFemaleCity;                              // 0x020C(0x0004) (Edit)
	float                                              m_fBaseSpeedRoboticsFemaleCity;                           // 0x0210(0x0004) (Edit)
	float                                              m_fBaseSpeedAssaultFemaleCity;                            // 0x0214(0x0004) (Edit)
	float                                              m_fBaseSpeedMedicFemaleCity;                              // 0x0218(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendBySpeed");
		return ptr;
	}


	void OnInit();
	class UAnimNodeSynch* STATIC_FindSynchAnimNode(const struct FName& nmNodeName);
};


// Class TgGame.TgAnimBlendBySpeedWithExhaustion
// 0x0038 (0x0254 - 0x021C)
class UTgAnimBlendBySpeedWithExhaustion : public UTgAnimBlendBySpeed
{
public:
	unsigned long                                      m_bEnableExhaustion : 1;                                  // 0x021C(0x0004) (Edit)
	float                                              m_fExhaustionLevel;                                       // 0x0220(0x0004) (Edit)
	TArray<int>                                        m_ExhaustedChildren;                                      // 0x0224(0x0010) (Edit, NeedCtorLink)
	TArray<int>                                        m_GainExhaustionChildren;                                 // 0x0234(0x0010) (Edit, NeedCtorLink)
	float                                              m_fExhaustionGainSpeed;                                   // 0x0244(0x0004) (Edit)
	float                                              m_fExhaustionLossSpeed;                                   // 0x0248(0x0004) (Edit)
	float                                              m_fExhaustionLevelMax;                                    // 0x024C(0x0004) (Edit)
	float                                              m_fExhaustionLevelMin;                                    // 0x0250(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendBySpeedWithExhaustion");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendInterpBySpeed
// 0x0014 (0x0138 - 0x0124)
class UTgAnimBlendInterpBySpeed : public UAnimNodeBlend
{
public:
	class ATgPawn*                                     m_TgPawn;                                                 // 0x0124(0x0008)
	float                                              m_fBlendTime;                                             // 0x012C(0x0004) (Edit)
	float                                              m_fFullRunSpeed;                                          // 0x0130(0x0004) (Edit)
	float                                              m_fFullIdleSpeed;                                         // 0x0134(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendInterpBySpeed");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendPerBone
// 0x0024 (0x017C - 0x0158)
class UTgAnimBlendPerBone : public UAnimNodeBlendPerBone
{
public:
	unsigned long                                      m_bLoopSourceChild : 1;                                   // 0x0158(0x0004) (Edit)
	unsigned long                                      m_bLoopTargetChild : 1;                                   // 0x0158(0x0004) (Edit)
	unsigned long                                      m_bPlaySourceChild : 1;                                   // 0x0158(0x0004) (Edit)
	unsigned long                                      m_bPlayTargetChild : 1;                                   // 0x0158(0x0004) (Edit)
	unsigned long                                      m_bSetStrengthFromAnimNode : 1;                           // 0x0158(0x0004) (Edit)
	unsigned long                                      m_bInvertStrengthFromAnimNode : 1;                        // 0x0158(0x0004) (Edit)
	unsigned long                                      m_bInitializedCachedNodeList : 1;                         // 0x0158(0x0004) (Transient)
	TArray<struct FName>                               m_StrengthAnimNodeNameList;                               // 0x015C(0x0010) (Edit, NeedCtorLink)
	TArray<class UAnimNode*>                           m_CachedNodeList;                                         // 0x016C(0x0010) (Transient, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendPerBone");
		return ptr;
	}


	void STATIC_PlayAnim(bool bLoop, float Rate, float StartTime);
};


// Class TgGame.TgAnimMetaData_InvisibleWallFailSafe
// 0x0008 (0x0068 - 0x0060)
class UTgAnimMetaData_InvisibleWallFailSafe : public UAnimMetaData
{
public:
	struct FName                                       WallEnableBaseName;                                       // 0x0060(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimMetaData_InvisibleWallFailSafe");
		return ptr;
	}

};


// Class TgGame.TgAnimMetaData_Keyframed
// 0x0020 (0x0080 - 0x0060)
class UTgAnimMetaData_Keyframed : public UAnimMetaData
{
public:
	TArray<struct FMetaDataKeyFrame>                   KeyFrames;                                                // 0x0060(0x0010) (Edit, NeedCtorLink, EditInline)
	unsigned long                                      bForceFirstKeyFrameOnBecomeRelevant : 1;                  // 0x0070(0x0004) (Edit, Deprecated)
	unsigned long                                      bForceLastKeyFrameOnCeaseRelevant : 1;                    // 0x0070(0x0004) (Edit, Deprecated)
	TEnumAsByte<EOnRelevanceBehavior>                  OnBecomeRelevantBehavior;                                 // 0x0074(0x0001) (Edit)
	TEnumAsByte<EOnRelevanceBehavior>                  OnCeaseRelevantBehavior;                                  // 0x0075(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x2];                                       // 0x0076(0x0002) MISSED OFFSET
	float                                              OnBecomeRelevantStrength;                                 // 0x0078(0x0004) (Edit)
	float                                              OnCeaseRelevantStrength;                                  // 0x007C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimMetaData_Keyframed");
		return ptr;
	}

};


// Class TgGame.TgAnimMetaData_DisplayGroupPSCParam
// 0x0018 (0x0098 - 0x0080)
class UTgAnimMetaData_DisplayGroupPSCParam : public UTgAnimMetaData_Keyframed
{
public:
	struct FName                                       ParamName;                                                // 0x0080(0x0008) (Edit)
	struct FName                                       DisplayGroup;                                             // 0x0088(0x0008) (Edit)
	TEnumAsByte<ETG_EQUIP_POINT>                       EqpSlot;                                                  // 0x0090(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0091(0x0003) MISSED OFFSET
	unsigned long                                      bActivateGroupOnRelevant : 1;                             // 0x0094(0x0004) (Edit)
	unsigned long                                      bDeactivateGroupOnCeaseRelevant : 1;                      // 0x0094(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimMetaData_DisplayGroupPSCParam");
		return ptr;
	}

};


// Class TgGame.TgAnimMetaData_MICScalarParameter
// 0x000C (0x008C - 0x0080)
class UTgAnimMetaData_MICScalarParameter : public UTgAnimMetaData_Keyframed
{
public:
	struct FName                                       MICParameterName;                                         // 0x0080(0x0008) (Edit)
	int                                                MaterialIndex;                                            // 0x0088(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimMetaData_MICScalarParameter");
		return ptr;
	}

};


// Class TgGame.TgAnimMetaData_MICScalarParameterExtended
// 0x003C (0x00C8 - 0x008C)
class UTgAnimMetaData_MICScalarParameterExtended : public UTgAnimMetaData_MICScalarParameter
{
public:
	unsigned long                                      bSearchSelf : 1;                                          // 0x008C(0x0004) (Edit)
	unsigned long                                      bSearchSiblings : 1;                                      // 0x008C(0x0004) (Edit)
	unsigned long                                      bSearchChildren : 1;                                      // 0x008C(0x0004) (Edit)
	unsigned long                                      bIncludeSearchParticles : 1;                              // 0x008C(0x0004) (Edit)
	unsigned long                                      bIncludeSearchMeshes : 1;                                 // 0x008C(0x0004) (Edit)
	unsigned long                                      bForceAllMaterials : 1;                                   // 0x008C(0x0004) (Edit)
	unsigned long                                      bFindAllMatchingMaterials : 1;                            // 0x008C(0x0004) (Edit)
	class UMaterialInstanceConstant*                   MaterialToFind;                                           // 0x0090(0x0008) (Edit, Const)
	class UMaterialInstanceConstant*                   MaterialToReplace;                                        // 0x0098(0x0008) (Edit, Const)
	struct FName                                       nmExclusiveChannel;                                       // 0x00A0(0x0008) (Edit, Const)
	TArray<struct FAlternateMaterialOverride>          AlternateMaterialList;                                    // 0x00A8(0x0010) (Edit, NeedCtorLink)
	TArray<struct FName>                               TexturesToHarvest;                                        // 0x00B8(0x0010) (Edit, Const, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimMetaData_MICScalarParameterExtended");
		return ptr;
	}

};


// Class TgGame.TgAnimMetaData_MaskingPlane
// 0x0040 (0x0108 - 0x00C8)
class UTgAnimMetaData_MaskingPlane : public UTgAnimMetaData_MICScalarParameterExtended
{
public:
	int                                                WallIndex;                                                // 0x00C8(0x0004) (Edit)
	struct FVector                                     WallNormal;                                               // 0x00CC(0x000C) (Edit)
	struct FVector                                     WallPosition0;                                            // 0x00D8(0x000C) (Edit)
	struct FVector                                     WallPosition1;                                            // 0x00E4(0x000C) (Edit)
	struct FName                                       WallEnableBaseName;                                       // 0x00F0(0x0008) (Const)
	struct FName                                       WallPositionBaseName;                                     // 0x00F8(0x0008) (Const)
	struct FName                                       WallNormalBaseName;                                       // 0x0100(0x0008) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimMetaData_MaskingPlane");
		return ptr;
	}

};


// Class TgGame.TgAnimMetaData_MICStates_Interp
// 0x0018 (0x0098 - 0x0080)
class UTgAnimMetaData_MICStates_Interp : public UTgAnimMetaData_Keyframed
{
public:
	struct FName                                       MICStateNameFrom;                                         // 0x0080(0x0008) (Edit)
	struct FName                                       MICStateNameTo;                                           // 0x0088(0x0008) (Edit)
	int                                                nMaterialIndex;                                           // 0x0090(0x0004) (Edit)
	unsigned long                                      bApplyToChildMeshes : 1;                                  // 0x0094(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimMetaData_MICStates_Interp");
		return ptr;
	}

};


// Class TgGame.TgAnimMetaData_KeyframedDisplayGroup
// 0x0018 (0x0078 - 0x0060)
class UTgAnimMetaData_KeyframedDisplayGroup : public UAnimMetaData
{
public:
	struct FName                                       DisplayGroup;                                             // 0x0060(0x0008) (Edit)
	float                                              m_fStartTime;                                             // 0x0068(0x0004) (Edit)
	float                                              m_fEndTime;                                               // 0x006C(0x0004) (Edit)
	TEnumAsByte<ETG_EQUIP_POINT>                       EqpSlot;                                                  // 0x0070(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0071(0x0003) MISSED OFFSET
	unsigned long                                      m_bDisplayGroupActivated : 1;                             // 0x0074(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimMetaData_KeyframedDisplayGroup");
		return ptr;
	}

};


// Class TgGame.TgAnimMetaData_MeshAccessory
// 0x002C (0x008C - 0x0060)
class UTgAnimMetaData_MeshAccessory : public UAnimMetaData
{
public:
	TArray<struct FMeshPlacement>                      m_Meshes;                                                 // 0x0060(0x0010) (Edit, NeedCtorLink, EditInline)
	unsigned long                                      m_bSkinIndependent : 1;                                   // 0x0070(0x0004) (Edit)
	unsigned long                                      m_bSetKeysNoInterp : 1;                                   // 0x0070(0x0004) (Edit)
	unsigned long                                      m_bUseScaling : 1;                                        // 0x0070(0x0004) (Edit)
	TArray<struct FTimeModifier>                       m_KeyFrames;                                              // 0x0074(0x0010) (Edit, NeedCtorLink, EditInline)
	float                                              m_fBecomeRelevantScale;                                   // 0x0084(0x0004) (Edit)
	float                                              m_fCeaseRelevantScale;                                    // 0x0088(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimMetaData_MeshAccessory");
		return ptr;
	}

};


// Class TgGame.TgAnimMetaData_MeshAccessory_Mastery
// 0x0000 (0x008C - 0x008C)
class UTgAnimMetaData_MeshAccessory_Mastery : public UTgAnimMetaData_MeshAccessory
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimMetaData_MeshAccessory_Mastery");
		return ptr;
	}

};


// Class TgGame.TgAnimMetaData_SkelControl_BoneScale
// 0x0020 (0x0080 - 0x0060)
class UTgAnimMetaData_SkelControl_BoneScale : public UAnimMetaData
{
public:
	TArray<struct FName>                               SkelControlNameList;                                      // 0x0060(0x0010) (Edit, NeedCtorLink)
	float                                              BoneScale;                                                // 0x0070(0x0004) (Edit)
	unsigned long                                      bFullControlOverController : 1;                           // 0x0074(0x0004) (Edit)
	struct FName                                       SkelControlName;                                          // 0x0078(0x0008) (Deprecated)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimMetaData_SkelControl_BoneScale");
		return ptr;
	}

};


// Class TgGame.TgAnimMetaData_SkelControl_BoneScale_KeyFrame
// 0x0038 (0x0098 - 0x0060)
class UTgAnimMetaData_SkelControl_BoneScale_KeyFrame : public UAnimMetaData
{
public:
	TArray<struct FName>                               SkelControlNameList;                                      // 0x0060(0x0010) (Edit, NeedCtorLink)
	TArray<struct FTimeModifier>                       KeyFrames;                                                // 0x0070(0x0010) (Edit, NeedCtorLink, EditInline)
	unsigned long                                      bAllowScaleUp : 1;                                        // 0x0080(0x0004) (Edit)
	unsigned long                                      bAllowScaleDown : 1;                                      // 0x0080(0x0004) (Edit)
	unsigned long                                      bAdjustControllerStrength : 1;                            // 0x0080(0x0004) (Const)
	unsigned long                                      bFullControlOverController : 1;                           // 0x0080(0x0004) (Edit)
	unsigned long                                      bSetKeysNoInterp : 1;                                     // 0x0080(0x0004) (Edit)
	unsigned long                                      bForceFirstKeyFrameOnBecomeRelevant : 1;                  // 0x0080(0x0004) (Deprecated)
	unsigned long                                      bForceLastKeyFrameOnCeaseRelevant : 1;                    // 0x0080(0x0004) (Deprecated)
	struct FName                                       SkelControlName;                                          // 0x0084(0x0008) (Deprecated)
	TEnumAsByte<EOnRelevanceChange>                    OnBecomeRelevantBehavior;                                 // 0x008C(0x0001) (Edit)
	TEnumAsByte<EOnRelevanceChange>                    OnCeaseRelevantBehavior;                                  // 0x008D(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x2];                                       // 0x008E(0x0002) MISSED OFFSET
	float                                              OnBecomeRelevantStrength;                                 // 0x0090(0x0004) (Edit)
	float                                              OnCeaseRelevantStrength;                                  // 0x0094(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimMetaData_SkelControl_BoneScale_KeyFrame");
		return ptr;
	}

};


// Class TgGame.TgAnimMetaData_SkelControl_Shalin
// 0x0000 (0x0098 - 0x0098)
class UTgAnimMetaData_SkelControl_Shalin : public UTgAnimMetaData_SkelControl_BoneScale_KeyFrame
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimMetaData_SkelControl_Shalin");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeAdditiveBlending
// 0x0024 (0x014C - 0x0128)
class UTgAnimNodeAdditiveBlending : public UAnimNodeAdditiveBlending
{
public:
	unsigned long                                      m_bSetStrengthFromAnimNode : 1;                           // 0x0128(0x0004) (Edit)
	unsigned long                                      m_bInvertStrengthFromAnimNode : 1;                        // 0x0128(0x0004) (Edit)
	unsigned long                                      m_bInitializedCachedNodeList : 1;                         // 0x0128(0x0004) (Transient)
	TArray<struct FName>                               m_StrengthAnimNodeNameList;                               // 0x012C(0x0010) (Edit, NeedCtorLink)
	TArray<class UAnimNode*>                           m_CachedNodeList;                                         // 0x013C(0x0010) (Transient, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeAdditiveBlending");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeAimOffset_Base
// 0x0004 (0x0170 - 0x016C)
class UTgAnimNodeAimOffset_Base : public UAnimNodeAimOffset
{
public:
	unsigned long                                      m_bBakeAllProfileOffsetsFromAnimations : 1;               // 0x016C(0x0004) (Edit)
	unsigned long                                      m_bPopulateAnimNamesWithPrefixes : 1;                     // 0x016C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeAimOffset_Base");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeAimOffset
// 0x0084 (0x01F4 - 0x0170)
class UTgAnimNodeAimOffset : public UTgAnimNodeAimOffset_Base
{
public:
	class ATgPawn*                                     Owner;                                                    // 0x0170(0x0008) (Const, Transient)
	TArray<class UAnimNode*>                           m_CachedNodeList;                                         // 0x0178(0x0010) (NeedCtorLink)
	unsigned long                                      m_bInitializedCachedNodeList : 1;                         // 0x0188(0x0004) (Transient)
	unsigned long                                      m_bDisableVerticalAiming : 1;                             // 0x0188(0x0004) (Deprecated)
	unsigned long                                      bInterpolating : 1;                                       // 0x0188(0x0004) (Const, Transient)
	unsigned long                                      m_bRandomAimPointsEnabled : 1;                            // 0x0188(0x0004) (Edit)
	unsigned long                                      m_bOverrideAim : 1;                                       // 0x0188(0x0004) (Edit)
	unsigned long                                      m_bAimAtTarget : 1;                                       // 0x0188(0x0004) (Edit)
	unsigned long                                      m_bDisableWeaponLeading : 1;                              // 0x0188(0x0004) (Edit)
	TEnumAsByte<EPitchControlType>                     m_PitchControlType;                                       // 0x018C(0x0001) (Edit, Const)
	unsigned char                                      UnknownData00[0x3];                                       // 0x018D(0x0003) MISSED OFFSET
	struct FInterpCurveFloat                           m_PitchControlUserCurve;                                  // 0x0190(0x0014) (Edit, Const, NeedCtorLink)
	float                                              TurnInPlaceOffset;                                        // 0x01A4(0x0004) (Edit, Const, Transient)
	float                                              LastAimX;                                                 // 0x01A8(0x0004) (Const, Transient)
	float                                              InterpSpeed;                                              // 0x01AC(0x0004) (Edit)
	struct FVector2D                                   m_AimOffsetPct;                                           // 0x01B0(0x0008) (Const, Transient)
	struct FVector2D                                   m_RandomAimPointsRangeX;                                  // 0x01B8(0x0008) (Edit)
	struct FVector2D                                   m_RandomAimPointsRangeY;                                  // 0x01C0(0x0008) (Edit)
	float                                              m_fRandomAimPointsInterpRate;                             // 0x01C8(0x0004) (Edit)
	float                                              m_fRandomAimPointsIntervalMin;                            // 0x01CC(0x0004) (Edit)
	float                                              m_fRandomAimPointsIntervalMax;                            // 0x01D0(0x0004) (Edit)
	float                                              m_fCurrentRandomAimPointsInterval;                        // 0x01D4(0x0004)
	struct FVector2D                                   m_TargetRandomAimLocation;                                // 0x01D8(0x0008)
	float                                              m_fDeltaTime;                                             // 0x01E0(0x0004)
	struct FVector2D                                   m_OverriddenAim;                                          // 0x01E4(0x0008) (Edit)
	class ATgWeaponMeshActor*                          m_WeaponMeshActor;                                        // 0x01EC(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeAimOffset");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeAimOffset_Charge
// 0x001C (0x0210 - 0x01F4)
class UTgAnimNodeAimOffset_Charge : public UTgAnimNodeAimOffset
{
public:
	unsigned long                                      m_bInterpToCurrentTurnRate : 1;                           // 0x01F4(0x0004) (Edit)
	unsigned long                                      m_bDisableIfNotMoving : 1;                                // 0x01F4(0x0004) (Edit)
	unsigned long                                      m_bResetOnBecomeRelevant : 1;                             // 0x01F4(0x0004) (Edit)
	float                                              m_fInterpSpeed;                                           // 0x01F8(0x0004) (Edit)
	float                                              m_fMaxYawRate;                                            // 0x01FC(0x0004) (Edit)
	float                                              m_fAimYawOffset;                                          // 0x0200(0x0004) (Transient)
	struct FRotator                                    m_rCachedOwnerRotator;                                    // 0x0204(0x000C) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeAimOffset_Charge");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeHitReactionOffset
// 0x002C (0x019C - 0x0170)
class UTgAnimNodeHitReactionOffset : public UTgAnimNodeAimOffset_Base
{
public:
	class ATgPawn*                                     Owner;                                                    // 0x0170(0x0008) (Const, Transient)
	struct FVector2D                                   m_vCurrentAngle;                                          // 0x0178(0x0008)
	unsigned long                                      m_bSecondaryReaction : 1;                                 // 0x0180(0x0004) (Edit)
	float                                              m_fMaxReactionTime;                                       // 0x0184(0x0004) (Edit)
	float                                              m_fMinTimeBetweenReactions;                               // 0x0188(0x0004) (Edit)
	TArray<struct FHitReactionInfo>                    m_ActiveReactions;                                        // 0x018C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeHitReactionOffset");
		return ptr;
	}


	void AddHit(const struct FVector2D& vHitDir, int nDamage);
};


// Class TgGame.TgAnimNodeBlendAnimsByDirection
// 0x0038 (0x01F4 - 0x01BC)
class UTgAnimNodeBlendAnimsByDirection : public UAnimNodeSequenceBlendBase
{
public:
	float                                              m_BlendSpeed;                                             // 0x01BC(0x0004) (Edit)
	unsigned long                                      m_bUsePlayRateByDirection : 1;                            // 0x01C0(0x0004) (Edit)
	unsigned long                                      m_bIncludeStandingAnim : 1;                               // 0x01C0(0x0004) (Edit)
	unsigned long                                      m_bForceStanding : 1;                                     // 0x01C0(0x0004) (Transient)
	unsigned long                                      m_bInterpolateWeights : 1;                                // 0x01C0(0x0004) (Const, Transient)
	unsigned long                                      m_bMirrorDirectionsWhenPawnMirrored : 1;                  // 0x01C0(0x0004) (Edit)
	unsigned long                                      m_bForwardLeftCorrection : 1;                             // 0x01C0(0x0004) (Edit)
	float                                              m_PlayRateByDirection[0x8];                               // 0x01C4(0x0004) (Edit)
	float                                              m_PlayRateStanding;                                       // 0x01E4(0x0004) (Edit)
	float                                              m_fStillThreshold;                                        // 0x01E8(0x0004) (Edit)
	float                                              m_DirAngle;                                               // 0x01EC(0x0004)
	float                                              m_LastRelevantTime;                                       // 0x01F0(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendAnimsByDirection");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeBlendByBlink
// 0x0044 (0x019C - 0x0158)
class UTgAnimNodeBlendByBlink : public UAnimNodeBlendPerBone
{
public:
	class ATgPawn*                                     m_TgPawn;                                                 // 0x0158(0x0008) (Transient)
	class USkeletalMeshComponent*                      m_SkelMesh;                                               // 0x0160(0x0008) (ExportObject, Transient, Component, EditInline)
	float                                              m_fBlinkAnimRate;                                         // 0x0168(0x0004) (Edit)
	struct FVector2D                                   m_vTimeBetweenBlinks;                                     // 0x016C(0x0008) (Edit)
	float                                              m_fTimeTillNextBlink;                                     // 0x0174(0x0004)
	TArray<struct FName>                               m_DisableBlinkingAnimNodeNameList;                        // 0x0178(0x0010) (Edit, NeedCtorLink)
	TArray<class UAnimNode*>                           m_CachedNodeList;                                         // 0x0188(0x0010) (Transient, NeedCtorLink)
	unsigned long                                      m_bInitializedCachedNodeList : 1;                         // 0x0198(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByBlink");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeBlendByPhysics
// 0x0038 (0x017C - 0x0144)
class UTgAnimNodeBlendByPhysics : public UAnimNodeBlendList
{
public:
	class ATgPawn*                                     m_TgPawn;                                                 // 0x0144(0x0008)
	TEnumAsByte<EPhysics>                              m_LastPhysics;                                            // 0x014C(0x0001)
	TEnumAsByte<EPhysics>                              m_CurrentPhysics;                                         // 0x014D(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x014E(0x0002) MISSED OFFSET
	int                                                m_CurrentPhysicsChildIndex;                               // 0x0150(0x0004)
	TArray<TEnumAsByte<EPhysics>>                      m_PhysicsChildren;                                        // 0x0154(0x0010) (Edit, NeedCtorLink)
	unsigned long                                      m_bDirectUnspecifiedPhysicsThroughChild0 : 1;             // 0x0164(0x0004) (Edit)
	float                                              DefaultBlendTime;                                         // 0x0168(0x0004) (Edit)
	TArray<struct FChildrenBlendInfo>                  m_ChildrenBlendInfo;                                      // 0x016C(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByPhysics");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeBlendByStrafe
// 0x000C (0x0130 - 0x0124)
class UTgAnimNodeBlendByStrafe : public UAnimNodeBlend
{
public:
	class ATgPawn*                                     m_TgPawn;                                                 // 0x0124(0x0008)
	float                                              m_fBlendTime;                                             // 0x012C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByStrafe");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeBlendList
// 0x0024 (0x0168 - 0x0144)
class UTgAnimNodeBlendList : public UAnimNodeBlendList
{
public:
	float                                              DefaultBlendTime;                                         // 0x0144(0x0004) (Edit)
	TArray<float>                                      ChildBlendTimes;                                          // 0x0148(0x0010) (Edit, NeedCtorLink)
	TArray<struct FChildBlendParam>                    SpecificChildBlendTimes;                                  // 0x0158(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendList");
		return ptr;
	}


	float STATIC_GetBlendTime(int ChildIndex);
};


// Class TgGame.TgAnimBlendBy1P3P
// 0x0008 (0x0170 - 0x0168)
class UTgAnimBlendBy1P3P : public UTgAnimNodeBlendList
{
public:
	class ATgPawn*                                     m_TgPawn;                                                 // 0x0168(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendBy1P3P");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByAmmo
// 0x0024 (0x018C - 0x0168)
class UTgAnimBlendByAmmo : public UTgAnimNodeBlendList
{
public:
	int                                                m_nDefaultChild;                                          // 0x0168(0x0004) (Edit)
	TEnumAsByte<ETG_EQUIP_POINT>                       m_EquipPoint;                                             // 0x016C(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x016D(0x0003) MISSED OFFSET
	unsigned long                                      m_bDelayUpdateUntilReplay : 1;                            // 0x0170(0x0004) (Edit)
	unsigned long                                      m_bCheckAmmoPerTick : 1;                                  // 0x0170(0x0004) (Edit)
	TArray<struct FAmmoBlendParams>                    m_ChildAmmoParams;                                        // 0x0174(0x0010) (Edit, NeedCtorLink)
	int                                                m_nPendingChildIndex;                                     // 0x0184(0x0004)
	int                                                m_nAmmoUpdateTickTag;                                     // 0x0188(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByAmmo");
		return ptr;
	}


	void SetAmmoChild(int targetAmmoChild);
	void SetAmmoAmt(int nAmmo);
	void STATIC_ReplayAnim();
	void STATIC_PlayAnim(bool bLoop, float Rate, float StartTime);
};


// Class TgGame.TgAnimBlendByBuffMonsterIntro
// 0x0018 (0x0180 - 0x0168)
class UTgAnimBlendByBuffMonsterIntro : public UTgAnimNodeBlendList
{
public:
	unsigned long                                      m_bScalePlayRateOfSpawnAndIntro : 1;                      // 0x0168(0x0004) (Edit)
	unsigned long                                      m_bEndIntroStateEarly : 1;                                // 0x0168(0x0004) (Edit)
	unsigned long                                      m_bIntroHasBeenSetup : 1;                                 // 0x0168(0x0004)
	float                                              m_fIntroTimeHittableAt;                                   // 0x016C(0x0004) (Edit)
	float                                              m_fTimeToStartIntroAnim;                                  // 0x0170(0x0004)
	class ATgPawn*                                     m_CachedPawn;                                             // 0x0174(0x0008)
	float                                              m_fSpawnIntroScaleRate;                                   // 0x017C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByBuffMonsterIntro");
		return ptr;
	}


	void SetupIntro(float fTotalIntroTime, float fIntroOffset);
};


// Class TgGame.TgAnimBlendByChurchillDrone
// 0x0004 (0x016C - 0x0168)
class UTgAnimBlendByChurchillDrone : public UTgAnimNodeBlendList
{
public:
	unsigned long                                      m_bLeftDrone : 1;                                         // 0x0168(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByChurchillDrone");
		return ptr;
	}


	void STATIC_ForceSetActive(bool bActive);
	void Fire();
	void Destroyed();
	void Spawned();
};


// Class TgGame.TgAnimBlendByDeployable
// 0x0000 (0x0168 - 0x0168)
class UTgAnimBlendByDeployable : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByDeployable");
		return ptr;
	}


	void Fire();
	void Destroyed();
	void Spawned();
};


// Class TgGame.TgAnimBlendByDirection
// 0x0010 (0x0178 - 0x0168)
class UTgAnimBlendByDirection : public UTgAnimNodeBlendList
{
public:
	class ATgPawn*                                     m_TgPawn;                                                 // 0x0168(0x0008)
	TEnumAsByte<EBlendByDirectionSpeedType>            m_SpeedType;                                              // 0x0170(0x0001) (Edit)
	TEnumAsByte<EBlendDirTypes>                        LastDirection;                                            // 0x0171(0x0001) (Const)
	unsigned char                                      UnknownData00[0x2];                                       // 0x0172(0x0002) MISSED OFFSET
	unsigned long                                      bAdjustRateByVelocity : 1;                                // 0x0174(0x0004) (Edit)
	unsigned long                                      bNoDirectionIsEnabled : 1;                                // 0x0174(0x0004) (Edit)
	unsigned long                                      bResetLooping : 1;                                        // 0x0174(0x0004) (Edit)
	unsigned long                                      m_bDelayBlendOutToPlayAnim : 1;                           // 0x0174(0x0004) (Edit)
	unsigned long                                      m_bIsAllowedToBlendOut : 1;                               // 0x0174(0x0004)
	unsigned long                                      m_bMirrorDirectionsWhenPawnMirrored : 1;                  // 0x0174(0x0004) (Edit)
	unsigned long                                      m_bStopChildrenOnCeaseRelevant : 1;                       // 0x0174(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByDirection");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByEmote
// 0x0010 (0x0178 - 0x0168)
class UTgAnimBlendByEmote : public UTgAnimNodeBlendList
{
public:
	TArray<struct FEmoteChildAnimInfo>                 m_CachedEmoteChildInfo;                                   // 0x0168(0x0010) (Transient, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByEmote");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByFall
// 0x0034 (0x019C - 0x0168)
class UTgAnimBlendByFall : public UTgAnimNodeBlendList
{
public:
	TEnumAsByte<EFallSource>                           m_FallSource;                                             // 0x0168(0x0001) (Edit)
	TEnumAsByte<EBlendFallTypes>                       FallState;                                                // 0x0169(0x0001) (Const)
	TEnumAsByte<EPhysics>                              m_PreviousTickPhysics;                                    // 0x016A(0x0001)
	unsigned char                                      UnknownData00[0x1];                                       // 0x016B(0x0001) MISSED OFFSET
	float                                              LastFallingVelocity;                                      // 0x016C(0x0004) (Const)
	class ATgPawn*                                     pOwner;                                                   // 0x0170(0x0008)
	float                                              m_fPrelandDistance;                                       // 0x0178(0x0004) (Edit)
	unsigned long                                      m_bDebugMeasureJumpUp : 1;                                // 0x017C(0x0004) (Edit)
	unsigned long                                      m_bDebugMeasureJumpDownToLand : 1;                        // 0x017C(0x0004) (Edit)
	unsigned long                                      m_bMeasuring : 1;                                         // 0x017C(0x0004)
	unsigned long                                      m_bUsesPreDown : 1;                                       // 0x017C(0x0004)
	unsigned long                                      m_bJumpOnly : 1;                                          // 0x017C(0x0004) (Edit)
	unsigned long                                      m_bForceDownOnRelevantWhileFalling : 1;                   // 0x017C(0x0004) (Edit)
	unsigned long                                      m_bPlayDownStateWhileFlying : 1;                          // 0x017C(0x0004) (Edit)
	struct FVector                                     m_StartMeasureJump;                                       // 0x0180(0x000C)
	float                                              m_fMeasureTime;                                           // 0x018C(0x0004)
	float                                              m_fLandingMovementPlayRate;                               // 0x0190(0x0004) (Edit)
	struct FName                                       m_nmNameLandingSynchGroup;                                // 0x0194(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByFall");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByFallTransition
// 0x0004 (0x01A0 - 0x019C)
class UTgAnimBlendByFallTransition : public UTgAnimBlendByFall
{
public:
	float                                              m_fPreDownVelocity;                                       // 0x019C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByFallTransition");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByFire
// 0x0084 (0x01EC - 0x0168)
class UTgAnimBlendByFire : public UTgAnimNodeBlendList
{
public:
	unsigned long                                      m_bSetToIdleOnCeaseRelevant : 1;                          // 0x0168(0x0004) (Edit)
	unsigned long                                      m_bShouldReplayIfAlreadyActive : 1;                       // 0x0168(0x0004) (Edit)
	struct FDeviceParameters                           m_InHandDeviceParameters;                                 // 0x016C(0x0014) (Edit, NeedCtorLink)
	struct FDeviceParameters                           m_OffHand1DeviceParameters;                               // 0x0180(0x0014) (Edit, NeedCtorLink)
	struct FDeviceParameters                           m_OffHand2DeviceParameters;                               // 0x0194(0x0014) (Edit, NeedCtorLink)
	struct FDeviceParameters                           m_OffHand3DeviceParameters;                               // 0x01A8(0x0014) (Edit, NeedCtorLink)
	struct FDeviceParameters                           m_OffHand4DeviceParameters;                               // 0x01BC(0x0014) (Edit, NeedCtorLink)
	struct FDeviceParameters                           m_RecallDeviceParameters;                                 // 0x01D0(0x0014) (Edit, NeedCtorLink)
	class ATgPawn*                                     m_OwningPawn;                                             // 0x01E4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByFire");
		return ptr;
	}


	void OnDeviceFormInterruptFire(class UTgDeviceForm* DeviceForm);
	void OnDeviceFormStopFire(class UTgDeviceForm* DeviceForm);
	void OnDeviceFormStartFire(class UTgDeviceForm* DeviceForm, float FireDuration);
	void OnDeviceFormBuildup(class UTgDeviceForm* DeviceForm, float BuildupTime);
};


// Class TgGame.TgAnimBlendByFlying
// 0x0038 (0x01A0 - 0x0168)
class UTgAnimBlendByFlying : public UTgAnimNodeBlendList
{
public:
	unsigned long                                      bAdjustRateByVelocity : 1;                                // 0x0168(0x0004) (Edit)
	unsigned long                                      m_bAdjustRateByAcceleration : 1;                          // 0x0168(0x0004) (Edit)
	unsigned long                                      m_bPreviewJetpackPerBoneBlend : 1;                        // 0x0168(0x0004) (Edit, Transient)
	unsigned long                                      m_bIsUsingHandsFreeJetpack : 1;                           // 0x0168(0x0004)
	float                                              m_fUpLoopStartTime;                                       // 0x016C(0x0004) (Edit)
	TEnumAsByte<EFlyDirTypes>                          LastDirection;                                            // 0x0170(0x0001) (Const)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0171(0x0003) MISSED OFFSET
	struct FName                                       m_nmHandsFreeJetpackPerBoneBlendNodeName;                 // 0x0174(0x0008) (Edit)
	class UAnimNodeBlendPerBone*                       m_HandsFreeJetpackPerBoneBlendNode;                       // 0x017C(0x0008)
	float                                              m_fHandsFreeJetpackBlendBias;                             // 0x0184(0x0004) (Edit)
	struct FName                                       m_nmHandsFreeJetpackBiasBlendNodeName;                    // 0x0188(0x0008) (Edit)
	class UAnimNodeBlend*                              m_HandsFreeJetpackBiasBlendNode;                          // 0x0190(0x0008)
	class ATgPawn*                                     m_TgPawn;                                                 // 0x0198(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByFlying");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByHeadSkin
// 0x0010 (0x0178 - 0x0168)
class UTgAnimBlendByHeadSkin : public UTgAnimNodeBlendList
{
public:
	TArray<struct FHeadSkinChildInfo>                  m_SkinMap;                                                // 0x0168(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByHeadSkin");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByInitialSpeed
// 0x001C (0x0184 - 0x0168)
class UTgAnimBlendByInitialSpeed : public UTgAnimNodeBlendList
{
public:
	float                                              m_fInitialSpeed;                                          // 0x0168(0x0004)
	int                                                m_nStartingIndex;                                         // 0x016C(0x0004)
	unsigned long                                      m_bLoopChain : 1;                                         // 0x0170(0x0004) (Edit)
	unsigned long                                      m_bAdvanceOnReplay : 1;                                   // 0x0170(0x0004) (Edit)
	unsigned long                                      m_bAdvanceOnAnimEnd : 1;                                  // 0x0170(0x0004) (Edit)
	unsigned long                                      m_ReplayedThisFrame : 1;                                  // 0x0170(0x0004)
	unsigned long                                      bUseAcceleration : 1;                                     // 0x0170(0x0004) (Edit)
	TArray<float>                                      Constraints;                                              // 0x0174(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByInitialSpeed");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByMountSkin
// 0x0010 (0x0178 - 0x0168)
class UTgAnimBlendByMountSkin : public UTgAnimNodeBlendList
{
public:
	TArray<struct FMountSkinChildInfo>                 m_SkinMap;                                                // 0x0168(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByMountSkin");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByNodeName
// 0x002C (0x0194 - 0x0168)
class UTgAnimBlendByNodeName : public UTgAnimNodeBlendList
{
public:
	TArray<struct FNodeNameToChildIndex>               m_NodeNameToChildIndex;                                   // 0x0168(0x0010) (Edit, NeedCtorLink)
	TArray<struct FRelevantNodeNameNodes>              m_CachedNodes;                                            // 0x0178(0x0010) (Transient, NeedCtorLink)
	class UAnimNode*                                   m_LastSuccessfulAnimNode;                                 // 0x0188(0x0008) (Transient)
	unsigned long                                      m_bHasCachedNodes : 1;                                    // 0x0190(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByNodeName");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByPaladinsCharacter
// 0x03DC (0x0544 - 0x0168)
class UTgAnimBlendByPaladinsCharacter : public UTgAnimNodeBlendList
{
public:
	class ATgWeaponMeshActor*                          m_WeaponMeshActor;                                        // 0x0168(0x0008)
	TEnumAsByte<ETG_EQUIP_POINT>                       m_SubNodeEquipSlot;                                       // 0x0170(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0171(0x0003) MISSED OFFSET
	struct FChildAnimParameters                        m_ChildParams[0x11];                                      // 0x0174(0x0038) (Edit, NeedCtorLink)
	TArray<TEnumAsByte<EPalCharParams>>                m_nChildAnimStack;                                        // 0x052C(0x0010) (NeedCtorLink)
	int                                                m_nCustomRetrieveIndex;                                   // 0x053C(0x0004)
	unsigned long                                      m_bBlendToIdleOnInterruptInspect : 1;                     // 0x0540(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByPaladinsCharacter");
		return ptr;
	}


	void STATIC_ReplayAnim();
	void STATIC_PlayAnim(bool bLoop, float InRate, float StartTime);
	void STATIC_SetActiveChild(int ChildIndex, float BlendTime);
	TEnumAsByte<EPalCharParams> STATIC_GetParamIndexFromChildIndex(int Index);
	TEnumAsByte<EPalCharParams> STATIC_GetParamIndexFromEqpSlot(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	void STATIC_UpdateAnimViaStackRemoval(TEnumAsByte<EPalCharParams> toRemove);
	void PlayTopOfStackAnim();
	void STATIC_ForceInterruptFlourish();
	void InterruptReload();
	void OnPutAway(unsigned char EquipPoint, int DeviceID, class UClass* WeaponClass);
	void OnRetrieve();
	void OnFlourish();
	void OnReload(float fReloadTime);
	void OnTriggerCharacterSpecific(int nCharacterSpecificSlot, float fActivationTime);
	void OnDeviceStopFire(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	void OnDeviceFire(TEnumAsByte<ETG_EQUIP_POINT> eqp, float fRefireRate);
	void OnDeviceStartFire(TEnumAsByte<ETG_EQUIP_POINT> eqp, float fRefireRate);
	void OnDeviceBuildup(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	void OnDeviceTargeting(TEnumAsByte<ETG_EQUIP_POINT> eqp);
};


// Class TgGame.TgAnimBlendByPaladinsCharacter_BarrierTank
// 0x0028 (0x056C - 0x0544)
class UTgAnimBlendByPaladinsCharacter_BarrierTank : public UTgAnimBlendByPaladinsCharacter
{
public:
	TArray<struct FName>                               m_AmmoSkelControlNames;                                   // 0x0544(0x0010) (Edit, NeedCtorLink)
	TArray<class USkelControlBase*>                    m_AmmoSkelControls;                                       // 0x0554(0x0010) (NeedCtorLink)
	class ATgPawn_BarrierTank*                         m_CachedBarrierTankPawn;                                  // 0x0564(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByPaladinsCharacter_BarrierTank");
		return ptr;
	}


	void OnRetrieve();
	bool STATIC_HasCachedBarrierTankPawn();
	void STATIC_SetActiveChild(int ChildIndex, float BlendTime);
	void STATIC_UpdateAmmoSkelControls();
};


// Class TgGame.TgAnimBlendByPaladinsCharacter_BombKing
// 0x0000 (0x0544 - 0x0544)
class UTgAnimBlendByPaladinsCharacter_BombKing : public UTgAnimBlendByPaladinsCharacter
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByPaladinsCharacter_BombKing");
		return ptr;
	}


	void OnDeviceStartFire(TEnumAsByte<ETG_EQUIP_POINT> eqp, float fRefireRate);
};


// Class TgGame.TgAnimBlendByPaladinsCharacter_Drogoz
// 0x0028 (0x056C - 0x0544)
class UTgAnimBlendByPaladinsCharacter_Drogoz : public UTgAnimBlendByPaladinsCharacter
{
public:
	TArray<struct FName>                               m_AmmoSkelControlNames;                                   // 0x0544(0x0010) (Edit, NeedCtorLink)
	TArray<class USkelControlBase*>                    m_AmmoSkelControls;                                       // 0x0554(0x0010) (NeedCtorLink)
	class ATgPawn_Drogoz*                              m_CachedDrogozPawn;                                       // 0x0564(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByPaladinsCharacter_Drogoz");
		return ptr;
	}


	void OnRetrieve();
	bool STATIC_HasCachedDrogozPawn();
	void STATIC_SetActiveChild(int ChildIndex, float BlendTime);
	void STATIC_UpdateAmmoSkelControls();
};


// Class TgGame.TgAnimBlendByPaladinsCharacter_Flak
// 0x0008 (0x054C - 0x0544)
class UTgAnimBlendByPaladinsCharacter_Flak : public UTgAnimBlendByPaladinsCharacter
{
public:
	class ATgPawn_Flak*                                m_CachedFlakPawn;                                         // 0x0544(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByPaladinsCharacter_Flak");
		return ptr;
	}


	bool STATIC_HasCachedFlakPawn();
	void OnRetrieve();
};


// Class TgGame.TgAnimBlendByPaladinsCharacter_Imani
// 0x0000 (0x0544 - 0x0544)
class UTgAnimBlendByPaladinsCharacter_Imani : public UTgAnimBlendByPaladinsCharacter
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByPaladinsCharacter_Imani");
		return ptr;
	}


	TEnumAsByte<EPalCharParams> STATIC_GetParamIndexFromEqpSlot(TEnumAsByte<ETG_EQUIP_POINT> eqp);
};


// Class TgGame.TgAnimBlendByPaladinsCharacter_Koga
// 0x0000 (0x0544 - 0x0544)
class UTgAnimBlendByPaladinsCharacter_Koga : public UTgAnimBlendByPaladinsCharacter
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByPaladinsCharacter_Koga");
		return ptr;
	}


	void OnWallClimb(bool bWallClimbing);
	TEnumAsByte<EPalCharParams> STATIC_GetParamIndexFromEqpSlot(TEnumAsByte<ETG_EQUIP_POINT> eqp);
};


// Class TgGame.TgAnimBlendByPaladinsCharacter_Owl
// 0x0000 (0x0544 - 0x0544)
class UTgAnimBlendByPaladinsCharacter_Owl : public UTgAnimBlendByPaladinsCharacter
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByPaladinsCharacter_Owl");
		return ptr;
	}


	TEnumAsByte<EPalCharParams> STATIC_GetParamIndexFromEqpSlot(TEnumAsByte<ETG_EQUIP_POINT> eqp);
};


// Class TgGame.TgAnimBlendByPaladinsCharacter_Tiberius
// 0x0000 (0x0544 - 0x0544)
class UTgAnimBlendByPaladinsCharacter_Tiberius : public UTgAnimBlendByPaladinsCharacter
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByPaladinsCharacter_Tiberius");
		return ptr;
	}


	TEnumAsByte<EPalCharParams> STATIC_GetParamIndexFromEqpSlot(TEnumAsByte<ETG_EQUIP_POINT> eqp);
};


// Class TgGame.TgAnimBlendByPercent
// 0x0020 (0x0188 - 0x0168)
class UTgAnimBlendByPercent : public UTgAnimNodeBlendList
{
public:
	float                                              m_fCurrentPercent;                                        // 0x0168(0x0004)
	int                                                m_nDeferredActiveChild;                                   // 0x016C(0x0004)
	int                                                m_fDeferredActiveChildBlendTime;                          // 0x0170(0x0004)
	unsigned long                                      m_bDeferUpdatesWhilePlaying : 1;                          // 0x0174(0x0004) (Edit)
	TArray<struct FBlendByPercentValues>               m_ChildParams;                                            // 0x0178(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByPercent");
		return ptr;
	}


	void STATIC_SetActiveChild(int ChildIndex, float BlendTime);
	void STATIC_UpdatePercent(float fPercent);
	bool STATIC_IsChildSequencePlaying();
};


// Class TgGame.TgAnimBlendByPhase
// 0x0024 (0x018C - 0x0168)
class UTgAnimBlendByPhase : public UTgAnimNodeBlendList
{
public:
	class ATgPawn*                                     m_TgPawn;                                                 // 0x0168(0x0008)
	int                                                m_LastPhase;                                              // 0x0170(0x0004)
	int                                                m_CurrentPhase;                                           // 0x0174(0x0004)
	unsigned long                                      m_bEnableTransitionAnims : 1;                             // 0x0178(0x0004) (Edit)
	TArray<struct Fm_PhaseProfile>                     m_PhaseProfiles;                                          // 0x017C(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByPhase");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByPhysics
// 0x003C (0x01A4 - 0x0168)
class UTgAnimBlendByPhysics : public UTgAnimNodeBlendList
{
public:
	int                                                PhysicsMap[0xE];                                          // 0x0168(0x0004) (Edit)
	int                                                LastPhysics;                                              // 0x01A0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByPhysics");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByPosture
// 0x0034 (0x019C - 0x0168)
class UTgAnimBlendByPosture : public UTgAnimNodeBlendList
{
public:
	class ATgPawn*                                     m_TgPawn;                                                 // 0x0168(0x0008)
	class ATgSkeletalMeshActor_Posture*                m_TgPostureMesh;                                          // 0x0170(0x0008)
	TEnumAsByte<ETG_POSTURE>                           m_LastPosture;                                            // 0x0178(0x0001)
	TEnumAsByte<ETG_POSTURE>                           m_CurrentPosture;                                         // 0x0179(0x0001)
	TEnumAsByte<ETG_POSTURE>                           m_TransitionFromPosture;                                  // 0x017A(0x0001)
	unsigned char                                      UnknownData00[0x1];                                       // 0x017B(0x0001) MISSED OFFSET
	unsigned long                                      m_bEnableTransitionAnims : 1;                             // 0x017C(0x0004) (Edit)
	unsigned long                                      m_bCheckLowerPriorityPostures : 1;                        // 0x017C(0x0004) (Edit)
	int                                                m_CurrentPostureChildIndex;                               // 0x0180(0x0004)
	TArray<struct Fm_PostureProfile>                   m_PostureProfiles;                                        // 0x0184(0x0010) (Edit, NeedCtorLink)
	class UAnimNodeSequence*                           m_TransitionAnimNodeSeq;                                  // 0x0194(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByPosture");
		return ptr;
	}


	void STATIC_ForceAllCameraAnimsEnd();
	bool STATIC_ForcePostureChange(bool bAllowTransitionAnims);
};


// Class TgGame.TgAnimBlendByProgressiveReload
// 0x0000 (0x0168 - 0x0168)
class UTgAnimBlendByProgressiveReload : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByProgressiveReload");
		return ptr;
	}


	void SetReloadType(int ReloadType);
};


// Class TgGame.TgAnimBlendBySceneCamera
// 0x0000 (0x0168 - 0x0168)
class UTgAnimBlendBySceneCamera : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendBySceneCamera");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendBySkin
// 0x0010 (0x0178 - 0x0168)
class UTgAnimBlendBySkin : public UTgAnimNodeBlendList
{
public:
	TArray<struct FSkinChildInfo>                      m_SkinMap;                                                // 0x0168(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendBySkin");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByStartingPosture
// 0x0010 (0x0178 - 0x0168)
class UTgAnimBlendByStartingPosture : public UTgAnimNodeBlendList
{
public:
	class ATgPawn*                                     m_TgPawn;                                                 // 0x0168(0x0008)
	TEnumAsByte<ETG_POSTURE>                           m_StartingPosture;                                        // 0x0170(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0171(0x0003) MISSED OFFSET
	unsigned long                                      m_bExpired : 1;                                           // 0x0174(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByStartingPosture");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByTag
// 0x0010 (0x0178 - 0x0168)
class UTgAnimBlendByTag : public UTgAnimNodeBlendList
{
public:
	TArray<struct FTagInfo>                            m_TagMap;                                                 // 0x0168(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByTag");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByWeaponSkin
// 0x0010 (0x0178 - 0x0168)
class UTgAnimBlendByWeaponSkin : public UTgAnimNodeBlendList
{
public:
	TArray<struct FWeaponSkinChildInfo>                m_SkinMap;                                                // 0x0168(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByWeaponSkin");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeBlendByAbilityDrag
// 0x0000 (0x0168 - 0x0168)
class UTgAnimNodeBlendByAbilityDrag : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByAbilityDrag");
		return ptr;
	}


	void STATIC_HookCloseRangeEnd();
	void STATIC_HookEndMissInvalid();
	void STATIC_HookMissInvalid();
	void STATIC_HookEndMissNoHit();
	void STATIC_HookMissNotHit();
	void STATIC_HookEnd();
	void STATIC_HookPull();
	void STATIC_HookHit();
	void ThrowHook();
};


// Class TgGame.TgAnimNodeBlendByAbilityFragGrenade
// 0x0000 (0x0168 - 0x0168)
class UTgAnimNodeBlendByAbilityFragGrenade : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByAbilityFragGrenade");
		return ptr;
	}


	void OnInterrupt();
	void StartThrow();
};


// Class TgGame.TgAnimNodeBlendByAbilityHyperShot
// 0x0000 (0x0168 - 0x0168)
class UTgAnimNodeBlendByAbilityHyperShot : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByAbilityHyperShot");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeBlendByAbilityReversal
// 0x0000 (0x0168 - 0x0168)
class UTgAnimNodeBlendByAbilityReversal : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByAbilityReversal");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeBlendByAbilitySaatiUlt
// 0x0000 (0x0168 - 0x0168)
class UTgAnimNodeBlendByAbilitySaatiUlt : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByAbilitySaatiUlt");
		return ptr;
	}


	void SetAnimState(unsigned char AmmoCount);
};


// Class TgGame.TgAnimNodeBlendByAbilitySimple
// 0x0005 (0x016D - 0x0168)
class UTgAnimNodeBlendByAbilitySimple : public UTgAnimNodeBlendList
{
public:
	unsigned long                                      m_bBlendToActiveOnStartFire : 1;                          // 0x0168(0x0004) (Edit)
	unsigned long                                      m_bBlendToActiveOnFire : 1;                               // 0x0168(0x0004) (Edit)
	unsigned long                                      m_bDelayBlendToActiveUntilAnimEnd : 1;                    // 0x0168(0x0004) (Edit)
	unsigned long                                      m_bDelayBlendToActiveUntilReplay : 1;                     // 0x0168(0x0004) (Edit)
	unsigned long                                      m_bDelayBlendToIdleUntilAnimEnd : 1;                      // 0x0168(0x0004) (Edit)
	unsigned long                                      m_bDelayBlendToIdleUntilReplay : 1;                       // 0x0168(0x0004) (Edit)
	unsigned long                                      m_bBlendToIdleImmediatelyOnInterrupt : 1;                 // 0x0168(0x0004) (Edit)
	unsigned long                                      m_bIsAbilityFiring : 1;                                   // 0x0168(0x0004) (Transient)
	TEnumAsByte<ETG_EQUIP_POINT>                       m_EqpPoint;                                               // 0x016C(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByAbilitySimple");
		return ptr;
	}


	void STATIC_ReplayAnim();
	void STATIC_PlayAnim(bool bLoop, float InRate, float StartTime);
	void SetAbilityFiring(bool bIsFiring, bool bIsOnFire, bool bIsInterrupted);
};


// Class TgGame.TgAnimNodeBlendByAbilityVine
// 0x0000 (0x0168 - 0x0168)
class UTgAnimNodeBlendByAbilityVine : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByAbilityVine");
		return ptr;
	}


	void STATIC_VineInactive();
	void STATIC_VinePost();
	void STATIC_VineHitPost();
	void STATIC_VinePull();
	void STATIC_VineThrow();
};


// Class TgGame.TgAnimNodeBlendByAFK
// 0x0008 (0x0170 - 0x0168)
class UTgAnimNodeBlendByAFK : public UTgAnimNodeBlendList
{
public:
	class ATgPawn*                                     PawnOwner;                                                // 0x0168(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByAFK");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeBlendByAndroxusDrift
// 0x002C (0x0194 - 0x0168)
class UTgAnimNodeBlendByAndroxusDrift : public UTgAnimNodeBlendList
{
public:
	TArray<struct FDriftInfo>                          m_DriftRecords;                                           // 0x0168(0x0010) (NeedCtorLink)
	class ATgPawn_Androxus*                            m_CachedAndroxusOwner;                                    // 0x0178(0x0008)
	unsigned long                                      m_bInDrift : 1;                                           // 0x0180(0x0004)
	unsigned long                                      m_bTransitionsCanBeInterrupted : 1;                       // 0x0180(0x0004) (Edit)
	float                                              m_fDriftStartTime;                                        // 0x0184(0x0004)
	float                                              m_fDriftRelevancyWindow;                                  // 0x0188(0x0004) (Edit)
	float                                              m_fDriftTriggerPercent;                                   // 0x018C(0x0004) (Edit)
	float                                              m_fMaxFallSpeed;                                          // 0x0190(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByAndroxusDrift");
		return ptr;
	}


	void StoppedDrift();
	void StartedDrift();
	float STATIC_GetDriftUsePercent();
};


// Class TgGame.TgAnimNodeBlendByCombat
// 0x0008 (0x0170 - 0x0168)
class UTgAnimNodeBlendByCombat : public UTgAnimNodeBlendList
{
public:
	class ATgPawn*                                     m_TgP;                                                    // 0x0168(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByCombat");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeBlendByCombatWariness
// 0x000C (0x0174 - 0x0168)
class UTgAnimNodeBlendByCombatWariness : public UTgAnimNodeBlendList
{
public:
	float                                              CombatWarinessDuration;                                   // 0x0168(0x0004) (Edit)
	unsigned long                                      AllowIdleAnimToComplete : 1;                              // 0x016C(0x0004) (Edit)
	unsigned long                                      AllowWaryAnimToComplete : 1;                              // 0x016C(0x0004) (Edit)
	unsigned long                                      IsWary : 1;                                               // 0x016C(0x0004) (Transient)
	float                                              WaryTime;                                                 // 0x0170(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByCombatWariness");
		return ptr;
	}


	void BecomeWary();
};


// Class TgGame.TgAnimNodeBlendByDeviceEquipped
// 0x0004 (0x016C - 0x0168)
class UTgAnimNodeBlendByDeviceEquipped : public UTgAnimNodeBlendList
{
public:
	int                                                m_DeviceId;                                               // 0x0168(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByDeviceEquipped");
		return ptr;
	}


	void SetDeviceEquipped(bool bEquipped);
};


// Class TgGame.TgAnimNodeBlendByDrogozFlying
// 0x002C (0x0194 - 0x0168)
class UTgAnimNodeBlendByDrogozFlying : public UTgAnimNodeBlendList
{
public:
	TArray<struct FBoosterFlightInfo>                  m_BoosterRecords;                                         // 0x0168(0x0010) (NeedCtorLink)
	class ATgPawn_Drogoz*                              m_CachedDrogozOwner;                                      // 0x0178(0x0008)
	unsigned long                                      m_bInThrust : 1;                                          // 0x0180(0x0004)
	unsigned long                                      m_bInBooster : 1;                                         // 0x0180(0x0004)
	unsigned long                                      m_bTransitionsCanBeInterrupted : 1;                       // 0x0180(0x0004) (Edit)
	float                                              m_fBoosterStartTime;                                      // 0x0184(0x0004)
	float                                              m_fBoosterRelevancyWindow;                                // 0x0188(0x0004) (Edit)
	float                                              m_fBoosterTriggerPercent;                                 // 0x018C(0x0004) (Edit)
	float                                              m_fMaxFlightFallSpeed;                                    // 0x0190(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByDrogozFlying");
		return ptr;
	}


	void StoppedBooster();
	void StartedBooster();
	float STATIC_GetBoosterUsePercent();
};


// Class TgGame.TgAnimNodeBlendByGameState
// 0x0008 (0x0170 - 0x0168)
class UTgAnimNodeBlendByGameState : public UTgAnimNodeBlendList
{
public:
	class ATgPawn*                                     PawnOwner;                                                // 0x0168(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByGameState");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeBlendByHealth
// 0x0018 (0x0180 - 0x0168)
class UTgAnimNodeBlendByHealth : public UTgAnimNodeBlendList
{
public:
	TArray<float>                                      m_HealthChildren;                                         // 0x0168(0x0010) (Edit, NeedCtorLink)
	class ATgPawn*                                     m_TgPawn;                                                 // 0x0178(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByHealth");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeBlendByHitReaction
// 0x0000 (0x0168 - 0x0168)
class UTgAnimNodeBlendByHitReaction : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByHitReaction");
		return ptr;
	}


	void OnMajorHit(const struct FVector& DirectionFromHit);
	void OnMinorHit(const struct FVector& DirectionFromHit);
};


// Class TgGame.TgAnimNodeBlendByIntroduction
// 0x0004 (0x016C - 0x0168)
class UTgAnimNodeBlendByIntroduction : public UTgAnimNodeBlendList
{
public:
	unsigned long                                      m_bIsRelevant : 1;                                        // 0x0168(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByIntroduction");
		return ptr;
	}


	void PlayIntroduction();
	void PrepareIntroduction();
};


// Class TgGame.TgAnimNodeBlendByKnockdown
// 0x0034 (0x019C - 0x0168)
class UTgAnimNodeBlendByKnockdown : public UTgAnimNodeBlendList
{
public:
	unsigned long                                      m_bAdjustPlayRateByVelocity : 1;                          // 0x0168(0x0004) (Edit)
	float                                              m_fVelocityMultiplier;                                    // 0x016C(0x0004) (Edit)
	float                                              m_PreviewVelocity;                                        // 0x0170(0x0004) (Edit)
	class ATgPawn*                                     m_TgPawn;                                                 // 0x0174(0x0008)
	struct FName                                       m_FaceDownAnimName;                                       // 0x017C(0x0008) (Edit)
	struct FName                                       m_FaceUpAnimName;                                         // 0x0184(0x0008) (Edit)
	struct FName                                       m_FaceDownRecoverAnimName;                                // 0x018C(0x0008) (Edit)
	struct FName                                       m_FaceUpRecoverAnimName;                                  // 0x0194(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByKnockdown");
		return ptr;
	}


	void SetDownStateAnim(bool bFaceDown);
};


// Class TgGame.TgAnimNodeBlendByLobby
// 0x0000 (0x0168 - 0x0168)
class UTgAnimNodeBlendByLobby : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByLobby");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeBlendByMeleeIdle
// 0x0008 (0x0170 - 0x0168)
class UTgAnimNodeBlendByMeleeIdle : public UTgAnimNodeBlendList
{
public:
	class ATgPawn*                                     m_TgPawn;                                                 // 0x0168(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByMeleeIdle");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeBlendBySimpleStance
// 0x0004 (0x016C - 0x0168)
class UTgAnimNodeBlendBySimpleStance : public UTgAnimNodeBlendList
{
public:
	int                                                m_nCurrentStance;                                         // 0x0168(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendBySimpleStance");
		return ptr;
	}


	void ChangeStance(int Stance);
};


// Class TgGame.TgAnimNodeBlendBySlowFall
// 0x0000 (0x0168 - 0x0168)
class UTgAnimNodeBlendBySlowFall : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendBySlowFall");
		return ptr;
	}


	void SetActiveAnimationIndex(int ChildIndex);
};


// Class TgGame.TgAnimNodeBlendByZoomPostFireTransition
// 0x0000 (0x0168 - 0x0168)
class UTgAnimNodeBlendByZoomPostFireTransition : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByZoomPostFireTransition");
		return ptr;
	}


	void SetZoomState(bool ZoomIn);
	void StartZoomTransition(float transitionTimeRemaining, bool ZoomIn);
};


// Class TgGame.TgAnimNodeBlendByZoomTransition
// 0x0004 (0x016C - 0x0168)
class UTgAnimNodeBlendByZoomTransition : public UTgAnimNodeBlendList
{
public:
	float                                              m_fTransitionStartTime;                                   // 0x0168(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByZoomTransition");
		return ptr;
	}


	void SetZoomState(bool ZoomIn);
	void StartZoomTransition(float zoomPercent, float totalTransitionTime, bool ZoomIn);
};


// Class TgGame.TgAnimNodeBlendList_EquipScreen
// 0x0000 (0x0168 - 0x0168)
class UTgAnimNodeBlendList_EquipScreen : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendList_EquipScreen");
		return ptr;
	}


	void PlayIdleAnim();
	void PlayBackpackReaction();
	void PlaySuitReaction();
	void PlayHelmetReaction();
	void PlayWeaponReaction();
};


// Class TgGame.TgAnimNodeChannelFire
// 0x0018 (0x0180 - 0x0168)
class UTgAnimNodeChannelFire : public UTgAnimNodeBlendList
{
public:
	TEnumAsByte<ETG_EQUIP_POINT>                       m_EquipPoint;                                             // 0x0168(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0169(0x0003) MISSED OFFSET
	unsigned long                                      m_bResetOnRelevant : 1;                                   // 0x016C(0x0004) (Edit)
	unsigned long                                      m_bCheckAnimSeqForAnim : 1;                               // 0x016C(0x0004) (Edit)
	unsigned long                                      m_bUseCooldownForEndChannel : 1;                          // 0x016C(0x0004) (Edit)
	unsigned long                                      m_bOnlyCallAnimEndWhenRelevant : 1;                       // 0x016C(0x0004) (Edit)
	unsigned long                                      m_bDoneChanneling : 1;                                    // 0x016C(0x0004) (Transient)
	float                                              m_fMaxLoopTime;                                           // 0x0170(0x0004) (Edit)
	float                                              m_fPreCooldownEndTimeTrigger;                             // 0x0174(0x0004) (Edit)
	float                                              m_fCooldownEndTime;                                       // 0x0178(0x0004) (Transient)
	float                                              m_fEndLoopTime;                                           // 0x017C(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeChannelFire");
		return ptr;
	}


	void SetLockedBase(bool bLocked);
	bool ShouldSetActiveChild(class UAnimNode* pAnimNode);
	void STATIC_ReplayAnim();
	void STATIC_EndChannel();
	void StartCooldownTimer(float fCooldown);
};


// Class TgGame.TgAnimNodeBlendByVampireMovement
// 0x0000 (0x0180 - 0x0180)
class UTgAnimNodeBlendByVampireMovement : public UTgAnimNodeChannelFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByVampireMovement");
		return ptr;
	}


	void STATIC_EndChannel();
};


// Class TgGame.TgAnimNodeLockableChannelFire
// 0x0004 (0x0184 - 0x0180)
class UTgAnimNodeLockableChannelFire : public UTgAnimNodeChannelFire
{
public:
	unsigned long                                      m_bPlayStartOnLock : 1;                                   // 0x0180(0x0004) (Edit)
	unsigned long                                      m_bPlayStartOnUnlock : 1;                                 // 0x0180(0x0004) (Edit)
	unsigned long                                      m_bPlayStartAfterLockLost : 1;                            // 0x0180(0x0004) (Edit)
	unsigned long                                      m_bLocked : 1;                                            // 0x0180(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeLockableChannelFire");
		return ptr;
	}


	void SetLockedBase(bool bLocked);
	void SetLocked(bool bLocked);
};


// Class TgGame.TgAnimNodePlayFireAnim
// 0x0010 (0x0178 - 0x0168)
class UTgAnimNodePlayFireAnim : public UTgAnimNodeBlendList
{
public:
	struct FName                                       FireAnimNodeName;                                         // 0x0168(0x0008) (Edit)
	class UAnimNodeSequence*                           FireAnimNodeSequence;                                     // 0x0170(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodePlayFireAnim");
		return ptr;
	}


	void PlayFireAnim(const struct FName& FireName);
};


// Class TgGame.TgAnimNodeRandom
// 0x0048 (0x01B0 - 0x0168)
class UTgAnimNodeRandom : public UTgAnimNodeBlendList
{
public:
	int                                                m_iDefaultChildIndex;                                     // 0x0168(0x0004) (Edit)
	unsigned long                                      m_bConsiderRelevancy : 1;                                 // 0x016C(0x0004) (Edit)
	unsigned long                                      m_bMasterOtherNodes : 1;                                  // 0x016C(0x0004) (Edit)
	unsigned long                                      m_bIsASlave : 1;                                          // 0x016C(0x0004) (Transient)
	unsigned long                                      m_bEnableTimer : 1;                                       // 0x016C(0x0004) (Edit)
	unsigned long                                      m_TimeAllChildren : 1;                                    // 0x016C(0x0004) (Edit)
	TArray<struct FName>                               m_SlaveNames;                                             // 0x0170(0x0010) (Edit, NeedCtorLink)
	TArray<class UTgAnimNodeRandom*>                   m_Slaves;                                                 // 0x0180(0x0010) (Transient, NeedCtorLink)
	int                                                m_nPrimaryChild;                                          // 0x0190(0x0004) (Edit)
	struct FVector2D                                   m_TimeRange;                                              // 0x0194(0x0008) (Edit)
	float                                              m_fRemainingTime;                                         // 0x019C(0x0004)
	TArray<struct FTgRandomAnimInfo>                   RandomInfo;                                               // 0x01A0(0x0010) (Edit, EditFixedSize, NeedCtorLink, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeRandom");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeStanceFireIntercept
// 0x0008 (0x0170 - 0x0168)
class UTgAnimNodeStanceFireIntercept : public UTgAnimNodeBlendList
{
public:
	int                                                m_nStanceToAllow;                                         // 0x0168(0x0004) (Edit)
	int                                                m_nCurrentStance;                                         // 0x016C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeStanceFireIntercept");
		return ptr;
	}


	void STATIC_ReplayAnim();
	void STATIC_PlayAnim(bool bLoop, float Rate, float StartTime);
};


// Class TgGame.TgAnimNodeStanceTransitionerSynchronized
// 0x0020 (0x0188 - 0x0168)
class UTgAnimNodeStanceTransitionerSynchronized : public UTgAnimNodeBlendList
{
public:
	float                                              StanceResetTime;                                          // 0x0168(0x0004) (Edit)
	unsigned long                                      CanResetStanceOnTick : 1;                                 // 0x016C(0x0004) (Edit)
	unsigned long                                      m_bDelayingChildSwitch : 1;                               // 0x016C(0x0004) (Transient)
	int                                                m_nCurrentStance;                                         // 0x0170(0x0004) (Transient)
	float                                              m_fTimestampToSwitchStance;                               // 0x0174(0x0004) (Transient)
	TArray<struct FStanceTransitionParam>              StanceTransitionControl;                                  // 0x0178(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeStanceTransitionerSynchronized");
		return ptr;
	}


	void STATIC_ReplayAnim();
	void STATIC_PlayAnim(bool bLoop, float Rate, float StartTime);
	void ChangeStance(int Stance, bool bAutoSync, bool bForceUpdate);
};


// Class TgGame.TgAnimNodeStanceDualFire
// 0x0008 (0x0190 - 0x0188)
class UTgAnimNodeStanceDualFire : public UTgAnimNodeStanceTransitionerSynchronized
{
public:
	unsigned long                                      m_bFireParityDirty : 1;                                   // 0x0188(0x0004)
	int                                                m_nDesiredStance;                                         // 0x018C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeStanceDualFire");
		return ptr;
	}


	void ChangeStance(int Stance, bool bAutoSync, bool bForceUpdate);
};


// Class TgGame.TgAnimNodeTargeting
// 0x0008 (0x0170 - 0x0168)
class UTgAnimNodeTargeting : public UTgAnimNodeBlendList
{
public:
	TEnumAsByte<ETG_EQUIP_POINT>                       m_EquipPoint;                                             // 0x0168(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0169(0x0003) MISSED OFFSET
	unsigned long                                      m_bResetOnRelevant : 1;                                   // 0x016C(0x0004) (Edit)
	unsigned long                                      m_bDoneTargeting : 1;                                     // 0x016C(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeTargeting");
		return ptr;
	}


	void STATIC_ReplayAnim();
	void STATIC_EndTargeting();
	void InterruptTargeting();
};


// Class TgGame.TgAnimNodeToggleWithTransition
// 0x0008 (0x0170 - 0x0168)
class UTgAnimNodeToggleWithTransition : public UTgAnimNodeBlendList
{
public:
	float                                              m_fTransitionStartTime;                                   // 0x0168(0x0004)
	float                                              m_fTransitionTimeRemaining;                               // 0x016C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeToggleWithTransition");
		return ptr;
	}


	void SetToggleState(bool bIsActive);
	void StartTransition(float fTransitionPercent, float fTotalTransitionTime, bool bTransitionToActive);
};


// Class TgGame.TgAnimNodeBlendByCombatWithTransition
// 0x0014 (0x0184 - 0x0170)
class UTgAnimNodeBlendByCombatWithTransition : public UTgAnimNodeToggleWithTransition
{
public:
	class ATgPawn*                                     m_TgP;                                                    // 0x0170(0x0008)
	unsigned long                                      m_bInCombatAck : 1;                                       // 0x0178(0x0004) (Transient)
	float                                              m_fTransitionIntoCombatTime;                              // 0x017C(0x0004) (Edit)
	float                                              m_fTransitionOutOfCombatTime;                             // 0x0180(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByCombatWithTransition");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeToggleWithTransition_Disengage
// 0x0008 (0x0178 - 0x0170)
class UTgAnimNodeToggleWithTransition_Disengage : public UTgAnimNodeToggleWithTransition
{
public:
	int                                                m_nPendingChildIndex;                                     // 0x0170(0x0004)
	unsigned long                                      m_bForceNewActiveChild : 1;                               // 0x0174(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeToggleWithTransition_Disengage");
		return ptr;
	}


	void STATIC_ReplayAnim();
	void STATIC_PlayAnim(bool bLoop, float Rate, float StartTime);
	void STATIC_SetActiveChild(int ChildIndex, float BlendTime);
};


// Class TgGame.TgAnimSequenceChain
// 0x0004 (0x016C - 0x0168)
class UTgAnimSequenceChain : public UTgAnimNodeBlendList
{
public:
	unsigned long                                      m_bLoopChain : 1;                                         // 0x0168(0x0004) (Edit)
	unsigned long                                      m_bResetOnRelevant : 1;                                   // 0x0168(0x0004) (Edit)
	unsigned long                                      m_bDelayBlendOutToPlayAnim : 1;                           // 0x0168(0x0004) (Edit)
	unsigned long                                      m_bAdvanceOnReplay : 1;                                   // 0x0168(0x0004) (Edit)
	unsigned long                                      m_bAdvanceOnAnimEnd : 1;                                  // 0x0168(0x0004) (Edit)
	unsigned long                                      m_bIsAllowedToBlendOut : 1;                               // 0x0168(0x0004)
	unsigned long                                      m_ReplayedThisFrame : 1;                                  // 0x0168(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimSequenceChain");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeEmoteCustomAnim
// 0x0004 (0x0130 - 0x012C)
class UTgAnimNodeEmoteCustomAnim : public UAnimNodePlayCustomAnim
{
public:
	unsigned long                                      c_bIsInHandDeviceMeshInvisible : 1;                       // 0x012C(0x0004)
	unsigned long                                      c_bHasReachedFullWeight : 1;                              // 0x012C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeEmoteCustomAnim");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeEmoteSequence
// 0x0024 (0x01E0 - 0x01BC)
class UTgAnimNodeEmoteSequence : public UAnimNodeSequenceBlendBase
{
public:
	float                                              m_fBlendSpeed;                                            // 0x01BC(0x0004) (Edit)
	struct FName                                       m_nmAnimName;                                             // 0x01C0(0x0008) (Edit)
	TArray<struct FEmoteAnimInfo>                      m_CachedEmoteAnims;                                       // 0x01C8(0x0010) (Transient, NeedCtorLink)
	int                                                m_nActiveAnim;                                            // 0x01D8(0x0004) (Transient)
	unsigned long                                      m_bNewAnim : 1;                                           // 0x01DC(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeEmoteSequence");
		return ptr;
	}


	void STATIC_PlayAnim(bool bLoop, float InRate, float StartTime);
};


// Class TgGame.TgAnimNodeFidget
// 0x0024 (0x0168 - 0x0144)
class UTgAnimNodeFidget : public UAnimNodeBlendList
{
public:
	float                                              m_SelectedIdleTimeBeforeFidgeting;                        // 0x0144(0x0004) (Transient)
	float                                              m_CurrentIdleTime;                                        // 0x0148(0x0004) (Transient)
	float                                              BlendToFidgetDuration;                                    // 0x014C(0x0004) (Edit)
	float                                              BlendFromFidgetDuration;                                  // 0x0150(0x0004) (Edit)
	TEnumAsByte<EFidgetType>                           FidgetType;                                               // 0x0154(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0155(0x0003) MISSED OFFSET
	float                                              MinimumIdleTimeBeforeFidgeting;                           // 0x0158(0x0004) (Edit)
	float                                              MaximumIdleTimeBeforeFidgeting;                           // 0x015C(0x0004) (Edit)
	unsigned long                                      AllowIdleAnimToComplete : 1;                              // 0x0160(0x0004) (Edit)
	float                                              ChanceToFidgetWhenIdleCompletes;                          // 0x0164(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeFidget");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeFitToDuration
// 0x001F (0x0130 - 0x0111)
class UTgAnimNodeFitToDuration : public UAnimNodeBlendBase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0111(0x0003) MISSED OFFSET
	float                                              Duration;                                                 // 0x0114(0x0004) (Edit)
	float                                              OverrideDuration;                                         // 0x0118(0x0004)
	unsigned long                                      bAllowIncreasedPlayRate : 1;                              // 0x011C(0x0004) (Edit)
	unsigned long                                      bAllowDecreasedPlayRate : 1;                              // 0x011C(0x0004) (Edit)
	unsigned long                                      bClampDuration : 1;                                       // 0x011C(0x0004) (Edit)
	unsigned long                                      m_bScaleByReload : 1;                                     // 0x011C(0x0004) (Edit)
	float                                              ClampedMinDuration;                                       // 0x0120(0x0004) (Edit)
	float                                              ClampedMaxDuration;                                       // 0x0124(0x0004) (Edit)
	TEnumAsByte<ETG_EQUIP_POINT>                       m_EquipPoint;                                             // 0x0128(0x0001) (Edit)
	unsigned char                                      UnknownData01[0x3];                                       // 0x0129(0x0003) MISSED OFFSET
	float                                              m_fDurationMultiplier;                                    // 0x012C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeFitToDuration");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeJumpLeanOffset
// 0x0030 (0x019C - 0x016C)
class UTgAnimNodeJumpLeanOffset : public UAnimNodeAimOffset
{
public:
	float                                              JumpLeanStrength;                                         // 0x016C(0x0004) (Edit)
	float                                              MaxLeanChangeSpeed;                                       // 0x0170(0x0004) (Edit)
	unsigned long                                      bMultiplyByZVelocity : 1;                                 // 0x0174(0x0004) (Edit)
	class UAnimNodeAimOffset*                          CachedAimNode;                                            // 0x0178(0x0008)
	struct FName                                       OldAimProfileName;                                        // 0x0180(0x0008)
	struct FVector2D                                   PreBlendAim;                                              // 0x0188(0x0008)
	float                                              LeanWeight;                                               // 0x0190(0x0004)
	float                                              LeanWeightTarget;                                         // 0x0194(0x0004)
	float                                              BlendTimeToGo;                                            // 0x0198(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeJumpLeanOffset");
		return ptr;
	}


	void SetLeanWeight(float WeightTarget, float BlendTime);
};


// Class TgGame.TgAnimNodeLog
// 0x0000 (0x0144 - 0x0144)
class UTgAnimNodeLog : public UAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeLog");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeMountSync
// 0x001B (0x012C - 0x0111)
class UTgAnimNodeMountSync : public UAnimNodeBlendBase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0111(0x0003) MISSED OFFSET
	class ATgPawn*                                     m_TgP;                                                    // 0x0114(0x0008)
	TArray<struct FName>                               m_nmSyncGroupNames;                                       // 0x011C(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeMountSync");
		return ptr;
	}

};


// Class TgGame.TgAnimNodePlayTgCameraAnim
// 0x0013 (0x0124 - 0x0111)
class UTgAnimNodePlayTgCameraAnim : public UAnimNodeBlendBase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0111(0x0003) MISSED OFFSET
	class UTgCameraShake*                              m_CameraShake;                                            // 0x0114(0x0008) (Edit)
	class ATgPawn*                                     m_TgPawn;                                                 // 0x011C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodePlayTgCameraAnim");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeSequence
// 0x0010 (0x01BC - 0x01AC)
class UTgAnimNodeSequence : public UAnimNodeSequence
{
public:
	unsigned long                                      bAutoPlay : 1;                                            // 0x01AC(0x0004) (Edit)
	unsigned long                                      bResetOnActivate : 1;                                     // 0x01AC(0x0004)
	unsigned long                                      HasDynamicLength : 1;                                     // 0x01AC(0x0004) (Edit)
	unsigned long                                      EnableFootControlsOnCease : 1;                            // 0x01AC(0x0004) (Edit)
	unsigned long                                      SynchronizeGroupOnReplay : 1;                             // 0x01AC(0x0004) (Edit)
	unsigned long                                      bRandomStartPosition : 1;                                 // 0x01AC(0x0004) (Edit)
	float                                              ChainedSequenceDuration;                                  // 0x01B0(0x0004) (Edit)
	struct FName                                       m_nmDisplayGroup;                                         // 0x01B4(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeSequence");
		return ptr;
	}


	void STATIC_PlayAnim(bool bLoop, float InRate, float StartTime);
};


// Class TgGame.TgAnimNodeSelfDestruct
// 0x0040 (0x01FC - 0x01BC)
class UTgAnimNodeSelfDestruct : public UTgAnimNodeSequence
{
public:
	int                                                NumberOfLoopsBeforeDestruct;                              // 0x01BC(0x0004) (Edit)
	int                                                LoopsCompleted;                                           // 0x01C0(0x0004)
	TArray<struct FName>                               ScaleOutSkelControlNames;                                 // 0x01C4(0x0010) (Edit, NeedCtorLink)
	float                                              TimeRemaingForScaleOut;                                   // 0x01D4(0x0004) (Edit)
	TArray<class USkelControlBase*>                    ScaleOutSkelControls;                                     // 0x01D8(0x0010) (Transient, NeedCtorLink)
	TArray<float>                                      ScaleOutStartScales;                                      // 0x01E8(0x0010) (Transient, NeedCtorLink)
	float                                              ScaleOutStartTime;                                        // 0x01F8(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeSelfDestruct");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeSequence_SyncToCooldown
// 0x0018 (0x01D4 - 0x01BC)
class UTgAnimNodeSequence_SyncToCooldown : public UTgAnimNodeSequence
{
public:
	TEnumAsByte<ETG_EQUIP_POINT>                       m_EqpPoint;                                               // 0x01BC(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x01BD(0x0003) MISSED OFFSET
	float                                              m_fMaxPlayRate;                                           // 0x01C0(0x0004) (Edit)
	float                                              m_fPlayRateWaitForCooldown;                               // 0x01C4(0x0004) (Edit)
	float                                              m_fPctStartWaitForCooldown;                               // 0x01C8(0x0004) (Edit)
	float                                              fCooldownEndTime;                                         // 0x01CC(0x0004)
	unsigned long                                      bWaitForCooldown : 1;                                     // 0x01D0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeSequence_SyncToCooldown");
		return ptr;
	}


	void STATIC_PlayAnim(bool bLoop, float InRate, float StartTime);
	void EndCooldown();
	void StartCooldownTimer(float fCooldown);
};


// Class TgGame.TgAnimNodeSimpleTransitioner
// 0x0020 (0x0164 - 0x0144)
class UTgAnimNodeSimpleTransitioner : public UAnimNodeBlendList
{
public:
	int                                                m_nDeviceId;                                              // 0x0144(0x0004) (Edit)
	unsigned long                                      m_bConfigureBasedOnDevice : 1;                            // 0x0148(0x0004) (Edit)
	unsigned long                                      m_bIgnoreFireMode : 1;                                    // 0x0148(0x0004) (Edit)
	int                                                m_nNumberOfStances;                                       // 0x014C(0x0004) (Edit)
	struct FName                                       m_StanceBaseName;                                         // 0x0150(0x0008) (Edit)
	struct FName                                       m_TransitionBaseName;                                     // 0x0158(0x0008) (Edit)
	float                                              m_BlendTransitionDuration;                                // 0x0160(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeSimpleTransitioner");
		return ptr;
	}


	bool Fire(int nMode);
	bool SetStance(int nStance, bool bNoBlend);
	void STATIC_ReplayAnim();
	void STATIC_PlayAnim(bool bLoop, float InRate, float StartTime);
};


// Class TgGame.TgAnimNodeSlot
// 0x0034 (0x016C - 0x0138)
class UTgAnimNodeSlot : public UAnimNodeSlot
{
public:
	class ATgPawn*                                     m_TgPawn;                                                 // 0x0138(0x0008) (Transient)
	unsigned long                                      m_bBlendOutIfVelocityIsGreaterThanZero : 1;               // 0x0140(0x0004) (Transient)
	unsigned long                                      m_bIsTransitionAnim : 1;                                  // 0x0140(0x0004) (Transient)
	unsigned long                                      m_bNotifyActorOnChildAnimEnd : 1;                         // 0x0140(0x0004) (Edit)
	struct FName                                       m_nmHackingTransitionAnimName;                            // 0x0144(0x0008) (Edit)
	struct FName                                       m_nmHackingLoopingAnimName;                               // 0x014C(0x0008) (Edit)
	struct FName                                       m_nmAFKTransitionAnimName;                                // 0x0154(0x0008) (Edit)
	struct FName                                       m_nmAFKLoopingAnimName;                                   // 0x015C(0x0008) (Edit)
	struct FName                                       m_nmQueuedAnim;                                           // 0x0164(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeSlot");
		return ptr;
	}


	void STATIC_StopCustomAnim(float BlendOutTime);
	void StopHacking();
	void PlayHacking();
	void StopAFK();
	void PlayAFK();
	void STATIC_SetPlayRate(float fPlayRate);
	float PlayLoopingCustomAnimWithTransition(const struct FName& TransitionAnimName, const struct FName& LoopingAnimName, float Rate, float BlendInTime, float BlendOutTime);
};


// Class TgGame.TgAnimNodeStance
// 0x0004 (0x0148 - 0x0144)
class UTgAnimNodeStance : public UAnimNodeBlendList
{
public:
	int                                                m_Stance;                                                 // 0x0144(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeStance");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeStanceTransition
// 0x0008 (0x014C - 0x0144)
class UTgAnimNodeStanceTransition : public UAnimNodeBlendList
{
public:
	int                                                m_SourceStance;                                           // 0x0144(0x0004) (Edit)
	int                                                m_DestinationStance;                                      // 0x0148(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeStanceTransition");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeStanceTransitioner
// 0x0030 (0x0174 - 0x0144)
class UTgAnimNodeStanceTransitioner : public UAnimNodeBlendList
{
public:
	int                                                m_DefaultStance;                                          // 0x0144(0x0004) (Edit)
	int                                                m_CurrentStance;                                          // 0x0148(0x0004) (Edit)
	unsigned long                                      m_bIsPlayingTransition : 1;                               // 0x014C(0x0004)
	float                                              m_BlendTransitionDuration;                                // 0x0150(0x0004) (Edit)
	TArray<struct FCachedTgAnimNodeStanceInfo>         m_StanceNodeInfos;                                        // 0x0154(0x0010) (NeedCtorLink)
	TArray<struct FCachedTgAnimNodeStanceTransitionInfo> m_TransitionNodeInfos;                                    // 0x0164(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeStanceTransitioner");
		return ptr;
	}


	bool BlendToStance(int DestinationStance);
	bool TransitionToStance(int DestinationStance);
	void STATIC_GetTransitionableStances(int SourceStance, TArray<int>* DestinationStances);
	bool SetStance(int Stance);
	void STATIC_ReplayAnim();
	void STATIC_PlayAnim(bool bLoop, float InRate, float StartTime);
	void GetStances(TArray<int>* Stances);
	int GetCurrentStance();
};


// Class TgGame.TgAnimNodeTiltTowardsVelocity
// 0x0023 (0x0134 - 0x0111)
class UTgAnimNodeTiltTowardsVelocity : public UAnimNodeBlendBase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0111(0x0003) MISSED OFFSET
	struct FVector2D                                   m_MaximumVelocity;                                        // 0x0114(0x0008) (Edit)
	int                                                m_PitchOffset;                                            // 0x011C(0x0004) (Transient)
	int                                                m_MaximumPitchOffset;                                     // 0x0120(0x0004) (Edit)
	int                                                m_RollOffset;                                             // 0x0124(0x0004) (Transient)
	int                                                m_MaximumRollOffset;                                      // 0x0128(0x0004) (Edit)
	class ATgPawn*                                     m_Pawn;                                                   // 0x012C(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeTiltTowardsVelocity");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeTriggerCameraAnim
// 0x0023 (0x0134 - 0x0111)
class UTgAnimNodeTriggerCameraAnim : public UAnimNodeBlendBase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0111(0x0003) MISSED OFFSET
	class UCameraAnim*                                 CameraAnim;                                               // 0x0114(0x0008) (Edit)
	float                                              fBlendInTime;                                             // 0x011C(0x0004) (Edit)
	float                                              fBlendOutTime;                                            // 0x0120(0x0004) (Edit)
	unsigned long                                      bLoopAnimation : 1;                                       // 0x0124(0x0004) (Edit)
	unsigned long                                      bBlendInOnBecomeRelevant : 1;                             // 0x0124(0x0004) (Edit)
	unsigned long                                      bBlendInOnReplayAnim : 1;                                 // 0x0124(0x0004) (Edit)
	unsigned long                                      bBlendOutOnStopFire : 1;                                  // 0x0124(0x0004) (Edit)
	unsigned long                                      bPlayAnimInLocalSpace : 1;                                // 0x0124(0x0004) (Edit)
	unsigned long                                      bPropertiesRelativeToBase : 1;                            // 0x0124(0x0004) (Edit)
	TEnumAsByte<ETG_EQUIP_POINT>                       m_StopFireEquipSlotTarget;                                // 0x0128(0x0001) (Edit)
	unsigned char                                      UnknownData01[0x3];                                       // 0x0129(0x0003) MISSED OFFSET
	class UCameraAnimInst*                             CameraAnimInst;                                           // 0x012C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeTriggerCameraAnim");
		return ptr;
	}


	void OnDeviceStopFire(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	void STATIC_ReplayAnim();
	void STATIC_EndCameraAnim();
	void StartCameraAnim();
};


// Class TgGame.TgAnimNotify_AkEvent
// 0x0010 (0x008C - 0x007C)
class UTgAnimNotify_AkEvent : public UAnimNotify_AkEvent
{
public:
	TArray<struct FPSE_SkinAk>                         m_SkinOverrideList;                                       // 0x007C(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotify_AkEvent");
		return ptr;
	}


	class UAkEvent* GetAkEventToPlay(class USkeletalMeshComponent* skel);
};


// Class TgGame.TgAnimNotify_ApplyRigidBodyPhysics
// 0x0023 (0x0088 - 0x0065)
class UTgAnimNotify_ApplyRigidBodyPhysics : public UAnimNotify
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0065(0x0003) MISSED OFFSET
	unsigned long                                      ShouldAttachToBone : 1;                                   // 0x0068(0x0004) (Edit)
	struct FName                                       BoneName;                                                 // 0x006C(0x0008) (Edit)
	struct FVector                                     ImpulseLocation;                                          // 0x0074(0x000C) (Edit)
	float                                              ImpulseRadius;                                            // 0x0080(0x0004) (Edit)
	float                                              ImpulseStrength;                                          // 0x0084(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotify_ApplyRigidBodyPhysics");
		return ptr;
	}

};


// Class TgGame.TgAnimNotify_AudioGroup
// 0x0014 (0x0079 - 0x0065)
class UTgAnimNotify_AudioGroup : public UAnimNotify
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0065(0x0003) MISSED OFFSET
	class USoundCue*                                   c_PreviewSound;                                           // 0x0068(0x0008) (Edit)
	struct FName                                       c_SoundCueName;                                           // 0x0070(0x0008) (Edit)
	TEnumAsByte<ETG_MESH_SOURCE>                       c_eMeshSource;                                            // 0x0078(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotify_AudioGroup");
		return ptr;
	}

};


// Class TgGame.TgAnimNotify_Footstep
// 0x0003 (0x0078 - 0x0075)
class UTgAnimNotify_Footstep : public UAnimNotify_Footstep
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0075(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotify_Footstep");
		return ptr;
	}

};


// Class TgGame.TgAnimNotify_InterpolateMorphTargetWeight
// 0x001B (0x0080 - 0x0065)
class UTgAnimNotify_InterpolateMorphTargetWeight : public UAnimNotify
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0065(0x0003) MISSED OFFSET
	struct FName                                       MorphNodePoseName;                                        // 0x0068(0x0008) (Edit)
	float                                              MorphTargetWeight;                                        // 0x0070(0x0004) (Edit)
	TEnumAsByte<EInterruptMorphTargetBehavior>         OnInterruptBehavior;                                      // 0x0074(0x0001) (Edit)
	unsigned char                                      UnknownData01[0x3];                                       // 0x0075(0x0003) MISSED OFFSET
	float                                              InterruptMorphTargetWeight;                               // 0x0078(0x0004) (Edit)
	float                                              InitialMorphTargetWeight;                                 // 0x007C(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotify_InterpolateMorphTargetWeight");
		return ptr;
	}


	void OnAnimNodeSequenceCeaseRelevant(class UAnimNodeSequence* OwningNode);
};


// Class TgGame.TgAnimNotify_PlayParticleEffect_Skinned
// 0x0014 (0x00AC - 0x0098)
class UTgAnimNotify_PlayParticleEffect_Skinned : public UAnimNotify_PlayParticleEffect
{
public:
	TArray<struct FPPE_Skin>                           m_SkinOverrideList;                                       // 0x0098(0x0010) (Edit, NeedCtorLink)
	unsigned long                                      m_bApplyTeamColor : 1;                                    // 0x00A8(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotify_PlayParticleEffect_Skinned");
		return ptr;
	}


	struct FParticleChannelContainer GetParticleChannels(class USkeletalMeshComponent* skel);
	class UParticleSystem* GetParticleSystemToPlay(class USkeletalMeshComponent* skel);
};


// Class TgGame.TgAnimNotify_PlayPetAnim
// 0x000B (0x0070 - 0x0065)
class UTgAnimNotify_PlayPetAnim : public UAnimNotify
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0065(0x0003) MISSED OFFSET
	struct FName                                       m_ChildSeqName;                                           // 0x0068(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotify_PlayPetAnim");
		return ptr;
	}

};


// Class TgGame.TgAnimNotify_SetMICParam
// 0x000F (0x0074 - 0x0065)
class UTgAnimNotify_SetMICParam : public UAnimNotify
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0065(0x0003) MISSED OFFSET
	struct FName                                       m_nmParamName;                                            // 0x0068(0x0008) (Edit)
	float                                              m_fTargetValue;                                           // 0x0070(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotify_SetMICParam");
		return ptr;
	}

};


// Class TgGame.TgAnimNotify_SetMICStates
// 0x001F (0x0084 - 0x0065)
class UTgAnimNotify_SetMICStates : public UAnimNotify
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0065(0x0003) MISSED OFFSET
	struct FName                                       MICStateName;                                             // 0x0068(0x0008) (Edit)
	struct FName                                       FromMICStateName;                                         // 0x0070(0x0008) (Edit)
	float                                              fInterpTime;                                              // 0x0078(0x0004) (Edit)
	int                                                nMaterialIndex;                                           // 0x007C(0x0004) (Edit)
	unsigned long                                      bApplyToChildMeshes : 1;                                  // 0x0080(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotify_SetMICStates");
		return ptr;
	}

};


// Class TgGame.TgAnimNotify_Sound
// 0x0010 (0x0098 - 0x0088)
class UTgAnimNotify_Sound : public UAnimNotify_Sound
{
public:
	TArray<struct FPSE_Skin>                           m_SkinOverrideList;                                       // 0x0088(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotify_Sound");
		return ptr;
	}


	class USoundCue* GetSoundCueToPlay(class USkeletalMeshComponent* skel);
};


// Class TgGame.TgAnimNotify_SwapToInhandWeaponMesh
// 0x0003 (0x0068 - 0x0065)
class UTgAnimNotify_SwapToInhandWeaponMesh : public UAnimNotify
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0065(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotify_SwapToInhandWeaponMesh");
		return ptr;
	}

};


// Class TgGame.TgAnimNotify_ToggleInvisibleWall
// 0x003B (0x00A0 - 0x0065)
class UTgAnimNotify_ToggleInvisibleWall : public UAnimNotify
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0065(0x0003) MISSED OFFSET
	unsigned long                                      TurnWallOn : 1;                                           // 0x0068(0x0004) (Edit)
	unsigned long                                      TurnOffOnCeaseRelevant : 1;                               // 0x0068(0x0004) (Edit)
	int                                                WallIndex;                                                // 0x006C(0x0004) (Edit)
	struct FVector                                     WallPosition;                                             // 0x0070(0x000C) (Edit)
	struct FVector                                     WallNormal;                                               // 0x007C(0x000C) (Edit)
	struct FName                                       WallEnableBaseName;                                       // 0x0088(0x0008) (Const)
	struct FName                                       WallPositionBaseName;                                     // 0x0090(0x0008) (Const)
	struct FName                                       WallNormalBaseName;                                       // 0x0098(0x0008) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotify_ToggleInvisibleWall");
		return ptr;
	}


	void OnAnimNodeSequenceCeaseRelevant(class UAnimNodeSequence* OwningNode);
};


// Class TgGame.TgAnimNotify_ToggleRigidBodies
// 0x0014 (0x0079 - 0x0065)
class UTgAnimNotify_ToggleRigidBodies : public UAnimNotify
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0065(0x0003) MISSED OFFSET
	TArray<struct FName>                               BoneNames;                                                // 0x0068(0x0010) (Edit, NeedCtorLink)
	TEnumAsByte<ERigidBodyFixationChange>              Effect;                                                   // 0x0078(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotify_ToggleRigidBodies");
		return ptr;
	}


	void OnAnimNodeSequenceBecomeRelevant(class UAnimNodeSequence* OwningNode);
	void OnAnimNodeSequenceCeaseRelevant(class UAnimNodeSequence* OwningNode);
};


// Class TgGame.TgAnimNotify_ToggleSocketSpecialFX
// 0x0013 (0x0078 - 0x0065)
class UTgAnimNotify_ToggleSocketSpecialFX : public UAnimNotify
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0065(0x0003) MISSED OFFSET
	struct FName                                       m_DisplayGroupName;                                       // 0x0068(0x0008) (Edit)
	int                                                m_EquipSlot;                                              // 0x0070(0x0004) (Edit)
	unsigned long                                      m_bActivateFxGroup : 1;                                   // 0x0074(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotify_ToggleSocketSpecialFX");
		return ptr;
	}

};


// Class TgGame.TgAnimNotify_ViewShake
// 0x0010 (0x00CC - 0x00BC)
class UTgAnimNotify_ViewShake : public UAnimNotify_ViewShake
{
public:
	float                                              m_fShakeRadius;                                           // 0x00BC(0x0004) (EditConst)
	float                                              m_fDuration;                                              // 0x00C0(0x0004) (EditConst)
	float                                              m_fAmplitude;                                             // 0x00C4(0x0004) (EditConst)
	unsigned long                                      m_bUseLocationRadiusBasedShake : 1;                       // 0x00C8(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotify_ViewShake");
		return ptr;
	}


	void Notify(class AActor* Owner, class UAnimNodeSequence* AnimSeqInstigator);
	void Clear1pCameraAnim();
};


// Class TgGame.TgAnimNotifySkinData
// 0x0028 (0x0088 - 0x0060)
class UTgAnimNotifySkinData : public UObject
{
public:
	struct FString                                     OwningNotify;                                             // 0x0060(0x0010) (AlwaysInit, NeedCtorLink)
	class USoundCue*                                   SoundCueTemplate;                                         // 0x0070(0x0008)
	class UParticleSystem*                             ParticleSystemTemplate;                                   // 0x0078(0x0008)
	int                                                nSkinId;                                                  // 0x0080(0x0004)
	int                                                nSkinLevel;                                               // 0x0084(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotifySkinData");
		return ptr;
	}

};


// Class TgGame.TgAnimTurnInPlace
// 0x0088 (0x01AC - 0x0124)
class UTgAnimTurnInPlace : public UAnimNodeBlend
{
public:
	unsigned long                                      bInitialized : 1;                                         // 0x0124(0x0004) (Const, Transient)
	unsigned long                                      bRootRotInitialized : 1;                                  // 0x0124(0x0004) (Const, Transient)
	unsigned long                                      m_bDisableRotation : 1;                                   // 0x0124(0x0004) (Edit)
	unsigned long                                      bDelayBlendOutToPlayAnim : 1;                             // 0x0124(0x0004) (Edit)
	unsigned long                                      bPlayingTurnTransition : 1;                               // 0x0124(0x0004) (Const)
	unsigned long                                      m_bCanChooseNewTransition : 1;                            // 0x0124(0x0004) (Edit)
	unsigned long                                      m_bOverrideInterpolationTime : 1;                         // 0x0124(0x0004) (Edit)
	unsigned long                                      m_bMirrorOffsetWhenPawnMirrored : 1;                      // 0x0124(0x0004) (Edit)
	unsigned long                                      m_bAlwaysUpdateYawOffset : 1;                             // 0x0124(0x0004) (Edit)
	unsigned long                                      m_bIgnoreTransitionAnimations : 1;                        // 0x0124(0x0004) (Edit)
	unsigned long                                      m_bOnlyUpdateRotationWhenMoving : 1;                      // 0x0124(0x0004) (Edit)
	unsigned long                                      m_bTurnTowardsVelocity : 1;                               // 0x0124(0x0004) (Edit)
	unsigned long                                      m_bUsePawnRotationAtZeroVelocity : 1;                     // 0x0124(0x0004) (Edit)
	unsigned long                                      m_bUse180ShortestRoute : 1;                               // 0x0124(0x0004) (Edit)
	unsigned long                                      m_bConstrictIdleYawOffset : 1;                            // 0x0124(0x0004) (Edit)
	unsigned long                                      m_bDisableAllTurning : 1;                                 // 0x0124(0x0004) (Edit)
	unsigned long                                      m_bJustBecameRelevant : 1;                                // 0x0124(0x0004)
	int                                                LastPawnYaw;                                              // 0x0128(0x0004) (Const, Transient)
	int                                                LastPawnPitch;                                            // 0x012C(0x0004) (Const, Transient)
	float                                              PawnRotationRate;                                         // 0x0130(0x0004) (Const, Transient)
	int                                                LastRootBoneYaw;                                          // 0x0134(0x0004) (Const, Transient)
	int                                                YawOffset;                                                // 0x0138(0x0004) (Edit, Const, Transient)
	int                                                PitchOffset;                                              // 0x013C(0x0004) (Edit, Const, Transient)
	float                                              RelativeOffset;                                           // 0x0140(0x0004) (Const, Transient)
	class ATgPawn*                                     m_TgPawn;                                                 // 0x0144(0x0008) (Const, Transient)
	TArray<class UTgAnimNodeAimOffset*>                OffsetNodes2;                                             // 0x014C(0x0010) (NeedCtorLink)
	TArray<struct FRotTransitionInfo>                  RotTransitions;                                           // 0x015C(0x0010) (Edit, NeedCtorLink)
	float                                              TransitionBlendTime;                                      // 0x016C(0x0004) (Edit)
	int                                                CurrentTransitionIndex;                                   // 0x0170(0x0004) (Const)
	float                                              TransitionThresholdAngle;                                 // 0x0174(0x0004) (Edit)
	TEnumAsByte<EForcedTransitionAngle>                m_ForcedTransitionAngle;                                  // 0x0178(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0179(0x0003) MISSED OFFSET
	float                                              m_fChooseNewTransitionPercent;                            // 0x017C(0x0004) (Edit)
	float                                              m_fInterpolationTime;                                     // 0x0180(0x0004) (Edit)
	float                                              m_RemainingInterpolationTime;                             // 0x0184(0x0004)
	TArray<class UTgAnimTurnInPlace_Player*>           PlayerNodes;                                              // 0x0188(0x0010) (NeedCtorLink)
	float                                              m_fIgnoredTransitionTime;                                 // 0x0198(0x0004) (Edit)
	float                                              m_fTurnInterpTime;                                        // 0x019C(0x0004) (Edit)
	struct FRotator                                    m_InterpRotation;                                         // 0x01A0(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimTurnInPlace");
		return ptr;
	}


	void OverrideYawOffset(float Value);
};


// Class TgGame.TgAnimTurnInPlace_Player
// 0x0010 (0x01BC - 0x01AC)
class UTgAnimTurnInPlace_Player : public UAnimNodeSequence
{
public:
	TArray<struct FTIP_Transition>                     TIP_Transitions;                                          // 0x01AC(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimTurnInPlace_Player");
		return ptr;
	}

};


// Class TgGame.TgAnimTurnInPlace_Rotator
// 0x001B (0x012C - 0x0111)
class UTgAnimTurnInPlace_Rotator : public UAnimNodeBlendBase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0111(0x0003) MISSED OFFSET
	TArray<class UTgAnimTurnInPlace*>                  c_TurnInPlaceNodes;                                       // 0x0114(0x0010) (Const, NeedCtorLink)
	class ATgPawn*                                     m_TgPawn;                                                 // 0x0124(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimTurnInPlace_Rotator");
		return ptr;
	}

};


// Class TgGame.TgSkelCon_CCD_IK_FootPlacement
// 0x0064 (0x0134 - 0x00D0)
class UTgSkelCon_CCD_IK_FootPlacement : public USkelControlBase
{
public:
	int                                                NumBones;                                                 // 0x00D0(0x0004) (Edit)
	int                                                MaxPerBoneIterations;                                     // 0x00D4(0x0004) (Edit)
	int                                                IterationsCount;                                          // 0x00D8(0x0004) (Const)
	float                                              Precision;                                                // 0x00DC(0x0004) (Edit)
	unsigned long                                      bStartFromTail : 1;                                       // 0x00E0(0x0004) (Edit)
	unsigned long                                      bNoTurnOptimization : 1;                                  // 0x00E0(0x0004) (Edit)
	unsigned long                                      bAllowStretching : 1;                                     // 0x00E0(0x0004) (Edit)
	unsigned long                                      bInvertFootUpAxis : 1;                                    // 0x00E0(0x0004) (Edit)
	unsigned long                                      bOrientFootToGround : 1;                                  // 0x00E0(0x0004) (Edit)
	unsigned long                                      bOnlyEnableForUpAdjustment : 1;                           // 0x00E0(0x0004) (Edit)
	unsigned long                                      m_bUseCachedFootOffset : 1;                               // 0x00E0(0x0004)
	TArray<struct FJointConstraintInformation>         JointConstraints;                                         // 0x00E4(0x0010) (Edit, Const, NeedCtorLink)
	float                                              MaxAngleSteps;                                            // 0x00F4(0x0004) (Edit)
	float                                              MaxStretchSteps;                                          // 0x00F8(0x0004) (Edit)
	float                                              FootOffset;                                               // 0x00FC(0x0004) (Edit)
	TEnumAsByte<EAxis>                                 FootUpAxis;                                               // 0x0100(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0101(0x0003) MISSED OFFSET
	struct FRotator                                    FootRotOffset;                                            // 0x0104(0x000C) (Edit)
	float                                              MaxUpAdjustment;                                          // 0x0110(0x0004) (Edit)
	float                                              MaxDownAdjustment;                                        // 0x0114(0x0004) (Edit)
	float                                              MaxFootOrientAdjust;                                      // 0x0118(0x0004) (Edit)
	struct FVector                                     EffectorLocation;                                         // 0x011C(0x000C)
	struct FVector                                     m_vCachedFootOffset;                                      // 0x0128(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_CCD_IK_FootPlacement");
		return ptr;
	}

};


// Class TgGame.TgSkelCon_ClockworkSpinner
// 0x0044 (0x0144 - 0x0100)
class UTgSkelCon_ClockworkSpinner : public USkelControlSingleBone
{
public:
	float                                              m_fInterpTime;                                            // 0x0100(0x0004) (Edit)
	float                                              m_fRemainingInterpTime;                                   // 0x0104(0x0004)
	float                                              m_fPauseTime;                                             // 0x0108(0x0004) (Edit)
	float                                              m_fRemainingPauseTime;                                    // 0x010C(0x0004)
	TEnumAsByte<EAxis>                                 RotationAxis;                                             // 0x0110(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0111(0x0003) MISSED OFFSET
	int                                                DeltaRotation;                                            // 0x0114(0x0004)
	float                                              m_fInterpRotation;                                        // 0x0118(0x0004) (Edit)
	unsigned long                                      bLimitedRotation : 1;                                     // 0x011C(0x0004) (Edit)
	unsigned long                                      bForward : 1;                                             // 0x011C(0x0004)
	unsigned long                                      m_bResetRotationOnZeroStrength : 1;                       // 0x011C(0x0004) (Edit)
	float                                              m_fRotationMin;                                           // 0x0120(0x0004) (Edit)
	float                                              m_fRotationMax;                                           // 0x0124(0x0004) (Edit)
	float                                              m_fResetInterpTime;                                       // 0x0128(0x0004) (Edit)
	float                                              m_fResetPauseTime;                                        // 0x012C(0x0004) (Edit)
	float                                              m_fResetRotation;                                         // 0x0130(0x0004) (Edit)
	float                                              m_fRotatorMin;                                            // 0x0134(0x0004)
	float                                              m_fRotatorMax;                                            // 0x0138(0x0004)
	float                                              RotationsPerSecond;                                       // 0x013C(0x0004)
	float                                              ResetRotationsPerSecond;                                  // 0x0140(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_ClockworkSpinner");
		return ptr;
	}

};


// Class TgGame.TgSkelCon_FootPlacement
// 0x0004 (0x015C - 0x0158)
class UTgSkelCon_FootPlacement : public USkelControlFootPlacement
{
public:
	unsigned long                                      bShouldUseWorldDown : 1;                                  // 0x0158(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_FootPlacement");
		return ptr;
	}

};


// Class TgGame.TgSkelCon_Gate
// 0x0010 (0x00E0 - 0x00D0)
class UTgSkelCon_Gate : public USkelControlBase
{
public:
	TArray<struct FSkelControlGateChild>               ChildControls;                                            // 0x00D0(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_Gate");
		return ptr;
	}

};


// Class TgGame.TgSkelCon_HitReaction
// 0x03A8 (0x0510 - 0x0168)
class UTgSkelCon_HitReaction : public UGameSkelCtrl_Recoil
{
public:
	TEnumAsByte<ERecoilHitDir>                         m_CurrentRecoilDir;                                       // 0x0168(0x0001) (Edit)
	TEnumAsByte<EHitReactionMoveType>                  m_MoveType;                                               // 0x0169(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x2];                                       // 0x016A(0x0002) MISSED OFFSET
	struct FRecoilInfo                                 m_RecoilFromFront;                                        // 0x016C(0x00E0) (Edit)
	struct FRecoilInfo                                 m_RecoilFromBack;                                         // 0x024C(0x00E0) (Edit)
	struct FRecoilInfo                                 m_RecoilFromLeft;                                         // 0x032C(0x00E0) (Edit)
	struct FRecoilInfo                                 m_RecoilFromRight;                                        // 0x040C(0x00E0) (Edit)
	TArray<struct FName>                               m_SlaveSkelControlNames;                                  // 0x04EC(0x0010) (Edit, NeedCtorLink)
	TArray<class USkelControlBase*>                    m_SlaveSkelControls;                                      // 0x04FC(0x0010) (Transient, NeedCtorLink)
	unsigned long                                      m_bInitialized : 1;                                       // 0x050C(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_HitReaction");
		return ptr;
	}


	struct FRecoilDef STATIC_GenRecoil(const struct FRecoilInfo& RecoilParam);
	struct FVector STATIC_VRandRange(const struct FVector& v1, const struct FVector& v2);
	void SetRecoilParam();
	void SetRecoilDir(TEnumAsByte<ERecoilHitDir> NewDir);
};


// Class TgGame.TgSkelCon_HookChain
// 0x0130 (0x0230 - 0x0100)
class UTgSkelCon_HookChain : public USkelControlSingleBone
{
public:
	float                                              m_fBoneScales[0x48];                                      // 0x0100(0x0004)
	class UTgDeviceForm_Drag*                          m_DragDeviceForm;                                         // 0x0220(0x0008)
	class UTgSkeletalMeshComponent*                    m_ChainComponent;                                         // 0x0228(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_HookChain");
		return ptr;
	}


	float GetAngleToBone(int BoneIndex);
};


// Class TgGame.TgSkelCon_LookAt
// 0x0014 (0x0180 - 0x016C)
class UTgSkelCon_LookAt : public USkelControlLookAt
{
public:
	class ATgPawn*                                     m_Owner;                                                  // 0x016C(0x0008)
	class ATgDeployable*                               m_DeployOwner;                                            // 0x0174(0x0008)
	unsigned long                                      m_bAimAtEnemyTarget : 1;                                  // 0x017C(0x0004) (Edit)
	unsigned long                                      m_AlwaysInterpolateTarget : 1;                            // 0x017C(0x0004) (Edit)
	unsigned long                                      m_bHadTargetLastTick : 1;                                 // 0x017C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_LookAt");
		return ptr;
	}

};


// Class TgGame.TgSkelCon_MirrorFromOtherMesh
// 0x0018 (0x0118 - 0x0100)
class UTgSkelCon_MirrorFromOtherMesh : public USkelControlSingleBone
{
public:
	struct FName                                       m_nmIdentifier;                                           // 0x0100(0x0008) (Edit)
	class ATgPawn*                                     m_PawnOwner;                                              // 0x0108(0x0008)
	class UTgSkelCon_MirrorToOtherMesh*                m_MirrorControl;                                          // 0x0110(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_MirrorFromOtherMesh");
		return ptr;
	}

};


// Class TgGame.TgSkelCon_MirrorToOtherMesh
// 0x0008 (0x0108 - 0x0100)
class UTgSkelCon_MirrorToOtherMesh : public USkelControlSingleBone
{
public:
	struct FName                                       m_nmIdentifier;                                           // 0x0100(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_MirrorToOtherMesh");
		return ptr;
	}

};


// Class TgGame.TgSkelCon_RotateToAim
// 0x0018 (0x0120 - 0x0108)
class UTgSkelCon_RotateToAim : public UTgSkelCon_MirrorToOtherMesh
{
public:
	float                                              m_fRotationSpeed;                                         // 0x0108(0x0004) (Edit)
	unsigned long                                      m_bUseConstantSpeed : 1;                                  // 0x010C(0x0004) (Edit)
	unsigned long                                      m_bAim2DOnly : 1;                                         // 0x010C(0x0004) (Edit)
	unsigned long                                      m_bVelocity2DOnly : 1;                                    // 0x010C(0x0004) (Edit)
	float                                              m_fMinVelocity;                                           // 0x0110(0x0004) (Edit)
	struct FRotator                                    m_rTargetRotation;                                        // 0x0114(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_RotateToAim");
		return ptr;
	}

};


// Class TgGame.TgSkelCon_RotateToNormal
// 0x0020 (0x0128 - 0x0108)
class UTgSkelCon_RotateToNormal : public UTgSkelCon_MirrorToOtherMesh
{
public:
	float                                              m_fRotationSpeed;                                         // 0x0108(0x0004) (Edit)
	unsigned long                                      m_bUseConstantSpeed : 1;                                  // 0x010C(0x0004) (Edit)
	unsigned long                                      m_bRotateInstantly : 1;                                   // 0x010C(0x0004) (Edit)
	struct FVector                                     m_vTargetNormal;                                          // 0x0110(0x000C)
	struct FRotator                                    m_rTargetRotation;                                        // 0x011C(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_RotateToNormal");
		return ptr;
	}

};


// Class TgGame.TgSkelCon_RotateToVelocity
// 0x0020 (0x0128 - 0x0108)
class UTgSkelCon_RotateToVelocity : public UTgSkelCon_MirrorToOtherMesh
{
public:
	float                                              m_fRotationSpeed;                                         // 0x0108(0x0004) (Edit)
	unsigned long                                      m_bUseConstantSpeed : 1;                                  // 0x010C(0x0004) (Edit)
	unsigned long                                      m_bVelocity2DOnly : 1;                                    // 0x010C(0x0004) (Edit)
	float                                              m_fMinVelocity;                                           // 0x0110(0x0004) (Edit)
	struct FRotator                                    m_rTargetRotation;                                        // 0x0114(0x000C)
	class AActor*                                      m_CachedOwner;                                            // 0x0120(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_RotateToVelocity");
		return ptr;
	}

};


// Class TgGame.TgSkelCon_OscillateBoneScale
// 0x0010 (0x0110 - 0x0100)
class UTgSkelCon_OscillateBoneScale : public USkelControlSingleBone
{
public:
	float                                              OscillationAmplitude;                                     // 0x0100(0x0004) (Edit)
	float                                              OscillationFrequency;                                     // 0x0104(0x0004) (Edit)
	float                                              OscillationBaseScale;                                     // 0x0108(0x0004) (Edit)
	float                                              Theta;                                                    // 0x010C(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_OscillateBoneScale");
		return ptr;
	}

};


// Class TgGame.TgSkelCon_OscillateRotation
// 0x0024 (0x0124 - 0x0100)
class UTgSkelCon_OscillateRotation : public USkelControlSingleBone
{
public:
	float                                              OscillationAmplitude;                                     // 0x0100(0x0004) (Edit)
	float                                              OscillationFrequency;                                     // 0x0104(0x0004) (Edit)
	struct FVector                                     OscillationAxis;                                          // 0x0108(0x000C) (Edit)
	TEnumAsByte<EBoneControlSpace>                     OscillationAxisSpace;                                     // 0x0114(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0115(0x0003) MISSED OFFSET
	struct FName                                       OscillationAxisSpaceBoneName;                             // 0x0118(0x0008) (Edit)
	float                                              Theta;                                                    // 0x0120(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_OscillateRotation");
		return ptr;
	}

};


// Class TgGame.TgSkelCon_OscillateTranslation
// 0x0024 (0x0124 - 0x0100)
class UTgSkelCon_OscillateTranslation : public USkelControlSingleBone
{
public:
	float                                              OscillationAmplitude;                                     // 0x0100(0x0004) (Edit)
	float                                              OscillationFrequency;                                     // 0x0104(0x0004) (Edit)
	struct FVector                                     OscillationAxis;                                          // 0x0108(0x000C) (Edit)
	TEnumAsByte<EBoneControlSpace>                     OscillationAxisSpace;                                     // 0x0114(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0115(0x0003) MISSED OFFSET
	struct FName                                       OscillationAxisSpaceBoneName;                             // 0x0118(0x0008) (Edit)
	float                                              Theta;                                                    // 0x0120(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_OscillateTranslation");
		return ptr;
	}

};


// Class TgGame.TgSkelCon_SkinGate
// 0x0024 (0x00F4 - 0x00D0)
class UTgSkelCon_SkinGate : public USkelControlBase
{
public:
	struct FSkelControlSkinGateChild                   DefaultChild;                                             // 0x00D0(0x0014)
	TArray<struct FSkelControlSkinGateChild>           ChildControls;                                            // 0x00E4(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_SkinGate");
		return ptr;
	}

};


// Class TgGame.TgSkelCon_Spinner
// 0x0044 (0x0144 - 0x0100)
class UTgSkelCon_Spinner : public USkelControlSingleBone
{
public:
	float                                              m_fDegreesPerSecond;                                      // 0x0100(0x0004) (Edit)
	struct FVector                                     m_vAxis;                                                  // 0x0104(0x000C) (Edit)
	unsigned long                                      m_PreviewStartStop : 1;                                   // 0x0110(0x0004) (Edit, Transient)
	unsigned long                                      m_bIsSpinning : 1;                                        // 0x0110(0x0004)
	unsigned long                                      m_bSpinningUp : 1;                                        // 0x0110(0x0004)
	unsigned long                                      m_bSpinningDown : 1;                                      // 0x0110(0x0004)
	unsigned long                                      m_bSpinDownToZero : 1;                                    // 0x0110(0x0004)
	unsigned long                                      m_bRotateToTargetRotation : 1;                            // 0x0110(0x0004) (Edit)
	float                                              m_fSpinUpTime;                                            // 0x0114(0x0004) (Edit)
	float                                              m_fSpinDownTime;                                          // 0x0118(0x0004) (Edit)
	float                                              m_fCurrentDegreesPerSecond;                               // 0x011C(0x0004)
	struct FRotator                                    m_TargetRotation;                                         // 0x0120(0x000C) (Edit)
	float                                              m_TimeToInterpToTargetRotation;                           // 0x012C(0x0004) (Edit)
	int                                                m_nRotationSpeedState;                                    // 0x0130(0x0004) (Transient)
	TArray<float>                                      m_fRotationSpeedStateMultipliers;                         // 0x0134(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_Spinner");
		return ptr;
	}


	void SpinToTargetRotation(const struct FRotator& TargetRotation, float Time, bool bReset);
	void Spin(bool bEnabled);
};


// Class TgGame.TgSkelCon_AstroSpinner
// 0x0008 (0x014C - 0x0144)
class UTgSkelCon_AstroSpinner : public UTgSkelCon_Spinner
{
public:
	class ATgPawn*                                     m_PawnOwner;                                              // 0x0144(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_AstroSpinner");
		return ptr;
	}

};


// Class TgGame.TgSkelCon_RuckusSpinner
// 0x0000 (0x0144 - 0x0144)
class UTgSkelCon_RuckusSpinner : public UTgSkelCon_Spinner
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_RuckusSpinner");
		return ptr;
	}

};


// Class TgGame.TgSkelCon_Spring
// 0x002C (0x0198 - 0x016C)
class UTgSkelCon_Spring : public USkelControlLookAt
{
public:
	struct FVector                                     m_vWorldSpaceGoal;                                        // 0x016C(0x000C)
	struct FVector                                     m_vInitialWorldSpaceGoalOffset;                           // 0x0178(0x000C) (Edit)
	struct FVector                                     m_vVelocity;                                              // 0x0184(0x000C)
	float                                              m_fSpringStiffness;                                       // 0x0190(0x0004) (Edit)
	float                                              m_fSpringDamping;                                         // 0x0194(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_Spring");
		return ptr;
	}

};


// Class TgGame.TgSkelControlSingleBone
// 0x0024 (0x0124 - 0x0100)
class UTgSkelControlSingleBone : public USkelControlSingleBone
{
public:
	unsigned long                                      SnapStrengthFromAnimNodes : 1;                            // 0x0100(0x0004) (Edit)
	unsigned long                                      m_bIsWidescreen : 1;                                      // 0x0100(0x0004) (Edit, Transient)
	float                                              SnapStrengthThreshold;                                    // 0x0104(0x0004) (Edit)
	struct FVector                                     m_WidescreenBoneTranslationOffset;                        // 0x0108(0x000C) (Edit)
	struct FRotator                                    m_WidescreenBoneRotationOffset;                           // 0x0114(0x000C) (Edit)
	float                                              m_WidescreenBoneScaleOffset;                              // 0x0120(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelControlSingleBone");
		return ptr;
	}

};


// Class TgGame.TgSkelControlSingleBone_Ammo
// 0x0020 (0x0144 - 0x0124)
class UTgSkelControlSingleBone_Ammo : public UTgSkelControlSingleBone
{
public:
	class ATgPawn*                                     m_PawnOwner;                                              // 0x0124(0x0008)
	unsigned long                                      m_bInvertStrengthFromAmmo : 1;                            // 0x012C(0x0004) (Edit)
	float                                              m_fFlatInterpolationRateDecrease;                         // 0x0130(0x0004) (Edit)
	float                                              m_fInterpolationRateDecrease;                             // 0x0134(0x0004) (Edit)
	float                                              m_fFlatInterpolationRateIncrease;                         // 0x0138(0x0004) (Edit)
	float                                              m_fInterpolationRateIncrease;                             // 0x013C(0x0004) (Edit)
	int                                                m_nMaxAmmoFallback;                                       // 0x0140(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelControlSingleBone_Ammo");
		return ptr;
	}

};


// Class TgGame.TgSkelControlSingleBone_DisplayGroup
// 0x0010 (0x0134 - 0x0124)
class UTgSkelControlSingleBone_DisplayGroup : public UTgSkelControlSingleBone
{
public:
	TArray<struct FDisplayGroupInfo>                   DisplayGroupInfos;                                        // 0x0124(0x0010) (Edit, ExportObject, NeedCtorLink, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelControlSingleBone_DisplayGroup");
		return ptr;
	}

};


// Class TgGame.TgSkelControlSingleBone_PistonBarrel
// 0x0008 (0x012C - 0x0124)
class UTgSkelControlSingleBone_PistonBarrel : public UTgSkelControlSingleBone
{
public:
	float                                              m_nDepressDistance;                                       // 0x0124(0x0004)
	float                                              m_nReturnSpeed;                                           // 0x0128(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelControlSingleBone_PistonBarrel");
		return ptr;
	}


	void Depress();
};


// Class TgGame.TgSkelControlSingleBone_Skinned
// 0x001C (0x0140 - 0x0124)
class UTgSkelControlSingleBone_Skinned : public UTgSkelControlSingleBone
{
public:
	float                                              DefaultStrength;                                          // 0x0124(0x0004) (Edit)
	TArray<struct FSkinStrengthOverride>               SkinOverrides;                                            // 0x0128(0x0010) (Edit, ExportObject, NeedCtorLink, EditInline)
	unsigned long                                      bInitializedStrength : 1;                                 // 0x0138(0x0004)
	float                                              fSkinStrength;                                            // 0x013C(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelControlSingleBone_Skinned");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByPaladinsCharacter_Lex
// 0x0028 (0x056C - 0x0544)
class UTgAnimBlendByPaladinsCharacter_Lex : public UTgAnimBlendByPaladinsCharacter
{
public:
	class ATgPawn_Lex*                                 m_CachedLex;                                              // 0x0544(0x0008)
	struct FName                                       m_LeftSlideSkelControlName;                               // 0x054C(0x0008) (Edit)
	struct FName                                       m_RightSlideSkelControlName;                              // 0x0554(0x0008) (Edit)
	class USkelControlBase*                            m_LeftSlideSkelControl;                                   // 0x055C(0x0008)
	class USkelControlBase*                            m_RightSlideSkelControl;                                  // 0x0564(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByPaladinsCharacter_Lex");
		return ptr;
	}


	void STATIC_SetActiveChild(int ChildIndex, float BlendTime);
	void STATIC_UpdateSlideSkelControls();
};


// Class TgGame.TgSkelControlSingleBone_Ammo_Lex
// 0x001C (0x0140 - 0x0124)
class UTgSkelControlSingleBone_Ammo_Lex : public UTgSkelControlSingleBone
{
public:
	class ATgPawn_Lex*                                 m_Lex;                                                    // 0x0124(0x0008)
	unsigned long                                      m_bLeftGun : 1;                                           // 0x012C(0x0004) (Edit)
	float                                              m_fFlatInterpolationRateDecrease;                         // 0x0130(0x0004) (Edit)
	float                                              m_fInterpolationRateDecrease;                             // 0x0134(0x0004) (Edit)
	float                                              m_fFlatInterpolationRateIncrease;                         // 0x0138(0x0004) (Edit)
	float                                              m_fInterpolationRateIncrease;                             // 0x013C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelControlSingleBone_Ammo_Lex");
		return ptr;
	}

};


// Class TgGame.TgBeamHelper
// 0x004C (0x00AC - 0x0060)
class UTgBeamHelper : public UTgObject
{
public:
	int                                                m_nSpecialFxId;                                           // 0x0060(0x0004)
	class UTgSpecialFx*                                m_pSpecialFx;                                             // 0x0064(0x0008)
	TArray<class UParticleSystemComponent*>            m_pPSCList;                                               // 0x006C(0x0010) (ExportObject, Component, NeedCtorLink, EditInline)
	unsigned long                                      m_bVisibilityEnabled : 1;                                 // 0x007C(0x0004)
	unsigned long                                      m_bCurrentlyVisible : 1;                                  // 0x007C(0x0004)
	unsigned long                                      m_bRequiresTarget : 1;                                    // 0x007C(0x0004)
	unsigned long                                      m_bTangentsEnabled : 1;                                   // 0x007C(0x0004)
	struct FVector                                     m_vInitialTangent;                                        // 0x0080(0x000C)
	class AActor*                                      m_pOwner;                                                 // 0x008C(0x0008)
	class AActor*                                      m_pTarget;                                                // 0x0094(0x0008)
	class UMeshComponent*                              m_pAttachMesh;                                            // 0x009C(0x0008) (ExportObject, Component, EditInline)
	struct FName                                       m_nmAttachMeshSocket;                                     // 0x00A4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBeamHelper");
		return ptr;
	}


	void STATIC_EnableTangents();
	void STATIC_SetVisible(bool bVisible);
	void Deactivate(bool bForceDeactivate);
	void STATIC_Activate();
	void AttachToTarget(class AActor* pTarget);
	void AttachToMesh(class UMeshComponent* pMesh, const struct FName& nmSocket);
	void AttachToOwner(class AActor* pOwner);
	void Tick(float fDeltaSeconds);
	void STATIC_SetVectorParameter(const struct FName& nmParam, const struct FVector& vValue);
	void STATIC_SetFloatParameter(const struct FName& nmParam, float fValue);
	void SetTangentsMulti(TArray<struct FVector> vSourceTangents, TArray<struct FVector> vTargetTangents);
	void SetTangents(const struct FVector& vSourceTangent, const struct FVector& vTargetTangent);
	void SetEndPoint(const struct FVector& vEndPoint);
	void STATIC_InitializeFromFx(class UTgSpecialFx* pSpecialFx);
	void Initialize(int nSpecialFxId);
	class UTgBeamHelper* CreateFromFx(class UTgSpecialFx* pSpecialFx);
	class UTgBeamHelper* Create(int nSpecialFxId);
};


// Class TgGame.TgDevice
// 0x0710 (0x0A0C - 0x02FC)
class ATgDevice : public AWeapon
{
public:
	struct FPointer                                    VfTable_ITgGameplayCurveOwner;                            // 0x02FC(0x0008) (Const, Native, NoExport)
	int                                                r_nDeviceId;                                              // 0x0304(0x0004) (Net)
	int                                                r_nDeviceInstanceId;                                      // 0x0308(0x0004) (Net)
	int                                                r_nInstanceCount;                                         // 0x030C(0x0004) (Net)
	TEnumAsByte<ETG_EQUIP_POINT>                       r_eEquippedAt;                                            // 0x0310(0x0001) (Net)
	unsigned char                                      CurrentFireMode;                                          // 0x0311(0x0001) (Net)
	unsigned char                                      m_PendingFireMode;                                        // 0x0312(0x0001)
	TEnumAsByte<ETargetingModeStatus>                  c_eTargetingModeStatus;                                   // 0x0313(0x0001)
	unsigned char                                      m_nDesiredFireMode;                                       // 0x0314(0x0001)
	TEnumAsByte<EDeviceFailType>                       m_eCachedDeviceFailType;                                  // 0x0315(0x0001)
	TEnumAsByte<EBankCooldownReduction>                m_eShouldBankCooldownReduction;                           // 0x0316(0x0001)
	unsigned char                                      m_nSkillUIMatchFireMode;                                  // 0x0317(0x0001)
	TEnumAsByte<ECastMode>                             m_eCastModeOverride;                                      // 0x0318(0x0001)
	TEnumAsByte<EReticuleType>                         m_ReticuleType;                                           // 0x0319(0x0001)
	TEnumAsByte<EReticuleType>                         m_ZoomedReticuleType;                                     // 0x031A(0x0001)
	TEnumAsByte<EDeviceEmoteAt>                        m_DeviceEmoteAt;                                          // 0x031B(0x0001)
	TEnumAsByte<EDeviceTimerBarType>                   m_DeviceTimerBarType;                                     // 0x031C(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x031D(0x0003) MISSED OFFSET
	int                                                r_nPointsAllocated;                                       // 0x0320(0x0004) (Net)
	unsigned long                                      m_bSocketMaxCalculated : 1;                               // 0x0324(0x0004)
	unsigned long                                      r_bParentDeviceOwnedByOffhand : 1;                        // 0x0324(0x0004) (Net)
	unsigned long                                      bPendingFire : 1;                                         // 0x0324(0x0004)
	unsigned long                                      m_IsPendingSetFireMode : 1;                               // 0x0324(0x0004)
	unsigned long                                      m_bEquipEffectsApplied : 1;                               // 0x0324(0x0004)
	unsigned long                                      m_CachedMissedInstantFire : 1;                            // 0x0324(0x0004)
	unsigned long                                      c_bUsesTargetingReticle : 1;                              // 0x0324(0x0004)
	unsigned long                                      r_OverrideUsesTargetingModeAsFalse : 1;                   // 0x0324(0x0004) (Net)
	unsigned long                                      s_bIgnoreReceivedAim : 1;                                 // 0x0324(0x0004)
	unsigned long                                      m_bHandDevice : 1;                                        // 0x0324(0x0004)
	unsigned long                                      m_bProcAsIfHandDevice : 1;                                // 0x0324(0x0004)
	unsigned long                                      m_bLockInputDuringFire : 1;                               // 0x0324(0x0004)
	unsigned long                                      m_bLockCameraDuringFire : 1;                              // 0x0324(0x0004)
	unsigned long                                      m_bShouldCacheAim : 1;                                    // 0x0324(0x0004)
	unsigned long                                      r_bConsumedOnUse : 1;                                     // 0x0324(0x0004) (Net)
	unsigned long                                      r_bConsumedOnDeath : 1;                                   // 0x0324(0x0004) (Net)
	unsigned long                                      m_bCachedDeviceCanFire : 1;                               // 0x0324(0x0004)
	unsigned long                                      m_bCarryPreFireToPostFire : 1;                            // 0x0324(0x0004)
	unsigned long                                      m_bConsumePowerPoolOnStartFire : 1;                       // 0x0324(0x0004)
	unsigned long                                      m_bAlwaysStartCooldown : 1;                               // 0x0324(0x0004)
	unsigned long                                      m_bIgnoreCooldown : 1;                                    // 0x0324(0x0004)
	unsigned long                                      m_bInTargetingMode : 1;                                   // 0x0324(0x0004)
	unsigned long                                      m_bWasCancelled : 1;                                      // 0x0324(0x0004)
	unsigned long                                      m_IsBeingInterrupted : 1;                                 // 0x0324(0x0004)
	unsigned long                                      c_bServerFireFailed : 1;                                  // 0x0324(0x0004)
	unsigned long                                      HasAlreadyFiredOnce : 1;                                  // 0x0324(0x0004)
	unsigned long                                      m_bBuildupShouldInterruptStealth : 1;                     // 0x0324(0x0004)
	unsigned long                                      m_bPreFireShouldInterruptStealth : 1;                     // 0x0324(0x0004)
	unsigned long                                      m_bFireShouldInterruptStealth : 1;                        // 0x0324(0x0004)
	unsigned long                                      m_bPostFireShouldInterruptStealth : 1;                    // 0x0324(0x0004)
	unsigned long                                      m_bReloadingShouldInterruptStealth : 1;                   // 0x0324(0x0004)
	unsigned long                                      m_bCancelingShouldInterruptStealth : 1;                   // 0x0324(0x0004)
	unsigned long                                      m_bStartFireShouldEnterCombat : 1;                        // 0x0328(0x0004)
	unsigned long                                      m_bFireShouldEnterCombat : 1;                             // 0x0328(0x0004)
	unsigned long                                      m_bShouldUseInstigatorsTimeDilation : 1;                  // 0x0328(0x0004)
	unsigned long                                      m_bDamages : 1;                                           // 0x0328(0x0004)
	unsigned long                                      m_bStuns : 1;                                             // 0x0328(0x0004)
	unsigned long                                      m_bDoAutoReload : 1;                                      // 0x0328(0x0004)
	unsigned long                                      m_bReloadWhenNotEnoughAmmo : 1;                           // 0x0328(0x0004)
	unsigned long                                      m_bProjectileFollowOwnerYaw : 1;                          // 0x0328(0x0004)
	unsigned long                                      m_bAimThroughReticule : 1;                                // 0x0328(0x0004)
	unsigned long                                      m_bNoReticleBloom : 1;                                    // 0x0328(0x0004)
	unsigned long                                      m_bUseCustomCastMode : 1;                                 // 0x0328(0x0004)
	unsigned long                                      m_bCanRegenAmmoWhileFiring : 1;                           // 0x0328(0x0004)
	unsigned long                                      m_bOverrideFireModeRegenAmmoWhileFiring : 1;              // 0x0328(0x0004)
	unsigned long                                      m_bUseSimultaneousRegenForAmmoCharges : 1;                // 0x0328(0x0004)
	unsigned long                                      m_bUsesSimulatedAmmo : 1;                                 // 0x0328(0x0004)
	unsigned long                                      m_bCanReloadEarly : 1;                                    // 0x0328(0x0004)
	unsigned long                                      m_bSetFullAmmoOnReloadForAnim : 1;                        // 0x0328(0x0004)
	unsigned long                                      m_bForce1pViewWhileFiring : 1;                            // 0x0328(0x0004)
	unsigned long                                      m_bForce3PViewInBuildup : 1;                              // 0x0328(0x0004)
	unsigned long                                      m_bForce3PViewWhileFiring : 1;                            // 0x0328(0x0004)
	unsigned long                                      m_bEnterCombatOnFire : 1;                                 // 0x0328(0x0004)
	unsigned long                                      m_bDeployAtFeetOnFailure : 1;                             // 0x0328(0x0004) (Edit)
	unsigned long                                      m_bMustBeOnGroundToFire : 1;                              // 0x0328(0x0004)
	unsigned long                                      m_bHideTargeterWhenInvalid : 1;                           // 0x0328(0x0004)
	unsigned long                                      m_bParentAnimComponentHands : 1;                          // 0x0328(0x0004)
	unsigned long                                      m_bParentAnimComponent1PHead : 1;                         // 0x0328(0x0004)
	unsigned long                                      m_bAmmoWasGiven : 1;                                      // 0x0328(0x0004)
	unsigned long                                      m_bFirstAmmoWasGiven : 1;                                 // 0x0328(0x0004)
	unsigned long                                      m_bCooldownWasModified : 1;                               // 0x0328(0x0004)
	unsigned long                                      m_bDisableLagCompensation : 1;                            // 0x0328(0x0004)
	unsigned long                                      m_bUseSeparateVerticalFrictionKeyframes : 1;              // 0x0328(0x0004)
	unsigned long                                      m_bUseRangeFalloffCurve : 1;                              // 0x0328(0x0004)
	unsigned long                                      m_bUseDeviceMeshWhenTargeting : 1;                        // 0x032C(0x0004)
	unsigned long                                      m_bPlayPutAway : 1;                                       // 0x032C(0x0004)
	unsigned long                                      m_bCanToggleTargeting : 1;                                // 0x032C(0x0004)
	unsigned long                                      m_bDoNotAllowHeadShots : 1;                               // 0x032C(0x0004)
	unsigned long                                      m_bConsolidateMultipleShots : 1;                          // 0x032C(0x0004) (Const)
	unsigned long                                      m_bAllowFiringDuring3pTo1pTransition : 1;                 // 0x032C(0x0004)
	unsigned long                                      s_bLockFiringForRoundEnd : 1;                             // 0x032C(0x0004)
	unsigned long                                      m_bPreventInterrupt : 1;                                  // 0x032C(0x0004)
	unsigned long                                      m_bPreventCancel : 1;                                     // 0x032C(0x0004)
	unsigned long                                      m_bAllowFireDuringGrab : 1;                               // 0x032C(0x0004)
	unsigned long                                      m_bLogServerFireFailures : 1;                             // 0x032C(0x0004)
	unsigned long                                      m_bUsesOutroLockout : 1;                                  // 0x032C(0x0004)
	unsigned long                                      m_bIsFireHoldDevice : 1;                                  // 0x032C(0x0004)
	unsigned long                                      m_bForceReleaseFireHoldWhenCharged : 1;                   // 0x032C(0x0004)
	unsigned long                                      m_bFireHoldFull : 1;                                      // 0x032C(0x0004)
	unsigned long                                      m_bIs2TapFirehold : 1;                                    // 0x032C(0x0004)
	unsigned long                                      m_DeviceTimerBarCountsUp : 1;                             // 0x032C(0x0004)
	unsigned long                                      m_bCooldownAfterDeployDeath : 1;                          // 0x032C(0x0004)
	unsigned long                                      m_bLockingInput : 1;                                      // 0x032C(0x0004)
	unsigned long                                      m_bLockingRotation : 1;                                   // 0x032C(0x0004)
	unsigned long                                      m_bLockingCamera : 1;                                     // 0x032C(0x0004)
	unsigned long                                      m_bSkipGenerateNewSeed : 1;                               // 0x032C(0x0004)
	unsigned long                                      m_bNoAutoFirePostHitDelay : 1;                            // 0x032C(0x0004)
	unsigned long                                      m_bDevicesLinked : 1;                                     // 0x032C(0x0004)
	int                                                m_nSocketIndex;                                           // 0x0330(0x0004)
	int                                                m_nSocketMax;                                             // 0x0334(0x0004)
	class ATgDevice*                                   s_ParentDevice;                                           // 0x0338(0x0008)
	TArray<class UTgDeviceFire*>                       m_FireMode;                                               // 0x0340(0x0010) (NeedCtorLink)
	int                                                r_nMeleeComboSeed;                                        // 0x0350(0x0004) (Net)
	class UTgDeviceForm*                               c_DeviceForm;                                             // 0x0354(0x0008)
	class UTgTimerManager*                             m_CooldownTimers;                                         // 0x035C(0x0008)
	TArray<struct FImpactInfo>                         PendingImpactList;                                        // 0x0364(0x0010) (Component, NeedCtorLink)
	struct FAimData                                    c_TargetingAim;                                           // 0x0374(0x0034)
	struct FAimData                                    m_CachedAim;                                              // 0x03A8(0x0034)
	float                                              m_fCachedFirePostHitDelay;                                // 0x03DC(0x0004)
	int                                                m_CachedFireRequestId;                                    // 0x03E0(0x0004)
	float                                              m_fCachedAttackSpeedPercChange;                           // 0x03E4(0x0004)
	struct FAimData                                    s_ReceivedAim;                                            // 0x03E8(0x0034)
	struct FPointer                                    m_pwzDeviceName;                                          // 0x041C(0x0008) (Native)
	int                                                m_nDeviceType;                                            // 0x0424(0x0004)
	float                                              EquipTime;                                                // 0x0428(0x0004)
	class UTgInventoryObject_Device*                   s_InventoryObject;                                        // 0x042C(0x0008)
	int                                                m_nSkillId;                                               // 0x0434(0x0004)
	int                                                r_nInventoryId;                                           // 0x0438(0x0004) (Net)
	float                                              m_fLastDeviceCanFireTimeStamp;                            // 0x043C(0x0004)
	float                                              m_EndOfLastFireTimeStamp;                                 // 0x0440(0x0004)
	float                                              m_fFiringTimer;                                           // 0x0444(0x0004)
	float                                              m_fTimeAccountedFor;                                      // 0x0448(0x0004)
	float                                              m_fTimeStampAccountedFor;                                 // 0x044C(0x0004)
	float                                              m_IndividualOffhandCooldownTime;                          // 0x0450(0x0004)
	float                                              m_fTotalReloadTime;                                       // 0x0454(0x0004)
	float                                              m_fBankedCooldownReduction;                               // 0x0458(0x0004)
	float                                              c_fCachedManaAtStartFire;                                 // 0x045C(0x0004)
	class UTgDeviceFire*                               m_WhileFiringDeviceMode;                                  // 0x0460(0x0008)
	float                                              m_fUnequipTime;                                           // 0x0468(0x0004)
	struct FVector                                     m_vMeshViewOffset;                                        // 0x046C(0x000C)
	float                                              m_fWeaponBob;                                             // 0x0478(0x0004)
	float                                              m_fMeshFOV;                                               // 0x047C(0x0004)
	struct FVector                                     m_vProjectileSpawnOffset;                                 // 0x0480(0x000C) (Edit)
	class UTgDeviceMod_Burst*                          m_BurstMod;                                               // 0x048C(0x0008) (ExportObject, NeedCtorLink, EditInline)
	class UTgDeviceMod_CooldownOverride*               m_CooldownMod;                                            // 0x0494(0x0008) (ExportObject, NeedCtorLink, EditInline)
	class UTgDeviceMod_TargetingAimForwarder*          m_AimForwarderMod;                                        // 0x049C(0x0008) (ExportObject, NeedCtorLink, EditInline)
	int                                                m_nFireLoopInstanceId;                                    // 0x04A4(0x0004)
	int                                                r_nAmmoClipCount;                                         // 0x04A8(0x0004) (Net)
	int                                                c_nSimLocalAmmoClipCount;                                 // 0x04AC(0x0004)
	TArray<struct FAmmoTransaction>                    m_AmmoTransactions;                                       // 0x04B0(0x0010) (NeedCtorLink)
	TArray<struct FAmmoTransaction>                    m_DelayedAmmoTransactions;                                // 0x04C0(0x0010) (NeedCtorLink)
	TArray<struct FAmmoTransaction>                    s_RecievedUnverifiedDelayedAmmoTransactions;              // 0x04D0(0x0010) (NeedCtorLink)
	TArray<struct FAmmoTransaction>                    m_DelayedAmmoTransactionRegen;                            // 0x04E0(0x0010) (NeedCtorLink)
	int                                                m_nPendingRegenAmmoTransactionID;                         // 0x04F0(0x0004)
	int                                                m_nPendingReloadAmmoTransactionID;                        // 0x04F4(0x0004)
	struct FTrackedFiringAmmoConsumption               c_EligableRefundFiringIDs[0x1E];                          // 0x04F8(0x0008)
	int                                                c_nEligableRefundFiringIDsIndexLast;                      // 0x05E8(0x0004)
	int                                                c_nEligableRefundFiringIDsIndexFirst;                     // 0x05EC(0x0004)
	int                                                m_nLastFiringIDToConsumeAmmo;                             // 0x05F0(0x0004)
	int                                                r_nMaxAmmoClipCount;                                      // 0x05F4(0x0004) (Net)
	int                                                m_UniqueAmmoValidationId;                                 // 0x05F8(0x0004)
	float                                              m_fAmmoRegenPerSec;                                       // 0x05FC(0x0004)
	float                                              m_fAmmoRegenCounter;                                      // 0x0600(0x0004)
	TArray<float>                                      m_AmmoChargeFireTimes;                                    // 0x0604(0x0010) (NeedCtorLink)
	TArray<class ATgProjectile*>                       m_FiredProjectiles;                                       // 0x0614(0x0010) (NeedCtorLink)
	float                                              m_fForce3PPersistDuration;                                // 0x0624(0x0004)
	float                                              m_fForce3PPersistTimer;                                   // 0x0628(0x0004)
	float                                              m_fEnterCombatDuration;                                   // 0x062C(0x0004)
	class ATgDeployable*                               r_Deployable;                                             // 0x0630(0x0008) (Net)
	int                                                r_nProjectiles;                                           // 0x0638(0x0004) (Net)
	float                                              m_fDeployZForgiveness;                                    // 0x063C(0x0004) (Edit)
	float                                              m_fBottomlessPitCheck;                                    // 0x0640(0x0004)
	float                                              m_fDeployZOffset;                                         // 0x0644(0x0004) (Edit)
	TArray<int>                                        m_Abilities;                                              // 0x0648(0x0010) (NeedCtorLink)
	int                                                m_DisplayIcon;                                            // 0x0658(0x0004)
	struct FString                                     m_DisplayName;                                            // 0x065C(0x0010) (NeedCtorLink)
	float                                              m_fOnGroundAltitudeThreshold;                             // 0x066C(0x0004)
	class ATgDevice*                                   m_PrimaryWeaponParent;                                    // 0x0670(0x0008)
	class UClass*                                      m_WeaponMeshActorClass;                                   // 0x0678(0x0008) (Edit)
	class AActor*                                      m_LastKnownHitActor;                                      // 0x0680(0x0008)
	TArray<struct FScriptDelegate>                     m_OnFiredDelegates;                                       // 0x0688(0x0010) (NeedCtorLink)
	TArray<struct FScriptDelegate>                     m_OnReloadDelegates;                                      // 0x0698(0x0010) (NeedCtorLink)
	TArray<struct FScriptDelegate>                     m_OnStartFireDelegates;                                   // 0x06A8(0x0010) (NeedCtorLink)
	TArray<struct FScriptDelegate>                     m_OnStopFireDelegates;                                    // 0x06B8(0x0010) (NeedCtorLink)
	TArray<struct FScriptDelegate>                     m_OnCooldownEndDelegates;                                 // 0x06C8(0x0010) (NeedCtorLink)
	TArray<struct FScriptDelegate>                     m_Generic1Delegates;                                      // 0x06D8(0x0010) (NeedCtorLink)
	TArray<struct FScriptDelegate>                     m_Generic2Delegates;                                      // 0x06E8(0x0010) (NeedCtorLink)
	TArray<struct FScriptDelegate>                     m_Generic3Delegates;                                      // 0x06F8(0x0010) (NeedCtorLink)
	TArray<int>                                        m_nLinkedDeviceIDs;                                       // 0x0708(0x0010) (NeedCtorLink)
	TArray<int>                                        m_nLinkedDeviceTypes;                                     // 0x0718(0x0010) (NeedCtorLink)
	TArray<struct FTgQueuedSimulatedProjectileSpawn>   c_QueuedSimulatedProjectileSpawns;                        // 0x0728(0x0010) (NeedCtorLink)
	TArray<struct FTgQueuedSimulatedProjectileSpawn>   s_QueuedProjectileSpawnsFromServer;                       // 0x0738(0x0010) (NeedCtorLink)
	TArray<struct FTgQueuedSimulatedProjectileSpawn>   s_QueuedProjectileSpawnsFromClient;                       // 0x0748(0x0010) (NeedCtorLink)
	TArray<struct FTgQueuedProjectileExplosion>        s_QueuedProjectileExplosions;                             // 0x0758(0x0010) (NeedCtorLink)
	int                                                s_nNumServerRefires;                                      // 0x0768(0x0004)
	int                                                s_nNumClientRefires;                                      // 0x076C(0x0004)
	TArray<struct FTgQueuedRefire>                     s_QueuedRefireRequests;                                   // 0x0770(0x0010) (NeedCtorLink)
	TArray<struct FTgQueuedInstantFireShot>            s_QueuedInstantFireShotsFromServer;                       // 0x0780(0x0010) (Component, NeedCtorLink)
	TArray<struct FTgQueuedInstantFireShot>            s_QueuedInstantFireShotsFromClient;                       // 0x0790(0x0010) (Component, NeedCtorLink)
	struct FPointer                                    m_RandomShotSpreadStream;                                 // 0x07A0(0x0008) (Const, Native, Transient)
	int                                                m_nLastSetShotSpreadSeed;                                 // 0x07A8(0x0004)
	struct FVector2D                                   m_AimAssistMagnetScale;                                   // 0x07AC(0x0008)
	struct FVector2D                                   m_AimAssistFrictionScale;                                 // 0x07B4(0x0008)
	struct FVector2D                                   m_AimAssistTrackingScale;                                 // 0x07BC(0x0008)
	float                                              m_fBulletMagnetismStrengthMultiplier;                     // 0x07C4(0x0004)
	TArray<struct FAimAssistKeyframeData>              m_AimAssistKeyframesMagnetVert;                           // 0x07C8(0x0010) (NeedCtorLink)
	TArray<struct FAimAssistKeyframeData>              m_AimAssistKeyframesMagnetHoriz;                          // 0x07D8(0x0010) (NeedCtorLink)
	TArray<struct FAimAssistKeyframeData>              m_AimAssistKeyframesFriction;                             // 0x07E8(0x0010) (NeedCtorLink)
	TArray<struct FAimAssistKeyframeData>              m_AimAssistKeyframesTrackingAccHoriz;                     // 0x07F8(0x0010) (NeedCtorLink)
	TArray<struct FAimAssistKeyframeData>              m_AimAssistKeyframesTrackingAngleHoriz;                   // 0x0808(0x0010) (NeedCtorLink)
	TArray<struct FAimAssistKeyframeData>              m_AimAssistKeyframesTrackingAccVert;                      // 0x0818(0x0010) (NeedCtorLink)
	TArray<struct FAimAssistKeyframeData>              m_AimAssistKeyframesTrackingAngleVert;                    // 0x0828(0x0010) (NeedCtorLink)
	TArray<struct FAimAssistKeyframeData>              m_AimAssistKeyframesFrictionVert;                         // 0x0838(0x0010) (NeedCtorLink)
	TArray<class ATgDevice*>                           m_GameplayCurveOverrideDevices;                           // 0x0848(0x0010) (NeedCtorLink)
	int                                                m_nServerControlledShotSpreadSeed;                        // 0x0858(0x0004)
	float                                              m_fOutroLockoutTime;                                      // 0x085C(0x0004)
	float                                              m_fMinTimeBetweenAmmoCharges;                             // 0x0860(0x0004) (Edit)
	class UForceFeedbackWaveform*                      m_ForceFeedbackStartHold;                                 // 0x0864(0x0008) (Edit)
	class UForceFeedbackWaveform*                      m_ForceFeedbackFullHold;                                  // 0x086C(0x0008) (Edit)
	class UForceFeedbackWaveform*                      m_ForceFeedbackStopHold;                                  // 0x0874(0x0008) (Edit)
	class UForceFeedbackWaveform*                      m_ForceFeedbackStartFire;                                 // 0x087C(0x0008) (Edit)
	class UForceFeedbackWaveform*                      m_ForceFeedbackStopFire;                                  // 0x0884(0x0008) (Edit)
	class UForceFeedbackWaveform*                      m_ForceFeedbackStartBuildup;                              // 0x088C(0x0008) (Edit)
	class UForceFeedbackWaveform*                      m_ForceFeedbackStopBuildup;                               // 0x0894(0x0008) (Edit)
	class UForceFeedbackWaveform*                      m_ForceFeedbackPostFire;                                  // 0x089C(0x0008) (Edit)
	class UForceFeedbackWaveform*                      m_ForceFeedbackStartReload;                               // 0x08A4(0x0008) (Edit)
	class UForceFeedbackWaveform*                      m_ForceFeedbackStopReload;                                // 0x08AC(0x0008) (Edit)
	class UForceFeedbackWaveform*                      m_ForceFeedbackStartCooldown;                             // 0x08B4(0x0008) (Edit)
	float                                              s_fForceReleaseFirHoldFUBARTime;                          // 0x08BC(0x0004)
	int                                                s_nLastRequestedFireHoldReleaseID;                        // 0x08C0(0x0004)
	float                                              m_f2TapInputTimer;                                        // 0x08C4(0x0004)
	struct FAccuracySettings                           m_AccuracySettings[0x5];                                  // 0x08C8(0x001C) (Edit)
	float                                              m_fCurrentAdvancedAccuracy;                               // 0x0954(0x0004)
	float                                              m_fLastShotTimestamp;                                     // 0x0958(0x0004)
	int                                                m_nFreeShotsLeft;                                         // 0x095C(0x0004)
	float                                              m_fLastMinAccuracy;                                       // 0x0960(0x0004)
	float                                              m_fReticleBloomScale;                                     // 0x0964(0x0004)
	struct FRecoilSettings                             m_RecoilSettings[0x5];                                    // 0x0968(0x0010) (Edit)
	int                                                r_nRecoilMultiCenti;                                      // 0x09B8(0x0004) (Edit, Net)
	float                                              m_fStartFiringTimestamp;                                  // 0x09BC(0x0004)
	float                                              m_fEndFiringTimeStamp;                                    // 0x09C0(0x0004)
	float                                              m_fAccumulatedFiringTime;                                 // 0x09C4(0x0004)
	int                                                m_nRandRecoilNum;                                         // 0x09C8(0x0004) (Transient)
	int                                                r_nRecoilSeed;                                            // 0x09CC(0x0004) (Net, Transient)
	int                                                m_nAimAssistPriorityWhileFiring;                          // 0x09D0(0x0004)
	int                                                r_nAllowUseWhileFlags;                                    // 0x09D4(0x0004) (Net)
	float                                              r_fAttackSpeedPercChange;                                 // 0x09D8(0x0004) (Net)
	float                                              m_fSimulatedAttackSpeedPercChange;                        // 0x09DC(0x0004)
	float                                              s_fAttackSpeedPercChangeLeniency;                         // 0x09E0(0x0004)
	TArray<struct FAttackSpeedModifier>                m_AttackSpeedModifiers;                                   // 0x09E4(0x0010) (NeedCtorLink)
	int                                                r_nDeviceLevel;                                           // 0x09F4(0x0004) (Net)
	float                                              m_fInstantHitValidationTolerance;                         // 0x09F8(0x0004)
	struct FScriptDelegate                             __DeviceEvent__Delegate;                                  // 0x09FC(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData01[0x4];                                       // 0x09FC(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice");
		return ptr;
	}


	bool HandleCustomPlayerKnockbackHit(class AActor* TargetPrimary, const struct FImpactInfo& ImpactPrimary, class AActor* TargetSecondary, const struct FImpactInfo& ImpactSecondary);
	bool HandleCustomWallKnockbackHit(class AActor* Target, const struct FImpactInfo& Impact);
	bool HandleCustomWallGrabbedHit(class AActor* Target, const struct FImpactInfo& Impact, class AActor* HitActor);
	void ServerNotifyDesiredTarget(class AActor* DesiredTarget);
	float STATIC_GetAttackSpeedMod();
	void UpdateAttackSpeedMod(int nSourceId, float fPercChange, bool bFromServer, bool bAddPercChange, float fDuration);
	void AddAttackSpeedMod(float fPercChange, float fDuration, bool bFromServer, int nSourceId);
	float GetCustomTimerBarMaxTime();
	float GetCustomTimerBarCurrentTime();
	void ApplyAllowUseWhileFlags(int nAllowUseWhileFlags);
	void UnregisterAsGameplayCurveOverrideDevice(class ATgDevice* Dev);
	void RegisterAsGameplayCurveOverrideDevice(class ATgDevice* Dev);
	void STATIC_UpdateOutroLockoutTime();
	void PlayNextSimulatedForceFeedbackWaveform(class UForceFeedbackWaveform* Prev, class UForceFeedbackWaveform* Next, float fScaleMagnitude, float fScaleDuration, bool bFromPawnPosition);
	void OnOwnerRespawn();
	void OnOwnerLiveRespawn();
	bool ReleaseHoldOnRightMouseReleased();
	bool CanToggleTargetingOff();
	void ClientSetAimAssistValues(float MagnetScaleX, float MagnetScaleY, float FrictionScaleX, float FrictionScaleY, float TrackingScaleX, float TrackingScaleY);
	void DesyncAmmoTransactionID(int Amt);
	bool ShouldStopActionOnOffhandSlotReleased();
	void OnCanceledClient();
	void OnCanceled();
	void OnKnock();
	void OnCripple();
	void ClientDeviceFirePropertyChange(int nMode, int nPropertyId, float fNewValue);
	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
	void NotifyDeviceEvent(TEnumAsByte<ENotifyDelegateEvents> ndeType);
	bool STATIC_UnregisterDelegate(TEnumAsByte<ENotifyDelegateEvents> ndeType, const struct FScriptDelegate& DeviceEventDelegate);
	bool RegisterDelegate(TEnumAsByte<ENotifyDelegateEvents> ndeType, const struct FScriptDelegate& DeviceEventDelegate);
	bool ShouldMountCancelFiring();
	struct FVector GetProjectileSpawnOffset();
	float GetRefireRate();
	float GetRefirePercent();
	void OnDeployableSpawned(class ATgDeployable* deployable);
	void OnDeployableDestroyed(class ATgDeployable* deployable);
	void ClientInterruptReload(bool bAllowAmmoFill);
	void InterruptReload();
	void PostReloadTimer();
	void PreReloadTimer();
	void STATIC_FullReloadTimer();
	void STATIC_PrepReload();
	bool StartReload(bool bIgnoreCurrentAmmo);
	void ClientForceReload();
	void ServerStartReload();
	void FlashUpdateAmmoOnPawn();
	void ResetAmmoTransactions();
	void ServerSyncAmmoTransactionID(int nNewID);
	void ReloadAmmoWithSynchronization();
	void ReloadAmmo(bool bToFull, bool bShouldValidate);
	void ClientSyncAmmoGivenFromServer(int Amount);
	void GiveAmmoWithClientSync(int Amount);
	void GiveAmmo(int Amount, bool bShouldValidate);
	void ConsumeAmmo(int Amount, bool bShouldValidate);
	void STATIC_UpdateLocalAmmoCount(int nNewAmmoAmt);
	void SetAmmo(int AmmoCount, int ClipSize, bool bShouldValidate, int ValidationIDOverride);
	bool UpdateDelayedAmmoTransactionRegen(int nTransactionID, int nAmmoCountAdded);
	int GiveAmmoDelayedWithValidationRegen(int nAmmoCountAdded);
	void ClientValidateDelayedRegenAmmoResponse(int nTransactionID, int nAmmoChanged);
	void ServerValidateDelayedRegenAmmoTransaction(int nTransactionID, int nAmmoChanged, bool bInitiateNewTransactionForRegen);
	bool ValidateDelayedAmmoTransactionRegen(int nTransactionID, bool bInitiateNewTransactionForRegen);
	bool SendImmediateSetAmmoDelayed(int nTransactionID);
	bool CancelSetAmmoDelayed(int nTransactionID);
	int SetAmmoDelayedWithValidation(int AmmoCount, float DelayAmt);
	void ClientValidateAmmoResponse(int nTransactionID, int nAmmoChanged, bool bFubar);
	void STATIC_LogWarnDelayedAmmoTransactionOnClient(int nTransactionID, int nAmmoAmountChanged, float fTimeDelayed, bool bLateServer, int nServerCurrentTransactionID);
	void ServerValidateAmmoTransaction(int nTransactionID, int nAmmoChanged);
	void STATIC_VerifyAmmoTransaction(int nTransactionID, int nAmmoChanged, bool bFilledClip);
	bool UsesSimulatedAmmo();
	void STATIC_Activate();
	bool AllowSwitchTo(class AWeapon* NewWeapon);
	void CancelUnequip();
	void STATIC_UnequipWeapon();
	bool STATIC_TryPutDown();
	bool STATIC_IsUnEquipping();
	void StopFiringLogic();
	void ClientReconnected();
	void AdjustForNewDilation(float fPrevDilation, float fNewDilation);
	bool IsFunctionallyToggleDevice();
	bool ApplyGlobalOffhandCooldown();
	void Destroyed();
	void STATIC_UpdateIndex();
	void STATIC_HandleDeviceFormStartFire(int nDeviceModeNum, float fRefireTime, struct FAimData* Aim);
	bool ShouldRefire(class UTgDeviceFire* FireMode, struct FAimData* Aim);
	void OutroLockoutTime();
	void DeviceBuildupTimer();
	void HandDeviceLockout();
	void FirePostHitDelay();
	void FirePreHitDelay();
	void RefireCheckTimer();
	void OnServerQueuedRefire();
	void STATIC_LockRotation(bool bShouldLock);
	void STATIC_LockCamera(bool bShouldLock);
	void LockInput(bool bShouldLock);
	void OnProjectileShutdown(class ATgProjectile* Proj);
	void OnTeleportNotify(class AActor* TeleportingActor);
	void ClientSetDesiredFireMode(int nDesiredFireMode);
	void SetDesiredFiremode(int nDesiredFireMode);
	void ChangeFireModeOnRefire();
	void STATIC_UpdateDesiredFireMode();
	void NotifySwitchMode();
	void NotifyPutAway();
	void ClientEndCooldown();
	void ClientResetCooldown(int nMode, float fCooldownTime);
	void ClientStartCooldown(int nMode, float fCooldownTime);
	void EndCooldown();
	float GetCooldownTime(int nMode);
	void ResetCooldown(int nMode, float fCooldownTimeOverride);
	void AuthStartCooldown(int nMode, float fCooldownTimeOverride);
	void StartCooldown(int nMode, float fCooldownTimeOverride);
	void ClientCooldownTimerExpired(int nTimerId, TEnumAsByte<ETGT_EVENT> eEvent);
	void CooldownTimerExpired(int nTimerId, TEnumAsByte<ETGT_EVENT> eEvent, bool bNoBecomeActive);
	float GetCooldownRemaining();
	float STATIC_GetAltFireDetonateDamagePct();
	bool AltFireDetonate();
	void STATIC_UpdateActiveProjectiles(class ATgProjectile* Proj);
	float STATIC_GetMinAccuracy();
	void TriggerAccuracyOnFire();
	void STATIC_FireAmmunition();
	void STATIC_PerProjectileFired(class ATgProjectile* Proj);
	void ConsumeAmmoFromFiring(int nAmmoConsumptionOverride, int nFireRequestIDOverride);
	bool ShouldConsumeAmmo(int nFireRequestId, TArray<struct FImpactToValidate> Impacts);
	int STATIC_GetAmmoToConsume();
	void TrackDeviceModeFired(class ATgPawn* PawnFiring);
	class AActor* STATIC_GetTrackingTarget();
	struct FVector STATIC_GetPhysicalFireStartLoc(const struct FVector& AimDir);
	int STATIC_GetProjectileIDOverride(int ProjectileIndex);
	class AProjectile* ProjectileFire(int ProjectileIndex);
	bool STATIC_OverrideProjectileAim(struct FAimData* Aim);
	void ServerProjectileFire(float MovementTimeStamp, const struct FVector& MovementInAccel, const struct FVector& MovementClientLoc, unsigned char MovementNewFlags, unsigned char MovementClientRoll, int MovementView, int ClientFireRequestId, int ProjectileIndex, float ProjectileLocationX, float ProjectileLocationY, float ProjectileLocationZ, float ProjectileAimVectorX, float ProjectileAimVectorY, float ProjectileAimVectorZ, float ProjectileEndTraceX, float ProjectileEndTraceY, float ProjectileEndTraceZ, unsigned char ExtraInfo);
	void AdjustSpawnedProjectile(class ATgProjectile* SpawnedProjectile);
	class ATgProj_NonSimulated* STATIC_SpawnServerOnlyProjectile(class UTgDeviceFire* FireMode, const struct FVector& ProjectileSpawnLocation, const struct FVector& ProjectileSpawnDir, int ProjectileIdOverride);
	class ATgProj_Simulated* SpawnSimulatedProjectile(bool bCanSpawnOnClientFirst, int FireRequestId, int ProjectileInstanceId, class UTgDeviceFire* FireMode, const struct FVector& ProjectileSpawnLocation, const struct FVector& ProjectileSpawnDir, int ProjectileIndex, int ProjectileIdOverride, float Range, class AActor* trackingTarget, const struct FVector& EndTrace, unsigned char ExtraInfo);
	void SpawnQueuedSimulatedProjectile();
	class UTgDeviceFire* STATIC_GetFireModeForFiringProjectile();
	void CustomFire();
	void AOEArcingFlash(TArray<struct FImpactInfo> ImpactList, const struct FVector& StartLocation);
	void ServerInstantFireSingleImpact(float MovementTimeStamp, const struct FVector& MovementInAccel, const struct FVector& MovementClientLoc, unsigned char MovementNewFlags, unsigned char MovementClientRoll, int MovementView, int ClientFireRequestId, float StartTraceX, float StartTraceY, float StartTraceZ, float EndTraceX, float EndTraceY, float EndTraceZ, const struct FImpactToValidate& Impact);
	void ServerInstantFireThreeImpacts(float MovementTimeStamp, const struct FVector& MovementInAccel, const struct FVector& MovementClientLoc, unsigned char MovementNewFlags, unsigned char MovementClientRoll, int MovementView, int ClientFireRequestId, float StartTraceX, float StartTraceY, float StartTraceZ, float EndTraceX, float EndTraceY, float EndTraceZ, const struct FImpactToValidate& Impact, int NumImpacts, const struct FImpactToValidate& InImpactList);
	void ServerInstantFire(float MovementTimeStamp, const struct FVector& MovementInAccel, const struct FVector& MovementClientLoc, unsigned char MovementNewFlags, unsigned char MovementClientRoll, int MovementView, int ClientFireRequestId, float StartTraceX, float StartTraceY, float StartTraceZ, float EndTraceX, float EndTraceY, float EndTraceZ, const struct FImpactToValidate& Impact, int NumImpacts, const struct FImpactToValidate& InImpactList);
	void STATIC_HandleClientReportedInstantShot(int nFireRequestId, const struct FAimData& InServerAim, const struct FAimData& InClientAim, const struct FImpactToValidate& InPrimaryImpact, TArray<struct FImpactToValidate> InClientImpacts);
	void OnInstantShotRejected(const struct FImpactToValidate& RejectedPrimaryImpact);
	void OnInstantShotVerified(const struct FImpactInfo& VerifiedPrimaryImpact);
	void SendImpactsForVerification(struct FAimData* baseaim, struct FImpactInfo* Impact, TArray<unsigned char>* nShotsToImpactIndex);
	void SetImpactExtraInfo(struct FImpactToValidate* Impact);
	void PerformOnInstantFireServerValidation(float AccuracyValue, float AccuracyRandomValue1, float AccuracyRandomValue2, struct FAimData* Aim);
	void STATIC_HandleInstantFireWithConsolidation(bool bSendForServerValidation, struct FAimData* baseaim, struct FAimData* Aim, struct FImpactInfo* Impact);
	void InstantFire();
	void RemoveHitFromTarget(class ATgPawn_Character* Target, int nHitSpecialSituationalType);
	void ApplyHitToTarget(class ATgPawn_Character* Target, int nHitSpecialSituationalType, const struct FVector& vHitLocation, const struct FVector& vHitNormal);
	void DeliverHit(const struct FImpactInfo& Impact);
	void DeliverQueuedPendingHits();
	struct FImpactInfo CalcWeaponFire(const struct FAimData& Aim, TArray<struct FImpactInfo>* ImpactList);
	void ServerForceStopFire();
	void ForceStopFire();
	void STATIC_ServerStopFire();
	void ServerStopFireAsEvent();
	void StopFireAsEvent();
	void StopFire();
	bool CanToggleDeviceStopFiring();
	void StartFiringOnServer(float MovementTimeStamp, const struct FVector& MovementInAccel, const struct FVector& MovementClientLoc, unsigned char MovementNewFlags, unsigned char MovementClientRoll, int MovementView, int ClientFireRequestId, unsigned char ClientFireMode, class AActor* HitActor, float StartTraceX, float StartTraceY, float StartTraceZ, float EndTraceX, float EndTraceY, float EndTraceZ, int nCompressedAimVector, bool bFirstBurstShot, float fAttackSpeedPercChange);
	void ServerStartFire(float MovementTimeStamp, const struct FVector& MovementInAccel, const struct FVector& MovementClientLoc, unsigned char MovementNewFlags, unsigned char MovementClientRoll, int MovementView, int ClientFireRequestId, unsigned char ClientFireMode, class AActor* HitActor, float StartTraceX, float StartTraceY, float StartTraceZ, float EndTraceX, float EndTraceY, float EndTraceZ, int nCompressedAimVector, bool bFirstBurstShot, float fAttackSpeedPercChange);
	void ServerRestartFireLoop(float MovementTimeStamp, const struct FVector& MovementInAccel, const struct FVector& MovementClientLoc, unsigned char MovementNewFlags, unsigned char MovementClientRoll, int MovementView, int ClientFireRequestId, unsigned char ClientFireMode, class AActor* HitActor, float StartTraceX, float StartTraceY, float StartTraceZ, float EndTraceX, float EndTraceY, float EndTraceZ, int nCompressedAimVector, bool bFirstBurstShot, float fAttackSpeedPercChange);
	void CallServerRestartFireLoop(const struct FAimData& Aim);
	void RestartFireLoop(bool bRefire);
	void CallServerStartFire(const struct FAimData& Aim, bool bPendingUpdate);
	float STATIC_GetLastMoveTimeStamp(struct FVector* LastSentMoveAcceleration, int* LastSentMoveCompressedFlags, struct FVector* LastSentClientLoc, unsigned char* LastSentClientRoll, int* LastSentView);
	void ServerAckProjectileSpawn(int ClientFireRequestId);
	void STATIC_HandleQueuedProjectileExplosion(class ATgProj_Simulated* SimulatedProjectile, float ProjectileAliveTime, class AActor* Other, float MovementTimeStamp, float AoeRewindTimeStamp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void ServerQueueProjectileExplode(int ClientFireRequestId, float ProjectileAliveTime, class AActor* Other, float MovementTimeStamp, float HitLocationX, float HitLocationY, float HitLocationZ, float HitNormalX, float HitNormalY, float HitNormalZ);
	void ServerStartFireAsEvent();
	void STATIC_FireLockComplete();
	void STATIC_GlobalOffhandCooldownCompleteClient();
	void STATIC_GlobalOffhandCooldownCompleteServer();
	void SetFireLock();
	void OnStartFireRequestSent();
	void HandleFalseFireRecory();
	bool StartFire();
	float GetRemainingFiringTime();
	bool ShouldSwitchBackToBasicAttackTargeting(TEnumAsByte<ECastMode> CastMode);
	bool ShouldConsumePowerPoolAfterFire();
	bool ShouldConsumePowerPoolOnStartFire();
	bool ShouldCooldownAfterFire();
	bool CanEnterCombat();
	bool ShouldInterruptReloadOnBeginTargeting();
	bool ShouldInterruptReloadOnFire();
	bool DeviceSpawnsClientProjectilesFirst();
	bool SimulateStartFire();
	void ClientSimulateStartFireFromServer();
	void ReleaseFireHoldInternal();
	void ServerReleaseFireHold(float fClientFireHoldPercent, int nClientFireRequestId);
	void ReleaseFireHold();
	void SetFireHoldAmt(float fFireHoldTime);
	void STATIC_InterruptFireHold();
	void STATIC_FireHoldForceReleaseFUBAR();
	void STATIC_FireHoldValidationTimer();
	void FireHoldTimer();
	bool StartFireHold();
	bool Use();
	bool CanDeviceStartFiringNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDebugRelevant, bool bIgnoreCachedValue, TEnumAsByte<EDeviceFailType>* failType);
	void CacheDeviceCanFire(bool bDeviceCanFire, TEnumAsByte<EDeviceFailType> failType);
	bool CanFireWithoutAimResult();
	bool CanFireWhileHanging();
	void ConsumeDevice();
	bool STATIC_UsesEnergy();
	bool STATIC_UsesMana();
	bool STATIC_UsesHealth();
	void PlayClientFireFx(const struct FVector& HitLocation, int nSocketIndex, bool bSuccessfulHit, float fRefireTime, int nShotsFired);
	bool STATIC_ShouldPlayFireFx();
	void ServerFlashEnterTargetingMode(bool bEnterTargeting);
	bool ShouldCancelStealth();
	void OnInterruptEvent();
	void ClientRemoveSpawnedProjectile(int nFiringID);
	void ClientInterrupt(bool bServerFireFailed);
	void ClientRefundAmmo(int nRefundAmount, int nFireRequestId);
	void ClientInitiatedInterrupt();
	void AsynchronusInterrupt();
	void STATIC_InterruptFiringOnServerInternal(bool bSendClientInterrupt, bool bServerFireFailed);
	void InterruptFiringServerOnly();
	void InterruptFiring(bool bServerFireFailed);
	void ServerNotifyClientAckLockout();
	void StopFiringServerDeviceLockout();
	void DeviceRestart(bool bPostRevive);
	void DeviceShutDown(bool bDeactiveMode, bool bResetCooldowns);
	void ServerDoRemoteDetonation(int nFireMode);
	void SetActiveState();
	void STATIC_GetAdjustedAim(float AccuracyValueOverride, float RandomValueOverride1, float RandomValueOverride2, int nMultifireIndex, struct FAimData* Aim, float* UsedAccuracyValue, float* UsedRandomValue1, float* UsedRandomValue2);
	bool CanFireIfLeftMouseDown();
	void STATIC_InterruptOtherDevices(class ATgPawn* TgP);
	void PostBeginPlay();
	float STATIC_GetRecoilMultiplier();
	class UTgGameplayCurvesSet_RecoilSimple* STATIC_GetRecoilCurve();
	void AddRecoil();
	void STATIC_GenerateRecoilSeed();
	bool ShouldInterruptEmote();
	bool ShouldInterruptMount();
	bool ShouldInterruptInhand();
	bool CanBeInterrupted();
	bool ShouldLockJumping();
	bool CanBeFiredWhileGrabbed();
	bool CanBeFiredWhileTweening();
	bool CanFiringBeCanceledByReactivation();
	bool STATIC_DoReactivationCancelLogic(unsigned char* bSuccessfulCancel);
	bool CanFiringBeCanceledByRightMouse();
	bool CanFiringBeCanceledByLeftMouse();
	bool CanBeCanceled();
	bool STATIC_InterceptSlotReleased(class ATgPlayerController* TgController);
	bool STATIC_InterceptSlotPressed(class ATgPlayerController* TgController);
	void STATIC_Handle2TapFireholdInput();
	void STATIC_TapTimer();
	bool STATIC_InterceptRightMouseReleased(class ATgPlayerController* TgController);
	bool STATIC_InterceptRightMousePressed(class ATgPlayerController* TgController);
	bool STATIC_InterceptLeftMouseReleased(class ATgPlayerController* TgController);
	bool STATIC_InterceptLeftMousePressed(class ATgPlayerController* TgController);
	float GetRange();
	bool IsEquipping();
	bool CanFiringBeLocked();
	bool STATIC_CanFireWhileMovementDisabled();
	bool CanFireWhileMounted();
	bool MustBeOnGroundToFire();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	bool STATIC_IsDeviceFiringLockedForUI();
	bool STATIC_IsDeviceFiringForUI();
	bool STATIC_NativeIsFiring();
	bool CanSpawnOnClientFirst(class UClass* ProjectileClass, bool bUsesTrackingTarget);
	void ForceCooldownIfFiring();
	void STATIC_DisplayMessage(const struct FString& sMessage);
	void DisplayDebug(class AHUD* HUD, float* out_YL, float* out_YPos);
	void STATIC_WeaponLog(const struct FString& msg, const struct FString& FuncStr);
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_GetExplosionFXParams(float EffectiveRadius, float DamageRadius, class AActor* pOwner, TEnumAsByte<ETG_EQUIP_POINT> eEquipSlot, TArray<struct FParticleSysParam>* Params);
	void STATIC_UpdateAttackSpeedModifiers();
	int STATIC_GetCurrentRecoilSettingsIdx();
	int STATIC_GetCurrentAccuracySettingsIdx();
	bool ShouldForce3P(class UTgDeviceForm* DeviceForm, bool bOnlyCheckDeviceForm);
	bool ShouldForce1P(class UTgDeviceForm* DeviceForm, bool bOnlyCheckDeviceForm);
	bool STATIC_UseRangeFalloffCurve();
	class UTgGameplayCurvesSet* STATIC_GetCurrentGameplayCurveSet(TEnumAsByte<ECurveSetTypes> Type);
	class UTgGameplayCurves* STATIC_GetCurrentGameplayCurves();
	void DeviceFailLog(bool bDeviceFailLog, const struct FString& S);
	bool ShouldAutoFire();
	float STATIC_GetFireHoldPct();
	float STATIC_GetFireHoldDamageLow();
	float STATIC_GetFireHoldAccuracyLow();
	float STATIC_GetFireHoldRate();
	float STATIC_GetFireHoldTime();
	bool STATIC_IsFireHoldDevice();
	class UTgGameplayCurvesSet* STATIC_GetShotSpreadTendencyCurvesSet();
	float STATIC_GetBaseDamageMultiplier(struct FImpactInfo* hitImpact);
	void ConsolidateImpacts(TArray<struct FImpactInfo>* ImpactsToConsolidate, TArray<float>* ShotRanges, TArray<unsigned char>* ShotToImpactIndex);
	bool STATIC_UpdateUltChargePercent();
	bool ShouldAltFireOnTick();
	bool STATIC_IsSuccessfulHitImpact(class AActor* ImpactedActor);
	float STATIC_GetHeadShotDamage(class UTgDeviceFire* FireMode);
	struct FString STATIC_GetProjectilePredictionStats();
	struct FString STATIC_GetInstantFirePredictionStats();
	struct FString STATIC_GetAimValidationStats();
	struct FString STATIC_GetLastUsedAimStats();
	void RecordUsedAim(struct FVector* InAim);
	void SetRandomShotSpreadSeed(int Seed);
	bool STATIC_ValidateClientInstantHit(int nFireRequestId, struct FImpactInfo* ValidPrimaryImpact, TArray<struct FImpactInfo>* OutValidImpacts, struct FAimData* InServerAim, struct FAimData* InClientAim, struct FImpactToValidate* InPrimaryImpact, TArray<struct FImpactToValidate>* InClientImpacts, TArray<float>* OutHitRanges);
	bool STATIC_ValidateClientProjectileImpact(class ATgProj_Simulated* SimulatedProjectile, float ProjectileAliveTime, class AActor* Other, float MovementTimeStamp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	int STATIC_GenerateUniqueAmmoValidationId();
	int STATIC_GenerateUniqueFireRequestId();
	bool STATIC_HasRemoteOwner();
	void ReplicatePlayerDeviceAmmo();
	int STATIC_GetPetIDOverride(int PetIndex);
	void DeviceAdjustHeal(int nPropertyId, struct FImpactInfo* Impact, float* fHeal);
	void DeviceAdjustDamage(int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
	void SetFireMode(int nFireModeNum, bool ForceSet);
	float STATIC_GetRandRecoil(float Min, float Max);
	float STATIC_GetAccuracy(int nMode);
	bool ShouldBlockReload(class ATgDevice* Dev, bool bIsAutoReload);
	bool STATIC_IsReloading();
	bool CanReload(bool bIsAutoReload);
	bool CheckAutoReload();
	float STATIC_GetCurrentReloadPct();
	void STATIC_UpdateAmmoRegen(bool bUpdateCooldown, float fCooldownFloor);
	bool STATIC_ShouldResetAmmoChargesOnRespawn();
	bool ShouldTreatAmmoAsCharges();
	int STATIC_GetCurrentAmmoAmount();
	bool RequiresAmmoToFire();
	bool STATIC_HasAmmo();
	bool ShouldShowAmmoCount();
	bool ShouldLiftInterrupt();
	bool ShouldInterruptLift();
	bool ShouldInterruptStealth();
	void SetInstanceCount(int nInstanceCount);
	void SetPointsAllocated(int nPoints);
	void ClientPtsAllocatedUpdated();
	bool AllocateDevicePoint();
	int STATIC_GetAllocatedDevicePoints();
	int STATIC_GetTotalDevicePoints();
	float STATIC_GetTargetingMinRange(class UTgDeviceFire* FireMode);
	void ExitTargetingMode();
	void EnterTargetingMode();
	bool STATIC_IsInTargetingMode();
	bool STATIC_IsTargetingModeReady(TEnumAsByte<EDeviceFailType>* failType);
	bool STATIC_IsInhandOverrideActive();
	bool STATIC_IsActive(bool bIgnoreCooldown, bool bIngoreEquipped);
	void STATIC_UpdateAimWhileFiring(struct FAimData* Aim);
	bool SupportsEffectSimulation();
	bool CanAllowLagCompensation();
	bool CanLockOnToTarget(class AActor* Target);
	void STATIC_GetWorldMapTargetAim(struct FAimData* Aim);
	void STATIC_GetSpawnPointTargetAim(struct FAimData* Aim);
	void STATIC_GetLockOnTargetAim(struct FAimData* Aim);
	void STATIC_GetGroundTargetAim(struct FAimData* Aim);
	void STATIC_GetLinearTargetAim(struct FAimData* Aim);
	void STATIC_GetSelfTargetAim(struct FAimData* Aim);
	void STATIC_GetAOETargetAim(struct FAimData* Aim);
	void STATIC_GetConeTargetAim(struct FAimData* Aim);
	void STATIC_GetReticleFindSpotAim(struct FAimData* Aim);
	void STATIC_GetReticleTargetAim(struct FAimData* Aim);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
	void STATIC_UpdateTargetingModeStatus(struct FAimData* Aim);
	struct FAimData STATIC_ValidateReceivedAim(float ClientMovementTimeStamp, const struct FAimData& Aim);
	struct FAimData CacheAim();
	void STATIC_GetCachedAim(struct FAimData* Aim);
	bool STATIC_UsesCachedAim();
	TEnumAsByte<ECastMode> DetermineCastMode(TEnumAsByte<ECastMode> desiredCastMode);
	bool ShouldAimThroughReticule();
	bool STATIC_ForceDefaultCastMode();
	bool STATIC_UsesTrackingTarget();
	bool STATIC_UsesTargetingMode();
	TEnumAsByte<EDeviceTargetMode> STATIC_GetTargetingMode();
	float STATIC_GetLockoutExtensionTime();
	float STATIC_GetCachedFiringPostHitDelay();
	float CacheFiringPostHitDelay();
	float STATIC_GetFiringPostHitDelay(int nMode);
	float STATIC_GetFiringPreHitDelay(int nMode);
	float STATIC_GetRefireTime(int nMode);
	float GetBuildupTime();
	void STATIC_GetCombatLogEventLocation(int* LocationX, int* LocationY);
	void SendCombatLogEvent(TEnumAsByte<EITEM_EVENT_TYPE> Type);
	void SendDeviceChangeEvent(TEnumAsByte<EDeviceChangeEvent> Event);
	bool STATIC_CanRestartFireMidLoop();
	void CheckAndUpdateCooldown();
	class UTgTimerManager* STATIC_GetCooldownTimerManager();
	bool STATIC_IsDeviceRefiring();
	bool STATIC_IsInCooldownGracePeriod();
	bool STATIC_IsInIndividualOffhandCooldown();
	float STATIC_GetIndividualOffhandCooldownTime();
	bool STATIC_IsDeviceCoolingDown();
	bool STATIC_ShouldBankCooldown();
	void DeviceConsumePowerPool(unsigned char FireModeNum);
	bool STATIC_HasEnoughPowerPool(unsigned char FireModeNum);
	bool STATIC_IsInPostfire();
	bool STATIC_IsInPrefire();
	float STATIC_GetConePullbackDistance();
	bool CanBeGrabbed();
	bool CanBeStasisLocked();
	bool CanBeCrippled();
	bool CanBeDisarmed();
	bool CanBeSilenced();
	bool CanBeStunned();
	bool STATIC_IsToggleDevice();
	bool STATIC_IsTestDevice();
	bool STATIC_IsBurnCard();
	bool STATIC_IsArmorCard();
	bool STATIC_IsTalent();
	bool STATIC_IsSpray();
	bool STATIC_IsCard();
	bool STATIC_IsEmote();
	bool STATIC_IsMovementAbility();
	bool STATIC_IsAbility(bool bExcludeMovement);
	bool STATIC_IsPurchasedAbility();
	bool STATIC_IsOwnedByOffhand();
	bool STATIC_IsOffhand();
	int STATIC_GetModeRange(int nMode);
	bool CheckModeRange(int nMode, const struct FVector& vDelta);
	void RemoveAllEffects();
	void OnCeaseActive();
	void OnBecomeActive();
	void CeaseActive(bool bSkipActiveEffects);
	void BecomeActive(bool bSkipActiveEffects);
	void RemoveEquipEffects();
	void ApplyEquipEffects(bool bPostRevive);
	class UTgDeviceFire* STATIC_GetDeviceFire(int nMode);
	class UTgDeviceFire* STATIC_GetCurrentFire();
	void TickTargetingMode(float DeltaSeconds);
	bool ServerDetonate(int nFireMode);
	bool STATIC_LogDebugInfo();
	void RemoveConsumableFromOwnerInventory();
	struct FString STATIC_GetDeviceName();
	void CalcFireSocketIndexMax();
	struct FName STATIC_GetFireSocketName();
	unsigned char STATIC_GetProjectileExtraInfo(unsigned char FromClient, bool bValidating);
	struct FName QueryDeployableClass(int nMode);
	struct FName QueryProjectileClass(int nMode);
	bool ApplyDeviceSetup();
	void DeviceEvent();
};


// Class TgGame.TgDevice_ActivateOnChildGeneric1
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_ActivateOnChildGeneric1 : public ATgDevice
{
public:
	class ATgDevice*                                   m_LinkedDev;                                              // 0x0A0C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ActivateOnChildGeneric1");
		return ptr;
	}


	void LinkedDeviceEquipped(class ATgDevice* Dev);
	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void STATIC_Activate();
};


// Class TgGame.TgDevice_ArcingBeam
// 0x0018 (0x0A24 - 0x0A0C)
class ATgDevice_ArcingBeam : public ATgDevice
{
public:
	TArray<struct FArcingInfo>                         m_ArcingList;                                             // 0x0A0C(0x0010) (NeedCtorLink)
	int                                                m_nMaxNumArcsPerTarget;                                   // 0x0A1C(0x0004)
	unsigned long                                      m_bCanTargetShields : 1;                                  // 0x0A20(0x0004)
	unsigned long                                      m_bIsArcing : 1;                                          // 0x0A20(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ArcingBeam");
		return ptr;
	}


	void TriggerArc(int Index);
	void STATIC_EndArcing(int Index);
	void STATIC_ApplyCustomFireToInitial(class AActor* InitialTarget, class UTgDeviceFire* FireMode);
	void BeginArcing(class AActor* InitialTarget, class UTgDeviceFire* FireMode);
	int GetNumArcJumps(class AActor* InitialTarget, class UTgDeviceFire* FireMode);
	void Tick(float DeltaTime);
	void TriggerArcsInArcingList(float DeltaTime);
	bool STATIC_IsValidArcTarget(class AActor* TestActor, const struct FArcingInfo& Info, bool bIgnoreHealth);
	class AActor* DetermineNextTarget(int Index);
};


// Class TgGame.TgDevice_Aura
// 0x0060 (0x0A6C - 0x0A0C)
class ATgDevice_Aura : public ATgDevice
{
public:
	float                                              r_fRadiusScale;                                           // 0x0A0C(0x0004) (Net)
	TArray<class AActor*>                              m_TouchingActors;                                         // 0x0A10(0x0010) (NeedCtorLink)
	TArray<class AActor*>                              m_PreviouslyTouchedActors;                                // 0x0A20(0x0010) (NeedCtorLink)
	TArray<class AActor*>                              m_AffectedActors;                                         // 0x0A30(0x0010) (NeedCtorLink)
	unsigned long                                      m_bIsAuraActive : 1;                                      // 0x0A40(0x0004)
	float                                              m_fLastBlockedByBlockersTime;                             // 0x0A44(0x0004)
	float                                              m_fMinBlockedByBlockersTime;                              // 0x0A48(0x0004)
	float                                              m_fDelayPreviouslyTouchedActorsCheck;                     // 0x0A4C(0x0004)
	float                                              m_fUpdatePreviouslyTouchedActorsCheckInterval;            // 0x0A50(0x0004)
	TArray<class AActor*>                              m_BlockedActors;                                          // 0x0A54(0x0010) (NeedCtorLink)
	class ATgCollisionProxy_Cylinder*                  m_CollisionProxy;                                         // 0x0A64(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Aura");
		return ptr;
	}


	void DisableAura();
	void EnableAura();
	void ScaleCollisionProxy();
	void SpawnCollisionProxy();
	void Destroyed();
	void DeviceShutDown(bool bDeactiveMode, bool bResetCooldowns);
	void ClearAllTouched();
	void ClearAllAffected();
	void OnProxyUnTouch(class AActor* Other);
	void OnProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool ShouldInterruptInhand();
	float STATIC_GetDistanceToTarget(class AActor* Target);
	float GetCurrentRadius();
	void RemoveEffects(class AActor* Target);
	void ApplyEffects(class AActor* Target);
	void SetFireMode(int nFireModeNum, bool ForceSet);
};


// Class TgGame.TgDevice_ActiveAura
// 0x0000 (0x0A6C - 0x0A6C)
class ATgDevice_ActiveAura : public ATgDevice_Aura
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ActiveAura");
		return ptr;
	}

};


// Class TgGame.TgDevice_PassiveAura
// 0x0000 (0x0A6C - 0x0A6C)
class ATgDevice_PassiveAura : public ATgDevice_Aura
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_PassiveAura");
		return ptr;
	}


	bool ShouldAuraBeActive();
};


// Class TgGame.TgDevice_AuraPerTarget
// 0x0004 (0x0A70 - 0x0A6C)
class ATgDevice_AuraPerTarget : public ATgDevice_PassiveAura
{
public:
	int                                                m_nAppliedStacks;                                         // 0x0A6C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_AuraPerTarget");
		return ptr;
	}

};


// Class TgGame.TgDevice_AutoHealing2
// 0x0014 (0x0A20 - 0x0A0C)
class ATgDevice_AutoHealing2 : public ATgDevice
{
public:
	unsigned long                                      m_bIsApplied : 1;                                         // 0x0A0C(0x0004)
	unsigned long                                      m_bForceRemoval : 1;                                      // 0x0A0C(0x0004)
	class ATgPawn*                                     m_CachedPawnOwner;                                        // 0x0A10(0x0008)
	float                                              m_fLastLowHealthSoundTime;                                // 0x0A18(0x0004)
	float                                              m_fPrevHealthPct;                                         // 0x0A1C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_AutoHealing2");
		return ptr;
	}


	void DeviceAdjustHeal(int nPropertyId, struct FImpactInfo* Impact, float* fHeal);
};


// Class TgGame.TgDevice_BarricadeMod
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_BarricadeMod : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_BarricadeMod");
		return ptr;
	}


	void ApplyTouchEffect(class AActor* Target);
};


// Class TgGame.TgDevice_AcceleratorField
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_AcceleratorField : public ATgDevice_BarricadeMod
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_AcceleratorField");
		return ptr;
	}

};


// Class TgGame.TgDevice_Bunker
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_Bunker : public ATgDevice_BarricadeMod
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Bunker");
		return ptr;
	}

};


// Class TgGame.TgDevice_Impede
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_Impede : public ATgDevice_BarricadeMod
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Impede");
		return ptr;
	}

};


// Class TgGame.TgDevice_BeyondTheVeil
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_BeyondTheVeil : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_BeyondTheVeil");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	void ApplyTouchEffect(class AActor* pOther);
};


// Class TgGame.TgDevice_ChainSequence
// 0x0010 (0x0A1C - 0x0A0C)
class ATgDevice_ChainSequence : public ATgDevice
{
public:
	int                                                m_nChainCount;                                            // 0x0A0C(0x0004)
	float                                              m_fChainResetTimer;                                       // 0x0A10(0x0004)
	float                                              m_fChainResetDuration;                                    // 0x0A14(0x0004) (Const)
	unsigned long                                      m_bReloadResetsChainCount : 1;                            // 0x0A18(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ChainSequence");
		return ptr;
	}


	void OnChainReset();
	void OnInterruptEvent();
	void STATIC_UpdateDesiredFireMode();
	void PostReloadTimer();
	void STATIC_FireAmmunition();
	int STATIC_GetChainFireModeIndex();
	int GetChainMax();
};


// Class TgGame.TgDevice_Charge
// 0x0074 (0x0A80 - 0x0A0C)
class ATgDevice_Charge : public ATgDevice
{
public:
	TEnumAsByte<EChargeState>                          m_eChargeState;                                           // 0x0A0C(0x0001)
	TEnumAsByte<EChargeStopOnHitType>                  m_bStopOnHitType;                                         // 0x0A0D(0x0001)
	TEnumAsByte<EChargeFiringType>                     m_ChargeTimingType;                                       // 0x0A0E(0x0001)
	unsigned char                                      UnknownData00[0x1];                                       // 0x0A0F(0x0001) MISSED OFFSET
	unsigned long                                      m_bUsePhysFlying : 1;                                     // 0x0A10(0x0004)
	unsigned long                                      m_bUseReticleTargetAim : 1;                               // 0x0A10(0x0004)
	unsigned long                                      m_bUseDamageRadiusForHitProxy : 1;                        // 0x0A10(0x0004)
	unsigned long                                      m_bIgnoreHumanoids : 1;                                   // 0x0A10(0x0004)
	unsigned long                                      m_bHitOnce : 1;                                           // 0x0A10(0x0004)
	unsigned long                                      m_bApplyHitOnTouch : 1;                                   // 0x0A10(0x0004)
	unsigned long                                      m_bApplyHitSpecialOnTouch : 1;                            // 0x0A10(0x0004)
	unsigned long                                      m_bCharging : 1;                                          // 0x0A10(0x0004)
	unsigned long                                      m_bInterruptDeviceIfChargeEnds : 1;                       // 0x0A10(0x0004)
	unsigned long                                      m_bUseDirectHitSpecial : 1;                               // 0x0A10(0x0004)
	unsigned long                                      m_bChargeBackward : 1;                                    // 0x0A10(0x0004)
	unsigned long                                      m_bCanLeftClickCancel : 1;                                // 0x0A10(0x0004)
	unsigned long                                      m_bIgnoreMovementCorrection : 1;                          // 0x0A10(0x0004)
	unsigned long                                      m_bAimTowardsAcceleration : 1;                            // 0x0A10(0x0004)
	unsigned long                                      m_bAimUpIfAccelZero : 1;                                  // 0x0A10(0x0004)
	unsigned long                                      m_bPostChargeUseWalkSpeed : 1;                            // 0x0A10(0x0004)
	unsigned long                                      m_bChargeRespectsMoveSpeedMultipliers : 1;                // 0x0A10(0x0004)
	unsigned long                                      s_bHasQueuedChargeDir : 1;                                // 0x0A10(0x0004)
	unsigned long                                      s_bForcingStartCharge : 1;                                // 0x0A10(0x0004)
	unsigned long                                      m_bEndChargeImmediately : 1;                              // 0x0A10(0x0004)
	unsigned long                                      m_bHasQueuedCharge : 1;                                   // 0x0A10(0x0004)
	class ATgCollisionProxy_Cylinder*                  m_HitProxy;                                               // 0x0A14(0x0008)
	struct FVector                                     m_vHitProxyRelativeLocation;                              // 0x0A1C(0x000C)
	struct FVector                                     m_vHitProxySizeOffset;                                    // 0x0A28(0x000C)
	float                                              s_fServerValidationSizeMultiplier;                        // 0x0A34(0x0004)
	float                                              m_fPostChargeVelocityMult;                                // 0x0A38(0x0004)
	float                                              m_fPostChargeVelocityCap;                                 // 0x0A3C(0x0004)
	float                                              m_fWaitForClientStartChargeAimTime;                       // 0x0A40(0x0004)
	struct FRotator                                    s_rQueuedChargeDir;                                       // 0x0A44(0x000C)
	float                                              m_fChargeQueueTime;                                       // 0x0A50(0x0004)
	struct FRotator                                    m_rLastChargeDirection;                                   // 0x0A54(0x000C)
	TArray<class AActor*>                              s_AppliedList;                                            // 0x0A60(0x0010) (NeedCtorLink)
	TArray<struct FTimestampedActor>                   s_HitActors;                                              // 0x0A70(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Charge");
		return ptr;
	}


	bool CanFiringBeCanceledByLeftMouse();
	void ApplyTouchHit(class ATgPawn* InstigatorPawn, const struct FVector& vHitLocation, const struct FVector& vHitNormal, class AActor* Target);
	void STATIC_EnableCorrection();
	struct FRotator STATIC_GetChargeDirection();
	void OnStoppedChargeOnHit(class AActor* Other);
	void OnValidTargetTouched(class AActor* Other);
	void ApplyDamageReduction(struct FImpactInfo* Impact);
	bool ShouldStopOnThisHit(class AActor* Other);
	float STATIC_GetChargeSpeed();
	float GetChargeTime();
	float GetChargeRange();
	TEnumAsByte<EChargeState> GetChargeState();
	bool CanBeInterrupted();
	bool CanBeCanceled();
	bool ShouldIgnoreActorHit(class AActor* pQueryActor);
	float STATIC_GetActorHitPeriod(class AActor* pQueryActor);
	void AddActorToHitlist(class AActor* pActor);
	void STATIC_ForceStartChargeOnServer();
	void STATIC_ServerStartChargeNewAim(int nPitch, int nYaw);
	bool StartFire();
	bool STATIC_ShouldQueuePendingFire(class UTgDeviceFire* FireMode);
	bool Use();
	void EndCharge();
	void StartCharge();
	void ChargeUnTouch(class AActor* Other);
	void ChargeTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool ServerValidateChargeHit(class AActor* Other);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
	void SetFireMode(int nFireModeNum, bool ForceSet);
};


// Class TgGame.TgDevice_ChargeBackward
// 0x0000 (0x0A80 - 0x0A80)
class ATgDevice_ChargeBackward : public ATgDevice_Charge
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ChargeBackward");
		return ptr;
	}

};


// Class TgGame.TgDevice_DoubleCharge
// 0x0008 (0x0A88 - 0x0A80)
class ATgDevice_DoubleCharge : public ATgDevice_Charge
{
public:
	int                                                m_nTotalNumShots;                                         // 0x0A80(0x0004)
	int                                                m_nShotsFired;                                            // 0x0A84(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DoubleCharge");
		return ptr;
	}


	int STATIC_GetTotalNumberOfShots();
	void StartCooldown(int nMode, float fCooldownTimeOverride);
	bool ShouldCooldownAfterFire();
	void RefireTimer();
	bool CanBeCanceled();
	void DeviceConsumePowerPool(unsigned char FireModeNum);
	void STATIC_UpdateTargetingModeStatus(struct FAimData* Aim);
};


// Class TgGame.TgDevice_DecoyMod
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_DecoyMod : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DecoyMod");
		return ptr;
	}

};


// Class TgGame.TgDevice_Pursuit
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_Pursuit : public ATgDevice_DecoyMod
{
public:
	float                                              m_fShatterBaseSpeed;                                      // 0x0A0C(0x0004)
	float                                              m_fShatterResonanceBaseSpeed;                             // 0x0A10(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Pursuit");
		return ptr;
	}

};


// Class TgGame.TgDevice_DeployMod
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_DeployMod : public ATgDevice
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_DeployMod;                     // 0x0A0C(0x0008) (Const, Native, NoExport)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DeployMod");
		return ptr;
	}


	void ModifyDeployableFiremode(class UTgDeviceFire* pFireMode);
	float STATIC_GetAdditiveHealth();
	bool AffectsDeployable(int nDeployableId);
};


// Class TgGame.TgDevice_DeployMod_AddHealth
// 0x0000 (0x0A14 - 0x0A14)
class ATgDevice_DeployMod_AddHealth : public ATgDevice_DeployMod
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DeployMod_AddHealth");
		return ptr;
	}


	float STATIC_GetAdditiveHealth();
};


// Class TgGame.TgDevice_DeployMod_PropertyMult
// 0x0000 (0x0A14 - 0x0A14)
class ATgDevice_DeployMod_PropertyMult : public ATgDevice_DeployMod
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DeployMod_PropertyMult");
		return ptr;
	}


	void ModifyDeployableFiremode(class UTgDeviceFire* pFireMode);
};


// Class TgGame.TgDevice_DualWield
// 0x0010 (0x0A1C - 0x0A0C)
class ATgDevice_DualWield : public ATgDevice
{
public:
	struct FVector                                     m_vProjectileSpawnOffset2;                                // 0x0A0C(0x000C) (Edit)
	unsigned long                                      m_bFireLeftWeapon : 1;                                    // 0x0A18(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DualWield");
		return ptr;
	}


	void SetLeftFire(bool bLeftFire);
	void STATIC_FireAmmunition();
	struct FVector GetProjectileSpawnOffset();
};


// Class TgGame.TgDevice_QuadWield
// 0x001C (0x0A38 - 0x0A1C)
class ATgDevice_QuadWield : public ATgDevice_DualWield
{
public:
	struct FVector                                     m_vProjectileSpawnOffset3;                                // 0x0A1C(0x000C) (Edit)
	struct FVector                                     m_vProjectileSpawnOffset4;                                // 0x0A28(0x000C) (Edit)
	int                                                m_nWeaponFireNumber;                                      // 0x0A34(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_QuadWield");
		return ptr;
	}


	void STATIC_FireAmmunition();
	struct FVector GetProjectileSpawnOffset();
};


// Class TgGame.TgDevice_EmitterMod
// 0x0004 (0x0A10 - 0x0A0C)
class ATgDevice_EmitterMod : public ATgDevice
{
public:
	unsigned long                                      m_bIsOnOthers : 1;                                        // 0x0A0C(0x0004)
	unsigned long                                      m_bIsOnOwner : 1;                                         // 0x0A0C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_EmitterMod");
		return ptr;
	}


	void RemoveTouchEffect(class AActor* Target, class ATgDevice_Emitter* Emitter);
	void ApplyTouchEffect(class AActor* Target, class ATgDevice_Emitter* Emitter);
};


// Class TgGame.TgDevice_Projector
// 0x0000 (0x0A10 - 0x0A10)
class ATgDevice_Projector : public ATgDevice_EmitterMod
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Projector");
		return ptr;
	}


	void RemoveTouchEffect(class AActor* Target, class ATgDevice_Emitter* Emitter);
	void ApplyTouchEffect(class AActor* Target, class ATgDevice_Emitter* Emitter);
};


// Class TgGame.TgDevice_Emote
// 0x004C (0x0A58 - 0x0A0C)
class ATgDevice_Emote : public ATgDevice
{
public:
	class ATgPawn_Character*                           m_CachedPawnOwner;                                        // 0x0A0C(0x0008)
	unsigned long                                      m_bAccelerationInterruptsDevice : 1;                      // 0x0A14(0x0004)
	unsigned long                                      m_bJumpingInterruptsDevice : 1;                           // 0x0A14(0x0004)
	unsigned long                                      m_bValidEmote : 1;                                        // 0x0A14(0x0004)
	class UClass*                                      m_DefaultCameraModuleClass;                               // 0x0A18(0x0008)
	class UClass*                                      m_FiringCameraModuleClass;                                // 0x0A20(0x0008)
	class UTgCameraModule*                             m_FiringCameraModule;                                     // 0x0A28(0x0008)
	float                                              m_fCameraTweenInTime;                                     // 0x0A30(0x0004)
	float                                              m_fCameraTweenOutTime;                                    // 0x0A34(0x0004)
	struct FVector                                     m_vFiringCameraOffset;                                    // 0x0A38(0x000C)
	int                                                m_nSelectedEmote;                                         // 0x0A44(0x0004)
	float                                              m_fEmotePreHitDelay;                                      // 0x0A48(0x0004)
	float                                              m_fEmotePostHitDelay;                                     // 0x0A4C(0x0004)
	float                                              m_fEmoteMoveSpeedCeiling;                                 // 0x0A50(0x0004)
	float                                              m_fEmoteIntroInputLockTime;                               // 0x0A54(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Emote");
		return ptr;
	}


	void SetMoveSpeedCeiling(bool bEnabled);
	void STATIC_ClearInputLockEarly();
	void Tick(float DeltaSeconds);
	class ATgPawn_Character* STATIC_GetCachedPawnOwner();
	void STATIC_TurnOffSpecialCamera();
	void STATIC_TurnOnSpecialCamera();
	bool CanBeCanceled();
	bool CanBeInterrupted();
	bool ShouldInterruptReloadOnFire();
	bool ShouldInterruptMount();
	bool CanBeFiredWhileTweening();
	bool CanFiringBeCanceledByReactivation();
	bool CanFiringBeCanceledByRightMouse();
	bool ShouldLockJumping();
	void STATIC_HandleDeviceFormStartFire(int nDeviceModeNum, float fRefireTime, struct FAimData* Aim);
	void SetEmote(int nSlot);
	void SetFirstValidEmote();
	void ServerSetEmote(int nSlot);
	bool Use();
	float STATIC_GetFiringPostHitDelay(int nMode);
	float STATIC_GetFiringPreHitDelay(int nMode);
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	void SetEmoteData();
	bool CanFiringBeLocked();
	bool ShouldBlockReload(class ATgDevice* Dev, bool bIsAutoReload);
	void PlayEmote(int nSlot);
};


// Class TgGame.TgDevice_FireInAir
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_FireInAir : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_FireInAir");
		return ptr;
	}

};


// Class TgGame.TgDevice_HitPulse
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_HitPulse : public ATgDevice
{
public:
	unsigned long                                      s_ShouldPayCostPerPulse : 1;                              // 0x0A0C(0x0004)
	unsigned long                                      s_bCostPaid : 1;                                          // 0x0A0C(0x0004)
	unsigned long                                      m_bConsumeAmmoOnEachPulse : 1;                            // 0x0A0C(0x0004)
	int                                                m_CurrentPulseIndex;                                      // 0x0A10(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_HitPulse");
		return ptr;
	}


	int STATIC_GetAmmoToConsume();
	bool ShouldConsumePowerPoolAfterFire();
	bool ShouldConsumePowerPoolOnStartFire();
	void ClientInterrupt(bool bServerFireFailed);
	void InterruptFiring(bool bServerFireFailed);
	float GetPersistTime(int nMode);
	void PulseHit();
	void PersistTimer();
	bool ApplyGlobalOffhandCooldown();
	float STATIC_GetLockoutExtensionTime();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	float STATIC_GetPersistPulseHitTime(int nMode);
	float STATIC_GetRefireTime(int nMode);
};


// Class TgGame.TgDevice_Latch
// 0x0048 (0x0A54 - 0x0A0C)
class ATgDevice_Latch : public ATgDevice
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_MoveSpeedMultiplier;           // 0x0A0C(0x0008) (Const, Native, NoExport)
	struct FAimData                                    m_FinalLatchTargeting;                                    // 0x0A14(0x0034)
	unsigned long                                      m_bIsPulling : 1;                                         // 0x0A48(0x0004)
	unsigned long                                      m_bHasPulledOnce : 1;                                     // 0x0A48(0x0004)
	unsigned long                                      m_bCanApplyPull : 1;                                      // 0x0A48(0x0004)
	unsigned long                                      m_bTeleportedAfterFiring : 1;                             // 0x0A48(0x0004)
	unsigned long                                      m_bIgnoreAllyLatch : 1;                                   // 0x0A48(0x0004)
	int                                                m_nHoverState;                                            // 0x0A4C(0x0004)
	float                                              m_fKillHoverFailsafe;                                     // 0x0A50(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Latch");
		return ptr;
	}


	bool CanBeCanceled();
	void Tick(float DeltaSeconds);
	void SetIsPullingHitSpecial(bool bIsPulling);
	void EndPull();
	void STATIC_FireAmmunition();
	void STATIC_ParentFireAmmunition();
	void PullToTarget();
	bool StartFire();
	bool ParentStartFire();
	struct FImpactInfo CalcWeaponFire(const struct FAimData& Aim, TArray<struct FImpactInfo>* ImpactList);
	void CallServerRestartFireLoop(const struct FAimData& Aim);
	void CallServerStartFire(const struct FAimData& Aim, bool bPendingUpdate);
	void STATIC_DeactivateHover();
	void OnOwnerRespawn();
	void STATIC_ActivateHover();
	float STATIC_TotalFireTime();
	struct FAimData STATIC_ValidateReceivedAim(float ClientMovementTimeStamp, const struct FAimData& Aim);
	float STATIC_GetTrueFiringPreHitDelay(int nMode);
	float STATIC_GetFiringPreHitDelay(int nMode);
	bool STATIC_ShouldUseGradualMovement();
	float STATIC_GetMoveSpeedMultiplier();
	bool STATIC_IsValidPullTarget(class AActor* pCandidate);
	void STATIC_GetReticleTargetAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_Leap
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_Leap : public ATgDevice
{
public:
	unsigned long                                      m_bLeapInLookDirection : 1;                               // 0x0A0C(0x0004)
	unsigned long                                      m_bDidJustLeap : 1;                                       // 0x0A0C(0x0004)
	unsigned long                                      m_bJumpTowardsAcceleration : 1;                           // 0x0A0C(0x0004)
	unsigned long                                      m_bFireOnLeap : 1;                                        // 0x0A0C(0x0004)
	unsigned long                                      m_bAddRandomLateralRotation : 1;                          // 0x0A0C(0x0004)
	unsigned long                                      m_bUseLateralScale : 1;                                   // 0x0A0C(0x0004)
	unsigned long                                      m_bUseVerticalScale : 1;                                  // 0x0A0C(0x0004)
	int                                                m_nRotationUU;                                            // 0x0A10(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Leap");
		return ptr;
	}


	void SetLeapParams(float* scaleLateral, float* scaleVertical, float* additiveLateral, float* additiveVertical);
	void STATIC_NotifyNewLeapDirection(const struct FVector& vNewDir);
	bool CanBeCanceled();
	struct FVector STATIC_ApplyRandomRotation(const struct FVector& vJumpVelocity);
	float STATIC_GetFiringPreHitDelay(int nMode);
};


// Class TgGame.TgDevice_LongReach
// 0x0038 (0x0A44 - 0x0A0C)
class ATgDevice_LongReach : public ATgDevice
{
public:
	float                                              m_fMinPullSpeed;                                          // 0x0A0C(0x0004)
	float                                              m_fMaxPullSpeed;                                          // 0x0A10(0x0004)
	float                                              m_fTimeToMaxPullSpeed;                                    // 0x0A14(0x0004)
	float                                              m_fPullSpeedInterpExp;                                    // 0x0A18(0x0004)
	class ATgPawn*                                     m_CachedTgP;                                              // 0x0A1C(0x0008)
	TArray<struct FNuggetPullVals>                     s_TouchingNuggets;                                        // 0x0A24(0x0010) (NeedCtorLink)
	float                                              m_fBlockedByBlockersRecheckTime;                          // 0x0A34(0x0004)
	class ATgCollisionProxy_Cylinder*                  s_CollisionProxy;                                         // 0x0A38(0x0008)
	unsigned long                                      s_bIsAuraActive : 1;                                      // 0x0A40(0x0004)
	unsigned long                                      m_bAutoActivateAura : 1;                                  // 0x0A40(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_LongReach");
		return ptr;
	}


	void DisableAura();
	void EnableAura();
	void SpawnCollisionProxy();
	void Destroyed();
	void DeviceShutDown(bool bDeactiveMode, bool bResetCooldowns);
	void ClearAllTouched();
	void OnProxyUnTouch(class AActor* Other);
	void OnProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool STATIC_IsNuggetValid(class AActor* Target);
};


// Class TgGame.TgDevice_Mark
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_Mark : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Mark");
		return ptr;
	}


	void STATIC_ImaniPRISwap(class ATgPawn* pPawn, class ATgRepInfo_Player** pPRI);
};


// Class TgGame.TgDevice_Meteor
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_Meteor : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Meteor");
		return ptr;
	}


	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
	class ATgChaosCapturePoint* STATIC_GetAnActiveCapturePoint();
	class ATgPawn_LanePusher* STATIC_GetAnActiveLanePusher();
};


// Class TgGame.TgDevice_OppressorMineMod
// 0x0010 (0x0A1C - 0x0A0C)
class ATgDevice_OppressorMineMod : public ATgDevice
{
public:
	TArray<class ATgDeploy_OppressorMine*>             m_MinesInRage;                                            // 0x0A0C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_OppressorMineMod");
		return ptr;
	}


	void CheckOwnerEffect(class ATgDeploy_OppressorMine* mine);
	void RemoveEffect(class ATgDeploy_OppressorMine* mine, class AActor* Target);
	void ApplyEffect(class ATgDeploy_OppressorMine* mine, class AActor* Target);
};


// Class TgGame.TgDevice_Amplitude
// 0x0000 (0x0A1C - 0x0A1C)
class ATgDevice_Amplitude : public ATgDevice_OppressorMineMod
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Amplitude");
		return ptr;
	}

};


// Class TgGame.TgDevice_Pet
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_Pet : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Pet");
		return ptr;
	}

};


// Class TgGame.TgDevice_PortalMod
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_PortalMod : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_PortalMod");
		return ptr;
	}


	void ApplyEffect();
};


// Class TgGame.TgDevice_RespawnBeacon
// 0x000C (0x0A18 - 0x0A0C)
class ATgDevice_RespawnBeacon : public ATgDevice
{
public:
	class ATgRespawnBeaconExit*                        s_BeaconExit;                                             // 0x0A0C(0x0008)
	unsigned long                                      r_bHasBeacon : 1;                                         // 0x0A14(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_RespawnBeacon");
		return ptr;
	}


	void DeviceShutDown(bool bDeactiveMode, bool bResetCooldowns);
	bool ShouldSwitchBackToBasicAttackTargeting(TEnumAsByte<ECastMode> CastMode);
	void STATIC_HandlePickUpAndDrop(bool bPickedUp);
	void STATIC_FireAmmunition();
	bool ShouldInterruptMount();
	bool STATIC_InterceptLeftMouseReleased(class ATgPlayerController* TgController);
	bool STATIC_InterceptLeftMousePressed(class ATgPlayerController* TgController);
	void ReplicatedEvent(const struct FName& VarName);
};


// Class TgGame.TgDevice_ReversalMod
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_ReversalMod : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ReversalMod");
		return ptr;
	}

};


// Class TgGame.TgDevice_Vengeance
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_Vengeance : public ATgDevice_ReversalMod
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Vengeance");
		return ptr;
	}

};


// Class TgGame.TgDevice_ShellShieldMod
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_ShellShieldMod : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ShellShieldMod");
		return ptr;
	}


	int ApplyDamageTakenEffect(int totalDamage);
	void ApplyTouchEffect(class AActor* Target);
};


// Class TgGame.TgDevice_BarrierReef
// 0x0004 (0x0A10 - 0x0A0C)
class ATgDevice_BarrierReef : public ATgDevice_ShellShieldMod
{
public:
	int                                                m_nHitsNeededOnCooldown;                                  // 0x0A0C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_BarrierReef");
		return ptr;
	}


	int ApplyDamageTakenEffect(int totalDamage);
};


// Class TgGame.TgDevice_Carapace
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_Carapace : public ATgDevice_ShellShieldMod
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Carapace");
		return ptr;
	}

};


// Class TgGame.TgDevice_ShieldMod
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_ShieldMod : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ShieldMod");
		return ptr;
	}

};


// Class TgGame.TgDevice_HeatTransfer
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_HeatTransfer : public ATgDevice_ShieldMod
{
public:
	int                                                m_nAccumulatedDamage;                                     // 0x0A0C(0x0004)
	int                                                m_nActivationDamage;                                      // 0x0A10(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_HeatTransfer");
		return ptr;
	}


	void RespondToDamageTaken(int Damage);
};


// Class TgGame.TgDevice_Rattle
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_Rattle : public ATgDevice_ShieldMod
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Rattle");
		return ptr;
	}


	void ApplyTouchEffect(class AActor* Target);
};


// Class TgGame.TgDevice_ToweringBarrier
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_ToweringBarrier : public ATgDevice_ShieldMod
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ToweringBarrier");
		return ptr;
	}

};


// Class TgGame.TgDevice_ToweringBarrier_Old
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_ToweringBarrier_Old : public ATgDevice_ShieldMod
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ToweringBarrier_Old");
		return ptr;
	}

};


// Class TgGame.TgDevice_SmokeScreenMod
// 0x0020 (0x0A2C - 0x0A0C)
class ATgDevice_SmokeScreenMod : public ATgDevice
{
public:
	TArray<class AActor*>                              m_ImmuneTargets;                                          // 0x0A0C(0x0010) (NeedCtorLink)
	TArray<float>                                      m_ImmuneTimes;                                            // 0x0A1C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_SmokeScreenMod");
		return ptr;
	}


	void RemoveEffect(class ATgDeploy_SmokeScreen* smokeScreen, class AActor* Target);
	void ApplyEffect(class ATgDeploy_SmokeScreen* smokeScreen, class AActor* Target);
	void ApplyOwnerTouchEffect(class AActor* Target);
	void ApplyOnTouchEffect(class AActor* Target);
};


// Class TgGame.TgDevice_Smother
// 0x0000 (0x0A2C - 0x0A2C)
class ATgDevice_Smother : public ATgDevice_SmokeScreenMod
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Smother");
		return ptr;
	}

};


// Class TgGame.TgDevice_Spray
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_Spray : public ATgDevice
{
public:
	unsigned long                                      m_bMissedSpray : 1;                                       // 0x0A0C(0x0004)
	int                                                m_nSelectedSpray;                                         // 0x0A10(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Spray");
		return ptr;
	}


	void OnInstantShotVerified(const struct FImpactInfo& VerifiedPrimaryImpact);
	void AuthStartCooldown(int nMode, float fCooldownTimeOverride);
	bool ShouldCooldownAfterFire();
	void STATIC_HandleDeviceFormStartFire(int nDeviceModeNum, float fRefireTime, struct FAimData* Aim);
	void ServerTrySpawnFXSpray();
	bool Use();
	void SetSpray(int nSlot);
	void SetFirstValidSpray();
	void ServerSetEmote(int nSlot);
	bool SelectedSprayRequiresFire(float* fCooldownOverride);
	void ActivateSpray(int nSlot);
	bool ShouldInterruptStealth();
};


// Class TgGame.TgDevice_Stim
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_Stim : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Stim");
		return ptr;
	}


	bool ShouldInterruptInhand();
	bool ShouldInterruptReloadOnFire();
};


// Class TgGame.TgDevice_ToggleWithLockout
// 0x000C (0x0A18 - 0x0A0C)
class ATgDevice_ToggleWithLockout : public ATgDevice_Stim
{
public:
	class ATgPawn*                                     m_CachedTgP;                                              // 0x0A0C(0x0008)
	float                                              m_fCurrentTransitionPct;                                  // 0x0A14(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ToggleWithLockout");
		return ptr;
	}


	void CustomFire();
	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
	void CompleteInterrupt();
	void StopFire();
	void ClientInterrupt(bool bServerFireFailed);
	void InterruptFiring(bool bServerFireFailed);
	void SetTransitionPct();
	void FiringEndTransition();
	bool CanBeInterrupted();
	bool CanBeCanceled();
	class ATgPawn* STATIC_GetCachedTgP();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	bool STATIC_IsToggleDevice();
};


// Class TgGame.TgDevice_ToggleADS
// 0x000C (0x0A24 - 0x0A18)
class ATgDevice_ToggleADS : public ATgDevice_ToggleWithLockout
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_MoveSpeedMultiplier;           // 0x0A18(0x0008) (Const, Native, NoExport)
	unsigned long                                      m_bDelayMoveSpeedPenalty : 1;                             // 0x0A20(0x0004)
	unsigned long                                      m_bIsZoomed : 1;                                          // 0x0A20(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ToggleADS");
		return ptr;
	}


	bool ShouldStopActionOnOffhandSlotReleased();
	bool IsFunctionallyToggleDevice();
	bool STATIC_InterceptSlotReleased(class ATgPlayerController* TgController);
	void CompleteInterrupt();
	bool STATIC_IsPlayerToggleZoomSet();
	bool STATIC_ShouldUseGradualMovement();
	float STATIC_GetMoveSpeedMultiplier();
};


// Class TgGame.TgDevice_ToggleModeWithLockout
// 0x0008 (0x0A20 - 0x0A18)
class ATgDevice_ToggleModeWithLockout : public ATgDevice_ToggleWithLockout
{
public:
	class ATgDevice*                                   m_CachedInhand;                                           // 0x0A18(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ToggleModeWithLockout");
		return ptr;
	}


	void LinkedDeviceEquipped(class ATgDevice* Dev);
};


// Class TgGame.TgDevice_TeamDevice
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_TeamDevice : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_TeamDevice");
		return ptr;
	}


	void TeamFlashCooldown(unsigned char nMode);
	void TeamGotoState(const struct FName& NewState);
	void TeamCooldownEnd();
	void TeamCooldownReset(int nMode, float fCooldownTime);
	void TeamCooldownStart(int nMode, float fCooldownTime);
	void TeamCooldownTimerExpired(int nTimerId, TEnumAsByte<ETGT_EVENT> eEvent);
	void EndCooldown();
	void ResetCooldown(int nMode, float fCooldownTimeOverride);
	void AuthStartCooldown(int nMode, float fCooldownTimeOverride);
	void ToggleCooldownEffects(bool bOnCooldown);
	void STATIC_FlashCooldown(unsigned char nMode);
	void CheckAndUpdateCooldown();
	class ATgRepInfo_TaskForce* STATIC_GetTaskForce();
	class UTgTimerManager* STATIC_GetCooldownTimerManager();
};


// Class TgGame.TgDevice_ItemStoreBeacon
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_ItemStoreBeacon : public ATgDevice_TeamDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ItemStoreBeacon");
		return ptr;
	}


	void CustomFire();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	bool STATIC_IsTargetingModeReady(TEnumAsByte<EDeviceFailType>* failType);
	bool STATIC_IsTeamBeaconActive();
	bool STATIC_IsBeaconEnabled();
	class ATgRespawnBeaconExit* STATIC_GetBeaconExit();
};


// Class TgGame.TgDevice_Toggle
// 0x0004 (0x0A10 - 0x0A0C)
class ATgDevice_Toggle : public ATgDevice
{
public:
	unsigned long                                      m_bIsToggle : 1;                                          // 0x0A0C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Toggle");
		return ptr;
	}


	bool ShouldInterruptReload();
	void ConsumeAmmoFromFiring(int nAmmoConsumptionOverride, int nFireRequestIDOverride);
	bool StartFire();
	void STATIC_FireAmmunition();
	bool CanDeviceFireInTargetingMode();
	bool STATIC_IsToggleDevice();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	void STATIC_UpdateUIToggleState();
};


// Class TgGame.TgDevice_Mount
// 0x001C (0x0A2C - 0x0A10)
class ATgDevice_Mount : public ATgDevice_Toggle
{
public:
	unsigned long                                      m_bForceFireDueToRespawn : 1;                             // 0x0A10(0x0004)
	unsigned long                                      m_bDismountProtection : 1;                                // 0x0A10(0x0004)
	unsigned long                                      m_bAutoMounting : 1;                                      // 0x0A10(0x0004)
	float                                              m_fZoomDurationOverride;                                  // 0x0A14(0x0004) (Edit)
	TArray<class ATgDevice*>                           m_CachedInhands;                                          // 0x0A18(0x0010) (NeedCtorLink)
	float                                              m_fAutoMountDismountProtectionDuration;                   // 0x0A28(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Mount");
		return ptr;
	}


	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
	void STATIC_InterruptOtherDevices(class ATgPawn* TgP);
	void STATIC_EndEnteringMount(bool bEndingFireLoop);
	void SetMountedCollision(bool IsActive);
	void OutroLockoutTime();
	void AutoDismount();
	void AuthStartCooldown(int nMode, float fCooldownTimeOverride);
	bool STATIC_IsOwnerOnGround();
	bool STATIC_CanOwnerMount();
	void STATIC_FireAmmunition();
	bool ShouldMountCancelFiring();
	bool CanFiringBeCanceledByRightMouse();
	bool STATIC_IsItemShopVolumeBlockingDismounting();
	bool CanBeInterrupted();
	bool CanFiringBeCanceledByReactivation();
	bool CanBeCanceled();
	void STATIC_EndDismountProtection();
	void STATIC_DismountOnDamage(int DamageAmt);
	void ServerForceMount();
	void ClientStartMount();
	void ClientGiveUpMounting();
	void AllowMountServer();
	void SetAllowMountServerTimer();
	void OnOwnerRespawn();
	bool Use();
	bool STATIC_IsAnyDeviceOverridingDismount(int DamageAmt);
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	bool RequiresAmmoToFire();
	bool STATIC_IsDeviceFiringLockedForUI();
	float STATIC_GetFiringPreHitDelay(int nMode);
};


// Class TgGame.TgDevice_ToggleInhand
// 0x0018 (0x0A24 - 0x0A0C)
class ATgDevice_ToggleInhand : public ATgDevice
{
public:
	class ATgPawn*                                     m_CachedTgP;                                              // 0x0A0C(0x0008)
	float                                              m_fCurrentTransitionPct;                                  // 0x0A14(0x0004)
	int                                                m_nProjectilesFired;                                      // 0x0A18(0x0004)
	unsigned long                                      m_bWaitForOutro : 1;                                      // 0x0A1C(0x0004)
	float                                              m_fActiveSustainTime;                                     // 0x0A20(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ToggleInhand");
		return ptr;
	}


	void UpdateTransitionPct(float fDefaultPct);
	void StopFire();
	void ClientInterrupt(bool bServerFireFailed);
	void InterruptFiring(bool bServerFireFailed);
	void STATIC_InitialFirePreHitDelay();
	void OutroTimer();
	void STATIC_SustainTimer();
	void STATIC_IntroTimer();
	void StartOutroTimer(float fDuration);
	void STATIC_StartSustainTimer();
	void StartIntroTimer(float fDuration);
	void STATIC_FireAmmunition();
	bool CanDeviceStartFiringNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDebugRelevant, bool bIgnoreCachedValue, TEnumAsByte<EDeviceFailType>* failType);
	bool CanToggleDeviceStopFiring();
	bool CanBeInterrupted();
	bool CanBeCanceled();
	float STATIC_GetBaseBuildupTime();
	class ATgPawn* STATIC_GetCachedTgP();
	float STATIC_GetFiringPostHitDelay(int nMode);
	float STATIC_GetFiringPreHitDelay(int nMode);
	float GetBuildupTime();
	bool STATIC_IsToggleDevice();
};


// Class TgGame.TgDevice_ToggleInhandFiremode
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_ToggleInhandFiremode : public ATgDevice
{
public:
	class ATgDevice*                                   m_CachedInhand;                                           // 0x0A0C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ToggleInhandFiremode");
		return ptr;
	}


	bool ShouldCooldownAfterFire();
	void STATIC_SyncFireModeWithServer(int m_nClientFireMode);
	void STATIC_FireAmmunition();
	bool ShouldStopActionOnOffhandSlotReleased();
	bool ShouldInterruptReloadOnFire();
	bool STATIC_HasCachedInhand();
};


// Class TgGame.TgDevice_TotemMod
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_TotemMod : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_TotemMod");
		return ptr;
	}

};


// Class TgGame.TgDevice_HealingRain
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_HealingRain : public ATgDevice_TotemMod
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_HealingRain");
		return ptr;
	}

};


// Class TgGame.TgDevice_MonolithTotem
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_MonolithTotem : public ATgDevice_TotemMod
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_MonolithTotem");
		return ptr;
	}

};


// Class TgGame.TgDevice_Outreach
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_Outreach : public ATgDevice_TotemMod
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Outreach");
		return ptr;
	}

};


// Class TgGame.TgDevice_WindTotem
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_WindTotem : public ATgDevice_TotemMod
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_WindTotem");
		return ptr;
	}

};


// Class TgGame.TgDevice_TurretMod
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_TurretMod : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_TurretMod");
		return ptr;
	}

};


// Class TgGame.TgDevice_HealingStation
// 0x000C (0x0A18 - 0x0A0C)
class ATgDevice_HealingStation : public ATgDevice_TurretMod
{
public:
	float                                              m_fFireTimer;                                             // 0x0A0C(0x0004)
	class ATgPawn*                                     m_CachedPawnOwner;                                        // 0x0A10(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_HealingStation");
		return ptr;
	}

};


// Class TgGame.TgDevice_MegaTurret
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_MegaTurret : public ATgDevice_TurretMod
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_MegaTurret");
		return ptr;
	}

};


// Class TgGame.TgDevice_WallClimb
// 0x0058 (0x0A64 - 0x0A0C)
class ATgDevice_WallClimb : public ATgDevice
{
public:
	class ATgPawn_Koga*                                m_CachedKoga;                                             // 0x0A0C(0x0008)
	struct FVector                                     m_vWallSimilarityTestNormal;                              // 0x0A14(0x000C)
	struct FVector                                     m_vCurrentWallClimbNormal;                                // 0x0A20(0x000C)
	unsigned long                                      m_bIsWallClimbing : 1;                                    // 0x0A2C(0x0004)
	unsigned long                                      r_bWantsWallClimb : 1;                                    // 0x0A2C(0x0004)
	unsigned long                                      m_bRequiresBaseable : 1;                                  // 0x0A2C(0x0004)
	unsigned long                                      m_bRequiresStepUpOn : 1;                                  // 0x0A2C(0x0004)
	unsigned long                                      m_bHitStepUpOn : 1;                                       // 0x0A2C(0x0004)
	unsigned long                                      m_bHitCanBase : 1;                                        // 0x0A2C(0x0004)
	unsigned long                                      m_bHitWorldGeometry : 1;                                  // 0x0A2C(0x0004)
	unsigned long                                      m_bGeometryTestResult : 1;                                // 0x0A2C(0x0004)
	float                                              m_fWallMagnetMovePerSec;                                  // 0x0A30(0x0004) (Edit)
	float                                              m_fWallClimbVertOffset;                                   // 0x0A34(0x0004)
	float                                              m_fWallNormalSimilarityThreshold;                         // 0x0A38(0x0004)
	float                                              m_fAngularThreshold;                                      // 0x0A3C(0x0004)
	float                                              m_fVelocityThreshold;                                     // 0x0A40(0x0004)
	float                                              m_fWallClimbSpeed;                                        // 0x0A44(0x0004)
	float                                              m_fWallGeometryNormalOffset;                              // 0x0A48(0x0004)
	float                                              m_fPostAbortLockout;                                      // 0x0A4C(0x0004)
	float                                              m_fMaxWallClimbTime;                                      // 0x0A50(0x0004)
	float                                              m_fGeometryTestPeriod;                                    // 0x0A54(0x0004)
	float                                              m_fWallClimbLockoutJumpVelocity;                          // 0x0A58(0x0004)
	float                                              m_fWallJumpZSpeed;                                        // 0x0A5C(0x0004) (Edit)
	float                                              m_fWallClimbTime;                                         // 0x0A60(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_WallClimb");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	bool STATIC_IsWallClimbingLockedOut();
	bool STATIC_DoWallNormalAndLookAgree(const struct FVector& vNormal);
	float STATIC_GetWallClimbAngularThreshold();
	float STATIC_GetWallClimbVelocityThreshold();
	void AbortWallClimb();
	bool ShouldBlockReload(class ATgDevice* Dev, bool bIsAutoReload);
};


// Class TgGame.TgDeviceFire
// 0x0208 (0x0268 - 0x0060)
class UTgDeviceFire : public UObject
{
public:
	class AActor*                                      m_Owner;                                                  // 0x0060(0x0008)
	TEnumAsByte<EWeaponFireType>                       m_nFireType;                                              // 0x0068(0x0001)
	TEnumAsByte<EDeviceTargetMode>                     m_eTargetingMode;                                         // 0x0069(0x0001)
	TEnumAsByte<EDeviceTargeterType>                   m_eTargeterType;                                          // 0x006A(0x0001)
	TEnumAsByte<ETargetSelectionType>                  m_eTargetSelectionTypeOverride;                           // 0x006B(0x0001)
	unsigned long                                      m_bIsAOE : 1;                                             // 0x006C(0x0004)
	unsigned long                                      m_bIsCone : 1;                                            // 0x006C(0x0004)
	unsigned long                                      m_bIsLinear : 1;                                          // 0x006C(0x0004)
	unsigned long                                      m_bContinuousFire : 1;                                    // 0x006C(0x0004)
	unsigned long                                      m_bRequireLOS : 1;                                        // 0x006C(0x0004)
	unsigned long                                      m_bVerifyTargetPlacement : 1;                             // 0x006C(0x0004)
	unsigned long                                      m_bAllowMultiplePets : 1;                                 // 0x006C(0x0004)
	unsigned long                                      m_bUseAccurateEncroachment : 1;                           // 0x006C(0x0004) (Const)
	unsigned long                                      m_bUseTargetingEncroachmentActor : 1;                     // 0x006C(0x0004) (Const)
	unsigned long                                      m_bScaleEncroachmentWithRangeMod : 1;                     // 0x006C(0x0004) (Const)
	unsigned long                                      m_bPassThroughShield : 1;                                 // 0x006C(0x0004) (Const)
	unsigned long                                      m_bPassThroughDeployWalls : 1;                            // 0x006C(0x0004) (Const)
	unsigned long                                      m_bIgnoreDeployablesForBlocking : 1;                      // 0x006C(0x0004) (Const)
	unsigned long                                      m_bAdjustDeployHeightToExtent : 1;                        // 0x006C(0x0004)
	unsigned long                                      m_bDeployOnOwnerLocation : 1;                             // 0x006C(0x0004)
	unsigned long                                      m_bAdjustToGround : 1;                                    // 0x006C(0x0004)
	unsigned long                                      m_bSpawnPetOnOwnerLocation : 1;                           // 0x006C(0x0004)
	unsigned long                                      m_bCanTriggerCounter : 1;                                 // 0x006C(0x0004)
	unsigned long                                      m_bEncroachmentFireLOSCheck : 1;                          // 0x006C(0x0004)
	unsigned long                                      m_bEncroachmentIgnorePitch : 1;                           // 0x006C(0x0004)
	unsigned long                                      m_bEncroachmentDebug : 1;                                 // 0x006C(0x0004)
	unsigned long                                      m_bApplyThirdPersonReticleAimOffset : 1;                  // 0x006C(0x0004)
	unsigned long                                      m_bTreatAmmoAsCharges : 1;                                // 0x006C(0x0004)
	unsigned long                                      m_bMaintainBurstTarget : 1;                               // 0x006C(0x0004)
	unsigned long                                      m_bCanTargetStealthedTargets : 1;                         // 0x006C(0x0004)
	TArray<class UTgEffectGroup*>                      m_EffectGroupList;                                        // 0x0070(0x0010) (NeedCtorLink)
	TArray<struct FTgPropertyInstance>                 m_Properties;                                             // 0x0080(0x0010) (NeedCtorLink)
	struct FPointer                                    m_pAmSetup;                                               // 0x0090(0x0008) (Native)
	struct FPointer                                    m_pFireModeSetup;                                         // 0x0098(0x0008) (Native)
	int                                                m_nId;                                                    // 0x00A0(0x0004)
	int                                                m_nAttackType;                                            // 0x00A4(0x0004)
	int                                                m_nMovementType;                                          // 0x00A8(0x0004)
	struct FName                                       m_nmOffhandAnimationType;                                 // 0x00AC(0x0008)
	int                                                m_nTargetAffectsType;                                     // 0x00B4(0x0004)
	int                                                m_nAllowUseWhileFlags;                                    // 0x00B8(0x0004)
	int                                                m_nDamageType;                                            // 0x00BC(0x0004)
	int                                                m_nArcingJumps;                                           // 0x00C0(0x0004)
	struct FMap_Mirror                                 m_PropertyIndexMap;                                       // 0x00C4(0x0048) (Native)
	float                                              m_fHealthCost;                                            // 0x010C(0x0004)
	float                                              m_fManaCost;                                              // 0x0110(0x0004)
	float                                              m_fEnergyCost;                                            // 0x0114(0x0004)
	float                                              m_fFireTime;                                              // 0x0118(0x0004)
	float                                              m_fBuildupTime;                                           // 0x011C(0x0004)
	float                                              m_fFirePreHitDelay;                                       // 0x0120(0x0004)
	float                                              m_fFirePostHitDelay;                                      // 0x0124(0x0004)
	int                                                m_nShotsPerFire;                                          // 0x0128(0x0004)
	struct FName                                       m_nmDamageTypeClass;                                      // 0x012C(0x0008)
	class UClass*                                      m_DamageTypeClass;                                        // 0x0134(0x0008)
	int                                                m_nMaxTargetCount;                                        // 0x013C(0x0004)
	float                                              m_fFireLockTime;                                          // 0x0140(0x0004)
	int                                                m_nAmmoClipSize;                                          // 0x0144(0x0004)
	float                                              m_fAmmoClipPreReloadTime;                                 // 0x0148(0x0004)
	float                                              m_fAmmoClipPostReloadTime;                                // 0x014C(0x0004)
	int                                                m_nAmmoCostPerShot;                                       // 0x0150(0x0004)
	int                                                m_nDeviceIdOverrideForDamageReports;                      // 0x0154(0x0004)
	float                                              m_fEncroachmentRayCastVerticalOffset;                     // 0x0158(0x0004) (Const)
	int                                                m_nTargetingEncroachmentActorOverride;                    // 0x015C(0x0004) (Const)
	class AActor*                                      m_TargetingEncroachmentActor;                             // 0x0160(0x0008) (Transient)
	struct FVector                                     m_vActorEncroachmentBaseScale;                            // 0x0168(0x000C) (Const)
	struct FName                                       m_nmWhileFiringCameraAnim;                                // 0x0174(0x0008)
	struct FRotator                                    m_AdjustToGroundRotationOffset;                           // 0x017C(0x000C)
	int                                                m_nCachedFireModeIndex;                                   // 0x0188(0x0004)
	TArray<class UTgEffect*>                           m_CachedRechargeBonusFlatAdditive;                        // 0x018C(0x0010) (NeedCtorLink)
	TArray<class UTgEffect*>                           m_CachedRechargeBonusFlatSubtractive;                     // 0x019C(0x0010) (NeedCtorLink)
	TArray<class UTgEffect*>                           m_CachedRechargeBonusPercentAdditive;                     // 0x01AC(0x0010) (NeedCtorLink)
	TArray<class UTgEffect*>                           m_CachedRechargeBonusPercentSubtractive;                  // 0x01BC(0x0010) (NeedCtorLink)
	TArray<class UTgEffect*>                           m_ModifiedEffects;                                        // 0x01CC(0x0010) (NeedCtorLink)
	TArray<float>                                      m_BaseValues;                                             // 0x01DC(0x0010) (NeedCtorLink)
	TArray<class UTgEffectGroup*>                      m_ModifiedEGLifetimes;                                    // 0x01EC(0x0010) (NeedCtorLink)
	TArray<float>                                      m_BaseLifetimes;                                          // 0x01FC(0x0010) (NeedCtorLink)
	TArray<class UTgEffectGroup*>                      m_ModifiedEGAppValues;                                    // 0x020C(0x0010) (NeedCtorLink)
	TArray<float>                                      m_BaseAppValues;                                          // 0x021C(0x0010) (NeedCtorLink)
	TArray<class UTgEffectGroup*>                      m_ModifiedEGMaxStacks;                                    // 0x022C(0x0010) (NeedCtorLink)
	TArray<float>                                      m_BaseMaxStacks;                                          // 0x023C(0x0010) (NeedCtorLink)
	TArray<class AActor*>                              m_CachedTargetList;                                       // 0x024C(0x0010) (NeedCtorLink)
	float                                              m_fSelectTargetsExtent;                                   // 0x025C(0x0004)
	class UTgGameplayCurves*                           m_GameplayCurves;                                         // 0x0260(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire");
		return ptr;
	}


	bool ShouldBlockEffectGroup(class UTgEffectGroup* effectGroup);
	bool CanSimulateTeleportFire();
	int GetNumArcJumps();
	float GetConeAttackAngleOffset();
	float GetSignedConeAttackAngle();
	float GetConeAttackAngle();
	float GetContagiousRadius();
	float GetMinCooldownTime();
	float GetFireLockTime();
	float GetBuildupTime();
	void SubmitWhileDeadEffects(class AActor* DamageInstigator, const struct FImpactInfo& Impact);
	void SubmitFinalBlowEffects(class AActor* DamageInstigator, const struct FImpactInfo& Impact);
	void SubmitHitEffects(class AActor* DamageInstigator, const struct FImpactInfo& Impact, int nType);
	void STATIC_HandleSuccessfulHit(class AActor* DamageInstigator, class APawn* OwnerInstigator, const struct FImpactInfo& Impact);
	void STATIC_HandleMiss();
	bool ApplyHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
	void TrackDeviceModeHit(class ATgPawn* Hitter, float fDistance, bool bHitPlayer);
	void RemoveHitSpecial(class AActor* Target, bool bForceRemove, int nHitSpecialSituationalType, int StackCount, class AActor* InstigatorOverride);
	void ApplyHitSpecial(class AActor* Target, const struct FImpactInfo& Impact, int nHitSpecialSituationalType, int StackCount, class AActor* InstigatorOverride);
	void RemoveEffectType(class AActor* Target, bool bForceRemove, int nEffectGroupType, int StackCount);
	void ApplyEffectType(class AActor* Target, int nEffectGroupType, const struct FImpactInfo& Impact, int StackCount);
	void STATIC_DisplayMessage(const struct FString& sMessage);
	void RemoveModifyEffects();
	void ApplyModifyEffects(class UTgEffectGroup* effectGroup);
	void SubmitEffect(const struct FImpactInfo& Impact, class UTgEffectGroup* effectGroup, bool bRemove, int StackCount, class AActor* InstigatorOverride);
	void RemoveEquipEffects();
	void ApplyEquipEffects();
	struct FTgPropertyInstance STATIC_NativeGetPropertyInstance(int nPropertyId);
	int STATIC_GetFireModeIndex();
	int STATIC_GetShotsPerFire();
	float STATIC_GetBasePropertyValueById(int nPropertyId);
	float STATIC_GetScaledPropertyValueByRef(int nDeviceLevel, struct FTgPropertyInstance* PropInst);
	float STATIC_GetScaledPropertyValueById(int nPropertyId, int nDeviceLevel);
	class UTgGameplayCurves* STATIC_GetCurrentGameplayCurves();
	struct FVector STATIC_GetAlternateAOEStartTrace(class AActor* DamageInstigator, float Radius, struct FVector* Center);
	struct FWeaponFireResults CalcActorEncroachmentTargetingFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, float RewindTime, TArray<struct FImpactInfo>* ImpactList, TArray<struct FImpactToValidate>* ImpactsToValidate);
	struct FImpactInfo CalcChargeTargetingFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
	struct FImpactInfo CalcDeployableTargetingFire(class AActor* DamageInstigator, const struct FAimData& Aim, int nDeployableId, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
	struct FImpactInfo CalcLinearFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
	struct FImpactInfo CalcArcingFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
	struct FWeaponFireResults CalcInstantFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, bool bNoBodyShotCheck, float RewindTime, TArray<struct FImpactInfo>* ImpactList, TArray<struct FImpactToValidate>* ImpactsToValidate);
	struct FImpactInfo CalcAoeFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, float RewindTime, TArray<struct FImpactInfo>* ImpactList);
	struct FImpactInfo CalcSliceFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bUseRange, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
	struct FImpactInfo CalcConeFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bUseRange, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
	struct FWeaponFireResults CalcWeaponModeFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, bool bNoBodyShotCheck, float RewindTime, TArray<struct FImpactInfo>* ImpactList, TArray<struct FImpactToValidate>* ImpactsToValidate);
	bool CheckValidTarget(class AActor* Target, bool bPredicting);
	bool STATIC_IsInCone(class AActor* SourceActor, class AActor* TargetActor, const struct FVector& StartCone, const struct FVector& ConeDir, float ConeAngle);
	bool STATIC_IsInSlice(class AActor* SourceActor, class AActor* TargetActor, const struct FVector& StartCone, const struct FVector& ConeDir, float ConeAngle, float ConeRadius);
	bool ShouldAddToImpactList(class AActor* HitActor, TArray<struct FImpactInfo> ImpactList);
	struct FVector STATIC_GetHitLocationToCenter(struct FVector* StartTrace, struct FVector* TargetLocation, struct FVector* targetExtent);
	struct FVector STATIC_GetHitLocationFlat(struct FVector* StartTrace, struct FVector* TargetLocation, struct FVector* targetExtent);
	bool STATIC_IgnoreTargetForBlocking(class AActor* Target);
	class AActor* STATIC_IsBlockedByBlocker(class AActor* DamageInstigator, class AActor* Target, const struct FVector& OriginLocation, const struct FVector& TargetLocation);
	TEnumAsByte<EDeviceTargetMode> STATIC_GetTargetingMode();
	void AddEffectiveRangeReduction(class AActor* DamageInstigator, const struct FVector& OriginLocation, bool bUseRadius, struct FImpactInfo* Impact);
	float STATIC_GetShotPowerCost(int nPacingType);
	bool STATIC_UsesActorEncroachmentForCalcTargetingFire();
	bool STATIC_IsArcingAttack();
	struct FImpactInfo STATIC_GetTraceImpact(const struct FVector& StartTrace, const struct FVector& EndTrace, const struct FVector& Extent, bool bIgnoreWorld, bool bCheckLockOn, bool bForceNoBodyShotCheck, float RewindTime, int nShotIndex, TArray<struct FImpactToValidate>* ImpactsToValidate);
	struct Fdword STATIC_GetTraceFlags(bool bIgnoreWorld);
	bool IsEnemy(class AActor* TargetActor);
	bool STATIC_IsSelfOrOwner(class AActor* Target);
	bool STATIC_IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth, bool bInvertTeam);
	bool CheckTeamPassThrough(class AActor* HitActor, const struct FVector& aimDirection);
	float STATIC_GetPostHitDelay();
	float STATIC_GetPreHitDelay();
	float STATIC_GetRefireTime();
	float STATIC_GetCustomValue5();
	float STATIC_GetCustomValue4();
	float STATIC_GetCustomValue3();
	float STATIC_GetCustomValue2();
	float STATIC_GetCustomValue1();
	bool STATIC_IsWithinEffectiveRange(float fDistance);
	bool STATIC_IsWithinRange(float fDistance);
	float STATIC_GetBonusShieldDamagePerc();
	float STATIC_GetHeadShotDamage();
	float STATIC_GetMaxDeployableCount();
	float STATIC_GetMinimumRadius();
	float STATIC_GetEffectiveRange();
	float GetCooldownTime();
	float STATIC_GetMinRange();
	float GetRange();
	float STATIC_GetProximityDistance();
	float STATIC_GetVisionRange();
	float STATIC_GetProjectileSpeed();
	float STATIC_GetDeployTime();
	float STATIC_GetFireAngle();
	float STATIC_GetPetLifeSpan();
	float STATIC_GetPersistPulse();
	float GetPersistTime();
	float STATIC_GetEffectiveRadius();
	float STATIC_GetPostLandDuration();
	float STATIC_GetRemoteActivationTime();
	float STATIC_GetAIRadius();
	float STATIC_GetAIRange();
	float STATIC_GetDamageRadius();
	bool STATIC_LogDebugInfo();
	void STATIC_VerifyProjectile();
	struct FName QueryClass(int nMode);
	class UTgEffectGroup* STATIC_GetEffectGroup(int nType, int* nIndex);
	bool SupportsEffectSimulation();
	float STATIC_GetPropertyValueById(int nPropertyId, int nPropertyIndex);
	float STATIC_GetPropertyValue(int nPropertyId);
	void SetPropertyInstance(struct FTgPropertyInstance* prop);
	void SetProperty(int nPropertyId, float fNewValue);
	struct FTgPropertyInstance STATIC_GetProperty(int nPropertyId);
	void TeleportFire();
	void CustomFire();
	bool STATIC_GetPetLocationAndRotation(const struct FPointer& botSetup, struct FVector* OutLocation, struct FRotator* OutRotation);
	class ATgPawn* SpawnPet(bool bPet);
	class AActor* STATIC_GetDeployableBase();
	bool STATIC_GetDeployLocationAndRotation(struct FVector* OutLocation, struct FRotator* OutRotation);
	void Deploy();
	void DeployAtLocation(const struct FVector& SpawnLocation, const struct FRotator& SpawnRotation);
	void DeployAtActor(class AActor* TargetActor);
	void STATIC_InitializeProjectile(class AProjectile* Proj, int ProjectileIdOverride);
	class UClass* STATIC_GetProjectileClass();
	void SpecialShieldDestroyed();
};


// Class TgGame.TgDeviceFire_BonusShieldDamage
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_BonusShieldDamage : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_BonusShieldDamage");
		return ptr;
	}


	float STATIC_GetBonusShieldDamagePerc();
};


// Class TgGame.TgDeviceFire_Cylinder
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_Cylinder : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Cylinder");
		return ptr;
	}


	struct FImpactInfo CalcAoeFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, float RewindTime, TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgDeviceFire_DamageVolume
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_DamageVolume : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_DamageVolume");
		return ptr;
	}


	bool STATIC_IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth, bool bInvertTeam);
};


// Class TgGame.TgDeviceFire_DeployablesOnly
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_DeployablesOnly : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_DeployablesOnly");
		return ptr;
	}


	bool STATIC_IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth, bool bInvertTeam);
};


// Class TgGame.TgDeviceFire_DeployAsIfProjectile
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_DeployAsIfProjectile : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_DeployAsIfProjectile");
		return ptr;
	}


	bool STATIC_GetDeployLocationAndRotation(struct FVector* OutLocation, struct FRotator* OutRotation);
};


// Class TgGame.TgDeviceFire_DeployOnLocation
// 0x001C (0x0284 - 0x0268)
class UTgDeviceFire_DeployOnLocation : public UTgDeviceFire
{
public:
	struct FVector                                     m_TargetLocation;                                         // 0x0268(0x000C)
	unsigned long                                      m_bSetRotation : 1;                                       // 0x0274(0x0004)
	struct FRotator                                    m_TargetRotation;                                         // 0x0278(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_DeployOnLocation");
		return ptr;
	}


	bool STATIC_GetDeployLocationAndRotation(struct FVector* OutLocation, struct FRotator* OutRotation);
};


// Class TgGame.TgDeviceFire_DeployOnTarget
// 0x000C (0x0274 - 0x0268)
class UTgDeviceFire_DeployOnTarget : public UTgDeviceFire
{
public:
	class AActor*                                      m_TargetHit;                                              // 0x0268(0x0008)
	unsigned long                                      m_bDeployAtFeet : 1;                                      // 0x0270(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_DeployOnTarget");
		return ptr;
	}


	class AActor* STATIC_GetDeployableBase();
	bool STATIC_GetDeployLocationAndRotation(struct FVector* OutLocation, struct FRotator* OutRotation);
};


// Class TgGame.TgDeviceFire_EncroachmentActorScale
// 0x000C (0x0274 - 0x0268)
class UTgDeviceFire_EncroachmentActorScale : public UTgDeviceFire
{
public:
	struct FVector                                     m_vBaseDimensions;                                        // 0x0268(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_EncroachmentActorScale");
		return ptr;
	}


	void STATIC_UpdateEncroachmentActorScale();
};


// Class TgGame.TgDeviceFire_EncroachmentFireCone
// 0x0010 (0x0278 - 0x0268)
class UTgDeviceFire_EncroachmentFireCone : public UTgDeviceFire
{
public:
	struct FVector                                     m_vBaseDimensions;                                        // 0x0268(0x000C)
	unsigned long                                      m_bBlockedByWorldOnly : 1;                                // 0x0274(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_EncroachmentFireCone");
		return ptr;
	}


	void STATIC_UpdateEncroachmentActorScale();
	bool STATIC_IgnoreTargetForBlocking(class AActor* Target);
};


// Class TgGame.TgDeviceFire_CustomEffect
// 0x0000 (0x0278 - 0x0278)
class UTgDeviceFire_CustomEffect : public UTgDeviceFire_EncroachmentFireCone
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_CustomEffect");
		return ptr;
	}


	void EffectCustom(class ATgPawn* Instigator, class ATgPawn* Target, int nHitSpecialSituationalType, float fValue, bool bAddToBase);
	void STATIC_SubmitEffectCustom(class ATgPawn* Instigator, class ATgPawn* Target, class UTgEffectGroup* effectGroup, const struct FImpactInfo& Impact, int nHitSpecialSituationalType, float fValue, bool bAddToBase);
};


// Class TgGame.TgDeviceFire_IgnoreCCImmune
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_IgnoreCCImmune : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_IgnoreCCImmune");
		return ptr;
	}


	bool STATIC_IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth, bool bInvertTeam);
};


// Class TgGame.TgDeviceFire_IgnoreCounter
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_IgnoreCounter : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_IgnoreCounter");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_IgnoreEthereal
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_IgnoreEthereal : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_IgnoreEthereal");
		return ptr;
	}


	bool STATIC_IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth, bool bInvertTeam);
};


// Class TgGame.TgDeviceFire_IgnorePets
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_IgnorePets : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_IgnorePets");
		return ptr;
	}


	bool STATIC_IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth, bool bInvertTeam);
};


// Class TgGame.TgDeviceFire_IgnoreReversal
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_IgnoreReversal : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_IgnoreReversal");
		return ptr;
	}


	bool STATIC_IgnoreTargetForBlocking(class AActor* Target);
};


// Class TgGame.TgDeviceFire_Melee
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_Melee : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Melee");
		return ptr;
	}


	bool ShouldAddToImpactList(class AActor* HitActor, TArray<struct FImpactInfo> ImpactList);
	bool STATIC_IgnoreTargetForBlocking(class AActor* Target);
};


// Class TgGame.TgDeviceFire_MirrorDamageToHeal
// 0x0004 (0x026C - 0x0268)
class UTgDeviceFire_MirrorDamageToHeal : public UTgDeviceFire
{
public:
	float                                              m_fHealAmount;                                            // 0x0268(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_MirrorDamageToHeal");
		return ptr;
	}


	void SubmitEffect(const struct FImpactInfo& Impact, class UTgEffectGroup* effectGroup, bool bRemove, int StackCount, class AActor* InstigatorOverride);
};


// Class TgGame.TgDeviceFire_MirrorDamageToHealBlock
// 0x0004 (0x026C - 0x0268)
class UTgDeviceFire_MirrorDamageToHealBlock : public UTgDeviceFire
{
public:
	float                                              m_fHealBlockAmount;                                       // 0x0268(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_MirrorDamageToHealBlock");
		return ptr;
	}


	void SubmitEffect(const struct FImpactInfo& Impact, class UTgEffectGroup* effectGroup, bool bRemove, int StackCount, class AActor* InstigatorOverride);
};


// Class TgGame.TgDeviceFire_Mount
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_Mount : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Mount");
		return ptr;
	}


	float STATIC_GetPreHitDelay();
};


// Class TgGame.TgDeviceFire_OwningPawnOnly
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_OwningPawnOnly : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_OwningPawnOnly");
		return ptr;
	}


	bool STATIC_IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth, bool bInvertTeam);
};


// Class TgGame.TgDeviceFire_PetsOnly
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_PetsOnly : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_PetsOnly");
		return ptr;
	}


	bool STATIC_IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth, bool bInvertTeam);
};


// Class TgGame.TgDeviceFire_ShieldsOnly
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_ShieldsOnly : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_ShieldsOnly");
		return ptr;
	}


	bool STATIC_IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth, bool bInvertTeam);
};


// Class TgGame.TgDeviceFire_Spray
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_Spray : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Spray");
		return ptr;
	}


	struct FWeaponFireResults CalcWeaponModeFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, bool bNoBodyShotCheck, float RewindTime, TArray<struct FImpactInfo>* ImpactList, TArray<struct FImpactToValidate>* ImpactsToValidate);
};


// Class TgGame.TgDeviceFire_WorldLOSOnly
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_WorldLOSOnly : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_WorldLOSOnly");
		return ptr;
	}


	bool STATIC_IgnoreTargetForBlocking(class AActor* Target);
};


// Class TgGame.TgDeviceForm
// 0x022C (0x028C - 0x0060)
class UTgDeviceForm : public UObject
{
public:
	struct FPointer                                    VfTable_FCallbackEventDevice;                             // 0x0060(0x0008) (Const, Native, NoExport)
	class ATgPawn*                                     PawnOwner;                                                // 0x0068(0x0008)
	struct FEquipDeviceInfo                            c_EquipDeviceInfo;                                        // 0x0070(0x000C)
	int                                                m_nDeviceType;                                            // 0x007C(0x0004)
	TEnumAsByte<EDeviceTargetMode>                     m_eTargetingMode;                                         // 0x0080(0x0001)
	TEnumAsByte<ETargetingModeStatus>                  c_eTargetingModeStatus;                                   // 0x0081(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x0082(0x0002) MISSED OFFSET
	unsigned long                                      c_bDeployed : 1;                                          // 0x0084(0x0004)
	unsigned long                                      c_bHandDevice : 1;                                        // 0x0084(0x0004)
	unsigned long                                      c_bDisableDefaultTimelapseRecovery : 1;                   // 0x0084(0x0004)
	unsigned long                                      c_bIsTransitioningToNewMode : 1;                          // 0x0084(0x0004)
	unsigned long                                      c_bTargetingModeEnabled : 1;                              // 0x0084(0x0004)
	unsigned long                                      c_bTargeterInitializedThisTick : 1;                       // 0x0084(0x0004)
	unsigned long                                      c_bTargeterIsInWorldDPG : 1;                              // 0x0084(0x0004)
	unsigned long                                      c_bUseInstigatorMesh : 1;                                 // 0x0084(0x0004)
	unsigned long                                      c_bIsInHand : 1;                                          // 0x0084(0x0004)
	unsigned long                                      m_bInitializingAssets : 1;                                // 0x0084(0x0004)
	unsigned long                                      m_bLoopWhileFiringCameraAnim : 1;                         // 0x0084(0x0004)
	unsigned long                                      m_bUseImpactFXOverride : 1;                               // 0x0084(0x0004)
	unsigned long                                      m_bRecoilTimerActive : 1;                                 // 0x0084(0x0004)
	unsigned long                                      m_bForce1pViewWhileFiring : 1;                            // 0x0084(0x0004) (Transient)
	unsigned long                                      m_bForce3PViewWhileFiring : 1;                            // 0x0084(0x0004) (Transient)
	unsigned long                                      m_bForce3PViewInBuildup : 1;                              // 0x0084(0x0004) (Transient)
	TArray<class UAnimSet*>                            c_PawnAnimSetOverrideList;                                // 0x0088(0x0010) (NeedCtorLink)
	TArray<struct FModeData>                           ModeDatas;                                                // 0x0098(0x0010) (NeedCtorLink)
	struct FPointer                                    m_pAmSetup;                                               // 0x00A8(0x0008) (Native)
	class UMeshComponent*                              c_Mesh;                                                   // 0x00B0(0x0008) (ExportObject, Component, EditInline)
	class UMeshComponent*                              c_AttachedMesh;                                           // 0x00B8(0x0008) (ExportObject, Component, EditInline)
	class UMeshComponent*                              c_ThirdPersonMesh;                                        // 0x00C0(0x0008) (ExportObject, Component, EditInline)
	class UTgSkeletalMeshComponent*                    c_FirstPersonMesh;                                        // 0x00C8(0x0008) (ExportObject, Component, EditInline)
	struct FName                                       c_nmMountPoint;                                           // 0x00D0(0x0008)
	struct FName                                       FormState;                                                // 0x00D8(0x0008)
	int                                                c_nFireMode;                                              // 0x00E0(0x0004)
	int                                                c_nEquipSlot;                                             // 0x00E4(0x0004)
	float                                              c_fLastReceivedRefireTime;                                // 0x00E8(0x0004)
	float                                              c_fLastFireTimestamp;                                     // 0x00EC(0x0004)
	int                                                c_nLastFxMode;                                            // 0x00F0(0x0004)
	class ATgSkeletalMeshActor*                        c_TargetingModeMeshIndicator;                             // 0x00F4(0x0008)
	class UTgSpecialFx*                                c_TargetingModeFx;                                        // 0x00FC(0x0008)
	struct FAimData                                    c_TargetingAim;                                           // 0x0104(0x0034)
	int                                                c_nTargetingModeFxId;                                     // 0x0138(0x0004)
	float                                              c_fRemainingTransitionTime;                               // 0x013C(0x0004)
	float                                              c_fTotalTransitionTime;                                   // 0x0140(0x0004)
	class AActor*                                      m_LockedTarget;                                           // 0x0144(0x0008)
	class UObjectReferencer*                           m_AssetReference;                                         // 0x014C(0x0008)
	class AActor*                                      m_OwnerActor;                                             // 0x0154(0x0008)
	TArray<class UTgAnimNodeBlendByAbilitySimple*>     m_AbilityBlendList1P;                                     // 0x015C(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeBlendByAbilitySimple*>     m_AbilityBlendList3P;                                     // 0x016C(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeChannelFire*>              m_ChannelFireBlendList1P;                                 // 0x017C(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeChannelFire*>              m_ChannelFireBlendList3P;                                 // 0x018C(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeTargeting*>                m_TargetingBlendList1P;                                   // 0x019C(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeTargeting*>                m_TargetingBlendList3P;                                   // 0x01AC(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeToggleWithTransition*>     m_ToggleTransitionNodes1P;                                // 0x01BC(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeToggleWithTransition*>     m_ToggleTransitionNodes3P;                                // 0x01CC(0x0010) (NeedCtorLink)
	TArray<class UTgAnimBlendByAmmo*>                  m_AmmoBlendList1P;                                        // 0x01DC(0x0010) (NeedCtorLink)
	TArray<class UTgAnimBlendByAmmo*>                  m_AmmoBlendList3P;                                        // 0x01EC(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeSequence_SyncToCooldown*>  m_CooldownSyncNode1P;                                     // 0x01FC(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeSequence_SyncToCooldown*>  m_CooldownSyncNode3P;                                     // 0x020C(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeBlendByDeviceEquipped*>    m_DeviceEquippedNode1P;                                   // 0x021C(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeBlendByDeviceEquipped*>    m_DeviceEquippedNode3P;                                   // 0x022C(0x0010) (NeedCtorLink)
	class UCameraAnimInst*                             m_WhileFiringCameraAnimInst;                              // 0x023C(0x0008)
	float                                              m_fWhileFiringCameraAnimBlendInTime;                      // 0x0244(0x0004)
	float                                              m_fWhileFiringCameraAnimBlendOutTime;                     // 0x0248(0x0004)
	struct FPointer                                    m_RandomShotSpreadStream;                                 // 0x024C(0x0008) (Const, Native, Transient)
	int                                                m_nLastSetShotSpreadSeed;                                 // 0x0254(0x0004)
	int                                                m_nSyntheticVisualBurstRate;                              // 0x0258(0x0004)
	int                                                m_nSyntheticShotsRemaining;                               // 0x025C(0x0004) (Transient)
	float                                              m_fSyntheticShotRefireRate;                               // 0x0260(0x0004) (Transient)
	float                                              m_fSyntheticShotTimer;                                    // 0x0264(0x0004) (Transient)
	struct FSyntheticImpactEffectArgs                  m_SyntheticImpactArgs;                                    // 0x0268(0x0018)
	class UTgGameplayCurves*                           m_GameplayCurves;                                         // 0x0280(0x0008)
	float                                              m_fRecoilTimer;                                           // 0x0288(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm");
		return ptr;
	}


	void OnDestroyed();
	void OnRetrieveAnimDone();
	void RecoverDeviceState(TEnumAsByte<ETG_REP_DEVICE_STATE> DesiredState);
	void SetToggleState(bool IsActive);
	void PlayToggleTransitionAnimations(float transitionPercent, float totalTransitionTime, bool transitionToActive);
	void GotoFormState(const struct FName& NewState);
	void STATIC_EndCurrentState();
	void AttachAndDeploy_DA();
	void DeviceAnimNotify();
	void DoInterrupt();
	void CooldownComplete();
	void Cooldown(int nFireModeNum, float fCooldownTime);
	void Hit(int nFireMode, class AActor* Target, float fDamageAmount, const struct FVector& HitLocation, const struct FVector& HitNormal, struct FExtraDamageInfo* ExtraInfo);
	void RecoverFireMultiHitLocations(float fDistUnit, int nSeed, float fSpreadAngle, int nNumShots, TArray<struct FVector>* vHitLocations, struct FVector* vAimStart, struct FVector* vAimDir, unsigned char* hitRanges);
	void FireMultiUnpacked(TArray<struct FVector> vHitLocations, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime, float fPackedDistanceUnit);
	void FireMulti(const struct FVector& vAimStart, const struct FVector& vAimDir, int nFireMode, float fMaxRange, int nSeed, float fSpreadAngle, int nNumShots, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime, unsigned char* hitRanges);
	void Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	void StopFire(int nFireModeNum);
	void OnEndViewTarget(class APlayerController* PC);
	void StopWhileFiringCameraAnim(class APlayerController* PC, bool bImmediate);
	void StartWhileFiringCameraAnim(class APlayerController* PC, int nFireMode);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	bool STATIC_SetAmmoNodesOnStartFire();
	bool IsCurrentInHandWeapon();
	class UTgDeviceForm* STATIC_InHandWeaponForm();
	void BuildUp(int nFireMode, int nEquipSlot, int nSocketIndex, float fBuildupTime);
	void FireHoldFull(bool bIsFull);
	void InterruptTargeting();
	void EnterTargeting();
	void ExitTargetingMode();
	void NotifyTargetingModeStatusChange();
	void NotifyEnterTargetingMode();
	void NotifyExitTargetingMode(bool bDeployed);
	void EnterTargetingMode();
	void STATIC_InitializeTargetingModeFX();
	void STATIC_EndDevicePuttingDown();
	void BeginDeviceTakingOut(bool PlayEquipAnim);
	void BeginActive();
	void ParticleSystemDone(class UParticleSystemComponent* PSC);
	class UTgSpecialFx* STATIC_GetWeaponSpecialFx(const struct FName& nmFxName, int nEquipSlot, int nFireMode);
	void PlayTracerEffects(const struct FVector& endLocation, const struct FName& nmFxName, int nEquipSlot, int nFireMode);
	void PlayImpactEffects(const struct FVector& HitLocation, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, const struct FVector& FireOrigin, float fHitTraceDistOverride, bool bGenerateUpdatedHitLocation, bool bSyntheticFireEvent);
	int STATIC_GetFakedBurstRate();
	void SetTargetArcingBeamEffect(class AActor* Target);
	void SetSourceArcingBeamEffect(class AActor* Source);
	void OnCreated();
	void Generic5(unsigned char byExtraData);
	void Generic4(unsigned char byExtraData);
	void Generic3(unsigned char byExtraData);
	void Generic2(unsigned char byExtraData);
	void Generic1(unsigned char byExtraData);
	void STATIC_DisableChannelFireBlendNodes(bool bIsCooldownEnd);
	void SetAbilityBlendNodesActive(bool bActive, bool bOnFire, bool bIsInterrupted);
	void SetAmmoBlendNodesAmount(int nAmmoAmt, bool bTickOnly);
	void OnReload(float fReloadTime);
	void Cache1PAnimNodes(class UTgSkeletalMeshComponent* SkelComp);
	void Cache3PAnimNodes(class UTgSkeletalMeshComponent* SkelComp);
	void CacheAnimNode(class UAnimNode* Node, bool bIs3p);
	void ClearAnimNodes(bool bIs3p);
	int STATIC_GetAssemblyIdFromFiremode(int nFireMode, bool bFromProj);
	class ATgPawn* STATIC_GetPawnById(int nPawnId);
	void STATIC_GetAdjustedAim(struct FAimData* Aim);
	float STATIC_GetAccuracy();
	bool ShouldForce3P();
	bool ShouldForce1P();
	bool CanPlayBasicHitFx(class ATgPawn* Target);
	bool STATIC_UsesTargetingMode();
	void STATIC_UpdateFirstPersonWeaponFOV(const struct FVector2D& Resolution);
	void STATIC_RecalculateMaterial();
	void STATIC_UpdateTargetingModeLocation(const struct FVector& NewLocation, const struct FRotator& NewRotation, float DistanceScale);
	void STATIC_UpdateTargetingModeStatusForFX(class UTgSpecialFx* Fx, TEnumAsByte<ETargetingModeStatus> Status, struct FAimData* Aim);
	void STATIC_UpdateTargetingModeStatus(TEnumAsByte<ETargetingModeStatus> Status, struct FAimData* Aim);
	class UTgSpecialFx* SpawnSpecialFxIndependent(int nSpecialFxId, const struct FParticleChannelContainer& PSysChannels);
	void ResetAfterRagDoll();
	void Destruct(const struct FVector& vLocation);
	int STATIC_GetFormIndex();
	void DeactivateFxGroup(const struct FName& nmGroup);
	class UTgSpecialFx* ActivateFxIndependent(const struct FName& nmGroup, bool bSkipActivate, const struct FParticleChannelContainer& PSysChannels);
	void ActivateFxGroup(const struct FName& nmGroup);
	bool STATIC_LogDebugInfo();
	void STATIC_InitCameraViewpoint();
	void DetachInHandDevice_DA();
	void DetachDevice_DA(class USkeletalMeshComponent* ParentMesh, class UMeshComponent* AttachedMesh);
	bool AttachInHandDevice_DA(bool bFirstPerson);
	void AttachDevice_DA(class USkeletalMeshComponent* ParentMesh, class UMeshComponent* AttachedMesh, const struct FName& nmSocket);
	void SetFireMode(int nMode);
};


// Class TgGame.TgDeviceForm_BladesInhand
// 0x0000 (0x028C - 0x028C)
class UTgDeviceForm_BladesInhand : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_BladesInhand");
		return ptr;
	}


	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
};


// Class TgGame.TgDeviceForm_Emote
// 0x0020 (0x02AC - 0x028C)
class UTgDeviceForm_Emote : public UTgDeviceForm
{
public:
	TArray<class UTgAnimNodeEmoteSequence*>            m_CachedEmoteSequences;                                   // 0x028C(0x0010) (NeedCtorLink)
	TArray<class UTgAnimBlendByEmote*>                 m_CachedEmoteLists;                                       // 0x029C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Emote");
		return ptr;
	}


	void CacheAnimNode(class UAnimNode* Node, bool bIs3p);
	void ClearAnimNodes(bool bIs3p);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	void SetActiveEmote(int nEmoteId);
};


// Class TgGame.TgDeviceForm_Inhand
// 0x0010 (0x029C - 0x028C)
class UTgDeviceForm_Inhand : public UTgDeviceForm
{
public:
	int                                                m_nAmmoCount;                                             // 0x028C(0x0004)
	int                                                m_nMaxAmmoCount;                                          // 0x0290(0x0004)
	float                                              m_fPreviousAmmoPerc;                                      // 0x0294(0x0004)
	float                                              m_fCurrentAmmoPerc;                                       // 0x0298(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Inhand");
		return ptr;
	}


	void OnWeaponMeshUpdated();
	void STATIC_UpdateAmmoCountFx(float fPreviousPerc, float fCurrentPerc);
	void OnAmmoCountUpdated(int nAmmoCount, int nMaxAmmoCount);
};


// Class TgGame.TgDeviceForm_Latch
// 0x0038 (0x02C4 - 0x028C)
class UTgDeviceForm_Latch : public UTgDeviceForm
{
public:
	int                                                m_nCurrentLatchAsmId;                                     // 0x028C(0x0004)
	float                                              m_fMaxPullDelay;                                          // 0x0290(0x0004)
	float                                              m_fProjSpeed;                                             // 0x0294(0x0004)
	class ATgPropActor*                                m_LatchEndpoint;                                          // 0x0298(0x0008)
	class AActor*                                      m_BeamTarget;                                             // 0x02A0(0x0008)
	struct FVector                                     m_vBeamTargetLocation;                                    // 0x02A8(0x000C)
	struct FVector                                     m_vBeamTargetDirection;                                   // 0x02B4(0x000C)
	unsigned long                                      m_bLatchInterrupted : 1;                                  // 0x02C0(0x0004)
	unsigned long                                      m_bBeamActive : 1;                                        // 0x02C0(0x0004)
	unsigned long                                      m_bBeamAttached : 1;                                      // 0x02C0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Latch");
		return ptr;
	}


	void Generic1(unsigned char byExtraData);
	void StopFire(int nFireModeNum);
	void Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	void STATIC_DisconnectBeam();
	void ConnectBeamToTarget();
	void STATIC_SetBeamActive(bool bActive);
	void STATIC_UpdateBeamEndpoint(float DeltaTime);
	void STATIC_MoveBeamEndpoint(const struct FVector& vNewPosition);
	bool STATIC_UsesTargetingMode();
	void SetFireMode(int nMode);
	void STATIC_SetLatchAssembly(int nAsmId);
};


// Class TgGame.TgDeviceForm_Mount
// 0x0010 (0x029C - 0x028C)
class UTgDeviceForm_Mount : public UTgDeviceForm
{
public:
	TArray<class UAnimSet*>                            m_LoadedAnimSets;                                         // 0x028C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Mount");
		return ptr;
	}


	void StopFire(int nFireModeNum);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	void GetAnimSetStringsForBot(int PlayerBotId, TArray<struct FString>* sPaths);
	TEnumAsByte<EMountType> STATIC_GetMountType();
};


// Class TgGame.TgDeviceForm_SpinnerWhileFiring
// 0x002C (0x02B8 - 0x028C)
class UTgDeviceForm_SpinnerWhileFiring : public UTgDeviceForm
{
public:
	struct FName                                       m_SpinnerName;                                            // 0x028C(0x0008) (Const)
	unsigned long                                      m_bShouldSpinOnFire : 1;                                  // 0x0294(0x0004) (Const)
	TArray<class UTgSkelCon_Spinner*>                  m_SpinnerSkelControls1p;                                  // 0x0298(0x0010) (NeedCtorLink)
	TArray<class UTgSkelCon_Spinner*>                  m_SpinnerSkelControls3p;                                  // 0x02A8(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_SpinnerWhileFiring");
		return ptr;
	}


	void SetSpinnersRotationSpeedState(int nState);
	void SetSpinnersActive(bool bActive);
	void StopFire(int nFireModeNum);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	void CacheSpinner(class UTgSkeletalMeshComponent* SkelComp, TArray<class UTgSkelCon_Spinner*>* SpinnerSkelControls);
	void Cache3PAnimNodes(class UTgSkeletalMeshComponent* SkelComp);
	void Cache1PAnimNodes(class UTgSkeletalMeshComponent* SkelComp);
	void CacheSkelControls(class UAnimTree* pAnimTree, TArray<class UTgSkelCon_Spinner*>* SpinnerSkelControls);
};


// Class TgGame.TgDeviceForm_Spray
// 0x0050 (0x02DC - 0x028C)
class UTgDeviceForm_Spray : public UTgDeviceForm
{
public:
	TArray<class UMaterialInterface*>                  m_SprayMaterial;                                          // 0x028C(0x0010) (NeedCtorLink)
	class UMaterialInstanceConstant*                   m_SprayMIC;                                               // 0x029C(0x0008)
	class UDecalComponent*                             c_SpawnedDecal;                                           // 0x02A4(0x0008) (ExportObject, Component, EditInline)
	int                                                m_nRandAlphaMaskMax;                                      // 0x02AC(0x0004)
	int                                                m_nPrevAlphaMask;                                         // 0x02B0(0x0004)
	class UTgSpecialFx*                                c_SprayHitFX;                                             // 0x02B4(0x0008)
	class UTgSpecialFx*                                c_SprayMissedFX;                                          // 0x02BC(0x0008)
	TArray<struct FSpraySetup>                         m_SpraySetups;                                            // 0x02C4(0x0010) (AlwaysInit, NeedCtorLink)
	int                                                m_nActiveSpraySetup;                                      // 0x02D4(0x0004)
	int                                                m_nDesiredSprayDeviceId;                                  // 0x02D8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Spray");
		return ptr;
	}


	void OnDestroyed();
	void PlayImpactEffects(const struct FVector& HitLocation, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, const struct FVector& FireOrigin, float fHitTraceDistOverride, bool bGenerateUpdatedHitLocation, bool bSyntheticFireEvent);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	void SpawnSprayDecal(const struct FVector& vLocation, const struct FRotator& rOrientation, float fRotation);
	bool SetSpray();
	int STATIC_GetWinsPerRole();
	int STATIC_GetCharacterMastery();
	void SetRandomSprayAlpha();
	void SetSprayBehaviorParams();
	void PlaySprayFX(bool bSuccessfulSpray);
};


// Class TgGame.TgDeviceForm_ToggleWithLockout
// 0x0000 (0x028C - 0x028C)
class UTgDeviceForm_ToggleWithLockout : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_ToggleWithLockout");
		return ptr;
	}


	void Generic2(unsigned char byExtraData);
	void Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	void Generic1(unsigned char byExtraData);
};


// Class TgGame.TgDeviceForm_ToggleADS
// 0x0014 (0x02A0 - 0x028C)
class UTgDeviceForm_ToggleADS : public UTgDeviceForm_ToggleWithLockout
{
public:
	float                                              m_fTransitionAmount;                                      // 0x028C(0x0004)
	float                                              m_fTransitionPerSec;                                      // 0x0290(0x0004)
	float                                              m_fDesiredScopeWorld1pFOV;                                // 0x0294(0x0004)
	float                                              m_fDesiredScopeWorld3pFOV;                                // 0x0298(0x0004)
	float                                              m_fLastSetWorldFOVInterp;                                 // 0x029C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_ToggleADS");
		return ptr;
	}


	void STATIC_EnableZoom(bool bIsActive);
	void PlayToggleTransitionAnimations(float transitionPercent, float totalTransitionTime, bool transitionToActive);
	void SetToggleState(bool bIsActive);
	void StopFire(int nFireModeNum);
};


// Class TgGame.TgDeviceInterface_AccelMultiplier
// 0x0000 (0x0060 - 0x0060)
class UTgDeviceInterface_AccelMultiplier : public UInterface
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceInterface_AccelMultiplier");
		return ptr;
	}


	float STATIC_GetAccelMultiplier();
};


// Class TgGame.TgDeviceInterface_DeployMod
// 0x0000 (0x0060 - 0x0060)
class UTgDeviceInterface_DeployMod : public UInterface
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceInterface_DeployMod");
		return ptr;
	}


	void ModifyDeployableFiremode(class UTgDeviceFire* pFireMode);
	float STATIC_GetAdditiveHealth();
	bool AffectsDeployable(int nDeployableId);
};


// Class TgGame.TgDeviceInterface_ListenConsumeMarks
// 0x0000 (0x0060 - 0x0060)
class UTgDeviceInterface_ListenConsumeMarks : public UInterface
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceInterface_ListenConsumeMarks");
		return ptr;
	}


	void OnMarksConsumed(class AActor* Target, class ATgDevice* instigatingDevice, float fNumMarks, float fBaseDamage, float fBonusDamage);
};


// Class TgGame.TgDeviceInterface_MoveSpeedMultiplier
// 0x0000 (0x0060 - 0x0060)
class UTgDeviceInterface_MoveSpeedMultiplier : public UInterface
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceInterface_MoveSpeedMultiplier");
		return ptr;
	}


	bool STATIC_ShouldUseGradualMovement();
	float STATIC_GetMoveSpeedMultiplier();
};


// Class TgGame.TgDeviceMod_Burst
// 0x0010 (0x0070 - 0x0060)
class UTgDeviceMod_Burst : public UObject
{
public:
	int                                                m_nBurstTotalShots;                                       // 0x0060(0x0004)
	int                                                m_nBurstShotsRemaining;                                   // 0x0064(0x0004)
	unsigned long                                      m_bIsFirstBurstShot : 1;                                  // 0x0068(0x0004)
	unsigned long                                      m_bOnlyFirstBurstCostsAmmo : 1;                           // 0x0068(0x0004)
	unsigned long                                      m_bBurstCanBeInterrupted : 1;                             // 0x0068(0x0004)
	unsigned long                                      m_bCanEndBurstEarly : 1;                                  // 0x0068(0x0004)
	unsigned long                                      m_bPlayFireOnFirstShotOnly : 1;                           // 0x0068(0x0004)
	unsigned long                                      c_bBurstPendingStopFire : 1;                              // 0x0068(0x0004)
	unsigned long                                      s_bInBurstRecovery : 1;                                   // 0x0068(0x0004)
	unsigned long                                      s_bIsStartingBurstFire : 1;                               // 0x0068(0x0004)
	float                                              m_fTimeBetweenShots;                                      // 0x006C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceMod_Burst");
		return ptr;
	}


	void SetTotalShotsInBurst(int nTotalShots);
	bool CheckRefire(class ATgDevice* Device, bool bWantsRefire, int* shotsRemaining);
	void STATIC_FiredBurstShot();
	bool STATIC_IsFirstShotInBurst();
	bool ShouldIncrementFireLoopInstance();
	void STATIC_EndBurst();
	void ResetBurst(class ATgDevice* Device);
	void ClearFirstShotInBurst();
	bool STATIC_HandleStopFire(class ATgDevice* Device);
	void StartServerBurst(bool bFirstShotInBurst);
	bool ServerStartFireDiscardFalseBurst();
	void STATIC_HandleFalseFireRecovery();
	bool STATIC_HandleBurstUse(class ATgDevice* Device);
	int STATIC_GetRemainingShotsInBurst();
	int STATIC_GetAmmoToConsumeOverride(int nAmmoToConsume);
	float STATIC_GetTotalBurstTime(class UTgDeviceFire* FireMode);
	float STATIC_GetPreHitDelayOverride(float fPreHitDelay);
	void STATIC_HandleDeviceInterrupted(class ATgDevice* Device);
	bool CanAllowInterrupt();
	float STATIC_GetPostHitDelayOverride(float fPostHitDelay);
};


// Class TgGame.TgDeviceMod_TargetingAimForwarder
// 0x0008 (0x0068 - 0x0060)
class UTgDeviceMod_TargetingAimForwarder : public UObject
{
public:
	class ATgDevice*                                   m_ForwardDev;                                             // 0x0060(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceMod_TargetingAimForwarder");
		return ptr;
	}


	void STATIC_GetTargetingAim(struct FAimData* Aim);
};


// Class TgGame.TgDeployable
// 0x01EC (0x046C - 0x0280)
class ATgDeployable : public AActor
{
public:
	struct FPointer                                    VfTable_ITgSkinnableInterface;                            // 0x0280(0x0008) (Const, Native, NoExport)
	struct FPointer                                    VfTable_ITgCombatActor;                                   // 0x0288(0x0008) (Const, Native, NoExport)
	struct FPointer                                    VfTable_ITgObserver_ViewTargetChanged;                    // 0x0290(0x0008) (Const, Native, NoExport)
	struct FPointer                                    VfTable_ITgInteractiveAudio;                              // 0x0298(0x0008) (Const, Native, NoExport)
	struct FPointer                                    VfTable_ITgGrabSource;                                    // 0x02A0(0x0008) (Const, Native, NoExport)
	struct FPointer                                    VfTable_ITgGameplayCurveOwner;                            // 0x02A8(0x0008) (Const, Native, NoExport)
	struct FPointer                                    VfTable_ITgSoundNotifyActorInterface;                     // 0x02B0(0x0008) (Const, Native, NoExport)
	int                                                r_nDeployableId;                                          // 0x02B8(0x0004) (Net)
	int                                                r_nSkinId;                                                // 0x02BC(0x0004) (Net)
	int                                                r_nWeaponSkinId;                                          // 0x02C0(0x0004)
	unsigned long                                      c_bInitialized : 1;                                       // 0x02C4(0x0004)
	unsigned long                                      m_bConsumedOnFire : 1;                                    // 0x02C4(0x0004)
	unsigned long                                      m_bFireOnDeploy : 1;                                      // 0x02C4(0x0004)
	unsigned long                                      m_bHasAlreadyFiredOnce : 1;                               // 0x02C4(0x0004)
	unsigned long                                      m_bInstantFire : 1;                                       // 0x02C4(0x0004)
	unsigned long                                      m_bRequiresEffectManager : 1;                             // 0x02C4(0x0004)
	unsigned long                                      c_bMinimapOnlyOwnerSee : 1;                               // 0x02C4(0x0004)
	unsigned long                                      r_bTakeDamage : 1;                                        // 0x02C4(0x0004) (Net)
	unsigned long                                      m_bInDestroyedState : 1;                                  // 0x02C4(0x0004)
	unsigned long                                      s_bDestroyedThisTick : 1;                                 // 0x02C4(0x0004)
	unsigned long                                      m_bIsDeployed : 1;                                        // 0x02C4(0x0004)
	unsigned long                                      m_bDestroyedAtEndOfPersistTime : 1;                       // 0x02C4(0x0004)
	unsigned long                                      c_bEnemyMatLoaded : 1;                                    // 0x02C4(0x0004)
	unsigned long                                      m_bApplyDeviceDamageBuffs : 1;                            // 0x02C4(0x0004)
	unsigned long                                      s_bAlwaysRelevantExceptRoyale : 1;                        // 0x02C4(0x0004)
	unsigned long                                      m_bProtectedFromGameModeDestroy : 1;                      // 0x02C4(0x0004)
	unsigned long                                      m_bProtectedFromOwnerDisconnectDestroy : 1;               // 0x02C4(0x0004)
	unsigned long                                      m_bDestroyOnOwnerDeathFlag : 1;                           // 0x02C4(0x0004)
	unsigned long                                      m_bAdjustMeshToGround : 1;                                // 0x02C4(0x0004)
	unsigned long                                      m_bIsVisionBlocker : 1;                                   // 0x02C4(0x0004) (Const)
	unsigned long                                      m_bIsAIVisionBlocker : 1;                                 // 0x02C4(0x0004) (Const)
	unsigned long                                      m_bIgnoreStealthInterrupts : 1;                           // 0x02C4(0x0004) (Const)
	unsigned long                                      m_bIsNeutralObscuringDeployable : 1;                      // 0x02C4(0x0004) (Const)
	unsigned long                                      m_bMovableProjBlocker : 1;                                // 0x02C4(0x0004) (Const)
	unsigned long                                      m_bShouldRagdoll : 1;                                     // 0x02C4(0x0004)
	unsigned long                                      m_bDeviceUsedIsHandDevice : 1;                            // 0x02C4(0x0004) (Const)
	unsigned long                                      m_bUseSilhouettesOverride : 1;                            // 0x02C4(0x0004)
	unsigned long                                      m_bOverrideTargetComponentHeight : 1;                     // 0x02C4(0x0004) (Edit)
	unsigned long                                      r_bInitialIsEnemy : 1;                                    // 0x02C4(0x0004) (Net)
	unsigned long                                      c_bIsSpectateToggleActive : 1;                            // 0x02C4(0x0004) (Transient)
	unsigned long                                      m_bUseRangeFalloffCurve : 1;                              // 0x02C4(0x0004)
	int                                                m_nDeployableType;                                        // 0x02C8(0x0004)
	int                                                r_nPhysicalType;                                          // 0x02CC(0x0004) (Net)
	int                                                r_nHealth;                                                // 0x02D0(0x0004) (Net)
	class ATgEffectManager*                            r_EffectManager;                                          // 0x02D4(0x0008) (Net)
	TArray<class UTgEffectGroup*>                      m_EquipEffects;                                           // 0x02DC(0x0010) (NeedCtorLink)
	TArray<struct FTgPropertyInstance>                 s_Properties;                                             // 0x02EC(0x0010) (NeedCtorLink)
	class UTgDeviceForm*                               c_Form;                                                   // 0x02FC(0x0008)
	class UTgSpecialFx*                                c_FireFx;                                                 // 0x0304(0x0008)
	class UMeshComponent*                              c_Mesh;                                                   // 0x030C(0x0008) (ExportObject, Component, EditInline)
	struct FVector                                     r_vFlashLocation;                                         // 0x0314(0x000C) (Net)
	unsigned char                                      r_nFlashCount;                                            // 0x0320(0x0001) (Net)
	unsigned char                                      r_nFlashFireCount;                                        // 0x0321(0x0001) (Net)
	unsigned char                                      c_nPreviousFlashFireCount;                                // 0x0322(0x0001)
	TEnumAsByte<EDeployableOverlayIcon>                m_InitHUDOverlayIcon;                                     // 0x0323(0x0001) (Const)
	TEnumAsByte<EDeployableOverlayState>               m_InitHUDOverlayState;                                    // 0x0324(0x0001) (Const)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0325(0x0003) MISSED OFFSET
	class UTgDeviceFire*                               m_FireMode;                                               // 0x0328(0x0008)
	float                                              m_fStateTime;                                             // 0x0330(0x0004)
	class ATgActorFactory*                             s_DeployFactory;                                          // 0x0334(0x0008)
	float                                              m_TimeCreated;                                            // 0x033C(0x0004)
	class UMeshComponent*                              m_DestroyedMesh;                                          // 0x0340(0x0008) (ExportObject, Component, EditInline)
	float                                              m_fLifeAfterDeathSecs;                                    // 0x0348(0x0004)
	int                                                r_nReplicateDestroyIt;                                    // 0x034C(0x0004) (Net)
	TScriptInterface<class UTgInteractiveAudio>        m_AsInteractiveAudio;                                     // 0x0350(0x0010)
	TArray<class ATgPawn*>                             s_GrabbedTargets;                                         // 0x0360(0x0010) (NeedCtorLink)
	float                                              s_fPersistTime;                                           // 0x0370(0x0004)
	class UDynamicLightEnvironmentComponent*           LightEnvironment;                                         // 0x0374(0x0008) (Const, ExportObject, Component, EditInline)
	float                                              r_fTimeToDeploySecs;                                      // 0x037C(0x0004) (Net)
	float                                              r_fInitDeployTime;                                        // 0x0380(0x0004) (Net)
	float                                              m_fCurrentDeployPercentage;                               // 0x0384(0x0004)
	float                                              r_fCurrentDeployTime;                                     // 0x0388(0x0004) (Net)
	float                                              m_fDamagedDuringDeploy;                                   // 0x038C(0x0004)
	class UTgDeviceFire*                               s_SpawnerDeviceMode;                                      // 0x0390(0x0008)
	class ATgDevice*                                   r_Owner;                                                  // 0x0398(0x0008) (Net)
	int                                                r_nOwnerFireMode;                                         // 0x03A0(0x0004) (Net)
	float                                              AlwaysRelevantDistanceSquared;                            // 0x03A4(0x0004)
	float                                              s_fMaxRelevancyDistanceSquared;                           // 0x03A8(0x0004)
	float                                              m_fMaxAimAssistStacks;                                    // 0x03AC(0x0004)
	TArray<class UTgAnimBlendByDeployable*>            m_DeployableAnimNodes;                                    // 0x03B0(0x0010) (NeedCtorLink)
	struct FVector                                     r_vRagdollDir;                                            // 0x03C0(0x000C) (Net)
	float                                              m_fCachedGroundProximity;                                 // 0x03CC(0x0004)
	float                                              m_fCachedGroundProximityTimestamp;                        // 0x03D0(0x0004)
	struct FCollisionSettingsDeployable                m_CollisionSettings;                                      // 0x03D4(0x0014)
	TArray<class ATgPawn*>                             m_PawnsBasedOnMe;                                         // 0x03E8(0x0010) (NeedCtorLink)
	class ATgSilhouetteManager*                        m_SilhouetteManager;                                      // 0x03F8(0x0008)
	int                                                m_nInitHUDOverlayDisplayMask;                             // 0x0400(0x0004) (Const)
	float                                              m_InitHUDOverlayEnemyViewDist;                            // 0x0404(0x0004) (Const)
	float                                              m_fHUDOverlayZOffset;                                     // 0x0408(0x0004) (Edit)
	struct FPointer                                    m_pAmSkin;                                                // 0x040C(0x0008) (Const, Native)
	struct FPointer                                    m_pAmWeaponSkin;                                          // 0x0414(0x0008) (Const, Native)
	class UCylinderComponent*                          m_TargetComponent;                                        // 0x041C(0x0008) (Edit, ExportObject, Component, EditInline)
	float                                              m_TargetCollisionTraceDistance;                           // 0x0424(0x0004) (Edit)
	float                                              m_fOverriddenTargetComponentHeight;                       // 0x0428(0x0004) (Edit)
	class ATgPawn*                                     m_LastDamager;                                            // 0x042C(0x0008)
	int                                                m_LastDamagerTimeStamp;                                   // 0x0434(0x0004)
	class ATgRepInfo_Deployable*                       r_DRI;                                                    // 0x0438(0x0008) (Net)
	class ATgPlayerController*                         c_LocalPC;                                                // 0x0440(0x0008)
	class UClass*                                      m_DRIClass;                                               // 0x0448(0x0008)
	float                                              m_fDisableSpectatorFxTime;                                // 0x0450(0x0004)
	float                                              m_fDisableSpectatorFxTimeRemaining;                       // 0x0454(0x0004) (Transient)
	class ATgAkActorUnoccluded*                        m_AkActorUnoccluded;                                      // 0x0458(0x0008)
	float                                              m_fHazardDistance;                                        // 0x0460(0x0004)
	float                                              m_fHazardRating;                                          // 0x0464(0x0004)
	int                                                r_nCachedMaxHealth;                                       // 0x0468(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable");
		return ptr;
	}


	void STATIC_ScaleFXList(const struct FName& fxListName, float fDamageRadius, float fDamageRadiusUU, float fRadiusScale);
	void SetHUDOverlayEnemyViewDist(float enemyViewDist);
	void SetHUDOverlayState(TEnumAsByte<EDeployableOverlayState> dos);
	void SetHUDOverlayIcon(TEnumAsByte<EDeployableOverlayIcon> doi);
	void AddHUDOverlayDisplayMask(int dodm);
	void SetHUDOverlayDisplayMask(int dodm);
	void CollisionChanged();
	void STATIC_UpdateDecalScale(class UTgSpecialFx* Fx, float radiusScale);
	bool STATIC_GetDefaultDecalDimensions(int nDecalId, int nSpecialFxId, float* Height, float* Width);
	void PlayGenericTakeHit(const struct FVector& HitLocation, const struct FVector& HitNormal, const struct FExtraDamageInfo& Info);
	void DeactivateSpectatorFxTimer();
	void ToggleSpectateFx(bool bForceDisable);
	bool STATIC_IsBoxExtentInRange(const struct FVector& BoxCenter, const struct FVector& BoxExtent);
	void InitReplicationInfo();
	bool DamageShouldEnterCombat();
	bool CanApplyEffects();
	struct FString STATIC_GetDeployableNameById(int DeployableId);
	void OnHealthUpdated();
	void TakeDamage(int Damage, class AController* EventInstigator, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void Destroyed();
	void Tick(float DeltaSeconds);
	void ClearBasedPawnList();
	void RemoveBasedPawn(class ATgPawn* basedPawn);
	void AddBasedPawn(class ATgPawn* basedPawn);
	void ShutDown();
	void DestroyIt(bool bSkipFx);
	void ReplacedByNewDeployable();
	void SpawningDeviceToggledOff();
	void ReplicatedEvent(const struct FName& VarName);
	void ActivateOnWhenDeployedFx(bool bOn);
	void ActivateWhileAliveFx(bool bOn);
	struct FName GetDestroyedDisplayGroup();
	struct FName GetWhileAliveDisplayGroup();
	void TickDeploy(float DeltaSeconds);
	void STATIC_UpdateTimeToDeploySecs(float fValue);
	void NotifyDeployed();
	void DeployComplete();
	void ResetPersistTime();
	void OnPersistTimerExpire();
	void CalcDeployPercentage();
	void OnSetTaskforce(class UTgSeqAct_SetTaskforce* Action);
	void RefireCheckTimer();
	void StartDeploy();
	void TimeDeviceFiring();
	bool BenefitsFromPctShieldIncrease();
	bool IsFiring();
	void STATIC_FlashFireCountUpdated();
	void FlashLocationUpdated();
	void FlashCountUpdated();
	void PlayFireFx();
	void ClearFlashLocation();
	void SetFlashLocation(const struct FVector& NewLoc);
	void ClearFlashCount();
	void IncrementFlashCount();
	void STATIC_FireAmmunitionDeployable();
	struct FVector STATIC_GetPhysicalFireAimDirection(const struct FVector& FireLoc, const struct FVector& TargetLocation);
	struct FVector STATIC_GetPhysicalFireStartLoc();
	class AProjectile* ProjectileFireDeployable();
	void ApplyHit(TArray<struct FImpactInfo>* ImpactList);
	void STATIC_InstantFireDeployable();
	struct FImpactInfo CalcDeviceFire(const struct FVector& StartTrace, const struct FVector& EndTrace, TArray<struct FImpactInfo>* ImpactList);
	void DeviceFired();
	void StopFire();
	void StartFire();
	void OnGetTaskForceNumber(class UTgSeqAct_GetTaskForceNumber* Action);
	void PostInitAnimTree(class USkeletalMeshComponent* SkelComp);
	int GetDeployableUniqueId();
	void STATIC_NotifyLocalPlayerTeamReceived();
	void PostBeginPlay();
	void STATIC_GetPullGrabSourceLocation(struct FVector* vSourceLoc);
	void STATIC_GetPullGrabOffsetFromSource(class ATgPawn* pGrabbedPawn, struct FVector* vOffset, struct FRotator* rRotation);
	void OnGrabTargetDetach(TEnumAsByte<EGrabState> endingGrabState, class ATgPawn* Target, bool bInterrupted);
	void OnGrabTargetAttach(TEnumAsByte<EGrabState> newGrabState, class ATgPawn* Target);
	class AActor* STATIC_GetLookAtTarget();
	void STATIC_InitializeEquipEffects(int nDeviceId);
	bool STATIC_UseRangeFalloffCurve();
	class UTgGameplayCurvesSet* STATIC_GetCurrentGameplayCurveSet(TEnumAsByte<ECurveSetTypes> Type);
	bool STATIC_IsObscuringOverriden(class ATgPawn* Viewer, class ATgPawn* Target, bool bViewerInside);
	void STATIC_NotifyQueuedLagCompWorldExplosion(class ATgProj_Simulated* Proj, const struct FVector& HitLocation, const struct FVector& HitVelocity);
	bool STATIC_CanQueueLagCompWorldExplosion(class ATgProj_Simulated* Proj, unsigned char* bHideProjectile);
	class AActor* STATIC_GetActorFromCombatActor();
	class AActor* STATIC_GetPetOwner();
	bool STATIC_IsPet();
	TEnumAsByte<EGameplayDesignType> STATIC_GetDesignType();
	class ATgEffectManager* STATIC_GetEffectManager();
	void DelayedRagdollConstraintBreak();
	void InitRagdoll();
	void OnViewTargetChanged(class AActor* aNewViewTarget);
	float STATIC_GetMarkedPercentInhand(class AActor* InstigatorPawn);
	float STATIC_GetMarkedPercent(class AActor* InstigatorPawn);
	int STATIC_GetPropIndex(int nPropId);
	float STATIC_GetPropCurrentValue(int nPropIndex);
	float STATIC_GetPropBaseValue(int nPropIndex);
	class UTgSpecialFx* STATIC_GetTakeHitFxOverride(class UTgSpecialFx* TakeHit);
	struct FVector STATIC_GetLocation();
	bool STATIC_LocalPlayerHasLOS();
	void STATIC_HandleNotificationsForAI(float fStatChange, class ATgPawn* InstigatorPawn);
	float STATIC_GetDamageToLeaveStealth();
	void TakeStealthDamage(float fDamage);
	bool ShieldDamageAppliesToHealth();
	int TakePersonalShieldDamage(float fDamage, class AController* InstigatedBy, class UClass* DamageType, const struct FImpactInfo& Impact, const struct FExtraDamageInfo& ExtraInfo, class AActor* DamageCauser);
	bool CanUsePersonalShield();
	bool CanTakeShieldDamage();
	void TakeManaDamage(float fDamage, class AController* InstigatedBy, class UClass* DamageType, const struct FImpactInfo& Impact, const struct FExtraDamageInfo& ExtraInfo, class AActor* DamageCauser);
	bool CanTakeManaDamage();
	bool CanBeLifestealTarget();
	bool CanBeLifestealInstigator();
	void TakeHealthDamage(float fDamage, class AController* InstigatedBy, class UClass* DamageType, const struct FImpactInfo& Impact, const struct FExtraDamageInfo& ExtraInfo, class AActor* DamageCauser);
	void MitigateHealthDamage(class ATgPawn* pInstigator, class UTgEffectDamage* Effect, const struct FImpactInfo& Impact, bool bIsHeadshot, float* NewValue, float* fPercReduction, unsigned char* bWasCapped);
	void STATIC_MitigateExecuteDamage(class ATgPawn* pInstigator, class UTgEffectDamage* Effect, const struct FImpactInfo& Impact, bool bIsHeadshot, float* NewValue, float* fPercReduction);
	float STATIC_GetSpecialDamageTakenPercentAI();
	float STATIC_GetSpecialDamageDealtPercentAI();
	void BuffDamage(class AActor* Target, class UTgEffectDamage* Effect, const struct FImpactInfo& Impact, float fBaseDamage, float* fProratedAmount, struct FExtraDamageInfo* ExtraInfo);
	bool STATIC_IsImmuneToHealing();
	bool CanBeExecuted();
	bool STATIC_IsImmuneToDamageByAbsorption();
	bool STATIC_IsImmuneToDamage();
	bool OnlyTakeHeadShots();
	bool CanTakeHeadShots();
	bool CanDealHeadShots();
	bool CanTakeHealthDamage();
	float STATIC_GetDiminishedGroundSpeed();
	void STATIC_GetAdditionalLifestealMultipliers(struct FDiminishedEffectInfo* DiminishingInfo, struct FImpactInfo* Impact);
	void STATIC_GetAdditionalDamageTakenMultipliers(class ATgDevice* damagingDevice, struct FDiminishedEffectInfo* DiminishingInfo, struct FImpactInfo* Impact);
	float STATIC_GetMaxShield();
	float STATIC_GetShieldHealth();
	float STATIC_GetMaxMana();
	float STATIC_GetMana();
	float STATIC_GetPureHealthPercent();
	float STATIC_GetHealthPercent();
	float STATIC_GetMaxPureHealth();
	float STATIC_GetMaxHealth();
	float STATIC_GetHealth();
	void STATIC_ForceAllGrabTargetsDetach(TEnumAsByte<EGrabState> eState);
	class AActor* STATIC_GetGrabSourceAsActor();
	void STATIC_RemoveGrabbedPawn(class ATgPawn* pTarget);
	void STATIC_AddGrabbedPawn(class ATgPawn* pTarget);
	class USkeletalMeshComponent* STATIC_GetGrabSourceSkeletalMesh();
	void STATIC_UnRegisterObstacle();
	void STATIC_RegisterObstacle();
	void STATIC_PostAkEvent(class UAkEvent* InAkEvent);
	void AdjustHeal(int nPropertyId, struct FImpactInfo* Impact, float* fHeal);
	struct FVector STATIC_GetHudOverlayLocation(bool bCentered);
	bool STATIC_IsHittable();
	bool IsInvisibleToAI(class AActor* TestActor);
	void UpdateHealth();
	bool IsFriendlyWithLocalPawn();
	int STATIC_GetSpawnerDeviceId();
	int STATIC_GetSpawnerDeviceInstanceId();
	void SetTaskForceNumber(int nTaskForceId);
	int STATIC_GetTaskForceNumber();
	class ATgRepInfo_TaskForce* STATIC_GetTaskForce();
	void SetInitialHealthPercent(float fPercent);
	void STATIC_UpdateDamagers(class ATgPawn* Damager);
	void STATIC_UpdateTargetCylinder();
	void PlayNotifySound(TEnumAsByte<ENotifySound> eSound);
	void PlayNotifySound_Internal(TEnumAsByte<ENotifySound> eSound);
	void PlayMessageAkEvent(const struct Fdword& dwMsgId);
	void QueueSoundShutdown();
	bool STATIC_FindGround(float fCheckDist, float fCheckRadius, const struct FVector& vRayDir, struct FVector* vSourceLocation, struct FVector* vGroundLocation, struct FVector* vGroundNormal);
	float STATIC_GetGroundDistance();
	float NativeGetCollisionRadius();
	float NativeGetCollisionHeight();
	float CalcMeshOffset();
	void AdjustMeshToGround();
	void STATIC_RecalculateMaterial(bool bIsFriendlyWithLocalPawn, bool bForce);
	void ForceRecalculateMaterial();
	void NotifyGroupChanged();
	int STATIC_GetMaxDeployHealth();
	void DeployableDestroyed();
	void SwapMeshToDestroyed();
	void ResetProperties();
	void SetProperty(int nPropertyId, float fNewValue);
	struct FTgPropertyInstance STATIC_GetProperty(int nPropertyId);
	void AddProperty(int nPropId, float fBase, float fRaw, float FMin, float FMax);
	void InitializeDefaultProps();
	bool ApplyDeployableSetup();
};


// Class TgGame.TgDeploy_BlackHole
// 0x003C (0x04A8 - 0x046C)
class ATgDeploy_BlackHole : public ATgDeployable
{
public:
	float                                              r_fRadiusScale;                                           // 0x046C(0x0004) (Net)
	float                                              m_fMaxPullSpeed;                                          // 0x0470(0x0004)
	float                                              m_fMinPullSpeed;                                          // 0x0474(0x0004)
	float                                              m_fDistanceWithMaxSpeed;                                  // 0x0478(0x0004)
	float                                              m_fEventHorizonDistance;                                  // 0x047C(0x0004)
	float                                              m_fInnerRadius;                                           // 0x0480(0x0004)
	TArray<class AActor*>                              m_ActorsInRange;                                          // 0x0484(0x0010) (NeedCtorLink)
	class ATgPawn*                                     m_CachedPawnOwner;                                        // 0x0494(0x0008)
	class ATgRepInfo_TaskForce*                        m_CachedEnemyTaskForce;                                   // 0x049C(0x0008)
	unsigned long                                      r_bPullActive : 1;                                        // 0x04A4(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_BlackHole");
		return ptr;
	}


	void Destroyed();
	void ClearAllTouched();
	void ReplicatedEvent(const struct FName& VarName);
	void ApplyPullEffects(class ATgPawn* Target, float DeltaTime);
};


// Class TgGame.TgDeploy_Bomb
// 0x0018 (0x0484 - 0x046C)
class ATgDeploy_Bomb : public ATgDeployable
{
public:
	float                                              r_fPersistTime;                                           // 0x046C(0x0004) (Net)
	class UStaticMeshComponent*                        m_CountdownIndicator;                                     // 0x0470(0x0008) (Edit, ExportObject, Component, EditInline)
	class UMaterialInstanceConstant*                   m_CountdownIndicatorMIC;                                  // 0x0478(0x0008) (Transient)
	float                                              r_fRadiusScale;                                           // 0x0480(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Bomb");
		return ptr;
	}


	void ScaleAbilityFX();
	void ScaleAbilityRadius();
	void DestroyIt(bool bSkipFx);
	void Tick(float DeltaSeconds);
	int STATIC_GetNumEnemyPlayersInList(TArray<struct FImpactInfo>* ImpactList);
	void ApplyHit(TArray<struct FImpactInfo>* ImpactList);
	void OnPersistTimerExpire();
	void PostBeginPlay();
	void ReplicatedEvent(const struct FName& VarName);
};


// Class TgGame.TgDeploy_DeathStamp
// 0x0008 (0x0474 - 0x046C)
class ATgDeploy_DeathStamp : public ATgDeployable
{
public:
	class ATgPawn*                                     m_PawnVictim;                                             // 0x046C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_DeathStamp");
		return ptr;
	}

};


// Class TgGame.TgDeploy_Geometry
// 0x0028 (0x0494 - 0x046C)
class ATgDeploy_Geometry : public ATgDeployable
{
public:
	TArray<class AActor*>                              m_OverlappingActors;                                      // 0x046C(0x0010) (NeedCtorLink)
	TArray<struct FVector>                             m_DesiredPushDirection;                                   // 0x047C(0x0010) (NeedCtorLink)
	unsigned long                                      m_bPushOverlappingActors : 1;                             // 0x048C(0x0004)
	unsigned long                                      m_bAllyPassthrough : 1;                                   // 0x048C(0x0004)
	unsigned long                                      m_bEnemyPassthrough : 1;                                  // 0x048C(0x0004)
	float                                              m_fPushFactor;                                            // 0x0490(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Geometry");
		return ptr;
	}


	void PushOverlappingActors(float DeltaSeconds);
	struct FVector CalcPushDirection(const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_FindOverlappingActors();
	bool ShouldSelfDestructWhenTouchedBy(class AActor* Other);
	bool STATIC_IsPushable(class AActor* Other);
};


// Class TgGame.TgDeploy_HealthNugget
// 0x0024 (0x0490 - 0x046C)
class ATgDeploy_HealthNugget : public ATgDeployable
{
public:
	unsigned long                                      m_bRenderAsActive : 1;                                    // 0x046C(0x0004)
	unsigned long                                      m_bIsActiveRendered : 1;                                  // 0x046C(0x0004)
	unsigned long                                      m_bCountTowardsHealingStats : 1;                          // 0x046C(0x0004)
	class ATgHelpTipActor*                             c_HelpTipActor;                                           // 0x0470(0x0008)
	float                                              m_fHealOverride;                                          // 0x0478(0x0004)
	float                                              m_fHoTOverride;                                           // 0x047C(0x0004)
	TArray<class AActor*>                              m_PendingTouches;                                         // 0x0480(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_HealthNugget");
		return ptr;
	}


	void Destroyed();
	void DestroyIt(bool bSkipFx);
	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void PostBeginPlay();
	void AdjustHeal(int nPropertyId, struct FImpactInfo* Impact, float* fHeal);
	void DeployAllyHealAOE(class ATgPawn_Character* TgP);
};


// Class TgGame.TgDeploy_HealthNugget_TeamOnly
// 0x000C (0x049C - 0x0490)
class ATgDeploy_HealthNugget_TeamOnly : public ATgDeploy_HealthNugget
{
public:
	int                                                r_nTaskForceAlignment;                                    // 0x0490(0x0004) (Net)
	float                                              m_fNuggetSpawnTime;                                       // 0x0494(0x0004)
	float                                              m_fNuggetGracePeriod;                                     // 0x0498(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_HealthNugget_TeamOnly");
		return ptr;
	}


	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgDeploy_MatchParentFireMode
// 0x0000 (0x046C - 0x046C)
class ATgDeploy_MatchParentFireMode : public ATgDeployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_MatchParentFireMode");
		return ptr;
	}

};


// Class TgGame.TgDeploy_DeployableLinked
// 0x0008 (0x0474 - 0x046C)
class ATgDeploy_DeployableLinked : public ATgDeploy_MatchParentFireMode
{
public:
	class ATgDeployable*                               m_ParentDeployable;                                       // 0x046C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_DeployableLinked");
		return ptr;
	}

};


// Class TgGame.TgDeploy_EffectAura
// 0x0044 (0x04B0 - 0x046C)
class ATgDeploy_EffectAura : public ATgDeploy_MatchParentFireMode
{
public:
	float                                              r_fRadiusScale;                                           // 0x046C(0x0004) (Net)
	TArray<class AActor*>                              m_TouchingActors;                                         // 0x0470(0x0010) (NeedCtorLink)
	TArray<class AActor*>                              m_AffectedActors;                                         // 0x0480(0x0010) (NeedCtorLink)
	float                                              m_fLastBlockedByBlockersTime;                             // 0x0490(0x0004)
	float                                              m_fMinBlockedByBlockersTime;                              // 0x0494(0x0004)
	TArray<class AActor*>                              m_BlockedActors;                                          // 0x0498(0x0010) (NeedCtorLink)
	class ATgCollisionProxy_Cylinder*                  m_CollisionProxy;                                         // 0x04A8(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_EffectAura");
		return ptr;
	}


	void ScaleFX();
	void ScaleCollisionProxy();
	void SpawnCollisionProxy();
	void Destroyed();
	void DestroyIt(bool bSkipFx);
	void ClearAllTouched();
	float GetCurrentRadius();
	void OnProxyUnTouch(class AActor* Other);
	void OnProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void ReplicatedEvent(const struct FName& VarName);
	float STATIC_GetDistanceToTarget(class AActor* Target);
	void RemoveEffects(class AActor* Target);
	void ApplyEffects(class AActor* Target);
};


// Class TgGame.TgDeploy_Explosion
// 0x0000 (0x04B0 - 0x04B0)
class ATgDeploy_Explosion : public ATgDeploy_EffectAura
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Explosion");
		return ptr;
	}


	void ScaleFX();
	void DestroyIt(bool bSkipFx);
};


// Class TgGame.TgDeploy_EffectField
// 0x0034 (0x04A0 - 0x046C)
class ATgDeploy_EffectField : public ATgDeploy_MatchParentFireMode
{
public:
	float                                              m_fEffectFieldHeight;                                     // 0x046C(0x0004)
	float                                              r_fRadiusScale;                                           // 0x0470(0x0004) (Net)
	TArray<class AActor*>                              m_TouchingPawns;                                          // 0x0474(0x0010) (NeedCtorLink)
	TArray<class AActor*>                              m_HitActors;                                              // 0x0484(0x0010) (NeedCtorLink)
	unsigned long                                      m_bOnlyHitOnce : 1;                                       // 0x0494(0x0004)
	unsigned long                                      m_bAllowStacking : 1;                                     // 0x0494(0x0004)
	class ATgCollisionProxy_Cylinder*                  m_CollisionProxy;                                         // 0x0498(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_EffectField");
		return ptr;
	}


	void ScaleCollisionProxy();
	void SpawnCollisionProxy();
	void Destroyed();
	void DestroyIt(bool bSkipFx);
	void ClearAllTouched();
	float GetCurrentRadius();
	void ProxyUnTouchHit(class AActor* Other);
	void ProxyTouchHit(class AActor* Other);
	void ApplyLingeringTouch(class AActor* Other);
	void OnProxyUnTouch(class AActor* Other);
	void OnProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgDeploy_DeployableLinkedEffectField
// 0x0008 (0x04A8 - 0x04A0)
class ATgDeploy_DeployableLinkedEffectField : public ATgDeploy_EffectField
{
public:
	class ATgDeployable*                               m_ParentDeployable;                                       // 0x04A0(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_DeployableLinkedEffectField");
		return ptr;
	}

};


// Class TgGame.TgDeploy_EffectFieldHitOnce
// 0x0000 (0x04A0 - 0x04A0)
class ATgDeploy_EffectFieldHitOnce : public ATgDeploy_EffectField
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_EffectFieldHitOnce");
		return ptr;
	}

};


// Class TgGame.TgDeploy_GeometryEffectField
// 0x0028 (0x04C8 - 0x04A0)
class ATgDeploy_GeometryEffectField : public ATgDeploy_EffectField
{
public:
	TArray<class AActor*>                              m_OverlappingActors;                                      // 0x04A0(0x0010) (NeedCtorLink)
	TArray<struct FVector>                             m_DesiredPushDirection;                                   // 0x04B0(0x0010) (NeedCtorLink)
	unsigned long                                      m_bPushOverlappingActors : 1;                             // 0x04C0(0x0004)
	unsigned long                                      m_bAllyPassthrough : 1;                                   // 0x04C0(0x0004)
	unsigned long                                      m_bEnemyPassthrough : 1;                                  // 0x04C0(0x0004)
	float                                              m_fPushFactor;                                            // 0x04C4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_GeometryEffectField");
		return ptr;
	}


	void PushOverlappingActors(float DeltaSeconds);
	struct FVector CalcPushDirection(const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_FindOverlappingActors();
	bool ShouldSelfDestructWhenTouchedBy(class AActor* Other);
	bool STATIC_IsPushable(class AActor* Other);
};


// Class TgGame.TgDeploy_EffectSpots
// 0x161C (0x1A88 - 0x046C)
class ATgDeploy_EffectSpots : public ATgDeploy_MatchParentFireMode
{
public:
	struct FEffectSpotInfo                             r_EffectSpots[0x64];                                      // 0x046C(0x002C) (Net)
	int                                                m_nNewSpotIndex;                                          // 0x159C(0x0004)
	class ATgCollisionProxy_Cylinder*                  m_CollisionProxy;                                         // 0x15A0(0x0008)
	float                                              m_fFirstPassRadius;                                       // 0x15A8(0x0004)
	TArray<class AActor*>                              m_TouchingActors;                                         // 0x15AC(0x0010) (NeedCtorLink)
	TArray<struct FEffectSpotTarget>                   m_AffectedActors;                                         // 0x15BC(0x0010) (NeedCtorLink)
	unsigned long                                      m_bUsesEffectRefresh : 1;                                 // 0x15CC(0x0004)
	float                                              m_fLastRefreshTime;                                       // 0x15D0(0x0004)
	float                                              m_fMinRefreshTime;                                        // 0x15D4(0x0004)
	struct FEffectSpotFXInfo                           c_SpotFX[0x64];                                           // 0x15D8(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_EffectSpots");
		return ptr;
	}


	void Destroyed();
	void DestroyIt(bool bSkipFx);
	void ClearAllTouched();
	void ClearEffectSpots();
	void STATIC_UpdateParticleParams(int spotIndex);
	void STATIC_UpdateSpotFX(int spotIndex);
	void ScaleCollisionProxy();
	void SpawnCollisionProxy();
	void STATIC_UpdateEffectSpots();
	int SpawnNewSpot(const struct FVector& vLocation, const struct FRotator& rRotation, float fRadius, float fHeight, int nFXIndex, int nIntensityLevel);
	void OnProxyUnTouch(class AActor* Other);
	void OnProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void Tick(float DeltaSeconds);
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_InitializeSpecialFX(int spotIndex);
	void RemoveEffects(class AActor* Target);
	void ApplyEffects(class AActor* Target);
};


// Class TgGame.TgDeploy_EffectTrail
// 0x0398 (0x0804 - 0x046C)
class ATgDeploy_EffectTrail : public ATgDeploy_MatchParentFireMode
{
public:
	class ATgPawn*                                     r_TrailPawn;                                              // 0x046C(0x0008) (Net)
	int                                                m_TrailEffectID;                                          // 0x0474(0x0004)
	class UTgSpecialFx*                                m_TrailEffects;                                           // 0x0478(0x0008)
	unsigned long                                      m_bHasInitialPoint : 1;                                   // 0x0480(0x0004)
	unsigned long                                      r_bInDeployMode : 1;                                      // 0x0480(0x0004) (Net)
	float                                              m_fPointDistance;                                         // 0x0484(0x0004)
	float                                              m_fPointLifetime;                                         // 0x0488(0x0004)
	int                                                m_nNextPointIndex;                                        // 0x048C(0x0004)
	int                                                m_nTailPointIndex;                                        // 0x0490(0x0004)
	struct FVector                                     m_TrailPoints[0x14];                                      // 0x0494(0x000C)
	struct FVector                                     m_ParticleSystemOffsets[0x14];                            // 0x0584(0x000C)
	float                                              m_TrailTimes[0x14];                                       // 0x0674(0x0004)
	class ATgCollisionProxy_Cylinder*                  m_CollisionProxies[0x14];                                 // 0x06C4(0x0008)
	class UDecalComponent*                             m_Decals[0x14];                                           // 0x0764(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_EffectTrail");
		return ptr;
	}


	void Destroyed();
	void ShutdownDeployMode();
	void OnPersistTimerExpire();
	void OnProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool CalculateAndSpawnNextPiece();
};


// Class TgGame.TgDeploy_Pickup
// 0x0004 (0x0470 - 0x046C)
class ATgDeploy_Pickup : public ATgDeployable
{
public:
	unsigned long                                      m_bApplyToEntireTeam : 1;                                 // 0x046C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Pickup");
		return ptr;
	}


	void ApplyEffect(class ATgPawn_Character* Target);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgDeploy_Pickup_Teamwide
// 0x0000 (0x0470 - 0x0470)
class ATgDeploy_Pickup_Teamwide : public ATgDeploy_Pickup
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Pickup_Teamwide");
		return ptr;
	}

};


// Class TgGame.TgDeploy_HHPickup
// 0x0000 (0x0470 - 0x0470)
class ATgDeploy_HHPickup : public ATgDeploy_Pickup_Teamwide
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_HHPickup");
		return ptr;
	}


	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_FlashHHPickup(class ATgPawn_Character* TgPC);
	void STATIC_UpdateHHUltPerc(class ATgRepInfo_TaskForce* TRI);
};


// Class TgGame.TgDeploy_Pickup_OwnerOnly
// 0x0000 (0x046C - 0x046C)
class ATgDeploy_Pickup_OwnerOnly : public ATgDeployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Pickup_OwnerOnly");
		return ptr;
	}


	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgDeploy_Placeholder
// 0x0000 (0x046C - 0x046C)
class ATgDeploy_Placeholder : public ATgDeployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Placeholder");
		return ptr;
	}

};


// Class TgGame.TgDeploy_ProxyMine
// 0x0000 (0x046C - 0x046C)
class ATgDeploy_ProxyMine : public ATgDeployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_ProxyMine");
		return ptr;
	}


	void CheckExplode();
	void DeployComplete();
	void InitReplicationInfo();
};


// Class TgGame.TgDeploy_RespawnBeacon
// 0x0000 (0x046C - 0x046C)
class ATgDeploy_RespawnBeacon : public ATgDeployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_RespawnBeacon");
		return ptr;
	}


	void DeployComplete();
};


// Class TgGame.TgDeploy_Shield
// 0x0004 (0x0470 - 0x046C)
class ATgDeploy_Shield : public ATgDeployable
{
public:
	unsigned long                                      bBasedOnPawn : 1;                                         // 0x046C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Shield");
		return ptr;
	}


	void Destroyed();
	void BaseChange();
	bool BenefitsFromPctShieldIncrease();
};


// Class TgGame.TgProjectile
// 0x0174 (0x0450 - 0x02DC)
class ATgProjectile : public AProjectile
{
public:
	struct FPointer                                    VfTable_ITgSkinnableInterface;                            // 0x02DC(0x0008) (Const, Native, NoExport)
	struct FPointer                                    VfTable_ITgObserver_ViewTargetChanged;                    // 0x02E4(0x0008) (Const, Native, NoExport)
	struct FPointer                                    VfTable_ITgSoundNotifyActorInterface;                     // 0x02EC(0x0008) (Const, Native, NoExport)
	struct FPointer                                    VfTable_ITgGrabSource;                                    // 0x02F4(0x0008) (Const, Native, NoExport)
	class UTgDeviceFire*                               s_LastDefaultMode;                                        // 0x02FC(0x0008)
	int                                                r_nProjectileId;                                          // 0x0304(0x0004) (Net)
	float                                              r_fDuration;                                              // 0x0308(0x0004) (Net)
	float                                              m_fPostLandDuration;                                      // 0x030C(0x0004)
	float                                              m_fLandZThreshold;                                        // 0x0310(0x0004)
	float                                              m_fPersistTime;                                           // 0x0314(0x0004)
	float                                              m_fPersistHitPulse;                                       // 0x0318(0x0004)
	int                                                m_nTargetPhysicalType;                                    // 0x031C(0x0004)
	class UMeshComponent*                              c_Mesh;                                                   // 0x0320(0x0008) (ExportObject, Component, EditInline)
	class UTgSpecialFx*                                c_ExplosionFx;                                            // 0x0328(0x0008)
	class UTgImpactFx*                                 c_ImpactFx;                                               // 0x0330(0x0008)
	unsigned long                                      c_bRotationFollowsVelocity : 1;                           // 0x0338(0x0004)
	unsigned long                                      m_bExplodeAtMaxRange : 1;                                 // 0x0338(0x0004)
	unsigned long                                      m_bDeployOnCharacter : 1;                                 // 0x0338(0x0004)
	unsigned long                                      m_bDeployOnTarget : 1;                                    // 0x0338(0x0004)
	unsigned long                                      m_bDeployOnGround : 1;                                    // 0x0338(0x0004)
	unsigned long                                      m_bAlwaysDeployUpwards : 1;                               // 0x0338(0x0004)
	unsigned long                                      m_bStickToWalls : 1;                                      // 0x0338(0x0004)
	unsigned long                                      c_bIsAOE : 1;                                             // 0x0338(0x0004)
	unsigned long                                      m_bCountDirectHitForAOE : 1;                              // 0x0338(0x0004)
	unsigned long                                      m_bUseAOEDirectHit : 1;                                   // 0x0338(0x0004)
	unsigned long                                      m_bHasExploded : 1;                                       // 0x0338(0x0004)
	unsigned long                                      m_bHitValidTarget : 1;                                    // 0x0338(0x0004)
	unsigned long                                      m_bIngoreBehindProjCollisions : 1;                        // 0x0338(0x0004)
	unsigned long                                      m_bIsInitialized : 1;                                     // 0x0338(0x0004)
	unsigned long                                      m_bIsShutDown : 1;                                        // 0x0338(0x0004)
	unsigned long                                      m_bPIEInitialized : 1;                                    // 0x0338(0x0004)
	unsigned long                                      m_bHasPlayedFizzleFX : 1;                                 // 0x0338(0x0004)
	unsigned long                                      m_bHasPlayedHitWallFX : 1;                                // 0x0338(0x0004)
	unsigned long                                      m_bHasPlayedHitTargetFX : 1;                              // 0x0338(0x0004)
	unsigned long                                      m_bSuppressDeployableSpawn : 1;                           // 0x0338(0x0004)
	unsigned long                                      m_bAltFireHit : 1;                                        // 0x0338(0x0004)
	unsigned long                                      m_bInvertTeam : 1;                                        // 0x0338(0x0004)
	unsigned long                                      m_bFirstShotAfterMovementAbility : 1;                     // 0x0338(0x0004)
	unsigned long                                      m_bCanSpawnOnClientFirst : 1;                             // 0x0338(0x0004)
	unsigned long                                      m_bIsNonThreatening : 1;                                  // 0x0338(0x0004)
	unsigned long                                      m_bShutdownOnNonThreatening : 1;                          // 0x0338(0x0004)
	unsigned long                                      m_bTrackToWorldLocation : 1;                              // 0x0338(0x0004)
	float                                              r_fAccelRate;                                             // 0x033C(0x0004) (Net)
	float                                              m_fTossZ;                                                 // 0x0340(0x0004)
	float                                              m_fFireAngle;                                             // 0x0344(0x0004)
	class AActor*                                      r_Owner;                                                  // 0x0348(0x0008) (Net)
	int                                                r_nOwnerFireModeId;                                       // 0x0350(0x0004) (Net)
	class UTgDeviceFire*                               m_OwnerFireMode;                                          // 0x0354(0x0008)
	TArray<class UTgDeviceFire*>                       m_ExtraFireModes;                                         // 0x035C(0x0010) (NeedCtorLink)
	float                                              r_fRange;                                                 // 0x036C(0x0004) (Net)
	float                                              m_fProximityDistance;                                     // 0x0370(0x0004)
	class ATgCollisionProxy*                           m_CollisionProxy;                                         // 0x0374(0x0008)
	int                                                s_nSpawnBotId;                                            // 0x037C(0x0004)
	int                                                s_nSpawnDeployableId;                                     // 0x0380(0x0004)
	TEnumAsByte<ESpawnDeployableOrientation>           m_DeployableSpawnOrientation;                             // 0x0384(0x0001)
	TEnumAsByte<ETG_EQUIP_POINT>                       r_eEquippedAt;                                            // 0x0385(0x0001) (Net)
	TEnumAsByte<EDeployableOverlayIcon>                m_eOverlayIcon;                                           // 0x0386(0x0001)
	unsigned char                                      UnknownData00[0x1];                                       // 0x0387(0x0001) MISSED OFFSET
	TArray<class ATgPawn*>                             s_GrabbedTargets;                                         // 0x0388(0x0010) (NeedCtorLink)
	float                                              m_fDamageRadius;                                          // 0x0398(0x0004)
	struct FVector                                     r_vSpawnLocation;                                         // 0x039C(0x000C) (Net)
	struct FVector                                     m_vSpawnRotation;                                         // 0x03A8(0x000C)
	struct FVector                                     m_vLocationLastTick;                                      // 0x03B4(0x000C)
	float                                              m_fMinTravelRange;                                        // 0x03C0(0x0004)
	float                                              s_fSpawnTime;                                             // 0x03C4(0x0004)
	int                                                m_nPostRenderIcon;                                        // 0x03C8(0x0004)
	int                                                m_nUniqueId;                                              // 0x03CC(0x0004)
	float                                              m_fBaseDamageMultiplier;                                  // 0x03D0(0x0004)
	struct FVector                                     c_vHitWallVelocity;                                       // 0x03D4(0x000C)
	class UDynamicLightEnvironmentComponent*           LightEnvironment;                                         // 0x03E0(0x0008) (Edit, Const, ExportObject, EditConst, Component, EditInline)
	struct FVector                                     m_vSpawnPosition;                                         // 0x03E8(0x000C)
	class UParticleSystemComponent*                    m_DebugProximityDistancePSC;                              // 0x03F4(0x0008) (ExportObject, Component, EditInline)
	float                                              m_fStandingStillPercent;                                  // 0x03FC(0x0004)
	int                                                m_nTargetsHitCount;                                       // 0x0400(0x0004)
	class UParticleSystem*                             m_DebugCollisionSphere;                                   // 0x0404(0x0008)
	struct FCollisionSettingsProjectile                m_CollisionSettings;                                      // 0x040C(0x0004)
	TArray<class AActor*>                              m_PassThroughTargets;                                     // 0x0410(0x0010) (NeedCtorLink)
	struct FTrackingSettings                           m_TrackingSettings;                                       // 0x0420(0x001C)
	float                                              m_fDelayTrackSeconds;                                     // 0x043C(0x0004)
	float                                              m_fExplosionOffsetDistance;                               // 0x0440(0x0004)
	float                                              s_fAoeRewindTime;                                         // 0x0444(0x0004)
	class ATgAkActorUnoccluded*                        m_AkActorUnoccluded;                                      // 0x0448(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProjectile");
		return ptr;
	}


	void SetNonThreatening();
	float CheckOcclusion();
	struct FRotator AlignDeployableByMyRotation(const struct FVector& HitNormal);
	void AltFireDetonate();
	void STATIC_GetExplosionFXParams(TArray<struct FParticleSysParam>* Params);
	void PlayAdditionalHitFX(class AActor* HitActor, const struct FVector& FXLocation, const struct FVector& HitNormal, const struct FVector& ProjDir, TArray<struct FParticleSysParam>* ExplosionParams);
	bool SuppressHitTargetFX(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, bool bExploded);
	void PlayHitTargetFX(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, bool bExploded);
	struct FName STATIC_GetExplodeInAirFxGroup();
	struct FName STATIC_GetHitWallFxGroup();
	struct FName STATIC_GetHitTargetFxGroup();
	void PlayHitWallExplosionFX(const struct FVector& HitNormal, const struct FVector& HitLocation);
	class UPhysicalMaterial* TraceWorldPhysicalGeometry(const struct FVector& StartLoc, const struct FVector& EndLoc, struct FVector* TraceHitLocation);
	void PlayFizzleFX(const struct FVector& HitNormal, bool bIsExplosionFizzle);
	void ReplicatedEvent(const struct FName& VarName);
	void ServerFizzle();
	void ServerDetonate();
	bool ProjectileCalcCamera(float fDeltaTime, struct FVector* out_CamLoc, struct FRotator* out_CamRot, float* out_FOV);
	void MyOnParticleSystemFinished(class UParticleSystemComponent* PSC);
	void Destroyed();
	void STATIC_HideProjectile();
	void TornOff();
	void ShutDown();
	void SpawnExplosionEffects(const struct FVector& HitLocation, const struct FVector& HitNormal, const struct FIMPACT_FX& ImpactFx);
	void Halt();
	void Fizzle();
	void CleanUpExploded();
	void ExplodeOnTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool STATIC_ShouldExplode();
	void ForceExplodeOnTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void Explode(const struct FVector& HitLocation, const struct FVector& HitNormal);
	class AActor* CalculateHitActor(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, struct FTraceHitInfo* HitInfo);
	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
	bool ApplyTheHit(class UTgDeviceFire* FireMode, const struct FImpactInfo& Impact, class AActor* DamageInstigator);
	bool CheckTeamPassThrough(class AActor* Other);
	void Tick(float DeltaSeconds);
	void ProxyUnTouch(class AActor* Other);
	void ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_HitPassThroughTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool ShouldExplodeOnTouching(class AActor* Other);
	bool STATIC_ForcefieldExclusionCheck(class AActor* Other);
	void STATIC_ProcessTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool WouldStopOnTouch(class AActor* Other);
	bool IsValidTouchTarget(class AActor* Other);
	bool CanHitTarget(class AActor* Other);
	bool STATIC_HitAllTaskforces();
	bool CanHitInstigator();
	bool STATIC_HandleOnProjectileHitTarget(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void ShutdownAndNotifyClient();
	void ProcessTouchAsEvent(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void FellOutOfWorld(class UClass* dmgType);
	void HitWall(const struct FVector& HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp);
	bool STATIC_IsOutsideMinRange(const struct FVector& HitLocation);
	void SetAcceleration();
	bool ProximityReached(class AActor* A, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_GetHitLocationForProximityTouch(class AActor* Target, struct FVector* HitLocation, struct FVector* HitNormal);
	bool STATIC_IsValidTarget(class AActor* A);
	void SetTarget(class AActor* TargetActor, const struct FVector& TargetLocation);
	struct FVector GetSeekLocation();
	void STATIC_UpdateSeekingDirection(float fDeltaTime);
	void RangeReached();
	bool ShouldExplodeAtMaxRange();
	bool CheckProjectileRange(const struct FVector& vLocOverride);
	void QueueSoundShutdown();
	struct FVector CalculateInitialVelocity(const struct FVector& vAimDirection, bool bPlayerControlled);
	void Init(const struct FVector& Direction);
	void Landed(const struct FVector& HitNormal, class AActor* FloorActor);
	void TimerExplode();
	void TimerPulse();
	void StartPulse();
	void PostProjectileInitialize();
	void PostBeginPlay();
	bool UseAOE();
	void STATIC_GetPullGrabSourceLocation(struct FVector* vSourceLoc);
	void STATIC_GetPullGrabOffsetFromSource(class ATgPawn* pGrabbedPawn, struct FVector* vOffset, struct FRotator* rRotation);
	void OnGrabTargetDetach(TEnumAsByte<EGrabState> endingGrabState, class ATgPawn* Target, bool bInterrupted);
	void OnGrabTargetAttach(TEnumAsByte<EGrabState> newGrabState, class ATgPawn* Target);
	void STATIC_ForceAllGrabTargetsDetach(TEnumAsByte<EGrabState> eState);
	class AActor* STATIC_GetGrabSourceAsActor();
	void STATIC_RemoveGrabbedPawn(class ATgPawn* pTarget);
	void STATIC_AddGrabbedPawn(class ATgPawn* pTarget);
	class USkeletalMeshComponent* STATIC_GetGrabSourceSkeletalMesh();
	class UParticleSystemComponent* SpawnDebugProximityDistancePSC();
	float GetTerminalVelocity();
	void STATIC_PostAkEvent(class UAkEvent* InAkEvent);
	void PlayNotifySound(TEnumAsByte<ENotifySound> eSound);
	void PlayNotifySound_Internal(TEnumAsByte<ENotifySound> eSound);
	void PlayMessageAkEvent(const struct Fdword& dwMsgId);
	void OnViewTargetChanged(class AActor* aNewViewTarget);
	bool STATIC_GetDeployLocationAndRotation(const struct FVector& vLocation, class AActor* TargetActor, const struct FVector& vNormal, struct FVector* OutLocation, struct FRotator* OutRotation);
	class ATgDeployable* SpawnDeployable(const struct FVector& vLocation, class AActor* TargetActor, const struct FVector& vNormal);
	bool STATIC_GetBotSpawnLocationAndRotation(const struct FVector& vLocation, const struct FPointer& botSetup, struct FVector* OutLocation, struct FRotator* OutRotation);
	class ATgPawn* SpawnBot(const struct FVector& vLocation, bool bPet);
	void STATIC_NativePostRenderFor(class APlayerController* PC, class UCanvas* Canvas, const struct FVector& CameraPosition, const struct FVector& CameraDir);
	void CompleteInitialization(unsigned char ExtraInfo);
	bool CheckPhysicality(int nPawnType);
	float STATIC_GetBuffedRange();
};


// Class TgGame.TgProj_NonSimulated
// 0x0018 (0x0468 - 0x0450)
class ATgProj_NonSimulated : public ATgProjectile
{
public:
	float                                              m_LagCompStep;                                            // 0x0450(0x0004) (Const)
	unsigned long                                      m_bPerformingLagCompensation : 1;                         // 0x0454(0x0004)
	unsigned long                                      m_bProcessingLagCompedTouches : 1;                        // 0x0454(0x0004)
	TArray<struct FLagCompedQueuedHitInfo>             m_LagCompedQueuedHits;                                    // 0x0458(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_NonSimulated");
		return ptr;
	}


	bool HitFromLagCompCheck(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void ProcessRemainingQueuedHits();
	void STATIC_ProcessTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void CheckShieldPassthrough();
	void Tick(float DeltaSeconds);
	void STATIC_SimForLagCompensation(float LagTime);
	bool STATIC_TargetHasHistoryComponent(class AActor* Target);
};


// Class TgGame.TgProj_Simulated
// 0x00DC (0x052C - 0x0450)
class ATgProj_Simulated : public ATgProjectile
{
public:
	unsigned long                                      m_bHasFlashedShutdown : 1;                                // 0x0450(0x0004)
	unsigned long                                      m_bHasFlashExploded : 1;                                  // 0x0450(0x0004)
	unsigned long                                      m_bIgnoreClientHits : 1;                                  // 0x0450(0x0004)
	unsigned long                                      m_bShouldQueueServerHits : 1;                             // 0x0450(0x0004)
	unsigned long                                      m_bHasQueuedServerHit : 1;                                // 0x0450(0x0004)
	unsigned long                                      m_bQueuedExplodeDoesNotHideProjectile : 1;                // 0x0450(0x0004)
	unsigned long                                      m_bQueuedExplodeTargetIsNonWorld : 1;                     // 0x0450(0x0004)
	unsigned long                                      m_bNeedsFrictionOverride : 1;                             // 0x0450(0x0004)
	unsigned long                                      m_bFlashSpecialExplosion : 1;                             // 0x0450(0x0004)
	unsigned long                                      m_bDynamicShadow : 1;                                     // 0x0450(0x0004)
	unsigned long                                      m_bShadowDecalImportant : 1;                              // 0x0450(0x0004)
	unsigned long                                      m_bTrackProjectileForTimelapse : 1;                       // 0x0450(0x0004)
	unsigned long                                      s_bTrackingInitialized : 1;                               // 0x0450(0x0004)
	unsigned long                                      m_bRequireAccurateTicksForPrediction : 1;                 // 0x0450(0x0004) (Const)
	unsigned long                                      m_bEventLoadPropsFromFiremode : 1;                        // 0x0450(0x0004)
	int                                                m_nProjectileInstanceId;                                  // 0x0454(0x0004)
	int                                                m_nClientFireRequestId;                                   // 0x0458(0x0004)
	int                                                m_nFireLoopInstanceId;                                    // 0x045C(0x0004)
	struct FVector                                     m_LerpFromClientOffset;                                   // 0x0460(0x000C)
	float                                              m_LerpTimeRemaining;                                      // 0x046C(0x0004)
	class AActor*                                      m_QueuedExplodeTarget;                                    // 0x0470(0x0008)
	float                                              m_fQueuedExplodeTimeAliveAtHit;                           // 0x0478(0x0004)
	struct FVector                                     m_QueuedExplodeLocation;                                  // 0x047C(0x000C)
	struct FVector                                     m_QueuedExplodeNormal;                                    // 0x0488(0x000C)
	struct FVector                                     m_QueuedExplodeVelocity;                                  // 0x0494(0x000C)
	struct FVector                                     m_vSpawnVelocity;                                         // 0x04A0(0x000C)
	struct FVector                                     m_vSpawnAcceleration;                                     // 0x04AC(0x000C)
	struct FRotator                                    m_rSpawnRotator;                                          // 0x04B8(0x000C)
	float                                              m_fAllowedClientMovementTime;                             // 0x04C4(0x0004)
	float                                              m_fSpawnTimeStamp;                                        // 0x04C8(0x0004)
	float                                              m_fGravityScale;                                          // 0x04CC(0x0004)
	float                                              m_fFrictionOverride;                                      // 0x04D0(0x0004)
	TArray<class ATgPlayerController*>                 s_InterestedPlayers;                                      // 0x04D4(0x0010) (NeedCtorLink)
	int                                                m_nShadowFXID;                                            // 0x04E4(0x0004)
	class UTgSpecialFx*                                m_ShadowFX;                                               // 0x04E8(0x0008)
	class UDecalComponent*                             m_ShadowDecal;                                            // 0x04F0(0x0008) (ExportObject, Component, EditInline)
	float                                              m_fShadowBaseWidth;                                       // 0x04F8(0x0004)
	float                                              m_fMaxDecalHeight;                                        // 0x04FC(0x0004)
	struct FRotator                                    m_CachedRotation;                                         // 0x0500(0x000C)
	float                                              m_fTrackingUpdateRate;                                    // 0x050C(0x0004)
	float                                              s_fTrackingUpdateTimer;                                   // 0x0510(0x0004)
	class UTgGameplayCurves*                           m_GameplayCurves;                                         // 0x0514(0x0008)
	int                                                m_nDeployableOverlayDisplayMask;                          // 0x051C(0x0004)
	TEnumAsByte<EDeployableOverlayIcon>                m_eDeployableOverlayIcon;                                 // 0x0520(0x0001)
	TEnumAsByte<EDeployableOverlayState>               m_eDeployableOverlayState;                                // 0x0521(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x0522(0x0002) MISSED OFFSET
	float                                              m_fDeployableOverlayEnemyViewDist;                        // 0x0524(0x0004)
	float                                              m_fDeployableActiveLifeTime;                              // 0x0528(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Simulated");
		return ptr;
	}


	void SetNonThreatening();
	void TickAhead(float tickAmount);
	void SetTarget(class AActor* TargetActor, const struct FVector& TargetLocation);
	void ClientTargetUpdate(class AActor* TargetActor, const struct FVector& TargetLocation);
	void HitWall(const struct FVector& HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp);
	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
	bool CheckProjectileRange(const struct FVector& vLocOverride);
	void CheckShieldPassthrough();
	void Tick(float DeltaSeconds);
	void Destroyed();
	void Fizzle();
	void ShutDown();
	void ClientSyncServerBounce(const struct FVector& HitLocation, const struct FVector& BounceVelocity);
	void ClientHitUpdate(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void ExplodeOnTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void ForceExplodeOnTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_FudgeProjectileHitLocationForShields(class AActor* Other, struct FVector* HitLocation, struct FVector* HitNormal);
	void SetShouldQueueServerHits(bool bShouldQueue);
	bool STATIC_HandleNonWorldQueuedExplodeTarget();
	void ClientHitTimeWall(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitVelocity);
	void ClientExplodeSpecial(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void ClientExplode(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void Explode(const struct FVector& HitLocation, const struct FVector& HitNormal);
	void SendSpawnAckToServer();
	void SendExplodeToServer(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_HitPassThroughTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_ProcessTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void HandleQueuedFirstWorldExplosion();
	void LoadFiremodeProp(int nPropId, float fValue);
	void ApplySpawnParams(float fDamageRadius, float fGeneric2);
	void ShutDownTrackingForTimelapse();
	void STATIC_InitTrackingForTimelapse();
	int STATIC_GetIndexForTimelapseTracking();
	void PredictStartLocationBasedOnPing(float Ping);
	float GetGravityZ();
	bool CheckFirstWorldExplosion(const struct FVector& StartPos, const struct FVector& EndPos, const struct FVector& projVelocity, float* fTimeHit);
	void SetLocationFromServer(const struct FVector& InLocation, bool bFarMove);
	void STATIC_FlashNotifyTarget(class AActor* TargetActor, const struct FVector& TargetLocation);
	void STATIC_FlashNotifyBounce(const struct FVector& BounceLocation, const struct FVector& BounceVelocity);
	void STATIC_FlashNotifyHitTimeWall(class AActor* TimeWall, const struct FVector& HitVelocity, const struct FVector& HitLocation);
	void STATIC_FlashNotifyHitWall(class AActor* Wall, const struct FVector& HitNormal, const struct FVector& HitLocation);
	void STATIC_FlashNotifyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_FlashNotifyExplodedSpecial(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_FlashNotifyExploded(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_FlashNotifyHalt();
	void STATIC_FlashNotifyFizzle();
	void STATIC_FlashNotifyShutdown();
	void STATIC_FlashNotifySpawn();
	void CompleteInitialization(unsigned char ExtraInfo);
};


// Class TgGame.TgProj_Bombardment
// 0x0010 (0x053C - 0x052C)
class ATgProj_Bombardment : public ATgProj_Simulated
{
public:
	float                                              m_fFadeInTime;                                            // 0x052C(0x0004)
	float                                              m_fCurrentFade;                                           // 0x0530(0x0004)
	class UMaterialInstanceTimeVarying*                m_CachedDecalMaterial;                                    // 0x0534(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Bombardment");
		return ptr;
	}

};


// Class TgGame.TgProj_FreeGrenade
// 0x0054 (0x0580 - 0x052C)
class ATgProj_FreeGrenade : public ATgProj_Simulated
{
public:
	unsigned long                                      m_bShieldTouched : 1;                                     // 0x052C(0x0004)
	unsigned long                                      m_bTimerExplodeDisabled : 1;                              // 0x052C(0x0004)
	unsigned long                                      m_bExplodeOnTouch : 1;                                    // 0x052C(0x0004)
	unsigned long                                      m_bExplodeOnGeometry : 1;                                 // 0x052C(0x0004)
	unsigned long                                      m_bExplodeOnFloor : 1;                                    // 0x052C(0x0004)
	unsigned long                                      m_bUseBilinearInterpolationForBounceDamping : 1;          // 0x052C(0x0004)
	unsigned long                                      m_bUseGravityZOverride : 1;                               // 0x052C(0x0004)
	class ATgDeployable*                               m_TouchedShield;                                          // 0x0530(0x0008)
	float                                              m_fToleranceZ;                                            // 0x0538(0x0004)
	float                                              m_fBounceDampingVertMin;                                  // 0x053C(0x0004)
	float                                              m_fBounceDampingVertMax;                                  // 0x0540(0x0004)
	float                                              m_fBounceDampingHorizMin;                                 // 0x0544(0x0004)
	float                                              m_fBounceDampingHorizMax;                                 // 0x0548(0x0004)
	float                                              m_fBounceDamping;                                         // 0x054C(0x0004)
	float                                              m_fSpeedToActivateBounceFX;                               // 0x0550(0x0004)
	float                                              m_fGravityZOverride;                                      // 0x0554(0x0004)
	int                                                m_nBounceCount;                                           // 0x0558(0x0004)
	int                                                m_nBouncesToExplode;                                      // 0x055C(0x0004)
	float                                              m_fBounceDistinctionDuration;                             // 0x0560(0x0004)
	int                                                m_fLastBounceTime;                                        // 0x0564(0x0004)
	struct FVector                                     m_vRecentHitNormal;                                       // 0x0568(0x000C)
	float                                              m_fRecentHitTime;                                         // 0x0574(0x0004)
	float                                              m_fDelayPredictStartLocPing;                              // 0x0578(0x0004)
	float                                              m_fBounceFlashThreshold;                                  // 0x057C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_FreeGrenade");
		return ptr;
	}


	void Destroyed();
	void Landed(const struct FVector& HitNormal, class AActor* FloorActor);
	void STATIC_ProcessTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool WouldStopOnTouch(class AActor* Other);
	void PlayBounceSound();
	void ApplyBounceDamping(float fBounceDamping, struct FVector* vBounceVelocity);
	struct FVector STATIC_GetBounceVelocity(const struct FVector& HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp);
	void ApplyBounce(const struct FVector& HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp);
	bool ShouldHitBounce(class AActor* Target, const struct FVector& HitNormal);
	void HitWall(const struct FVector& HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp);
	void OnLand();
	void STATIC_DisableLandExplodeTimer();
	void PlayLandExplodeFX();
	void StartLandExplodeTimer();
	void TimerExplode();
	float STATIC_GetPostLandDuration();
	void PlayHitTargetFX(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, bool bExploded);
	void PlayHitWallExplosionFX(const struct FVector& HitNormal, const struct FVector& HitLocation);
	void Timer();
	void ShutDown();
	void PostBeginPlay();
	void ApplySpawnParams(float fDamageRadius, float fSimPing);
	void CompleteInitialization(unsigned char ExtraInfo);
	void PredictStartLocationBasedOnPing(float Ping);
	float GetGravityZ();
};


// Class TgGame.TgProj_Piercing
// 0x0000 (0x052C - 0x052C)
class ATgProj_Piercing : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Piercing");
		return ptr;
	}

};


// Class TgGame.TgProj_SpeedOverTime
// 0x0000 (0x052C - 0x052C)
class ATgProj_SpeedOverTime : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_SpeedOverTime");
		return ptr;
	}

};


// Class TgGame.TgProj_SpeedOverRange
// 0x0000 (0x052C - 0x052C)
class ATgProj_SpeedOverRange : public ATgProj_SpeedOverTime
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_SpeedOverRange");
		return ptr;
	}

};


// Class TgGame.TgProj_ExtraColliders
// 0x0030 (0x055C - 0x052C)
class ATgProj_ExtraColliders : public ATgProj_SpeedOverRange
{
public:
	class ATgCollisionProxy_Cylinder*                  m_SecondaryCollisionProxies[0x2];                         // 0x052C(0x0008)
	class UParticleSystemComponent*                    m_SecondaryDebugProximityDistancePSC[0x2];                // 0x053C(0x0008) (ExportObject, Component, EditInline)
	TArray<struct FTrackedCollision>                   m_TrackedCollisions;                                      // 0x054C(0x0010) (Component, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_ExtraColliders");
		return ptr;
	}


	void PlayHitWallExplosionFX(const struct FVector& HitNormal, const struct FVector& HitLocation);
	void PlayHitTargetFX(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, bool bExploded);
	float STATIC_GetDecalRotationOffset();
	void STATIC_HideProjectile();
	void Destroyed();
	void SpawnSecondaryCollisionProxies();
	float GetCollistionOffsetDistance();
	struct FVector GetCollisionOffsetDir();
	void STATIC_HandleSecondaryProxyUntouch(class AActor* Other);
	void STATIC_HandleSecondaryProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void ProxyUnTouch(class AActor* Other);
	void ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void ForwardProxyUntouch(class AActor* Other);
	void ForwardProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void OnSecondaryProxyUnTouch(class AActor* Other);
	void OnSecondaryProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void CompleteInitialization(unsigned char ExtraInfo);
};


// Class TgGame.TgAudioComponent
// 0x0010 (0x02DC - 0x02CC)
class UTgAudioComponent : public UAudioComponent
{
public:
	unsigned long                                      m_bCanBeHeardDuringStealth : 1;                           // 0x02CC(0x0004)
	float                                              m_fStealthFadeInTime;                                     // 0x02D0(0x0004)
	float                                              m_fStealthFadeOutTime;                                    // 0x02D4(0x0004)
	float                                              m_fStealthVolumeMultiplier;                               // 0x02D8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAudioComponent");
		return ptr;
	}


	void STATIC_OcclusionChanged(bool bNowOccluded);
	void STATIC_ApplyAdditionalPriority();
};


// Class TgGame.TgAudioComponent_ModByVelocity
// 0x0000 (0x02DC - 0x02DC)
class UTgAudioComponent_ModByVelocity : public UTgAudioComponent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAudioComponent_ModByVelocity");
		return ptr;
	}

};


// Class TgGame.TgDecalManager
// 0x0000 (0x02BC - 0x02BC)
class ATgDecalManager : public ADecalManager
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDecalManager");
		return ptr;
	}

};


// Class TgGame.TgEmitter
// 0x0008 (0x029C - 0x0294)
class ATgEmitter : public AEmitter
{
public:
	struct FName                                       BoneName;                                                 // 0x0294(0x0008) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter");
		return ptr;
	}


	void ScaleEmitter(float ScaleFactor);
	void AttachTo(class APawn* P, const struct FName& NewBoneName);
	void ReplicatedEvent(const struct FName& VarName);
};


// Class TgGame.TgEmitter_CameraEffect
// 0x0024 (0x02C0 - 0x029C)
class ATgEmitter_CameraEffect : public ATgEmitter
{
public:
	float                                              m_fDistFromCamera;                                        // 0x029C(0x0004) (Edit)
	unsigned long                                      m_bShowOnlyIn1P : 1;                                      // 0x02A0(0x0004) (Edit)
	unsigned long                                      m_bShowOnlyIn3P : 1;                                      // 0x02A0(0x0004) (Edit)
	unsigned long                                      m_bIsIn1P : 1;                                            // 0x02A0(0x0004)
	unsigned long                                      m_bIsCameraEffectActive : 1;                              // 0x02A0(0x0004)
	TArray<struct FFx_Sound>                           m_SoundList;                                              // 0x02A4(0x0010) (Component, NeedCtorLink)
	int                                                m_nSourceFxId;                                            // 0x02B4(0x0004)
	class ATgPawn*                                     m_EffectSourcePawn;                                       // 0x02B8(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter_CameraEffect");
		return ptr;
	}


	void STATIC_UpdateLocation(float CamFOVDeg, struct FVector* CamLoc, struct FRotator* CamRot);
	void StopSounds();
	void PlaySounds();
	void SetSoundList(TArray<struct FFx_Sound> SoundList);
	void SetCameraEffectActive(bool bActive);
	void Reactivate();
	void Deactivate();
	void STATIC_Activate();
	void Destroyed();
};


// Class TgGame.TgEmitter_CameraEffect_DamageBase
// 0x0001 (0x02C1 - 0x02C0)
class ATgEmitter_CameraEffect_DamageBase : public ATgEmitter_CameraEffect
{
public:
	TEnumAsByte<EDamageEffectScreenLocation>           ScreenLocation;                                           // 0x02C0(0x0001) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter_CameraEffect_DamageBase");
		return ptr;
	}


	void STATIC_UpdateLocation(float CamFOVDeg, struct FVector* CamLoc, struct FRotator* CamRot);
	void STATIC_Activate();
	void SetDamageIntensity(float fDamageIntensity, bool bCritical);
};


// Class TgGame.TgEmitter_CameraEffect_LowHealth
// 0x0004 (0x02C4 - 0x02C0)
class ATgEmitter_CameraEffect_LowHealth : public ATgEmitter_CameraEffect
{
public:
	float                                              m_fFade;                                                  // 0x02C0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter_CameraEffect_LowHealth");
		return ptr;
	}


	void STATIC_UpdateFOV(float fFOV);
	void SetDeathProximity(float fCloseToDeath);
};


// Class TgGame.TgEmitter_TeamColor
// 0x0008 (0x029C - 0x0294)
class ATgEmitter_TeamColor : public AEmitter
{
public:
	int                                                nTaskForce;                                               // 0x0294(0x0004) (Edit)
	struct FParticleChannelContainer                   DefaultParticleChannels;                                  // 0x0298(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter_TeamColor");
		return ptr;
	}


	void STATIC_NotifyLocalPlayerTeamReceived();
	void SetPSCChannels();
};


// Class TgGame.TgEmitterSpawnable
// 0x0000 (0x0294 - 0x0294)
class ATgEmitterSpawnable : public AEmitter
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitterSpawnable");
		return ptr;
	}

};


// Class TgGame.TgImpactFx
// 0x004C (0x00AC - 0x0060)
class UTgImpactFx : public UObject
{
public:
	float                                              c_fMaxFxDistance;                                         // 0x0060(0x0004)
	unsigned long                                      c_bAlignToSurfaceNormal : 1;                              // 0x0064(0x0004)
	struct FIMPACT_FX                                  c_EmptyImpact;                                            // 0x0068(0x0034)
	TArray<struct FIMPACT_FX>                          c_Impacts;                                                // 0x009C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgImpactFx");
		return ptr;
	}


	struct FIMPACT_FX STATIC_GetImpactFx(class UPhysicalMaterial* HitMaterial);
	bool STATIC_IsEffectRelevant(class AActor* Viewer, const struct FVector& HitLocation);
	void ApplyImpact(class AActor* Instigator, class AActor* HitActor, const struct FVector& HitLocation, const struct FVector& HitNormal, const struct FIMPACT_FX& Impact);
};


// Class TgGame.TgParticleModuleTypeDataLight
// 0x0010 (0x0078 - 0x0068)
class UTgParticleModuleTypeDataLight : public UParticleModuleTypeDataBase
{
public:
	class UPointLightComponent*                        m_PointLightComponent;                                    // 0x0068(0x0008) (Edit, ExportObject, Component, EditInline)
	class UPointLightComponent*                        m_PLCDuplicate;                                           // 0x0070(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgParticleModuleTypeDataLight");
		return ptr;
	}

};


// Class TgGame.TgPhysicalMaterialProperty
// 0x0008 (0x0068 - 0x0060)
class UTgPhysicalMaterialProperty : public UPhysicalMaterialPropertyBase
{
public:
	struct FName                                       MaterialType;                                             // 0x0060(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPhysicalMaterialProperty");
		return ptr;
	}

};


// Class TgGame.TgSilhouetteComponentPaladins
// 0x0064 (0x0300 - 0x029C)
class UTgSilhouetteComponentPaladins : public UTgSilhouetteComponent
{
public:
	struct FSilhouetteColorSettings                    m_ColorSettings;                                          // 0x029C(0x0024) (Edit)
	struct FSilhouetteFadeSettings                     m_FadeSettings;                                           // 0x02C0(0x0014) (Edit)
	struct FSilhouettePulseSettings                    m_PulseSettings;                                          // 0x02D4(0x002C) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSilhouetteComponentPaladins");
		return ptr;
	}

};


// Class TgGame.TgSilhouetteComponentPaladinsDeployable
// 0x0000 (0x0300 - 0x0300)
class UTgSilhouetteComponentPaladinsDeployable : public UTgSilhouetteComponentPaladins
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSilhouetteComponentPaladinsDeployable");
		return ptr;
	}

};


// Class TgGame.TgSilhouetteComponentPaladinsPawn
// 0x0000 (0x0300 - 0x0300)
class UTgSilhouetteComponentPaladinsPawn : public UTgSilhouetteComponentPaladins
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSilhouetteComponentPaladinsPawn");
		return ptr;
	}

};


// Class TgGame.TgSilhouetteComponentPayload
// 0x0000 (0x0300 - 0x0300)
class UTgSilhouetteComponentPayload : public UTgSilhouetteComponentPaladins
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSilhouetteComponentPayload");
		return ptr;
	}

};


// Class TgGame.TgSilhouetteManager
// 0x0024 (0x02A4 - 0x0280)
class ATgSilhouetteManager : public AActor
{
public:
	class AActor*                                      m_Owner;                                                  // 0x0280(0x0008)
	unsigned long                                      m_bSilhouettesEnabled : 1;                                // 0x0288(0x0004)
	unsigned long                                      m_bForceSilhouetteVisible : 1;                            // 0x0288(0x0004) (Edit, Const)
	TArray<struct FTgSilhouetteInfo>                   m_SilhouetteInfos;                                        // 0x028C(0x0010) (Transient, Component, NeedCtorLink)
	class UClass*                                      m_SilhouetteClass;                                        // 0x029C(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSilhouetteManager");
		return ptr;
	}


	void TickSilhouettes(float DeltaSeconds);
	bool ShouldAnySilhouettesBeVisible();
	void STATIC_UpdateSilhouetteVisibility();
	void ClearAllSilhouetteInfos();
	bool RemoveSilhouetteInfo(class UMeshComponent* ParentMesh);
	int STATIC_FindSilhouetteInfo(class UMeshComponent* ParentMesh);
	int InitializeSilhouetteComponent(class UMeshComponent* InMesh, float fLifeAfterDeath);
};


// Class TgGame.TgSoundGroup
// 0x0020 (0x0080 - 0x0060)
class UTgSoundGroup : public UObject
{
public:
	TArray<class USoundCue*>                           c_SoundCues;                                              // 0x0060(0x0010) (Const, NeedCtorLink)
	TArray<struct FFootstepSoundInfo>                  c_FootstepSounds;                                         // 0x0070(0x0010) (Const, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSoundGroup");
		return ptr;
	}


	void PlayFootStepSound(class APawn* P, int FootDown, const struct FName& MaterialType);
	void STATIC_PlaySound(TEnumAsByte<EeTG_SOUNDS> eSound, class APawn* P);
};


// Class TgGame.TgSpecialFx
// 0x00CC (0x012C - 0x0060)
class UTgSpecialFx : public UObject
{
public:
	int                                                c_nFxId;                                                  // 0x0060(0x0004)
	class UMeshComponent*                              c_OwnerMesh;                                              // 0x0064(0x0008) (ExportObject, Component, EditInline)
	class AActor*                                      c_Owner;                                                  // 0x006C(0x0008)
	unsigned long                                      c_bAttached : 1;                                          // 0x0074(0x0004)
	unsigned long                                      c_bAppliesToAllModes : 1;                                 // 0x0074(0x0004)
	unsigned long                                      c_bSelfManage : 1;                                        // 0x0074(0x0004)
	unsigned long                                      c_bFromEffectForm : 1;                                    // 0x0074(0x0004)
	unsigned long                                      c_bVisualComplete : 1;                                    // 0x0074(0x0004)
	unsigned long                                      c_bAudioComplete : 1;                                     // 0x0074(0x0004)
	unsigned long                                      c_bMuteSound : 1;                                         // 0x0074(0x0004)
	unsigned long                                      c_bIsDebuff : 1;                                          // 0x0074(0x0004)
	unsigned long                                      c_bHasTeamMaterials : 1;                                  // 0x0074(0x0004)
	unsigned long                                      c_bActive : 1;                                            // 0x0074(0x0004)
	unsigned long                                      c_bSoundActive : 1;                                       // 0x0074(0x0004)
	unsigned long                                      c_bIsSpawnFx : 1;                                         // 0x0074(0x0004)
	unsigned long                                      c_bUseBeam : 1;                                           // 0x0074(0x0004)
	unsigned long                                      c_bLifetimeManagedExternally : 1;                         // 0x0074(0x0004)
	unsigned long                                      c_bLocalPawnIsOwner : 1;                                  // 0x0074(0x0004) (AlwaysInit)
	unsigned long                                      m_bMatLoaded : 1;                                         // 0x0074(0x0004)
	unsigned long                                      m_bMatLoadedFriendly : 1;                                 // 0x0074(0x0004)
	unsigned long                                      m_bMatLoadedLocal : 1;                                    // 0x0074(0x0004)
	unsigned long                                      m_bDecalMatLoaded : 1;                                    // 0x0074(0x0004)
	unsigned long                                      m_bDecalMatLoadedFriendly : 1;                            // 0x0074(0x0004)
	unsigned long                                      m_bDecalMatLoadedLocal : 1;                               // 0x0074(0x0004)
	int                                                c_nPriorityType;                                          // 0x0078(0x0004)
	int                                                c_nPrioritySort;                                          // 0x007C(0x0004)
	struct FName                                       c_nmSocket;                                               // 0x0080(0x0008)
	struct FName                                       c_nmDisplayGroup;                                         // 0x0088(0x0008)
	int                                                c_nDisplayMode;                                           // 0x0090(0x0004)
	int                                                c_nIndex;                                                 // 0x0094(0x0004)
	int                                                c_nEquipSlot;                                             // 0x0098(0x0004)
	class UMaterialInstance*                           c_MaterialInstance;                                       // 0x009C(0x0008)
	float                                              c_fTransition;                                            // 0x00A4(0x0004)
	int                                                c_nHitEffectBase;                                         // 0x00A8(0x0004)
	float                                              c_fMaxEffectDistance;                                     // 0x00AC(0x0004)
	struct FParticleChannelContainer                   c_ParticleChannelOverride;                                // 0x00B0(0x0004)
	int                                                c_nSortPriorityOverride;                                  // 0x00B4(0x0004)
	TEnumAsByte<ELightFxState>                         c_LightComponentState;                                    // 0x00B8(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x00B9(0x0003) MISSED OFFSET
	class ULightComponent*                             c_LightComponent;                                         // 0x00BC(0x0008) (ExportObject, Component, AlwaysInit, EditInline)
	struct FPointer                                    c_ManagedLightEmitter;                                    // 0x00C4(0x0008) (AlwaysInit)
	TArray<struct FFx_Sound>                           c_SoundList;                                              // 0x00CC(0x0010) (Component, AlwaysInit, NeedCtorLink)
	TArray<struct FFx_PSC>                             c_PSCList;                                                // 0x00DC(0x0010) (Component, AlwaysInit, NeedCtorLink)
	TArray<struct FFx_Material>                        c_MaterialList;                                           // 0x00EC(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<struct FFx_Decal>                           c_DecalList;                                              // 0x00FC(0x0010) (Component, AlwaysInit, NeedCtorLink)
	class UTgCameraShake*                              c_CameraShake;                                            // 0x010C(0x0008)
	class UTgTimerManager*                             c_ActiveTimer;                                            // 0x0114(0x0008)
	TArray<struct FAppliedMaterialHandle>              m_AppliedMaterials;                                       // 0x011C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSpecialFx");
		return ptr;
	}


	bool STATIC_IsLocal();
	bool STATIC_IsFriendly();
	float CalculateOrientedDecalRotation(const struct FVector& HitLocation, const struct FVector& HitNormal, const struct FVector& DecalOrientationDirection);
	void SetDepthPriorityGroup(TEnumAsByte<ESceneDepthPriorityGroup> NewDepthPriorityGroup);
	void STATIC_SetKillOnDeactivate();
	void STATIC_ListSounds();
	void UpdateBeamFx(const struct FVector& HitLocation, const struct FVector& HitOrigin, class AActor* targetOverride);
	void SpawnTracer(const struct FVector& HitLocation, const struct FVector& HitOrigin);
	class AActor* STATIC_GetHitActor(const struct FVector& EffectLocation, const struct FVector& HitLocation);
	bool STATIC_HasSoundCue();
	void RemoveMICFxFromOwningPawn();
	void ApplyMICFxToOwningPawn(int nMatTypeCodeOverride, int nMaterialPriority);
	class USkeletalMeshComponent* STATIC_FindMeshWithSocket(const struct FName& nmSocket, class USkeletalMeshComponent* first, class AActor* Second, struct FName* BoneName, struct FVector* RelativeLocation, struct FRotator* RelativeRotation, struct FVector* RelativeScale);
	void OverridePSCChannels(const struct FParticleChannelContainer& PSysChannels);
	struct FParticleChannelContainer STATIC_GetLocalPlayerPSCChannels(class UParticleSystemComponent* ActivePSC, class UParticleSystem* Template);
	void STATIC_UpdateHiddenDecals(bool bClearAll);
	bool STATIC_InitDecalFadeOut(struct FFx_Decal* Decal);
	void DeactivateDecal(struct FFx_Decal* Decal);
	void ActivateDecal(struct FFx_Decal* Decal);
	void StopSound();
	void STATIC_PlaySound();
	void CheckDeactivate();
	void OnAudioFinishedFX(class UAudioComponent* FinishedComponent);
	void OnParticleSystemFinished(class UParticleSystemComponent* FinishedComponent);
	void Deactivate(bool bForceDeactivate);
	float STATIC_Activate(const struct FVector& HitLocation, bool bSkipRelevantChecking, bool bForceSetManaged);
	void AdjustEffectFOV(float NewFOV);
	void AdjustEffectScale(int nPSCIndex, float fScale);
	void AdjustFxScaleByRadius(float fScale);
	void AdjustEffectRadius(int nPSCIndex, float fScale);
	class ATgPawn* STATIC_FindLocalPlayerPawn();
	class ATgPlayerController* STATIC_FindLocalPlayerController();
	bool STATIC_IsFxRelevant(const struct FVector& SpawnLocation);
	void SetHitEffectScaleBasedOnDamage(int nHealthChange);
	void STATIC_PlayCameraShake(const struct FVector& Epicenter);
	void SpawnDecalAt(const struct FVector& HitLocation, const struct FVector& HitNormal, float DecalRotation, float Scale);
	void STATIC_SpawnSound(const struct FVector& Location, bool bForceSetManaged);
	void STATIC_SpawnEmitter(const struct FVector& HitLocation, const struct FVector& HitNormal, float fScale, TArray<struct FParticleSysParam> Params);
	void STATIC_UpdateSoundPlaying(class UAudioComponent* pacSound);
	bool AreAnySoundsPlaying();
	void SetPSCRunning(class UParticleSystemComponent* pPSC, bool bOn);
	bool AreAnyPSCRunning();
	void ResetParticles(bool bResetInstances);
	void PlaySoundAt(const struct FVector& Location);
	bool ShouldShowWhenStealthed();
	void STATIC_SetHidden(bool bNewHidden);
	void AdjustHidden(bool bHidden);
	void OnActiveTimeExpired();
	void SetActiveTime(float Duration, class ATgPawn* Owner);
	class AActor* SpawnActor(class UClass* InClass, const struct FVector& Location, const struct FRotator& Rotation);
	void SetPSCChannels(class UParticleSystemComponent* PSC, bool bOnlyAllowNonZeroMask, class UParticleSystem* Template);
	void ActivateLocalPlayerFx(class UParticleSystemComponent* ActivePSC);
	class UMeshComponent* STATIC_GetOwnerMesh(class AActor* pOwner);
	struct FRotator STATIC_GetEffectRotation();
	struct FVector STATIC_GetEffectLocation();
	void Detach();
	void AttachToOwner(class AActor* pOwner);
};


// Class TgGame.TgSpecialFxLightManager
// 0x0034 (0x0094 - 0x0060)
class UTgSpecialFxLightManager : public UObject
{
public:
	unsigned long                                      c_FxLightsEnabled : 1;                                    // 0x0060(0x0004) (Config)
	unsigned long                                      c_FxLightsUnconstrained : 1;                              // 0x0060(0x0004) (Config)
	int                                                c_FxLightsMaxActive;                                      // 0x0064(0x0004) (Config)
	int                                                c_FxLightsMaxDying;                                       // 0x0068(0x0004) (Config)
	TArray<struct FPointer>                            m_ActiveEmitters;                                         // 0x006C(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<struct FPointer>                            m_DyingEmitters;                                          // 0x007C(0x0010) (AlwaysInit, NeedCtorLink)
	class ATgPawn*                                     c_LocalPawn;                                              // 0x008C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSpecialFxLightManager");
		return ptr;
	}


	void STATIC_UserSetLevel(int LightLevel);
	void SetLevelInternal(int LightLevel);
	void STATIC_LightKilledElsewhere(const struct FPointer& FxEmitterKilled);
	void SetLightState(const struct FPointer& ExtantFxEmitter, TEnumAsByte<ESpecialFxLightState> NewFxLightState);
	void AddLight(const struct FPointer& NewFxEmitter);
	void STATIC_InitializeFxLightManager();
};


// Class TgGame.TgEffect
// 0x0040 (0x00A0 - 0x0060)
class UTgEffect : public UObject
{
public:
	class UTgEffectGroup*                              m_EffectGroup;                                            // 0x0060(0x0008)
	int                                                m_nEffectID;                                              // 0x0068(0x0004)
	int                                                m_nPropertyId;                                            // 0x006C(0x0004)
	int                                                m_nCalcMethodCode;                                        // 0x0070(0x0004)
	unsigned long                                      m_bUseOnInterval : 1;                                     // 0x0074(0x0004)
	unsigned long                                      m_bRemovable : 1;                                         // 0x0074(0x0004)
	unsigned long                                      m_bAllowStacking : 1;                                     // 0x0074(0x0004)
	unsigned long                                      m_bApplyToProperty : 1;                                   // 0x0074(0x0004)
	int                                                m_nPropertyValueId;                                       // 0x0078(0x0004)
	float                                              m_fCurrent;                                               // 0x007C(0x0004)
	float                                              m_fBase;                                                  // 0x0080(0x0004)
	float                                              m_fMinimum;                                               // 0x0084(0x0004)
	float                                              m_fMaximum;                                               // 0x0088(0x0004)
	float                                              m_fScalingFactor;                                         // 0x008C(0x0004)
	float                                              m_fStaticValueOffset;                                     // 0x0090(0x0004)
	float                                              m_MaxKnockbackZ;                                          // 0x0094(0x0004)
	float                                              m_MinKnockbackZ;                                          // 0x0098(0x0004)
	float                                              m_KnockbackZMultiplier;                                   // 0x009C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffect");
		return ptr;
	}


	int STATIC_GetDeviceIdFromMode(class UTgDeviceFire* DeviceFireMode);
	int STATIC_GetDamageReportDeviceId();
	void ApplyEnterCombatRules(class AActor* Instigator, class AActor* Target);
	int STATIC_GetTopMostDevice(class UTgDeviceFire* devFire);
	void TrackStats(class ATgPawn* Instigator, class AActor* Target, const struct FImpactInfo& Impact, float fDamage, int iTargetDeviceModeId, bool bIsEnemy, float fMissingHealth, float fMitigatedDamage, float fDamageToShields);
	void Remove(class AActor* Target);
	void Reapply(class AActor* Target);
	float STATIC_GetScaledBaseValue();
	float STATIC_GetProratedValue();
	void ApplyToProperty(class AActor* Target, int nPropertyId, float fProratedAmount, bool bRemove);
	bool RemoveStacks(class AActor* Target, int nNumStacks);
	bool ApplyStacks(class AActor* Target, int nNumStacks);
	bool ApplyEffect(class AActor* Target, const struct FImpactInfo& Impact, bool bLatent);
	void SetProperty(class AActor* Target, int nPropertyId, float fNewValue);
	bool CanBeApplied(class AActor* Target);
	class UTgEffect* CloneEffect();
};


// Class TgGame.TgEffect_Lift
// 0x0000 (0x00A0 - 0x00A0)
class UTgEffect_Lift : public UTgEffect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffect_Lift");
		return ptr;
	}


	void Remove(class AActor* Target);
	bool ApplyEffect(class AActor* Target, const struct FImpactInfo& Impact, bool bLatent);
};


// Class TgGame.TgEffect_TimeBasedScaling_Base
// 0x0000 (0x00A0 - 0x00A0)
class UTgEffect_TimeBasedScaling_Base : public UTgEffect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffect_TimeBasedScaling_Base");
		return ptr;
	}


	float STATIC_GetScaledBaseValue();
};


// Class TgGame.TgEffect_TimeBasedScaling
// 0x0010 (0x00B0 - 0x00A0)
class UTgEffect_TimeBasedScaling : public UTgEffect_TimeBasedScaling_Base
{
public:
	int                                                m_nSiegeIntervalSeconds;                                  // 0x00A0(0x0004) (Const)
	int                                                m_nTDMIntervalSeconds;                                    // 0x00A4(0x0004) (Const)
	int                                                m_nOnslaughtIntervalSeconds;                              // 0x00A8(0x0004) (Const)
	int                                                m_nKOTHIntervalSeconds;                                   // 0x00AC(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffect_TimeBasedScaling");
		return ptr;
	}

};


// Class TgGame.TgEffect_TimeFromCartRepairScaling
// 0x0004 (0x00A4 - 0x00A0)
class UTgEffect_TimeFromCartRepairScaling : public UTgEffect_TimeBasedScaling_Base
{
public:
	float                                              m_fIntervalSeconds;                                       // 0x00A0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffect_TimeFromCartRepairScaling");
		return ptr;
	}


	float STATIC_GetScaledBaseValue();
};


// Class TgGame.TgEffectDamage
// 0x0024 (0x00C4 - 0x00A0)
class UTgEffectDamage : public UTgEffect
{
public:
	int                                                m_nSimplifiedPropertyId;                                  // 0x00A0(0x0004)
	class UClass*                                      m_DamageTypeClass;                                        // 0x00A4(0x0008)
	class UClass*                                      m_DefaultDamageTypeClass;                                 // 0x00AC(0x0008)
	float                                              m_fDamageInitial;                                         // 0x00B4(0x0004)
	float                                              m_fBonusDamageToShields;                                  // 0x00B8(0x0004)
	unsigned long                                      m_bAllowLifeSteal : 1;                                    // 0x00BC(0x0004)
	unsigned long                                      m_bCanBeBuffed : 1;                                       // 0x00BC(0x0004)
	int                                                m_nScalingDoTCounter;                                     // 0x00C0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectDamage");
		return ptr;
	}


	unsigned char STATIC_GetDamageReportFireModeIndex();
	int STATIC_GetDamageReportDeviceId();
	float STATIC_GetProratedValue();
	bool ApplyOnThisInterval();
	bool RemoveStacks(class AActor* Target, int nNumStacks);
	bool ApplyStacks(class AActor* Target, int nNumStacks);
	void PerformLifeSteal(class ATgPawn* InstigatorPawn, const struct FImpactInfo& Impact, float fDamageAmount);
	bool ApplyEffect(class AActor* Target, const struct FImpactInfo& Impact, bool bLatent);
	bool CanBeApplied(class AActor* Target);
	void SendDamageMessages(class AActor* Source, class AActor* Target, float fDamage, float fDamageToShields, float fMitigated, const struct FImpactInfo& thisImpact, struct FExtraDamageInfo* ExtraInfo);
	void PostDamageHandler(class AActor* pTarget, class ATgPawn* pInstigator, const struct FImpactInfo& Impact, float fPrevHealth, float fHealthChange, float fBuffedDamage, float fMitigatedDamage, float fShieldDamage, struct FExtraDamageInfo* ExtraInfo);
	void SetDamageTypeClass();
	class UTgEffect* CloneEffect();
};


// Class TgGame.TgEffectDamage_AstroDOT
// 0x0028 (0x00EC - 0x00C4)
class UTgEffectDamage_AstroDOT : public UTgEffectDamage
{
public:
	TArray<float>                                      m_EffectTimeStamps;                                       // 0x00C4(0x0010) (NeedCtorLink)
	TArray<float>                                      m_EffectDamageValues;                                     // 0x00D4(0x0010) (NeedCtorLink)
	struct FPointer                                    m_EffectInfo;                                             // 0x00E4(0x0008) (Native)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectDamage_AstroDOT");
		return ptr;
	}


	void STATIC_InitializeEffectInfo();
	class UTgEffect* CloneEffect();
	void AddDamageStamp(float Damage);
	bool ApplyEffect(class AActor* Target, const struct FImpactInfo& Impact, bool bLatent);
};


// Class TgGame.TgEffectDamage_Execute
// 0x0004 (0x00C8 - 0x00C4)
class UTgEffectDamage_Execute : public UTgEffectDamage
{
public:
	unsigned long                                      m_bApplied : 1;                                           // 0x00C4(0x0004)
	unsigned long                                      m_bExecute : 1;                                           // 0x00C4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectDamage_Execute");
		return ptr;
	}


	float STATIC_GetProratedValue();
	bool ApplyEffect(class AActor* Target, const struct FImpactInfo& Impact, bool bLatent);
};


// Class TgGame.TgEffectDamage_PresenceDoT
// 0x0028 (0x00EC - 0x00C4)
class UTgEffectDamage_PresenceDoT : public UTgEffectDamage
{
public:
	TArray<float>                                      m_EffectTimeStamps;                                       // 0x00C4(0x0010) (NeedCtorLink)
	TArray<float>                                      m_EffectDamageValues;                                     // 0x00D4(0x0010) (NeedCtorLink)
	struct FPointer                                    m_DamageInstances;                                        // 0x00E4(0x0008) (Native)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectDamage_PresenceDoT");
		return ptr;
	}


	class UTgEffect* CloneEffect();
	bool ApplyEffect(class AActor* Target, const struct FImpactInfo& Impact, bool bLatent);
};


// Class TgGame.TgEffectHeal
// 0x0010 (0x00B0 - 0x00A0)
class UTgEffectHeal : public UTgEffect
{
public:
	float                                              m_fMissingHealthInitial;                                  // 0x00A0(0x0004)
	int                                                m_nIntervalCount;                                         // 0x00A4(0x0004)
	int                                                m_nSimplifiedPropertyId;                                  // 0x00A8(0x0004)
	int                                                m_nScalingHoTCounter;                                     // 0x00AC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectHeal");
		return ptr;
	}


	class UTgEffect* CloneEffect();
	void PostHealHandler(class AActor* pTarget, class ATgPawn* pInstigator, const struct FImpactInfo& Impact, float fHealthChange, float fHealAmount);
	bool RemoveStacks(class AActor* Target, int nNumStacks);
	bool ApplyStacks(class AActor* Target, int nNumStacks);
	bool ApplyEffect(class AActor* Target, const struct FImpactInfo& Impact, bool bLatent);
	bool CanBeApplied(class AActor* Target);
};


// Class TgGame.TgEffectModifyDeployable
// 0x0000 (0x00A0 - 0x00A0)
class UTgEffectModifyDeployable : public UTgEffect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectModifyDeployable");
		return ptr;
	}


	void Remove(class AActor* Target);
	float STATIC_GetProratedValue();
	void ApplyToProperty(class AActor* Target, int nPropertyId, float fProratedAmount, bool bRemove);
	bool ApplyEffect(class AActor* Target, const struct FImpactInfo& Impact, bool bLatent);
	void SetProperty(class AActor* Target, int nPropertyId, float fNewValue);
	bool CanBeApplied(class AActor* Target);
};


// Class TgGame.TgEffectModifyEffect
// 0x0000 (0x00A0 - 0x00A0)
class UTgEffectModifyEffect : public UTgEffect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectModifyEffect");
		return ptr;
	}


	void Remove(class AActor* Target);
	float STATIC_GetProratedValue();
	void ApplyToProperty(class AActor* Target, int nPropertyId, float fProratedAmount, bool bRemove);
	bool ApplyEffect(class AActor* Target, const struct FImpactInfo& Impact, bool bLatent);
	void SetProperty(class AActor* Target, int nPropertyId, float fNewValue);
	bool CanBeApplied(class AActor* Target);
};


// Class TgGame.TgEffectModifyProperty
// 0x001C (0x00BC - 0x00A0)
class UTgEffectModifyProperty : public UTgEffect
{
public:
	class UTgDeviceFire*                               m_TargetDeviceFire;                                       // 0x00A0(0x0008)
	int                                                m_eEquipPointTarget;                                      // 0x00A8(0x0004)
	TArray<float>                                      m_fStaticValueOffsets;                                    // 0x00AC(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectModifyProperty");
		return ptr;
	}


	void RefreshAppliedProperty();
	void Remove(class AActor* Target);
	void ApplyToProperty(class AActor* Target, int nPropertyId, float fProratedAmount, bool bRemove);
	bool ApplyEffect(class AActor* Target, const struct FImpactInfo& Impact, bool bLatent);
	void SetProperty(class AActor* Target, int nPropertyId, float fNewValue);
	bool CanBeApplied(class AActor* Target);
};


// Class TgGame.TgEffectModifyProperty_Ability1
// 0x0010 (0x00CC - 0x00BC)
class UTgEffectModifyProperty_Ability1 : public UTgEffectModifyProperty
{
public:
	TArray<class UTgDeviceFire*>                       m_LastRetrievedOverrides;                                 // 0x00BC(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectModifyProperty_Ability1");
		return ptr;
	}

};


// Class TgGame.TgEffectModifyProperty_Ability2
// 0x0010 (0x00CC - 0x00BC)
class UTgEffectModifyProperty_Ability2 : public UTgEffectModifyProperty
{
public:
	TArray<class UTgDeviceFire*>                       m_LastRetrievedOverrides;                                 // 0x00BC(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectModifyProperty_Ability2");
		return ptr;
	}

};


// Class TgGame.TgEffectModifyProperty_AltFire
// 0x0010 (0x00CC - 0x00BC)
class UTgEffectModifyProperty_AltFire : public UTgEffectModifyProperty
{
public:
	TArray<class UTgDeviceFire*>                       m_LastRetrievedOverrides;                                 // 0x00BC(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectModifyProperty_AltFire");
		return ptr;
	}

};


// Class TgGame.TgEffectModifyProperty_Child
// 0x0000 (0x00BC - 0x00BC)
class UTgEffectModifyProperty_Child : public UTgEffectModifyProperty
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectModifyProperty_Child");
		return ptr;
	}

};


// Class TgGame.TgEffectModifyProperty_Child_FireMode1
// 0x0000 (0x00BC - 0x00BC)
class UTgEffectModifyProperty_Child_FireMode1 : public UTgEffectModifyProperty_Child
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectModifyProperty_Child_FireMode1");
		return ptr;
	}

};


// Class TgGame.TgEffectModifyProperty_Child_FireMode2
// 0x0000 (0x00BC - 0x00BC)
class UTgEffectModifyProperty_Child_FireMode2 : public UTgEffectModifyProperty_Child
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectModifyProperty_Child_FireMode2");
		return ptr;
	}

};


// Class TgGame.TgEffectModifyProperty_Child_FireMode3
// 0x0000 (0x00BC - 0x00BC)
class UTgEffectModifyProperty_Child_FireMode3 : public UTgEffectModifyProperty_Child
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectModifyProperty_Child_FireMode3");
		return ptr;
	}

};


// Class TgGame.TgEffectModifyProperty_Inhand
// 0x0010 (0x00CC - 0x00BC)
class UTgEffectModifyProperty_Inhand : public UTgEffectModifyProperty
{
public:
	TArray<class UTgDeviceFire*>                       m_LastRetrievedOverrides;                                 // 0x00BC(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectModifyProperty_Inhand");
		return ptr;
	}

};


// Class TgGame.TgEffectPermanent
// 0x0000 (0x00A0 - 0x00A0)
class UTgEffectPermanent : public UTgEffect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectPermanent");
		return ptr;
	}


	void STATIC_ForcedRemove(class AActor* Target);
	void Remove(class AActor* Target);
	bool ApplyEffect(class AActor* Target, const struct FImpactInfo& Impact, bool bLatent);
};


// Class TgGame.TgEffectForm
// 0x009C (0x00FC - 0x0060)
class UTgEffectForm : public UObject
{
public:
	int                                                c_nEffectGroupId;                                         // 0x0060(0x0004)
	int                                                c_nInstigatorID;                                          // 0x0064(0x0004)
	int                                                c_nType;                                                  // 0x0068(0x0004)
	class AActor*                                      c_Owner;                                                  // 0x006C(0x0008)
	struct FPointer                                    c_pwzEffectName;                                          // 0x0074(0x0008) (Native)
	struct FPointer                                    c_pwzDescription;                                         // 0x007C(0x0008) (Native)
	int                                                c_nEffectIconId;                                          // 0x0084(0x0004)
	TArray<class UTgSpecialFx*>                        c_AppliedFxArray;                                         // 0x0088(0x0010) (NeedCtorLink)
	unsigned long                                      c_bHiddenDueToStealth : 1;                                // 0x0098(0x0004)
	unsigned long                                      c_bHiddenDueToFirstPerson : 1;                            // 0x0098(0x0004)
	unsigned long                                      c_bMICApplied : 1;                                        // 0x0098(0x0004)
	unsigned long                                      m_bSpawnAtHitLocation : 1;                                // 0x0098(0x0004)
	unsigned long                                      c_bIsDebuff : 1;                                          // 0x0098(0x0004)
	unsigned long                                      c_bIsCrit : 1;                                            // 0x0098(0x0004)
	unsigned long                                      c_bLocal : 1;                                             // 0x0098(0x0004)
	TEnumAsByte<ETG_POSTURE>                           c_Posture;                                                // 0x009C(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x009D(0x0003) MISSED OFFSET
	int                                                c_PostureID;                                              // 0x00A0(0x0004)
	class UMaterialInstanceConstant*                   m_MaterialInstanceConstant;                               // 0x00A4(0x0008)
	class ATgPawn*                                     m_OwnerPawn;                                              // 0x00AC(0x0008)
	struct FVector                                     m_HitLocation;                                            // 0x00B4(0x000C)
	struct FVector                                     m_HitNormal;                                              // 0x00C0(0x000C)
	int                                                c_nSkinId;                                                // 0x00CC(0x0004)
	int                                                c_nWeaponSkinId;                                          // 0x00D0(0x0004)
	class ATgEmitter_CameraEffect*                     c_CameraEffect;                                           // 0x00D4(0x0008)
	int                                                c_nStackCount;                                            // 0x00DC(0x0004)
	int                                                c_nBodyMeshMaterialHandle;                                // 0x00E0(0x0004)
	int                                                c_nMountMeshMaterialHandle;                               // 0x00E4(0x0004)
	int                                                c_nHeadMeshMaterialHandle;                                // 0x00E8(0x0004)
	int                                                c_nWeaponMesh1PMaterialHandle;                            // 0x00EC(0x0004)
	int                                                c_nHandsMeshMaterialHandle;                               // 0x00F0(0x0004)
	int                                                c_nHeadMesh1PMaterialHandle;                              // 0x00F4(0x0004)
	int                                                c_nWeaponMesh3PMaterialHandle;                            // 0x00F8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm");
		return ptr;
	}


	void SetEffectFormVisibility(bool bVisible);
	bool ShouldShowEffectForm();
	void AdjustHidden();
	void Detach();
	void Reattach();
	void Attach(class AActor* pOwner);
	void STATIC_HideEffectForm();
	void ShowEffectForm(bool bLocal);
	void STATIC_RecalculateFx();
};


// Class TgGame.TgEffectForm_BuffBelt
// 0x0018 (0x0114 - 0x00FC)
class UTgEffectForm_BuffBelt : public UTgEffectForm
{
public:
	struct FPointer                                    VfTable_FTickableObject;                                  // 0x00FC(0x0008) (Const, Native, NoExport)
	float                                              m_OrbitAngleYawOffset;                                    // 0x0104(0x0004)
	float                                              m_OrbitHeightOffset;                                      // 0x0108(0x0004)
	unsigned long                                      m_bFirstUpdate : 1;                                       // 0x010C(0x0004)
	float                                              m_OrbitRotationSpeed;                                     // 0x0110(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_BuffBelt");
		return ptr;
	}

};


// Class TgGame.TgEffectForm_DisablePawn
// 0x0004 (0x0100 - 0x00FC)
class UTgEffectForm_DisablePawn : public UTgEffectForm
{
public:
	unsigned long                                      m_bPauseAnims : 1;                                        // 0x00FC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_DisablePawn");
		return ptr;
	}


	void STATIC_HideEffectForm();
	void ShowEffectForm(bool bLocal);
};


// Class TgGame.TgEffectForm_Freeze
// 0x0004 (0x0104 - 0x0100)
class UTgEffectForm_Freeze : public UTgEffectForm_DisablePawn
{
public:
	int                                                m_BurstingIceFXId;                                        // 0x0100(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_Freeze");
		return ptr;
	}


	void STATIC_HideEffectForm();
};


// Class TgGame.TgEffectForm_WithMeshes
// 0x0010 (0x010C - 0x00FC)
class UTgEffectForm_WithMeshes : public UTgEffectForm
{
public:
	TArray<struct FEffectMeshInfo>                     m_EffectMeshInfos;                                        // 0x00FC(0x0010) (Component, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_WithMeshes");
		return ptr;
	}


	void DetachMeshes();
	void AttachMeshes(class AActor* pOwner);
	void AdjustHidden();
	void Detach();
	void Reattach();
	void Attach(class AActor* pOwner);
	void STATIC_HideEffectForm();
	void ShowEffectForm(bool bLocal);
	void STATIC_RecalculateFx();
};


// Class TgGame.TgEffectGroup
// 0x017C (0x01DC - 0x0060)
class UTgEffectGroup : public UObject
{
public:
	int                                                m_nType;                                                  // 0x0060(0x0004)
	class AActor*                                      m_Target;                                                 // 0x0064(0x0008)
	class AActor*                                      m_Instigator;                                             // 0x006C(0x0008)
	class AActor*                                      m_InstigatorDeployable;                                   // 0x0074(0x0008)
	int                                                m_nEffectGroupId;                                         // 0x007C(0x0004)
	float                                              m_fLifeTime;                                              // 0x0080(0x0004)
	float                                              m_fModLifeTime;                                           // 0x0084(0x0004)
	float                                              m_fLifeTimeIncreaseFromInstigator;                        // 0x0088(0x0004)
	float                                              m_fApplyInterval;                                         // 0x008C(0x0004)
	TArray<class UTgEffect*>                           m_Effects;                                                // 0x0090(0x0010) (NeedCtorLink)
	int                                                m_nDamageType;                                            // 0x00A0(0x0004)
	TEnumAsByte<EAttackType>                           m_eAttackType;                                            // 0x00A4(0x0001)
	TEnumAsByte<EStunType>                             m_StunType;                                               // 0x00A5(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x00A6(0x0002) MISSED OFFSET
	unsigned long                                      m_bIsManaged : 1;                                         // 0x00A8(0x0004)
	unsigned long                                      m_bHasStealthEffect : 1;                                  // 0x00A8(0x0004)
	unsigned long                                      m_bDoesDamage : 1;                                        // 0x00A8(0x0004)
	unsigned long                                      m_bDoesDamageOverTime : 1;                                // 0x00A8(0x0004)
	unsigned long                                      m_bContagious : 1;                                        // 0x00A8(0x0004)
	unsigned long                                      s_bActiveFlag : 1;                                        // 0x00A8(0x0004)
	unsigned long                                      s_bCriticalHitFlag : 1;                                   // 0x00A8(0x0004)
	unsigned long                                      m_bDeviceSpecificFlag : 1;                                // 0x00A8(0x0004)
	unsigned long                                      m_bHasVisual : 1;                                         // 0x00A8(0x0004)
	unsigned long                                      m_bSupportsEffectSimulation : 1;                          // 0x00A8(0x0004)
	float                                              m_fPercAbsorbedDamage;                                    // 0x00AC(0x0004)
	int                                                m_nApplicationType;                                       // 0x00B0(0x0004)
	float                                              m_fApplicationValue;                                      // 0x00B4(0x0004)
	float                                              m_fApplicationChance;                                     // 0x00B8(0x0004)
	int                                                m_nApplicationCategoryCode;                               // 0x00BC(0x0004)
	int                                                m_nBehaviorCategoryCode;                                  // 0x00C0(0x0004)
	int                                                m_nReqDeviceInstanceId;                                   // 0x00C4(0x0004)
	float                                              m_fBuffValue;                                             // 0x00C8(0x0004)
	float                                              m_fPhysicalPowerScaling;                                  // 0x00CC(0x0004)
	float                                              m_fMagicalPowerScaling;                                   // 0x00D0(0x0004)
	float                                              m_fLifetimeScaling;                                       // 0x00D4(0x0004)
	float                                              m_fLifetimeMax;                                           // 0x00D8(0x0004)
	int                                                m_nScalingType;                                           // 0x00DC(0x0004)
	int                                                m_nTargetType;                                            // 0x00E0(0x0004)
	int                                                m_nTargetAffectsType;                                     // 0x00E4(0x0004)
	int                                                m_nHitSpecialSituationalType;                             // 0x00E8(0x0004)
	int                                                m_nNumStacks;                                             // 0x00EC(0x0004)
	int                                                m_nNumMaxStacks;                                          // 0x00F0(0x0004)
	class UTgEffectGroup*                              s_NonContagiousEffectGroup;                               // 0x00F4(0x0008)
	struct FImpactInfo                                 m_Impact;                                                 // 0x00FC(0x007C) (Component)
	int                                                m_nPosture;                                               // 0x0178(0x0004)
	int                                                m_nFxAppliedId;                                           // 0x017C(0x0004)
	struct FName                                       m_nmDisplayGroup;                                         // 0x0180(0x0008)
	int                                                s_ManagedEffectListIndex;                                 // 0x0188(0x0004)
	class ATgEffectManager*                            s_OwnerEffectManager;                                     // 0x018C(0x0008)
	struct FName                                       m_nmDamageTypeClass;                                      // 0x0194(0x0008)
	int                                                m_nSourceDeviceInstId;                                    // 0x019C(0x0004)
	int                                                m_nSourceItemId;                                          // 0x01A0(0x0004)
	float                                              s_fEGShieldHealth;                                        // 0x01A4(0x0004)
	float                                              s_fEGShieldHealthMax;                                     // 0x01A8(0x0004)
	class UForceFeedbackWaveform*                      m_Waveform;                                               // 0x01AC(0x0008)
	struct FPointer                                    m_pEffectGroupSetup;                                      // 0x01B4(0x0008) (Native)
	struct FLifeTimeCalcInfo                           m_LastLifeTimeCalcInfo;                                   // 0x01BC(0x0020)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectGroup");
		return ptr;
	}


	bool SupportsEffectSimulation();
	float STATIC_HealShield(float fHeal);
	float DamageShield(float fDamage);
	float STATIC_GetShieldMaxHealth();
	float STATIC_GetShieldHealth();
	bool STATIC_HasShield();
	void STATIC_ExtendLifeTime(float fAmount);
	void QueueRemovalOnManagerTick();
	float STATIC_GetUtilityPower();
	float GetLifeTime(bool bModifiers, struct FLifeTimeCalcInfo* CalcInfo);
	float STATIC_GetScaledBaseLifeTime();
	int STATIC_GetScalingLevel();
	void LifeDone();
	void ApplyInterval();
	bool ApplyEffects();
	float STATIC_GetIntervalTimeRemaining();
	float STATIC_GetPercentTimeRemaining();
	float STATIC_GetTimeRemaining();
	float STATIC_GetTimeElapsed();
	void STATIC_HandleStatusEffects(bool bRemoving);
	void STATIC_SetActive(bool bActive, bool bRemoving);
	bool STATIC_IsActive();
	bool STATIC_HasCategoryCode(int nCategoryCode, bool bBehaviorOnly, bool bIgnoreIfBlockCategory);
	bool STATIC_DoesDamage();
	bool ReceivesDiminishingReturns();
	bool AppliesDiminishingReturns();
	bool STATIC_IsCrowdControl();
	bool STATIC_IsSuperiorCrowdControl();
	bool AppliesEnterCombatRules();
	bool STATIC_IsMutableDebuff();
	bool STATIC_IsHealingDebuff();
	bool STATIC_IsDebuff();
	bool STATIC_IsDot();
	bool STATIC_IsCrit();
	bool STATIC_IsStealth();
	bool STATIC_IsSlow();
	bool STATIC_IsInstantaneous();
	bool PersistsThroughDeath();
	bool STATIC_IsBuff();
	float CalcDoTLifeTimeProtection(class AActor* Target, float fValue, float* fDirectReduction, float* fPercReduction);
	float CalcCategoryProtection(class AActor* Target, float fValue, float* fPercReduction);
	bool STATIC_EffectExists(int nPropId);
	float QueryFxTransitionTime();
	float TotalPropertyEffectAmt(int nPropertyId);
	void RemoveEffects(bool bClearTimers);
	class UTgEffectGroup* CloneEffectGroup(bool bCloneAllEffects);
};


// Class TgGame.TgEffectManager
// 0x0604 (0x0884 - 0x0280)
class ATgEffectManager : public AActor
{
public:
	struct FDiminishedEffectInfo                       r_GroundSpeedMods;                                        // 0x0280(0x0010) (Net)
	struct FEffectListEntry                            r_ManagedEffectList[0x10];                                // 0x0290(0x0010) (Net)
	unsigned char                                      c_byCounterList[0x10];                                    // 0x0390(0x0001)
	TEnumAsByte<EStunType>                             s_eCachedStunType;                                        // 0x03A0(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x03A1(0x0003) MISSED OFFSET
	float                                              m_fTimeRemaining[0x10];                                   // 0x03A4(0x0004)
	class UTgEffectForm*                               c_Forms[0x10];                                            // 0x03E4(0x0008)
	unsigned long                                      c_ActiveTimers : 1;                                       // 0x0464(0x0004)
	unsigned long                                      r_bRelevancyNotify : 1;                                   // 0x0464(0x0004) (Net)
	struct FEffectQueueEntry                           r_EventQueue[0x10];                                       // 0x0468(0x0020) (Net)
	int                                                r_nNextQueueIndex;                                        // 0x0668(0x0004) (Net)
	int                                                r_nFirstValidQueueIndex;                                  // 0x066C(0x0004) (Net)
	int                                                c_nLastQueueIndex;                                        // 0x0670(0x0004)
	TArray<class UTgEffectGroup*>                      s_AppliedEffectGroups;                                    // 0x0674(0x0010) (NeedCtorLink)
	TArray<class UTgEffect*>                           s_AppliedPermanentEffects;                                // 0x0684(0x0010) (NeedCtorLink)
	class AActor*                                      r_Owner;                                                  // 0x0694(0x0008) (Net)
	class UTgEffectGroup*                              m_ApplyDamageEffectGroup;                                 // 0x069C(0x0008)
	class UTgEffect*                                   m_ApplyDamageEffect;                                      // 0x06A4(0x0008)
	class UTgEffectGroup*                              m_ApplyHealthEffectGroup;                                 // 0x06AC(0x0008)
	class UTgEffect*                                   m_ApplyHealthEffect;                                      // 0x06B4(0x0008)
	class UTgEffectGroup*                              m_ApplyManaEffectGroup;                                   // 0x06BC(0x0008)
	class UTgEffect*                                   m_ApplyManaEffect;                                        // 0x06C4(0x0008)
	class UTgEffectGroup*                              m_ApplyEnergyEffectGroup;                                 // 0x06CC(0x0008)
	class UTgEffect*                                   m_ApplyEnergyEffect;                                      // 0x06D4(0x0008)
	TArray<struct FStunStackEntry>                     s_StunStack;                                              // 0x06DC(0x0010) (NeedCtorLink)
	TArray<struct FEnergyStunStackEntry>               s_EnergyStunStack;                                        // 0x06EC(0x0010) (NeedCtorLink)
	TArray<struct FReduceActiveCooldownEntry>          s_ReduceActiveCooldownEffects;                            // 0x06FC(0x0010) (NeedCtorLink)
	float                                              m_fMaxReduceActiveCooldownDelay;                          // 0x070C(0x0004)
	int                                                s_nSilenceCount;                                          // 0x0710(0x0004)
	int                                                s_nDisarmCount;                                           // 0x0714(0x0004)
	int                                                s_nCrippleCount;                                          // 0x0718(0x0004)
	int                                                s_nStealthCount;                                          // 0x071C(0x0004)
	int                                                s_nDazeCount;                                             // 0x0720(0x0004)
	int                                                s_nSlowCount;                                             // 0x0724(0x0004)
	int                                                s_bStealthDisabledCount;                                  // 0x0728(0x0004)
	int                                                s_nOnFireCount;                                           // 0x072C(0x0004)
	int                                                s_nCCImmuneCount;                                         // 0x0730(0x0004)
	int                                                s_nBleedingCount;                                         // 0x0734(0x0004)
	int                                                s_nKnockbackCount;                                        // 0x0738(0x0004)
	int                                                s_nRootCount;                                             // 0x073C(0x0004)
	int                                                s_nPoisonedCount;                                         // 0x0740(0x0004)
	int                                                s_nBoostCount;                                            // 0x0744(0x0004)
	int                                                s_nStealthInCombatCount;                                  // 0x0748(0x0004)
	int                                                s_nWallHackCount;                                         // 0x074C(0x0004)
	int                                                s_nForceOutOfCombatCount;                                 // 0x0750(0x0004)
	int                                                s_nPolymorphCount;                                        // 0x0754(0x0004)
	int                                                s_nRevealedCount;                                         // 0x0758(0x0004)
	int                                                s_nFlashCount;                                            // 0x075C(0x0004)
	int                                                s_nBanishCount;                                           // 0x0760(0x0004)
	int                                                s_nDruidMarkCount;                                        // 0x0764(0x0004)
	float                                              s_fSpawnGuardTime;                                        // 0x0768(0x0004)
	TArray<class AActor*>                              s_InstigatorWallReveals;                                  // 0x076C(0x0010) (NeedCtorLink)
	TArray<int>                                        s_nInstigatorWallRevealCount;                             // 0x077C(0x0010) (NeedCtorLink)
	TArray<class AActor*>                              s_InstigatorStealthReveals;                               // 0x078C(0x0010) (NeedCtorLink)
	TArray<int>                                        s_nInstigatorStealthRevealCount;                          // 0x079C(0x0010) (NeedCtorLink)
	TArray<int>                                        s_nMarkedCounts;                                          // 0x07AC(0x0010) (NeedCtorLink)
	TArray<class UTgEffect*>                           s_SlowCaps;                                               // 0x07BC(0x0010) (NeedCtorLink)
	TArray<class UTgEffect*>                           s_MaxHPDamageCaps;                                        // 0x07CC(0x0010) (NeedCtorLink)
	TArray<class UTgEffect*>                           s_CurHPDamageCaps;                                        // 0x07DC(0x0010) (NeedCtorLink)
	TArray<class UTgEffect*>                           s_HPDamageCaps;                                           // 0x07EC(0x0010) (NeedCtorLink)
	TArray<class UTgEffect*>                           s_HPHealingCaps;                                          // 0x07FC(0x0010) (NeedCtorLink)
	int                                                s_FreezeBehaviorCount;                                    // 0x080C(0x0004)
	TArray<struct FDiminishingReturnsStackInfo>        s_DiminishingReturnsStacks;                               // 0x0810(0x0010) (NeedCtorLink)
	int                                                m_nDiminishingReturnMaxStacks;                            // 0x0820(0x0004) (Const)
	TArray<class UTgEffectGroup*>                      s_ActiveDamageDeviceIntercepts;                           // 0x0824(0x0010) (NeedCtorLink)
	TArray<class UTgEffectGroup*>                      s_ActiveDamageMitigationIntercepts;                       // 0x0834(0x0010) (NeedCtorLink)
	TArray<class UTgEffectGroup*>                      s_ActiveOnLandedIntercepts;                               // 0x0844(0x0010) (NeedCtorLink)
	TArray<class UTgEffectGroup*>                      s_ActiveWallGrabbedHits;                                  // 0x0854(0x0010) (NeedCtorLink)
	TArray<class UTgEffectGroup*>                      s_ActiveWallKnockbackHits;                                // 0x0864(0x0010) (NeedCtorLink)
	TArray<class UTgEffectGroup*>                      s_ActivePlayerKnockbackHits;                              // 0x0874(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectManager");
		return ptr;
	}


	int ShieldTakeDamage(int nDamage);
	void PostDemoRewind();
	void UpdateFirstValidQueueIndex();
	void ReplicatedEvent(const struct FName& VarName);
	void PostBeginPlay();
	void STATIC_HandlePlayerKnockbackHit(int nPawnId);
	void STATIC_HandleWallKnockbackHit(const struct FVector& HitNormal);
	void STATIC_HandleWallGrabbedHit(const struct FKnockbackHit& Hit);
	bool CheckStacksForDisplay(class UTgEffectGroup* pEffect);
	int STATIC_GetStackCountFromEffectGroupId(int nEffectGroupID, class AActor* aInstigator);
	class UTgEffectGroup* ProcessEffect(class UTgEffectGroup* effectGroup, class AActor* aInstigator, int nNumStacks, const struct FImpactInfo& Impact);
	void RemoveProperty(class UTgEffectGroup* effectGroup);
	class UTgEffectGroup* ApplyProperty(float nValue, int nPropId, class AActor* aInstigator, const struct FImpactInfo& Impact, int nCategory, bool bApplyAsPercent);
	void ProcessReduceActiveCooldownEffects();
	void RemoveDelayedReduceActiveCooldownEffect(const struct FReduceActiveCooldownEntry& effectEntry);
	void AddDelayedReduceActiveCooldownEffect(const struct FReduceActiveCooldownEntry& effectEntry);
	void ReduceActiveCooldown(const struct FReduceActiveCooldownEntry& effectEntry, bool bInitialApplication);
	void ApplyStasis(int nValue, class AActor* aInstigator, int nAttackType, int nDamageType, const struct FImpactInfo& Impact, int nEffectGroupCategory);
	void RemoveSpawnGuard();
	void ApplySpawnGuard();
	void ApplyStun(float fDuration, class AActor* aInstigator, int nAttackType, int nDamageType, const struct FImpactInfo& Impact, TEnumAsByte<EStunType> StunType);
	void ApplyEnergy(int nEnergy, class AActor* aInstigator, int nAttackType, int nDamageType, const struct FImpactInfo& Impact, int nEffectGroupCategory);
	void ApplyMana(int nMana, class AActor* aInstigator, int nAttackType, int nDamageType, const struct FImpactInfo& Impact, int nEffectGroupCategory);
	void ApplyHealth(int nHealth, class AActor* aInstigator, int nAttackType, int nDamageType, const struct FImpactInfo& Impact, int nEffectGroupCategory);
	void ApplyDamage(int nDamage, class AActor* aInstigator, int nAttackType, int nDamageType, const struct FImpactInfo& Impact, int nEffectGroupCategory);
	int CountApplicationOfPermanentEffect(class UTgEffect* pEffect);
	void STATIC_UnregisterPermanentEffect(class UTgEffect* pEffect);
	void RegisterPermanentEffect(class UTgEffect* pEffect);
	void STATIC_HandleOnLandedIntercepts();
	void RecalculateBeltFx();
	void STATIC_RecalculateFx();
	bool STATIC_IsDazed();
	bool STATIC_IsSlowed();
	bool STATIC_IsStunned();
	bool STATIC_IsSpawnGuarded();
	void ClearAllClientEffectForms();
	void STATIC_UpdateEffectFormVisibility();
	class UTgEffectGroup* STATIC_GetEffectGroupByCategory(int nCategoryCode, class AActor* theInstigator);
	class UTgEffectGroup* STATIC_GetEffectGroup(int nEffectGroupID, class AActor* theInstigator);
	void RemoveAllPermanentEffects();
	void RemoveAllMesmerizeEffects();
	void RemoveAllStealthEffects();
	void RemoveAllWhileDeadEffects();
	void RemoveAllEffectsOnDeath();
	void RemoveAllEffects();
	class UTgEffectGroup* STATIC_GetNextStrongest(class UTgEffectGroup* eg);
	bool STATIC_IsStrongest(class UTgEffectGroup* eg, bool bConsiderLifetime, class UTgEffectGroup** prevStrongest);
	void RemoveAllCrowdControl();
	void RemoveAllSuperiorCrowdControl();
	void RemoveAllDebuff();
	bool ResetEffectGroupLifeTimeByCategory(int nCategoryCode, float Lifetime);
	bool ResetEffectGroupLifeTimeById(int nEffectGroupID, float Lifetime);
	bool RemoveAllEffectGroups(class UTgEffectGroup* eg);
	bool RemoveEffectGroupsBySourceDevice(int nDeviceInstId);
	int STATIC_RemoveEffectGroupsByCategoryMarked(int nCategoryCode, int nMarkType, int nNumStacks, class AActor* theInstigator);
	int RemoveEffectGroupsByCategory(int nCategoryCode, int nNumStacks, class AActor* theInstigator);
	bool RemoveEffectGroupById(int nEffectGroupID, int nNumStacks, class AActor* theInstigator);
	void STATIC_UpdateManagedEffectForms(bool bFromServer);
	void STATIC_UpdateQueueEffectForms();
	void STATIC_UpdateEffectForms();
	void ClearEffectRep(class UTgEffectGroup* Group);
	void STATIC_UpdateEffectRep(class UTgEffectGroup* eg);
	int SetEffectRep(class UTgEffectGroup* eg, int nSkinId);
};


// Class TgGame.TgActorFactory
// 0x0040 (0x02C0 - 0x0280)
class ATgActorFactory : public AActor
{
public:
	int                                                m_nMapObjectId;                                           // 0x0280(0x0004) (Edit, EditConst)
	unsigned long                                      s_bAutoSpawn : 1;                                         // 0x0284(0x0004) (Edit)
	int                                                s_nTeamNumber;                                            // 0x0288(0x0004) (EditConst)
	unsigned char                                      s_nTaskForce;                                             // 0x028C(0x0001) (Edit)
	TEnumAsByte<EMinimapFactoryType>                   m_MinimapType;                                            // 0x028D(0x0001) (Edit)
	TEnumAsByte<EeSelectionMethod>                     s_eSelectionMethod;                                       // 0x028E(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x1];                                       // 0x028F(0x0001) MISSED OFFSET
	int                                                s_nSelectionListId;                                       // 0x0290(0x0004)
	int                                                s_nSelectedObjectId;                                      // 0x0294(0x0004)
	int                                                m_nSelectionListPropId;                                   // 0x0298(0x0004)
	int                                                s_nNameId;                                                // 0x029C(0x0004)
	int                                                s_nFactoryId;                                             // 0x02A0(0x0004) (Transient)
	class ATgRepInfo_Factory*                          m_FRI;                                                    // 0x02A4(0x0008) (Transient)
	class UClass*                                      m_FRIClass;                                               // 0x02AC(0x0008)
	int                                                s_nCurListIndex;                                          // 0x02B4(0x0004)
	class USpriteComponent*                            m_WorldIconSprite;                                        // 0x02B8(0x0008) (Edit, ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgActorFactory");
		return ptr;
	}


	void Destroyed();
	void PostBeginPlay();
	void PreBeginPlay();
	void SetTaskForceNumber(int nNewTaskForce);
	void CalcFactoryPlacement(const struct FVector& Extent, bool bCenterOnGround, struct FVector* OutLocation, struct FRotator* OutRotation);
	void SpawnObject();
	void STATIC_LoadObjectConfig();
};


// Class TgGame.TgBotFactory
// 0x00B0 (0x0370 - 0x02C0)
class ATgBotFactory : public ATgActorFactory
{
public:
	TEnumAsByte<EeBotSelection>                        LocationSelection;                                        // 0x02C0(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x02C1(0x0003) MISSED OFFSET
	TArray<class ANavigationPoint*>                    LocationList;                                             // 0x02C4(0x0010) (Edit, Const, NeedCtorLink)
	int                                                s_nCurLocationIndex;                                      // 0x02D4(0x0004)
	class ANavigationPoint*                            SafetyLocation;                                           // 0x02D8(0x0008) (Edit)
	unsigned long                                      ShouldTraceSpawnLocationToFloor : 1;                      // 0x02E0(0x0004) (Edit)
	unsigned long                                      bUseSmiteStaggerSpawning : 1;                             // 0x02E0(0x0004) (Edit)
	unsigned long                                      bSpawnAsSquad : 1;                                        // 0x02E0(0x0004) (Edit)
	unsigned long                                      bAutoSpawn : 1;                                           // 0x02E0(0x0004)
	unsigned long                                      m_bFirstSpawn : 1;                                        // 0x02E0(0x0004)
	unsigned long                                      bBulkSpawn : 1;                                           // 0x02E0(0x0004) (Edit)
	unsigned long                                      bRespawn : 1;                                             // 0x02E0(0x0004) (Edit)
	unsigned long                                      bStartBotsInIntroState : 1;                               // 0x02E0(0x0004) (Edit)
	unsigned long                                      bHasDifferentInitialIntro : 1;                            // 0x02E0(0x0004) (Edit)
	unsigned long                                      m_bFirstSpawnWave : 1;                                    // 0x02E0(0x0004)
	unsigned long                                      m_bIgnoreCollisionOnSpawn : 1;                            // 0x02E0(0x0004) (Edit)
	unsigned long                                      m_bUseCollisionHeightForSpawnPlacement : 1;               // 0x02E0(0x0004) (Edit)
	int                                                nBotCount;                                                // 0x02E4(0x0004)
	int                                                nCurrentCount;                                            // 0x02E8(0x0004)
	int                                                nActiveCount;                                             // 0x02EC(0x0004) (Edit)
	int                                                nTotalSpawns;                                             // 0x02F0(0x0004)
	int                                                nLane;                                                    // 0x02F4(0x0004) (Edit)
	int                                                nNavPointsToSkipForPathing;                               // 0x02F8(0x0004) (Edit)
	float                                              fStaggerSpawnDelay;                                       // 0x02FC(0x0004) (Edit)
	class UTgAISquad*                                  s_CurrentSquad;                                           // 0x0300(0x0008) (Transient)
	class UClass*                                      m_SquadClass;                                             // 0x0308(0x0008)
	int                                                m_nLocationId;                                            // 0x0310(0x0004) (Edit)
	int                                                nSpawnTableId;                                            // 0x0314(0x0004) (Edit)
	int                                                nDefaultSpawnTableId;                                     // 0x0318(0x0004) (Edit)
	float                                              fSpawnDelay;                                              // 0x031C(0x0004) (Edit)
	TArray<struct FSpawnQueueEntry>                    m_SpawnQueue;                                             // 0x0320(0x0010) (NeedCtorLink)
	class ATgBotEncounterVolume*                       m_SpawnVolume;                                            // 0x0330(0x0008)
	int                                                m_nLastGroup;                                             // 0x0338(0x0004)
	float                                              fSpawnHealthPercent;                                      // 0x033C(0x0004) (Edit)
	float                                              fIntroductionDuration;                                    // 0x0340(0x0004) (Edit)
	float                                              fInitialIntroductionDuration;                             // 0x0344(0x0004) (Edit)
	class ATgSplineActor*                              m_StartingSpline;                                         // 0x0348(0x0008) (Edit)
	class UStaticMeshComponent*                        m_RespawnIndicator;                                       // 0x0350(0x0008) (Edit, ExportObject, Component, EditInline)
	class UMaterialInstanceConstant*                   m_RespawnIndicatorMIC;                                    // 0x0358(0x0008) (Transient)
	class UTexture2D*                                  m_TextureNormal;                                          // 0x0360(0x0008)
	float                                              fLastKillTime;                                            // 0x0368(0x0004)
	float                                              fRespawnDelay;                                            // 0x036C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBotFactory");
		return ptr;
	}


	void OnKillCurrentSquad(class UTgSeqAct_KillCurrentSquad* killSquadAction);
	void STATIC_UpdateRespawnTimeIndicator(float fPct);
	void OnBotDamaged(class ATgPawn* Bot, class AController* DamageInstigator, class UClass* DamageType, int DamageAmount);
	void OnGetBot(class UTgSeqAct_GetBot* inAction);
	void OnSetTaskforce(class UTgSeqAct_SetTaskforce* Action);
	void OnTriggerBots(class UTgSeqAct_TriggerBots* Action);
	void KillBots(bool bDespawn);
	void Despawn();
	void StartEncounter(class ATgBotEncounterVolume* Volume);
	void ContinueEncounter();
	void EndEncounter();
	void OnDespawnBots(class UTgSeqAct_DespawnBots* inAction);
	void OnKillBots(class UTgSeqAct_KillBots* inAction);
	void STATIC_OnToggle(class USeqAct_Toggle* Action);
	void PostBeginPlay();
	float STATIC_GetStaggerSpawnTime();
	int STATIC_GetRemainingTotalSpawns();
	void STATIC_KillCurrentSquad();
	void SquadDied(class UTgAISquad* squad);
	void BotDied(class ATgPawn* Pawn, class ATgAIController* aic);
	class AActor* STATIC_UseSpawnTable();
	void CalcFactoryPlacement(const struct FVector& Extent, bool bCenterOnGround, struct FVector* OutLocation, struct FRotator* OutRotation);
	class AActor* SpawnBotAdjusted(const struct FSpawnQueueEntry& Entry);
	class AActor* SpawnBotId(int nBotId, int nSkinId);
	class AActor* SpawnNextBot();
	class AActor* SpawnBot();
	void ClearQueue();
	void BuildQueue();
	void ResetQueue();
	void STATIC_LoadObjectConfig();
};


// Class TgGame.TgBotFactory_BonusTrigger
// 0x0000 (0x0370 - 0x0370)
class ATgBotFactory_BonusTrigger : public ATgBotFactory
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBotFactory_BonusTrigger");
		return ptr;
	}

};


// Class TgGame.TgBotFactory_Leashed
// 0x0018 (0x0388 - 0x0370)
class ATgBotFactory_Leashed : public ATgBotFactory
{
public:
	struct FVector                                     LeashLocation;                                            // 0x0370(0x000C) (Edit)
	float                                              LeashRange;                                               // 0x037C(0x0004) (Edit)
	class AVolume*                                     LeashVolume;                                              // 0x0380(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBotFactory_Leashed");
		return ptr;
	}


	class AActor* SpawnBotAdjusted(const struct FSpawnQueueEntry& Entry);
};


// Class TgGame.TgBotFactory_PointCapture
// 0x0008 (0x0390 - 0x0388)
class ATgBotFactory_PointCapture : public ATgBotFactory_Leashed
{
public:
	class ATgCapturePoint*                             m_CapturePoint;                                           // 0x0388(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBotFactory_PointCapture");
		return ptr;
	}


	void BotDied(class ATgPawn* Pawn, class ATgAIController* aic);
};


// Class TgGame.TgBotFactory_Minions
// 0x001C (0x038C - 0x0370)
class ATgBotFactory_Minions : public ATgBotFactory
{
public:
	TEnumAsByte<EMinionFactoryType>                    m_eFactoryType;                                           // 0x0370(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0371(0x0003) MISSED OFFSET
	unsigned long                                      m_OverrideShouldSpawnSuperMinions : 1;                    // 0x0374(0x0004) (Transient)
	int                                                m_nWaveNumber;                                            // 0x0378(0x0004) (Transient)
	int                                                m_nLastBonusWave;                                         // 0x037C(0x0004) (Transient)
	int                                                m_nLanePushersInQueue;                                    // 0x0380(0x0004) (Transient)
	float                                              m_fLastBonusActivationTime;                               // 0x0384(0x0004) (Transient)
	float                                              m_fSuperMinionEndTime;                                    // 0x0388(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBotFactory_Minions");
		return ptr;
	}


	void BotDied(class ATgPawn* Pawn, class ATgAIController* aic);
	void BuildQueue();
	bool ShouldSpawnBonusMinions();
	bool ShouldSpawnSuperMinions();
	void SetSuperMinionsActive(float fSeconds);
};


// Class TgGame.TgBotFactorySpawnable
// 0x0000 (0x0370 - 0x0370)
class ATgBotFactorySpawnable : public ATgBotFactory
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBotFactorySpawnable");
		return ptr;
	}

};


// Class TgGame.TgDeployableFactory
// 0x0018 (0x02D8 - 0x02C0)
class ATgDeployableFactory : public ATgActorFactory
{
public:
	int                                                nCurrentCount;                                            // 0x02C0(0x0004)
	float                                              s_fLastSpawnTime;                                         // 0x02C4(0x0004)
	unsigned long                                      s_bSpawnOnce : 1;                                         // 0x02C8(0x0004) (Edit)
	int                                                s_nDeployableId;                                          // 0x02CC(0x0004) (Edit)
	int                                                s_SpawnGroupNum;                                          // 0x02D0(0x0004) (Edit)
	float                                              s_fDeployableLifeSpan;                                    // 0x02D4(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployableFactory");
		return ptr;
	}


	void OnSetTaskforce(class UTgSeqAct_SetTaskforce* Action);
	void OnKillBots(class UTgSeqAct_KillBots* inAction);
	void STATIC_OnToggle(class USeqAct_Toggle* Action);
	void DeployableDied();
	void PostBeginPlay();
	void SpawnObject();
};


// Class TgGame.TgDestructibleFactory
// 0x0008 (0x02C8 - 0x02C0)
class ATgDestructibleFactory : public ATgActorFactory
{
public:
	class ULightEnvironmentComponent*                  LightEnvironment;                                         // 0x02C0(0x0008) (Edit, Const, ExportObject, EditConst, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDestructibleFactory");
		return ptr;
	}


	void SpawnObject();
};


// Class TgGame.TgBotFactoryComponent
// 0x0000 (0x024C - 0x024C)
class UTgBotFactoryComponent : public UPrimitiveComponent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBotFactoryComponent");
		return ptr;
	}

};


// Class TgGame.TgGameplayEventsWriter
// 0x0000 (0x01C8 - 0x01C8)
class UTgGameplayEventsWriter : public UGameplayEventsWriter
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayEventsWriter");
		return ptr;
	}


	void STATIC_LogPaladinsPlayerKillDeath(int EventID, int KillType, class AController* Killer, class UClass* dmgType, class AController* Dead);
	int STATIC_ResolvePlayerIndex(class AController* Player);
};


// Class TgGame.AudioLUT
// 0x00F4 (0x0154 - 0x0060)
class UAudioLUT : public UObject
{
public:
	struct FVector                                     LutStartPos;                                              // 0x0060(0x000C)
	struct FVector                                     LutEndPos;                                                // 0x006C(0x000C)
	struct FMap_Mirror                                 spatial_hash;                                             // 0x0078(0x0048) (Native)
	struct FMap_Mirror                                 lut;                                                      // 0x00C0(0x0048) (Native)
	struct FMap_Mirror                                 PositionSampleMap;                                        // 0x0108(0x0048) (Native)
	float                                              ListenerDistance;                                         // 0x0150(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.AudioLUT");
		return ptr;
	}

};


// Class TgGame.TgAkAudioManagement
// 0x0114 (0x0174 - 0x0060)
class UTgAkAudioManagement : public UObject
{
public:
	struct FAkMeterCallbackState                       m_MeterCallbackSlots[0x10];                               // 0x0060(0x0010)
	TArray<struct Fdword>                              dwAllBusses;                                              // 0x0160(0x0010) (NeedCtorLink)
	unsigned long                                      m_bInitialized : 1;                                       // 0x0170(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAkAudioManagement");
		return ptr;
	}


	struct Fdword STATIC_GetBusUID(const struct FString& sBusName);
	void Initialize();
};


// Class TgGame.TgInteractiveAudio
// 0x0000 (0x0060 - 0x0060)
class UTgInteractiveAudio : public UInterface
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInteractiveAudio");
		return ptr;
	}

};


// Class TgGame.TgSoundNotifyActorInterface
// 0x0000 (0x0060 - 0x0060)
class UTgSoundNotifyActorInterface : public UInterface
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSoundNotifyActorInterface");
		return ptr;
	}


	void PlayNotifySound(TEnumAsByte<ENotifySound> eSound);
	void PlayNotifySound_Internal(TEnumAsByte<ENotifySound> eSound);
};


// Class TgGame.TgGrabSource
// 0x0000 (0x0060 - 0x0060)
class UTgGrabSource : public UInterface
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGrabSource");
		return ptr;
	}


	void STATIC_GetPullGrabSourceLocation(struct FVector* vSourceLoc);
	void STATIC_GetPullGrabOffsetFromSource(class ATgPawn* pGrabbedPawn, struct FVector* vOffset, struct FRotator* rRotation);
	void OnGrabTargetDetach(TEnumAsByte<EGrabState> endingGrabState, class ATgPawn* Target, bool bInterrupted);
	void OnGrabTargetAttach(TEnumAsByte<EGrabState> newGrabState, class ATgPawn* Target);
	void STATIC_ForceAllGrabTargetsDetach(TEnumAsByte<EGrabState> eState);
	class AActor* STATIC_GetGrabSourceAsActor();
	void STATIC_RemoveGrabbedPawn(class ATgPawn* pTarget);
	void STATIC_AddGrabbedPawn(class ATgPawn* pTarget);
	class USkeletalMeshComponent* STATIC_GetGrabSourceSkeletalMesh();
};


// Class TgGame.TgSoundEventsManager
// 0x0028 (0x0088 - 0x0060)
class UTgSoundEventsManager : public UObject
{
public:
	unsigned long                                      m_bInitialized : 1;                                       // 0x0060(0x0004)
	TEnumAsByte<ENotifySound>                          m_eLastEvent;                                             // 0x0064(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0065(0x0003) MISSED OFFSET
	TArray<struct FTimestampedGameObjectId>            m_GameObjectShutdownQueue;                                // 0x0068(0x0010) (NeedCtorLink)
	TArray<struct FQueuedSoundEvent>                   m_DeferredEvents;                                         // 0x0078(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSoundEventsManager");
		return ptr;
	}


	void QueueForShutdown(class AActor* pActor);
};


// Class TgGame.TgDroppedItem
// 0x002C (0x02AC - 0x0280)
class ATgDroppedItem : public AActor
{
public:
	float                                              m_fLifeSpan;                                              // 0x0280(0x0004)
	unsigned long                                      m_bFadeOut : 1;                                           // 0x0284(0x0004)
	struct FName                                       m_nmPickUpState;                                          // 0x0288(0x0008)
	int                                                r_nItemId;                                                // 0x0290(0x0004) (Net)
	class UMeshComponent*                              c_Mesh;                                                   // 0x0294(0x0008) (ExportObject, Component, EditInline)
	TArray<class UTgEffectGroup*>                      s_EffectGroupList;                                        // 0x029C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDroppedItem");
		return ptr;
	}


	void GiveTo(class ATgPawn* P);
	void ReplicatedEvent(const struct FName& VarName);
	bool ApplyItemSetup();
	class UTgEffectGroup* STATIC_GetEffectGroup(int nType, int* nIndex);
};


// Class TgGame.TgInventoryManager
// 0x00EC (0x0398 - 0x02AC)
class ATgInventoryManager : public AInventoryManager
{
public:
	int                                                r_ItemCount;                                              // 0x02AC(0x0004) (Net)
	int                                                m_nPreviousDeviceInstanceId;                              // 0x02B0(0x0004)
	unsigned long                                      m_bNeedsInvUpdate : 1;                                    // 0x02B4(0x0004)
	class AWeapon*                                     m_PreviousWeapon;                                         // 0x02B8(0x0008)
	unsigned char                                      UnknownData00[0x48];                                      // 0x02C0(0x0048) UNKNOWN PROPERTY: MapProperty TgGame.TgInventoryManager.m_InventoryMap
	unsigned char                                      UnknownData01[0x48];                                      // 0x0308(0x0048) UNKNOWN PROPERTY: MapProperty TgGame.TgInventoryManager.s_ReplicateMap
	unsigned char                                      UnknownData02[0x48];                                      // 0x0350(0x0048) UNKNOWN PROPERTY: MapProperty TgGame.TgInventoryManager.s_DeletionMap

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryManager");
		return ptr;
	}


	void ChangedWeapon();
	void ServerSetCurrentWeapon(class ATgDevice* NewWeapon);
	void SetCurrentWeapon(class ATgDevice* DesiredWeapon);
	void STATIC_SetPendingWeapon(class AWeapon* DesiredWeapon);
	void ServerSetInventoryDirty();
	void ServerTestShowInventory();
	void Destroyed();
	void PostBeginPlay();
	void STATIC_ForwardPawnOnEnergyGiven(float fEnergy);
	void STATIC_InventoryCleanup();
	void TestShowInventory();
	void ApplyAllPassiveItemEffects(bool bRemove);
	void SetInventoryDirty();
	bool STATIC_IsValid();
	class UTgInventoryObject* STATIC_GetInventoryByName(const struct FString& sName);
	class UTgInventoryObject* STATIC_GetInventoryByEquipPoint(TEnumAsByte<ETG_EQUIP_POINT> ePoint, int nItemType);
	class UTgInventoryObject* STATIC_GetInventoryById(const struct FQWord& qwInventoryId);
	class ATgDevice* STATIC_GetDeviceByInstanceId(int nDeviceInstanceId);
	void SwapDevices(class UTgInventoryObject_Device* pInv, int nEquipPoint);
	void RemoveDevice(class UTgInventoryObject_Device* pInv);
	class ATgDevice* AddDevice(int nDeviceId, int nEquipPoint, class ATgDevice* parentDevice, bool bReplaceIfOccupied, int nLevel, int nPower);
	void RequestInventory();
};


// Class TgGame.TgInventoryManager_Player
// 0x0000 (0x0398 - 0x0398)
class ATgInventoryManager_Player : public ATgInventoryManager
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryManager_Player");
		return ptr;
	}


	void ChangeDeviceLevel(int nEquipPoint, int nLevel);
	void RemoveDevice(class UTgInventoryObject_Device* pInv);
	class ATgDevice* AddDevice(int nDeviceId, int nEquipPoint, class ATgDevice* parentDevice, bool bReplaceIfOccupied, int nLevel, int nPower);
	int CountFilledBurnCardSlots();
	void RemoveBurnCards();
};


// Class TgGame.TgInventoryObject
// 0x0048 (0x00A8 - 0x0060)
class UTgInventoryObject : public UObject
{
public:
	struct FInventoryData                              m_InventoryData;                                          // 0x0060(0x0024)
	int                                                m_nRefData;                                               // 0x0084(0x0004)
	class ATgInventoryManager*                         m_InvManager;                                             // 0x0088(0x0008)
	unsigned long                                      m_bTemporary : 1;                                         // 0x0090(0x0004)
	TEnumAsByte<EReplicatedState>                      s_ReplicatedState;                                        // 0x0094(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	struct FPointer                                    m_pAmItem;                                                // 0x0098(0x0008) (Const, Native)
	int                                                c_nNbrAcquired;                                           // 0x00A0(0x0004)
	float                                              c_fTimeAcquired;                                          // 0x00A4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject");
		return ptr;
	}


	int STATIC_GetInstanceCount();
	void SetInstanceCount(int nInstanceCount);
	struct FInventoryData STATIC_GetInventoryData();
	bool STATIC_IsEquippableType();
	bool STATIC_IsUsableType();
};


// Class TgGame.TgInventoryObject_Device
// 0x001C (0x00C4 - 0x00A8)
class UTgInventoryObject_Device : public UTgInventoryObject
{
public:
	class ATgDevice*                                   s_Device;                                                 // 0x00A8(0x0008)
	int                                                m_nDeviceInstanceId;                                      // 0x00B0(0x0004)
	int                                                c_nNumFindDeviceFails;                                    // 0x00B4(0x0004)
	int                                                m_nStackCount;                                            // 0x00B8(0x0004)
	struct FPointer                                    m_pAmDevice;                                              // 0x00BC(0x0008) (Const, Native)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Device");
		return ptr;
	}


	bool STATIC_IsCard();
	void SetInstanceCount(int nInstanceCount);
};


// Class TgGame.TgInvListener
// 0x0000 (0x00C4 - 0x00C4)
class UTgInvListener : public UTgInventoryObject_Device
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_AbilityProcBase
// 0x0008 (0x00CC - 0x00C4)
class UTgInventoryObject_Listen_AbilityProcBase : public UTgInvListener
{
public:
	int                                                m_nAbilitySlotRestriction;                                // 0x00C4(0x0004) (Const)
	int                                                m_nAbilityTypeRestriction;                                // 0x00C8(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AbilityProcBase");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_AbilityInstant
// 0x0000 (0x00CC - 0x00CC)
class UTgInventoryObject_Listen_AbilityInstant : public UTgInventoryObject_Listen_AbilityProcBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AbilityInstant");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Ability
// 0x0000 (0x00CC - 0x00CC)
class UTgInventoryObject_Listen_Ability : public UTgInventoryObject_Listen_AbilityInstant
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Ability");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_UseWhileCCed
// 0x0004 (0x00D0 - 0x00CC)
class UTgInventoryObject_Listen_UseWhileCCed : public UTgInventoryObject_Listen_Ability
{
public:
	unsigned long                                      m_bIsActive : 1;                                          // 0x00CC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_UseWhileCCed");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_AbilityEnd
// 0x0000 (0x00CC - 0x00CC)
class UTgInventoryObject_Listen_AbilityEnd : public UTgInventoryObject_Listen_AbilityInstant
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AbilityEnd");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_AbilityEndTargetFiremodeOnly
// 0x0000 (0x00CC - 0x00CC)
class UTgInventoryObject_Listen_AbilityEndTargetFiremodeOnly : public UTgInventoryObject_Listen_AbilityEnd
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AbilityEndTargetFiremodeOnly");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ReduceOtherCooldownOnStopFire
// 0x0000 (0x00CC - 0x00CC)
class UTgInventoryObject_Listen_ReduceOtherCooldownOnStopFire : public UTgInventoryObject_Listen_AbilityEnd
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ReduceOtherCooldownOnStopFire");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_AbilityStart
// 0x0000 (0x00CC - 0x00CC)
class UTgInventoryObject_Listen_AbilityStart : public UTgInventoryObject_Listen_AbilityInstant
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AbilityStart");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_AbilityStart_LowHealth
// 0x0000 (0x00CC - 0x00CC)
class UTgInventoryObject_Listen_AbilityStart_LowHealth : public UTgInventoryObject_Listen_AbilityStart
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AbilityStart_LowHealth");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Kindling
// 0x0000 (0x00CC - 0x00CC)
class UTgInventoryObject_Listen_Kindling : public UTgInventoryObject_Listen_AbilityStart
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Kindling");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ReduceOtherCooldownOnStartFire
// 0x0000 (0x00CC - 0x00CC)
class UTgInventoryObject_Listen_ReduceOtherCooldownOnStartFire : public UTgInventoryObject_Listen_AbilityStart
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ReduceOtherCooldownOnStartFire");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ProcOnDamageThreshold
// 0x0008 (0x00D4 - 0x00CC)
class UTgInventoryObject_Listen_ProcOnDamageThreshold : public UTgInventoryObject_Listen_AbilityInstant
{
public:
	float                                              m_fAccumulatedDamage;                                     // 0x00CC(0x0004)
	unsigned long                                      m_bAppliedSinceLastFire : 1;                              // 0x00D0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ProcOnDamageThreshold");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_AbilityProcDeployables
// 0x0000 (0x00CC - 0x00CC)
class UTgInventoryObject_Listen_AbilityProcDeployables : public UTgInventoryObject_Listen_AbilityProcBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AbilityProcDeployables");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_AddShieldDamage
// 0x0000 (0x00CC - 0x00CC)
class UTgInventoryObject_Listen_AddShieldDamage : public UTgInventoryObject_Listen_AbilityProcBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AddShieldDamage");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Combo
// 0x0000 (0x00CC - 0x00CC)
class UTgInventoryObject_Listen_Combo : public UTgInventoryObject_Listen_AbilityProcBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Combo");
		return ptr;
	}


	void RemoveUIMarks(class AActor* Target, int nNumMarks);
	void AddUIMarks(class AActor* Target, int nNumMarks);
};


// Class TgGame.TgInventoryObject_Listen_Combo_Barik
// 0x0030 (0x00FC - 0x00CC)
class UTgInventoryObject_Listen_Combo_Barik : public UTgInventoryObject_Listen_Combo
{
public:
	TArray<struct FComboInfo>                          m_ComboInfoList;                                          // 0x00CC(0x0010) (NeedCtorLink)
	TArray<struct FUIMarkInfo>                         m_UIMarkInfoList;                                         // 0x00DC(0x0010) (NeedCtorLink)
	TArray<struct FBurningMarkInfo>                    m_BurningMarks;                                           // 0x00EC(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Combo_Barik");
		return ptr;
	}


	void TriggerBurningMarks(class AActor* Target);
	void STATIC_UpdateUIMarks();
	void STATIC_UpdateExpiredComboInfos();
	void TouchedBarricade(class AActor* Target, class AActor* barricade);
};


// Class TgGame.TgInventoryObject_Listen_Combo_BombKing
// 0x0010 (0x00DC - 0x00CC)
class UTgInventoryObject_Listen_Combo_BombKing : public UTgInventoryObject_Listen_Combo
{
public:
	TArray<struct FStickyHitInfo>                      m_HitActors;                                              // 0x00CC(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Combo_BombKing");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Combo_Buck
// 0x0000 (0x00CC - 0x00CC)
class UTgInventoryObject_Listen_Combo_Buck : public UTgInventoryObject_Listen_Combo
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Combo_Buck");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Combo_Cassie
// 0x000C (0x00D8 - 0x00CC)
class UTgInventoryObject_Listen_Combo_Cassie : public UTgInventoryObject_Listen_Combo
{
public:
	float                                              m_fDodgeRollFireTime;                                     // 0x00CC(0x0004)
	class ATgPawn_Cassie*                              m_CachedCassiePawn;                                       // 0x00D0(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Combo_Cassie");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Combo_Drogoz
// 0x0004 (0x00D0 - 0x00CC)
class UTgInventoryObject_Listen_Combo_Drogoz : public UTgInventoryObject_Listen_Combo
{
public:
	float                                              m_fLastThrustTime;                                        // 0x00CC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Combo_Drogoz");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Combo_Evie
// 0x0018 (0x00E4 - 0x00CC)
class UTgInventoryObject_Listen_Combo_Evie : public UTgInventoryObject_Listen_Combo
{
public:
	TArray<class AActor*>                              m_MarkedTargets;                                          // 0x00CC(0x0010) (NeedCtorLink)
	float                                              m_fBlinkTimestamp;                                        // 0x00DC(0x0004)
	float                                              m_fIceBlockTimestamp;                                     // 0x00E0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Combo_Evie");
		return ptr;
	}


	void MarksExpired();
};


// Class TgGame.TgInventoryObject_Listen_Combo_Fernando
// 0x0004 (0x00D0 - 0x00CC)
class UTgInventoryObject_Listen_Combo_Fernando : public UTgInventoryObject_Listen_Combo
{
public:
	int                                                m_nNumContacts;                                           // 0x00CC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Combo_Fernando");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Combo_Grohk
// 0x000C (0x00D8 - 0x00CC)
class UTgInventoryObject_Listen_Combo_Grohk : public UTgInventoryObject_Listen_Combo
{
public:
	float                                              m_fFirstHitThisTickTimestamp;                             // 0x00CC(0x0004)
	int                                                m_nHitsThisChain;                                         // 0x00D0(0x0004)
	unsigned long                                      m_bBonusActive : 1;                                       // 0x00D4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Combo_Grohk");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Combo_Grover
// 0x000C (0x00D8 - 0x00CC)
class UTgInventoryObject_Listen_Combo_Grover : public UTgInventoryObject_Listen_Combo
{
public:
	struct FVector                                     m_vAxeStartingLocation;                                   // 0x00CC(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Combo_Grover");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Combo_Kinessa
// 0x0000 (0x00CC - 0x00CC)
class UTgInventoryObject_Listen_Combo_Kinessa : public UTgInventoryObject_Listen_Combo
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Combo_Kinessa");
		return ptr;
	}


	bool STATIC_IsOppressorMineTarget(class AActor* TgP);
};


// Class TgGame.TgInventoryObject_Listen_Combo_Makoa
// 0x0010 (0x00DC - 0x00CC)
class UTgInventoryObject_Listen_Combo_Makoa : public UTgInventoryObject_Listen_Combo
{
public:
	TArray<struct FMarkedTargetHook>                   m_MarkedTargets;                                          // 0x00CC(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Combo_Makoa");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Combo_Pip
// 0x0040 (0x010C - 0x00CC)
class UTgInventoryObject_Listen_Combo_Pip : public UTgInventoryObject_Listen_Combo
{
public:
	TArray<class ATgProjectile*>                       m_Projectiles;                                            // 0x00CC(0x0010) (NeedCtorLink)
	TArray<struct FVector>                             m_SpawnLocations;                                         // 0x00DC(0x0010) (NeedCtorLink)
	TArray<class AActor*>                              m_MarkedTargetsFlask;                                     // 0x00EC(0x0010) (NeedCtorLink)
	TArray<float>                                      m_fMarkedTimesFlask;                                      // 0x00FC(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Combo_Pip");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Combo_Ruckus
// 0x0020 (0x00EC - 0x00CC)
class UTgInventoryObject_Listen_Combo_Ruckus : public UTgInventoryObject_Listen_Combo
{
public:
	class ATgPawn_Ruckus*                              m_CachedRuckusOwner;                                      // 0x00CC(0x0008)
	int                                                m_nDamageReductionStacks;                                 // 0x00D4(0x0004)
	int                                                m_nBonusDamageStacks;                                     // 0x00D8(0x0004)
	float                                              m_fDamageReductionStackTime;                              // 0x00DC(0x0004)
	float                                              m_fBonusDamageStackTime;                                  // 0x00E0(0x0004)
	unsigned long                                      m_bEmitterActive : 1;                                     // 0x00E4(0x0004)
	unsigned long                                      m_bComboEffectsOn : 1;                                    // 0x00E4(0x0004)
	float                                              m_fComboBonusTime;                                        // 0x00E8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Combo_Ruckus");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Combo_Saati
// 0x0020 (0x00EC - 0x00CC)
class UTgInventoryObject_Listen_Combo_Saati : public UTgInventoryObject_Listen_Combo
{
public:
	TArray<class AActor*>                              m_MarkedTargets;                                          // 0x00CC(0x0010) (NeedCtorLink)
	TArray<float>                                      m_fMarkedTimestamps;                                      // 0x00DC(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Combo_Saati");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Combo_Skye
// 0x000C (0x00D8 - 0x00CC)
class UTgInventoryObject_Listen_Combo_Skye : public UTgInventoryObject_Listen_Combo
{
public:
	float                                              m_fLastStealthTime;                                       // 0x00CC(0x0004)
	unsigned long                                      m_bComboActive : 1;                                       // 0x00D0(0x0004)
	unsigned long                                      m_bCanTriggerCombo : 1;                                   // 0x00D0(0x0004)
	int                                                m_nHitStacks;                                             // 0x00D4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Combo_Skye");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Combo_Viktor
// 0x0010 (0x00DC - 0x00CC)
class UTgInventoryObject_Listen_Combo_Viktor : public UTgInventoryObject_Listen_Combo
{
public:
	TArray<struct FTimedMarkedTarget>                  m_MarkedTargets;                                          // 0x00CC(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Combo_Viktor");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Combo_Ying
// 0x003C (0x0108 - 0x00CC)
class UTgInventoryObject_Listen_Combo_Ying : public UTgInventoryObject_Listen_Combo
{
public:
	float                                              m_fCombo1MaxDuration;                                     // 0x00CC(0x0004)
	float                                              m_fCombo1BonusDamagePercent;                              // 0x00D0(0x0004)
	float                                              m_fCombo2BonusDamage;                                     // 0x00D4(0x0004)
	TArray<class AActor*>                              m_MarkedTargets;                                          // 0x00D8(0x0010) (NeedCtorLink)
	TArray<float>                                      m_fMarkTimes;                                             // 0x00E8(0x0010) (NeedCtorLink)
	class AActor*                                      m_InhandTarget;                                           // 0x00F8(0x0008)
	int                                                m_nInhandHits;                                            // 0x0100(0x0004)
	int                                                m_nCombo1DeviceId;                                        // 0x0104(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Combo_Ying");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_DeployOnAbility
// 0x0001 (0x00CD - 0x00CC)
class UTgInventoryObject_Listen_DeployOnAbility : public UTgInventoryObject_Listen_AbilityProcBase
{
public:
	TEnumAsByte<EDeployOnAbilityType>                  m_eDeployType;                                            // 0x00CC(0x0001) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_DeployOnAbility");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_DeployWithProjectile
// 0x0000 (0x00CC - 0x00CC)
class UTgInventoryObject_Listen_DeployWithProjectile : public UTgInventoryObject_Listen_AbilityProcBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_DeployWithProjectile");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_DirectHit
// 0x0000 (0x00CC - 0x00CC)
class UTgInventoryObject_Listen_DirectHit : public UTgInventoryObject_Listen_AbilityProcBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_DirectHit");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_DuringAbility
// 0x0005 (0x00D1 - 0x00CC)
class UTgInventoryObject_Listen_DuringAbility : public UTgInventoryObject_Listen_AbilityProcBase
{
public:
	unsigned long                                      m_bAbilityInActiveState : 1;                              // 0x00CC(0x0004)
	unsigned long                                      m_bIsActive : 1;                                          // 0x00CC(0x0004)
	TEnumAsByte<EDuringAbilityType>                    m_eDuringType;                                            // 0x00D0(0x0001) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_DuringAbility");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ActiveDuringAbility
// 0x0003 (0x00D4 - 0x00D1)
class UTgInventoryObject_Listen_ActiveDuringAbility : public UTgInventoryObject_Listen_DuringAbility
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x00D1(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ActiveDuringAbility");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ActiveDuringAbility_NotFiringInhand
// 0x0000 (0x00D4 - 0x00D4)
class UTgInventoryObject_Listen_ActiveDuringAbility_NotFiringInhand : public UTgInventoryObject_Listen_ActiveDuringAbility
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ActiveDuringAbility_NotFiringInhand");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ActiveDuringAbility_WhileOutOfCombat
// 0x0004 (0x00D8 - 0x00D4)
class UTgInventoryObject_Listen_ActiveDuringAbility_WhileOutOfCombat : public UTgInventoryObject_Listen_ActiveDuringAbility
{
public:
	unsigned long                                      m_bPawnInCombat : 1;                                      // 0x00D4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ActiveDuringAbility_WhileOutOfCombat");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ActiveMovementHit
// 0x0000 (0x00D4 - 0x00D4)
class UTgInventoryObject_Listen_ActiveMovementHit : public UTgInventoryObject_Listen_ActiveDuringAbility
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ActiveMovementHit");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_BowlingBall
// 0x0008 (0x00DC - 0x00D4)
class UTgInventoryObject_Listen_BowlingBall : public UTgInventoryObject_Listen_ActiveDuringAbility
{
public:
	float                                              m_fRocketBootsEndTime;                                    // 0x00D4(0x0004)
	float                                              m_fPostRocketBootsTime;                                   // 0x00D8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_BowlingBall");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_LastStand
// 0x0004 (0x00D8 - 0x00D4)
class UTgInventoryObject_Listen_LastStand : public UTgInventoryObject_Listen_ActiveDuringAbility
{
public:
	unsigned long                                      m_bHealthInActiveRange : 1;                               // 0x00D4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_LastStand");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ModifyRecoilDuringAbility
// 0x0004 (0x00D8 - 0x00D4)
class UTgInventoryObject_Listen_ModifyRecoilDuringAbility : public UTgInventoryObject_Listen_ActiveDuringAbility
{
public:
	int                                                m_nPreviousRecoil;                                        // 0x00D4(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ModifyRecoilDuringAbility");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Mount
// 0x0000 (0x00D4 - 0x00D4)
class UTgInventoryObject_Listen_Mount : public UTgInventoryObject_Listen_ActiveDuringAbility
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Mount");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_MountShield
// 0x0008 (0x00DC - 0x00D4)
class UTgInventoryObject_Listen_MountShield : public UTgInventoryObject_Listen_Mount
{
public:
	float                                              m_fNextMountShieldTime;                                   // 0x00D4(0x0004)
	float                                              m_fMinMountShieldTime;                                    // 0x00D8(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_MountShield");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Proximity
// 0x0000 (0x00D4 - 0x00D4)
class UTgInventoryObject_Listen_Proximity : public UTgInventoryObject_Listen_ActiveDuringAbility
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Proximity");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Undying
// 0x0000 (0x00D4 - 0x00D4)
class UTgInventoryObject_Listen_Undying : public UTgInventoryObject_Listen_ActiveDuringAbility
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Undying");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_DeployedDuringAbility
// 0x0003 (0x00D4 - 0x00D1)
class UTgInventoryObject_Listen_DeployedDuringAbility : public UTgInventoryObject_Listen_DuringAbility
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x00D1(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_DeployedDuringAbility");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_EmitterEffect
// 0x0003 (0x00D4 - 0x00D1)
class UTgInventoryObject_Listen_EmitterEffect : public UTgInventoryObject_Listen_DuringAbility
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x00D1(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_EmitterEffect");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_FiringDuringAbility
// 0x0003 (0x00D4 - 0x00D1)
class UTgInventoryObject_Listen_FiringDuringAbility : public UTgInventoryObject_Listen_DuringAbility
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x00D1(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_FiringDuringAbility");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_FiringDuringAbilityAltMode
// 0x0000 (0x00D4 - 0x00D4)
class UTgInventoryObject_Listen_FiringDuringAbilityAltMode : public UTgInventoryObject_Listen_FiringDuringAbility
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_FiringDuringAbilityAltMode");
		return ptr;
	}

};


// Class TgGame.TgInvListener_OnDamagedDuringAbility
// 0x0003 (0x00D4 - 0x00D1)
class UTgInvListener_OnDamagedDuringAbility : public UTgInventoryObject_Listen_DuringAbility
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x00D1(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_OnDamagedDuringAbility");
		return ptr;
	}

};


// Class TgGame.TgInvListener_OnEliminationOrKillDuringAbility
// 0x0003 (0x00D4 - 0x00D1)
class UTgInvListener_OnEliminationOrKillDuringAbility : public UTgInventoryObject_Listen_DuringAbility
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x00D1(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_OnEliminationOrKillDuringAbility");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Exhilarate
// 0x0000 (0x00CC - 0x00CC)
class UTgInventoryObject_Listen_Exhilarate : public UTgInventoryObject_Listen_AbilityProcBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Exhilarate");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_FireOnKillWithChildDevice
// 0x0000 (0x00CC - 0x00CC)
class UTgInventoryObject_Listen_FireOnKillWithChildDevice : public UTgInventoryObject_Listen_AbilityProcBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_FireOnKillWithChildDevice");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_FireOnKillWithChildDeviceWithFiremode
// 0x0000 (0x00CC - 0x00CC)
class UTgInventoryObject_Listen_FireOnKillWithChildDeviceWithFiremode : public UTgInventoryObject_Listen_AbilityProcBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_FireOnKillWithChildDeviceWithFiremode");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_FireOnMiss
// 0x0000 (0x00CC - 0x00CC)
class UTgInventoryObject_Listen_FireOnMiss : public UTgInventoryObject_Listen_AbilityProcBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_FireOnMiss");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_FireWithProjectile
// 0x0000 (0x00CC - 0x00CC)
class UTgInventoryObject_Listen_FireWithProjectile : public UTgInventoryObject_Listen_AbilityProcBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_FireWithProjectile");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_FullBurstHit
// 0x0018 (0x00E4 - 0x00CC)
class UTgInventoryObject_Listen_FullBurstHit : public UTgInventoryObject_Listen_AbilityProcBase
{
public:
	int                                                m_nCurrentFireLoopInstanceId;                             // 0x00CC(0x0004)
	int                                                m_nCurrentHits;                                           // 0x00D0(0x0004)
	int                                                m_nTargetHits;                                            // 0x00D4(0x0004)
	unsigned long                                      m_bBonusActive : 1;                                       // 0x00D8(0x0004)
	class AActor*                                      m_pLastTargetHit;                                         // 0x00DC(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_FullBurstHit");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_GiftGiver
// 0x0004 (0x00D0 - 0x00CC)
class UTgInventoryObject_Listen_GiftGiver : public UTgInventoryObject_Listen_AbilityProcBase
{
public:
	unsigned long                                      m_bHasActivated : 1;                                      // 0x00CC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_GiftGiver");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_HitStealthTarget
// 0x0000 (0x00CC - 0x00CC)
class UTgInventoryObject_Listen_HitStealthTarget : public UTgInventoryObject_Listen_AbilityProcBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_HitStealthTarget");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_HitWithDevice
// 0x000C (0x00D8 - 0x00CC)
class UTgInventoryObject_Listen_HitWithDevice : public UTgInventoryObject_Listen_AbilityProcBase
{
public:
	unsigned long                                      m_bIgnoreChildDevice : 1;                                 // 0x00CC(0x0004)
	unsigned long                                      m_bAutoProcOnInhand : 1;                                  // 0x00CC(0x0004)
	unsigned long                                      m_bAutoProcOnAsIfInhand : 1;                              // 0x00CC(0x0004)
	unsigned long                                      m_bSkipActiveCheck : 1;                                   // 0x00CC(0x0004)
	unsigned long                                      m_bSkipStartCooldown : 1;                                 // 0x00CC(0x0004)
	unsigned long                                      m_bUseAllyTargets : 1;                                    // 0x00CC(0x0004)
	int                                                m_nLastFireLoopInstanceId;                                // 0x00D0(0x0004)
	int                                                m_nNumTimesApplied;                                       // 0x00D4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_HitWithDevice");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_HitAndHitSpecialWithDevice
// 0x0000 (0x00D8 - 0x00D8)
class UTgInventoryObject_Listen_HitAndHitSpecialWithDevice : public UTgInventoryObject_Listen_HitWithDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_HitAndHitSpecialWithDevice");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_HitWithDeviceOrChildItems
// 0x0000 (0x00D8 - 0x00D8)
class UTgInventoryObject_Listen_HitWithDeviceOrChildItems : public UTgInventoryObject_Listen_HitWithDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_HitWithDeviceOrChildItems");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_HitWithDeviceOrDeviceId
// 0x0000 (0x00D8 - 0x00D8)
class UTgInventoryObject_Listen_HitWithDeviceOrDeviceId : public UTgInventoryObject_Listen_HitWithDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_HitWithDeviceOrDeviceId");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_HitWithInhandWhileDeviceFiring
// 0x0000 (0x00D8 - 0x00D8)
class UTgInventoryObject_Listen_HitWithInhandWhileDeviceFiring : public UTgInventoryObject_Listen_HitWithDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_HitWithInhandWhileDeviceFiring");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ReduceOtherCooldownOnHit
// 0x0000 (0x00D8 - 0x00D8)
class UTgInventoryObject_Listen_ReduceOtherCooldownOnHit : public UTgInventoryObject_Listen_HitWithDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ReduceOtherCooldownOnHit");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Weaken
// 0x0004 (0x00DC - 0x00D8)
class UTgInventoryObject_Listen_Weaken : public UTgInventoryObject_Listen_HitWithDevice
{
public:
	int                                                m_nAppliedCategoryCodeToCheck;                            // 0x00D8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Weaken");
		return ptr;
	}

};


// Class TgGame.TgInvListener_HitWithDeviceFiremode
// 0x0000 (0x00D8 - 0x00D8)
class UTgInvListener_HitWithDeviceFiremode : public UTgInventoryObject_Listen_HitWithDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_HitWithDeviceFiremode");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_HitWithDeviceSpecial
// 0x0004 (0x00D0 - 0x00CC)
class UTgInventoryObject_Listen_HitWithDeviceSpecial : public UTgInventoryObject_Listen_AbilityProcBase
{
public:
	unsigned long                                      m_bSkipActiveCheck : 1;                                   // 0x00CC(0x0004)
	unsigned long                                      m_bSkipStartCooldown : 1;                                 // 0x00CC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_HitWithDeviceSpecial");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_HitWithPetDevice
// 0x0004 (0x00D0 - 0x00CC)
class UTgInventoryObject_Listen_HitWithPetDevice : public UTgInventoryObject_Listen_AbilityProcBase
{
public:
	unsigned long                                      m_bSkipActiveCheck : 1;                                   // 0x00CC(0x0004)
	unsigned long                                      m_bSkipStartCooldown : 1;                                 // 0x00CC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_HitWithPetDevice");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ImpalerArrowHit
// 0x0000 (0x00CC - 0x00CC)
class UTgInventoryObject_Listen_ImpalerArrowHit : public UTgInventoryObject_Listen_AbilityProcBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ImpalerArrowHit");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_LoogieExplodedHit
// 0x0004 (0x00D0 - 0x00CC)
class UTgInventoryObject_Listen_LoogieExplodedHit : public UTgInventoryObject_Listen_AbilityProcBase
{
public:
	unsigned long                                      m_bNeedToApplyCooldown : 1;                               // 0x00CC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_LoogieExplodedHit");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_LoogieHit
// 0x0008 (0x00D4 - 0x00CC)
class UTgInventoryObject_Listen_LoogieHit : public UTgInventoryObject_Listen_AbilityProcBase
{
public:
	int                                                m_nLastFireLoopInstanceId;                                // 0x00CC(0x0004)
	int                                                m_nNumTimesApplied;                                       // 0x00D0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_LoogieHit");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_MendingSpiritsActive
// 0x0014 (0x00E0 - 0x00CC)
class UTgInventoryObject_Listen_MendingSpiritsActive : public UTgInventoryObject_Listen_AbilityProcBase
{
public:
	TArray<class ATgPawn*>                             m_PawnTargets;                                            // 0x00CC(0x0010) (NeedCtorLink)
	unsigned long                                      m_bEffectsAreActive : 1;                                  // 0x00DC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_MendingSpiritsActive");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_MirrorDamageToHeal
// 0x0008 (0x00D4 - 0x00CC)
class UTgInventoryObject_Listen_MirrorDamageToHeal : public UTgInventoryObject_Listen_AbilityProcBase
{
public:
	class UTgDeviceFire_MirrorDamageToHeal*            m_CachedFiremode;                                         // 0x00CC(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_MirrorDamageToHeal");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_MirrorInhandDamageToHeal
// 0x0000 (0x00D4 - 0x00D4)
class UTgInventoryObject_Listen_MirrorInhandDamageToHeal : public UTgInventoryObject_Listen_MirrorDamageToHeal
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_MirrorInhandDamageToHeal");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_MirrorPetDamageToHeal
// 0x0008 (0x00D4 - 0x00CC)
class UTgInventoryObject_Listen_MirrorPetDamageToHeal : public UTgInventoryObject_Listen_AbilityProcBase
{
public:
	class UTgDeviceFire_MirrorDamageToHeal*            m_CachedFiremode;                                         // 0x00CC(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_MirrorPetDamageToHeal");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_PoisonBolts
// 0x0014 (0x00E0 - 0x00CC)
class UTgInventoryObject_Listen_PoisonBolts : public UTgInventoryObject_Listen_AbilityProcBase
{
public:
	TArray<struct FPoisonBoltInfo>                     m_PoisonBoltTargets;                                      // 0x00CC(0x0010) (NeedCtorLink)
	int                                                m_EffectGroupID;                                          // 0x00DC(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_PoisonBolts");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ReduceSelfDamageDeployable
// 0x0000 (0x00CC - 0x00CC)
class UTgInventoryObject_Listen_ReduceSelfDamageDeployable : public UTgInventoryObject_Listen_AbilityProcBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ReduceSelfDamageDeployable");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ReduceSelfDamageProjectile
// 0x0000 (0x00CC - 0x00CC)
class UTgInventoryObject_Listen_ReduceSelfDamageProjectile : public UTgInventoryObject_Listen_AbilityProcBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ReduceSelfDamageProjectile");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ReloadCard
// 0x0004 (0x00D0 - 0x00CC)
class UTgInventoryObject_Listen_ReloadCard : public UTgInventoryObject_Listen_AbilityProcBase
{
public:
	int                                                m_nPendingHitCounter;                                     // 0x00CC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ReloadCard");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_TagForLifesteal
// 0x0028 (0x00F4 - 0x00CC)
class UTgInventoryObject_Listen_TagForLifesteal : public UTgInventoryObject_Listen_AbilityProcBase
{
public:
	TArray<class AActor*>                              m_TagActors;                                              // 0x00CC(0x0010) (NeedCtorLink)
	TArray<float>                                      m_TagTimes;                                               // 0x00DC(0x0010) (NeedCtorLink)
	class UTgDeviceFire_MirrorDamageToHeal*            m_CachedFiremode;                                         // 0x00EC(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_TagForLifesteal");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Thunderstruck
// 0x0014 (0x00E0 - 0x00CC)
class UTgInventoryObject_Listen_Thunderstruck : public UTgInventoryObject_Listen_AbilityProcBase
{
public:
	TArray<class AActor*>                              m_UniqueTargets;                                          // 0x00CC(0x0010) (NeedCtorLink)
	unsigned long                                      m_bCachedIsArcing : 1;                                    // 0x00DC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Thunderstruck");
		return ptr;
	}

};


// Class TgGame.TgInvListener_DeathAfterHit
// 0x0014 (0x00E0 - 0x00CC)
class UTgInvListener_DeathAfterHit : public UTgInventoryObject_Listen_AbilityProcBase
{
public:
	float                                              m_fResetTimer;                                            // 0x00CC(0x0004)
	TArray<class AActor*>                              m_pLastTargetsHit;                                        // 0x00D0(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_DeathAfterHit");
		return ptr;
	}

};


// Class TgGame.TgInvListener_DeployWithProjectileOnWall
// 0x0000 (0x00CC - 0x00CC)
class UTgInvListener_DeployWithProjectileOnWall : public UTgInventoryObject_Listen_AbilityProcBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_DeployWithProjectileOnWall");
		return ptr;
	}

};


// Class TgGame.TgInvListener_HeadshotBonusDamage
// 0x0000 (0x00CC - 0x00CC)
class UTgInvListener_HeadshotBonusDamage : public UTgInventoryObject_Listen_AbilityProcBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_HeadshotBonusDamage");
		return ptr;
	}

};


// Class TgGame.TgInvListener_HitSelfOnDamageOrHeal
// 0x0000 (0x00CC - 0x00CC)
class UTgInvListener_HitSelfOnDamageOrHeal : public UTgInventoryObject_Listen_AbilityProcBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_HitSelfOnDamageOrHeal");
		return ptr;
	}

};


// Class TgGame.TgInvListener_SetInhandFiremodeAfterDeviceFired
// 0x0008 (0x00D4 - 0x00CC)
class UTgInvListener_SetInhandFiremodeAfterDeviceFired : public UTgInventoryObject_Listen_AbilityProcBase
{
public:
	int                                                m_nRemainingShots;                                        // 0x00CC(0x0004)
	float                                              m_fRemainingTime;                                         // 0x00D0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_SetInhandFiremodeAfterDeviceFired");
		return ptr;
	}

};


// Class TgGame.TgInvListener_SoulChargesActive
// 0x0004 (0x00D0 - 0x00CC)
class UTgInvListener_SoulChargesActive : public UTgInventoryObject_Listen_AbilityProcBase
{
public:
	unsigned long                                      m_bIsListenerActive : 1;                                  // 0x00CC(0x0004)
	unsigned long                                      m_bIsCardLogicActive : 1;                                 // 0x00CC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_SoulChargesActive");
		return ptr;
	}

};


// Class TgGame.TgInvListener_SoulChargesConsumed
// 0x0008 (0x00D4 - 0x00CC)
class UTgInvListener_SoulChargesConsumed : public UTgInventoryObject_Listen_AbilityProcBase
{
public:
	unsigned long                                      m_bIsListenerActive : 1;                                  // 0x00CC(0x0004)
	int                                                m_nNumSoulCharges;                                        // 0x00D0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_SoulChargesConsumed");
		return ptr;
	}

};


// Class TgGame.TgInvListener_TargetOverHealed
// 0x0010 (0x00DC - 0x00CC)
class UTgInvListener_TargetOverHealed : public UTgInventoryObject_Listen_AbilityProcBase
{
public:
	TArray<struct FTOHInfo>                            s_Stacks;                                                 // 0x00CC(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_TargetOverHealed");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_AbilityShieldDamage
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_AbilityShieldDamage : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AbilityShieldDamage");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ActiveDuringDimensionalLink
// 0x000C (0x00D0 - 0x00C4)
class UTgInventoryObject_Listen_ActiveDuringDimensionalLink : public UTgInvListener
{
public:
	class ATgDevice_DimensionalLink*                   m_CachedLinkDevice;                                       // 0x00C4(0x0008)
	unsigned long                                      m_bCardIsActive : 1;                                      // 0x00CC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ActiveDuringDimensionalLink");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ActiveWhileAlliesNear
// 0x001C (0x00E0 - 0x00C4)
class UTgInventoryObject_Listen_ActiveWhileAlliesNear : public UTgInvListener
{
public:
	float                                              m_fPawnCheckRateInterval;                                 // 0x00C4(0x0004)
	float                                              m_fTimeUntilNextPawnCheck;                                // 0x00C8(0x0004)
	unsigned long                                      m_bAppliedToSelf : 1;                                     // 0x00CC(0x0004)
	TArray<int>                                        m_AlliesInRange;                                          // 0x00D0(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ActiveWhileAlliesNear");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ActiveWhileInGrass
// 0x0008 (0x00CC - 0x00C4)
class UTgInventoryObject_Listen_ActiveWhileInGrass : public UTgInvListener
{
public:
	unsigned long                                      m_bCachedIsInGrass : 1;                                   // 0x00C4(0x0004)
	float                                              s_fExitTimestamp;                                         // 0x00C8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ActiveWhileInGrass");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ActiveWhileNotCCed
// 0x0010 (0x00D4 - 0x00C4)
class UTgInventoryObject_Listen_ActiveWhileNotCCed : public UTgInvListener
{
public:
	int                                                m_nAppliedStacks;                                         // 0x00C4(0x0004)
	class ATgPawn*                                     m_CachedPawn;                                             // 0x00C8(0x0008)
	float                                              m_fTimeSpentCCFree;                                       // 0x00D0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ActiveWhileNotCCed");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ActiveWhileOffCooldown
// 0x0004 (0x00C8 - 0x00C4)
class UTgInventoryObject_Listen_ActiveWhileOffCooldown : public UTgInvListener
{
public:
	unsigned long                                      m_bIsActive : 1;                                          // 0x00C4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ActiveWhileOffCooldown");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Accelerant
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_Accelerant : public UTgInventoryObject_Listen_ActiveWhileOffCooldown
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Accelerant");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ActiveWhileDeployableActive
// 0x0004 (0x00CC - 0x00C8)
class UTgInventoryObject_Listen_ActiveWhileDeployableActive : public UTgInventoryObject_Listen_ActiveWhileOffCooldown
{
public:
	int                                                m_nActiveDeployableCount;                                 // 0x00C8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ActiveWhileDeployableActive");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ActiveWhileDeployableInactive
// 0x0004 (0x00CC - 0x00C8)
class UTgInventoryObject_Listen_ActiveWhileDeployableInactive : public UTgInventoryObject_Listen_ActiveWhileOffCooldown
{
public:
	int                                                m_nActiveDeployableCount;                                 // 0x00C8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ActiveWhileDeployableInactive");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_AtTheReady
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_AtTheReady : public UTgInventoryObject_Listen_ActiveWhileOffCooldown
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AtTheReady");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Compensate
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_Compensate : public UTgInventoryObject_Listen_ActiveWhileOffCooldown
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Compensate");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Featherweight
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_Featherweight : public UTgInventoryObject_Listen_ActiveWhileOffCooldown
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Featherweight");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_LiftOff
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_LiftOff : public UTgInventoryObject_Listen_ActiveWhileOffCooldown
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_LiftOff");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_MoraleBoost
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_MoraleBoost : public UTgInventoryObject_Listen_ActiveWhileOffCooldown
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_MoraleBoost");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ReduceInhandSelfDamage
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_ReduceInhandSelfDamage : public UTgInventoryObject_Listen_ActiveWhileOffCooldown
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ReduceInhandSelfDamage");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Sprint
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_Sprint : public UTgInventoryObject_Listen_ActiveWhileOffCooldown
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Sprint");
		return ptr;
	}

};


// Class TgGame.TgInvListener_ExplosiveImpalerArrow
// 0x0034 (0x00FC - 0x00C8)
class UTgInvListener_ExplosiveImpalerArrow : public UTgInventoryObject_Listen_ActiveWhileOffCooldown
{
public:
	struct FAimData                                    m_AimData;                                                // 0x00C8(0x0034)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_ExplosiveImpalerArrow");
		return ptr;
	}

};


// Class TgGame.TgInvListener_ReplaceCurveSets
// 0x0000 (0x00C8 - 0x00C8)
class UTgInvListener_ReplaceCurveSets : public UTgInventoryObject_Listen_ActiveWhileOffCooldown
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_ReplaceCurveSets");
		return ptr;
	}

};


// Class TgGame.TgInvListener_SetChildDamageType
// 0x0014 (0x00DC - 0x00C8)
class UTgInvListener_SetChildDamageType : public UTgInventoryObject_Listen_ActiveWhileOffCooldown
{
public:
	int                                                m_nOldDamageType;                                         // 0x00C8(0x0004)
	struct FName                                       m_nmOldDamageTypeClass;                                   // 0x00CC(0x0008)
	class UClass*                                      m_OldDamageTypeClass;                                     // 0x00D4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_SetChildDamageType");
		return ptr;
	}

};


// Class TgGame.TgInvListener_SetChildFiremode
// 0x0000 (0x00C8 - 0x00C8)
class UTgInvListener_SetChildFiremode : public UTgInventoryObject_Listen_ActiveWhileOffCooldown
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_SetChildFiremode");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Jolt
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_Jolt : public UTgInvListener_SetChildFiremode
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Jolt");
		return ptr;
	}

};


// Class TgGame.TgInvListener_SetFiremodeOnDevices
// 0x0000 (0x00C8 - 0x00C8)
class UTgInvListener_SetFiremodeOnDevices : public UTgInventoryObject_Listen_ActiveWhileOffCooldown
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_SetFiremodeOnDevices");
		return ptr;
	}

};


// Class TgGame.TgInvListener_SetPetFiremode
// 0x0000 (0x00C8 - 0x00C8)
class UTgInvListener_SetPetFiremode : public UTgInventoryObject_Listen_ActiveWhileOffCooldown
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_SetPetFiremode");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ActiveWhilePawnsNear
// 0x000C (0x00D0 - 0x00C4)
class UTgInventoryObject_Listen_ActiveWhilePawnsNear : public UTgInvListener
{
public:
	int                                                m_nAppliedStacks;                                         // 0x00C4(0x0004)
	float                                              m_fPawnCheckRateInterval;                                 // 0x00C8(0x0004)
	float                                              m_fTimeUntilNextPawnCheck;                                // 0x00CC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ActiveWhilePawnsNear");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_AddDamage
// 0x0004 (0x00C8 - 0x00C4)
class UTgInventoryObject_Listen_AddDamage : public UTgInvListener
{
public:
	unsigned long                                      m_bAutoProcOnInhand : 1;                                  // 0x00C4(0x0004)
	unsigned long                                      m_bCheckIsValidTarget : 1;                                // 0x00C4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AddDamage");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_AddDamageMaxHealthPercent
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_AddDamageMaxHealthPercent : public UTgInventoryObject_Listen_AddDamage
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AddDamageMaxHealthPercent");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_AddDamagePerTarget
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_AddDamagePerTarget : public UTgInventoryObject_Listen_AddDamage
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AddDamagePerTarget");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_AddDamagePlusHit
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_AddDamagePlusHit : public UTgInventoryObject_Listen_AddDamage
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AddDamagePlusHit");
		return ptr;
	}

};


// Class TgGame.TgInvListener_AddDamageMissingHealth
// 0x0000 (0x00C8 - 0x00C8)
class UTgInvListener_AddDamageMissingHealth : public UTgInventoryObject_Listen_AddDamage
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_AddDamageMissingHealth");
		return ptr;
	}

};


// Class TgGame.TgInvListener_AddDamageMissingHealthPercent
// 0x0000 (0x00C8 - 0x00C8)
class UTgInvListener_AddDamageMissingHealthPercent : public UTgInventoryObject_Listen_AddDamage
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_AddDamageMissingHealthPercent");
		return ptr;
	}

};


// Class TgGame.TgInvListener_ConsumeMarksForDamage
// 0x0010 (0x00D8 - 0x00C8)
class UTgInvListener_ConsumeMarksForDamage : public UTgInventoryObject_Listen_AddDamage
{
public:
	TArray<class ATgPawn*>                             m_PendingMarkRemoval;                                     // 0x00C8(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_ConsumeMarksForDamage");
		return ptr;
	}

};


// Class TgGame.TgInvListener_ExtraDamageAboveHealthPercent
// 0x0000 (0x00C8 - 0x00C8)
class UTgInvListener_ExtraDamageAboveHealthPercent : public UTgInventoryObject_Listen_AddDamage
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_ExtraDamageAboveHealthPercent");
		return ptr;
	}

};


// Class TgGame.TgInvListener_ExtraDamageBelowHealthPercent
// 0x0000 (0x00C8 - 0x00C8)
class UTgInvListener_ExtraDamageBelowHealthPercent : public UTgInventoryObject_Listen_AddDamage
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_ExtraDamageBelowHealthPercent");
		return ptr;
	}

};


// Class TgGame.TgInvListener_ScaleDamageOverDistance
// 0x0000 (0x00C8 - 0x00C8)
class UTgInvListener_ScaleDamageOverDistance : public UTgInventoryObject_Listen_AddDamage
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_ScaleDamageOverDistance");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_AdrenalineJunkie
// 0x0014 (0x00D8 - 0x00C4)
class UTgInventoryObject_Listen_AdrenalineJunkie : public UTgInvListener
{
public:
	class ATgDevice_RestoreStamina*                    m_CachedRestoreStaminaDevice;                             // 0x00C4(0x0008)
	class ATgDevice_NinjaInhand*                       m_CachedNinjaSMG;                                         // 0x00CC(0x0008)
	float                                              m_DamageRemainder;                                        // 0x00D4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AdrenalineJunkie");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_AffectedByDevice
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_AffectedByDevice : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AffectedByDevice");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_AffectedByDeviceActiveWhile
// 0x0004 (0x00C8 - 0x00C4)
class UTgInventoryObject_Listen_AffectedByDeviceActiveWhile : public UTgInventoryObject_Listen_AffectedByDevice
{
public:
	unsigned long                                      m_bIsCardActive : 1;                                      // 0x00C4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AffectedByDeviceActiveWhile");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_AffectedByDeviceDamage
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_AffectedByDeviceDamage : public UTgInventoryObject_Listen_AffectedByDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AffectedByDeviceDamage");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_AffectedByDeviceKill
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_AffectedByDeviceKill : public UTgInventoryObject_Listen_AffectedByDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AffectedByDeviceKill");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_AffectedByDeviceLifesteal
// 0x0008 (0x00CC - 0x00C4)
class UTgInventoryObject_Listen_AffectedByDeviceLifesteal : public UTgInventoryObject_Listen_AffectedByDevice
{
public:
	class UTgDeviceFire_MirrorDamageToHeal*            m_CachedFiremode;                                         // 0x00C4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AffectedByDeviceLifesteal");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_AffectedByDeviceTarget
// 0x0014 (0x00D8 - 0x00C4)
class UTgInventoryObject_Listen_AffectedByDeviceTarget : public UTgInventoryObject_Listen_AffectedByDevice
{
public:
	unsigned long                                      m_bIsCardActive : 1;                                      // 0x00C4(0x0004)
	TArray<class AActor*>                              m_HitActors;                                              // 0x00C8(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AffectedByDeviceTarget");
		return ptr;
	}

};


// Class TgGame.TgInvListener_AffectedByDeviceApplyEffect
// 0x0000 (0x00C4 - 0x00C4)
class UTgInvListener_AffectedByDeviceApplyEffect : public UTgInventoryObject_Listen_AffectedByDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_AffectedByDeviceApplyEffect");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_AirBlast
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_AirBlast : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AirBlast");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ArcingBeam
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_ArcingBeam : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ArcingBeam");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_AuraMod
// 0x001C (0x00E0 - 0x00C4)
class UTgInventoryObject_Listen_AuraMod : public UTgInvListener
{
public:
	TArray<class AActor*>                              m_AffectedActors;                                         // 0x00C4(0x0010) (NeedCtorLink)
	unsigned long                                      m_bAuraIsActive : 1;                                      // 0x00D4(0x0004)
	class ATgDevice_Aura*                              m_CachedAuraDevice;                                       // 0x00D8(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AuraMod");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Backstab
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_Backstab : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Backstab");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_BackstabExtraDamage
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_BackstabExtraDamage : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_BackstabExtraDamage");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_BarricadeEffect
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_BarricadeEffect : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_BarricadeEffect");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_BlastShotHitEffect
// 0x0014 (0x00D8 - 0x00C4)
class UTgInventoryObject_Listen_BlastShotHitEffect : public UTgInvListener
{
public:
	TArray<class AActor*>                              m_PreviouslyHitActors;                                    // 0x00C4(0x0010) (NeedCtorLink)
	int                                                m_nTargetType;                                            // 0x00D4(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_BlastShotHitEffect");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_CombatRepair
// 0x0008 (0x00CC - 0x00C4)
class UTgInventoryObject_Listen_CombatRepair : public UTgInvListener
{
public:
	class ATgPawn*                                     m_CachedPawnOwner;                                        // 0x00C4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_CombatRepair");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Conduit
// 0x0018 (0x00DC - 0x00C4)
class UTgInventoryObject_Listen_Conduit : public UTgInvListener
{
public:
	int                                                m_nDeviceIdShockPulseMain;                                // 0x00C4(0x0004)
	int                                                m_nDeviceIdShockPulseSupport;                             // 0x00C8(0x0004)
	TArray<class AActor*>                              m_EnemiesHitThisPulse;                                    // 0x00CC(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Conduit");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_CorvusUltDeployEffect
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_CorvusUltDeployEffect : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_CorvusUltDeployEffect");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_CreditDamageOnHeal
// 0x0004 (0x00C8 - 0x00C4)
class UTgInventoryObject_Listen_CreditDamageOnHeal : public UTgInvListener
{
public:
	float                                              m_fLastHealTimeStamp;                                     // 0x00C4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_CreditDamageOnHeal");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_CreditOnKillOrAssist
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_CreditOnKillOrAssist : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_CreditOnKillOrAssist");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_DefianceHit
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_DefianceHit : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_DefianceHit");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_DeployOnDeployable
// 0x0010 (0x00D4 - 0x00C4)
class UTgInventoryObject_Listen_DeployOnDeployable : public UTgInvListener
{
public:
	TArray<int>                                        m_ValidDeployableIds;                                     // 0x00C4(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_DeployOnDeployable");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_DeployOnDeviceHit
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_DeployOnDeviceHit : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_DeployOnDeviceHit");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_DistanceFromObjective
// 0x0014 (0x00D8 - 0x00C4)
class UTgInventoryObject_Listen_DistanceFromObjective : public UTgInvListener
{
public:
	unsigned long                                      m_bIsActive : 1;                                          // 0x00C4(0x0004)
	float                                              m_fTimeNearObjective;                                     // 0x00C8(0x0004)
	int                                                m_nNumStacksApplied;                                      // 0x00CC(0x0004)
	class ATgPawn_Character*                           m_CachedCharacterPawn;                                    // 0x00D0(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_DistanceFromObjective");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_DistanceFromObjectiveOutOfCombat
// 0x0004 (0x00DC - 0x00D8)
class UTgInventoryObject_Listen_DistanceFromObjectiveOutOfCombat : public UTgInventoryObject_Listen_DistanceFromObjective
{
public:
	unsigned long                                      m_bInCombat : 1;                                          // 0x00D8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_DistanceFromObjectiveOutOfCombat");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_DoubleTap
// 0x0028 (0x00EC - 0x00C4)
class UTgInventoryObject_Listen_DoubleTap : public UTgInvListener
{
public:
	float                                              m_fBaseWeaponDamage;                                      // 0x00C4(0x0004)
	float                                              m_fDoubleTapDelay;                                        // 0x00C8(0x0004)
	TArray<class AActor*>                              m_PendingDoubleTapActors;                                 // 0x00CC(0x0010) (NeedCtorLink)
	TArray<float>                                      m_PendingDoubleTapTimes;                                  // 0x00DC(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_DoubleTap");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_EnergyCharge
// 0x0014 (0x00D8 - 0x00C4)
class UTgInventoryObject_Listen_EnergyCharge : public UTgInvListener
{
public:
	class ATgPawn*                                     m_CachedTgPawn;                                           // 0x00C4(0x0008)
	float                                              m_fChargeMultiplierDamageDealt;                           // 0x00CC(0x0004)
	float                                              m_fChargeMultiplierDamageTaken;                           // 0x00D0(0x0004)
	float                                              m_fChargeMultiplierPetDamage;                             // 0x00D4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_EnergyCharge");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_EquivalentExchange
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_EquivalentExchange : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_EquivalentExchange");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_FireInsteadOfDeath
// 0x0008 (0x00CC - 0x00C4)
class UTgInventoryObject_Listen_FireInsteadOfDeath : public UTgInvListener
{
public:
	float                                              m_fImmuneTimer;                                           // 0x00C4(0x0004)
	unsigned long                                      m_bPendingActivation : 1;                                 // 0x00C8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_FireInsteadOfDeath");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_FireOnAllyHealed
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_FireOnAllyHealed : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_FireOnAllyHealed");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_FireOnDamageInterruptedStealth
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_FireOnDamageInterruptedStealth : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_FireOnDamageInterruptedStealth");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_FireOnKill
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_FireOnKill : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_FireOnKill");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_FireOnElimination
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_FireOnElimination : public UTgInventoryObject_Listen_FireOnKill
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_FireOnElimination");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_FireOnLandAfterLeap
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_FireOnLandAfterLeap : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_FireOnLandAfterLeap");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_FireOnLowHealth
// 0x0004 (0x00C8 - 0x00C4)
class UTgInventoryObject_Listen_FireOnLowHealth : public UTgInvListener
{
public:
	unsigned long                                      m_bPendingActivation : 1;                                 // 0x00C4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_FireOnLowHealth");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_FireOnPawnDiedNearby
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_FireOnPawnDiedNearby : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_FireOnPawnDiedNearby");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_FireOnTeleport
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_FireOnTeleport : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_FireOnTeleport");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_FireWithDeployable
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_FireWithDeployable : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_FireWithDeployable");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_FirstShotAfterMovementAbility
// 0x0010 (0x00D4 - 0x00C4)
class UTgInventoryObject_Listen_FirstShotAfterMovementAbility : public UTgInvListener
{
public:
	float                                              m_fLastMovementAbilityTime;                               // 0x00C4(0x0004)
	unsigned long                                      m_bJustFinishedMovementAbility : 1;                       // 0x00C8(0x0004)
	int                                                m_nNumApplicationsRemaining;                              // 0x00CC(0x0004)
	float                                              m_fLastAppliedTime;                                       // 0x00D0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_FirstShotAfterMovementAbility");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Exaction
// 0x0008 (0x00DC - 0x00D4)
class UTgInventoryObject_Listen_Exaction : public UTgInventoryObject_Listen_FirstShotAfterMovementAbility
{
public:
	class UTgDeviceFire_MirrorDamageToHeal*            m_CachedFiremode;                                         // 0x00D4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Exaction");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_FirstShotDuringOrAfterMovementAbility
// 0x0004 (0x00D8 - 0x00D4)
class UTgInventoryObject_Listen_FirstShotDuringOrAfterMovementAbility : public UTgInventoryObject_Listen_FirstShotAfterMovementAbility
{
public:
	unsigned long                                      m_bMovementAbilityActive : 1;                             // 0x00D4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_FirstShotDuringOrAfterMovementAbility");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_FirstShotDuringOrAfterStealth
// 0x0008 (0x00CC - 0x00C4)
class UTgInventoryObject_Listen_FirstShotDuringOrAfterStealth : public UTgInvListener
{
public:
	unsigned long                                      m_bWasStealthed : 1;                                      // 0x00C4(0x0004)
	float                                              m_fLastStealthTime;                                       // 0x00C8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_FirstShotDuringOrAfterStealth");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_FragGrenade
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_FragGrenade : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_FragGrenade");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_GaleStorm
// 0x0010 (0x00D4 - 0x00C4)
class UTgInventoryObject_Listen_GaleStorm : public UTgInvListener
{
public:
	class ATgDevice_RestoreStamina*                    m_CachedRestoreStaminaDevice;                             // 0x00C4(0x0008)
	class ATgDevice_NinjaRMB2*                         m_CachedNinjaRMB2;                                        // 0x00CC(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_GaleStorm");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_GourdEffect
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_GourdEffect : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_GourdEffect");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Headhunter
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_Headhunter : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Headhunter");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_HealthByPercent
// 0x0004 (0x00C8 - 0x00C4)
class UTgInventoryObject_Listen_HealthByPercent : public UTgInvListener
{
public:
	int                                                m_iAppliedStacks;                                         // 0x00C4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_HealthByPercent");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_HealthPCT_In_Range
// 0x0004 (0x00C8 - 0x00C4)
class UTgInventoryObject_Listen_HealthPCT_In_Range : public UTgInvListener
{
public:
	unsigned long                                      m_bApplied : 1;                                           // 0x00C4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_HealthPCT_In_Range");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_HitAirborne
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_HitAirborne : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_HitAirborne");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_HitAirborneOwner
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_HitAirborneOwner : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_HitAirborneOwner");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_HitOnHeadshot
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_HitOnHeadshot : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_HitOnHeadshot");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Hustle
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_Hustle : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Hustle");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_InCombat
// 0x0004 (0x00C8 - 0x00C4)
class UTgInventoryObject_Listen_InCombat : public UTgInvListener
{
public:
	unsigned long                                      m_bEffectIsApplied : 1;                                   // 0x00C4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_InCombat");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_InHand_HitMissStacker
// 0x0008 (0x00CC - 0x00C4)
class UTgInventoryObject_Listen_InHand_HitMissStacker : public UTgInvListener
{
public:
	float                                              m_fLastStackTime;                                         // 0x00C4(0x0004)
	int                                                m_nAppliedStacks;                                         // 0x00C8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_InHand_HitMissStacker");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_LazarusResurrect
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_LazarusResurrect : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_LazarusResurrect");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_LoogieExploded
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_LoogieExploded : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_LoogieExploded");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_MirrorDamageToHealBlock
// 0x0008 (0x00CC - 0x00C4)
class UTgInventoryObject_Listen_MirrorDamageToHealBlock : public UTgInvListener
{
public:
	class UTgDeviceFire_MirrorDamageToHealBlock*       m_CachedFiremode;                                         // 0x00C4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_MirrorDamageToHealBlock");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_NearObjective
// 0x000C (0x00D0 - 0x00C4)
class UTgInventoryObject_Listen_NearObjective : public UTgInvListener
{
public:
	unsigned long                                      m_bIsActive : 1;                                          // 0x00C4(0x0004)
	class ATgPawn_Character*                           m_CachedCharacterPawn;                                    // 0x00C8(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_NearObjective");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_AuraNearObjective
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_AuraNearObjective : public UTgInventoryObject_Listen_NearObjective
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AuraNearObjective");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ReachOut
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_ReachOut : public UTgInventoryObject_Listen_NearObjective
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ReachOut");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_NearOwnTurret
// 0x0004 (0x00C8 - 0x00C4)
class UTgInventoryObject_Listen_NearOwnTurret : public UTgInvListener
{
public:
	unsigned long                                      m_bIsActive : 1;                                          // 0x00C4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_NearOwnTurret");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_OnAssistOrKill
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_OnAssistOrKill : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_OnAssistOrKill");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_OnHealChangeHealing
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_OnHealChangeHealing : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_OnHealChangeHealing");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_OppressorMineEffect
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_OppressorMineEffect : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_OppressorMineEffect");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_OutOfCombat
// 0x0004 (0x00C8 - 0x00C4)
class UTgInventoryObject_Listen_OutOfCombat : public UTgInvListener
{
public:
	unsigned long                                      m_bEffectIsApplied : 1;                                   // 0x00C4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_OutOfCombat");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_PetAbility
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_PetAbility : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_PetAbility");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_AugmentPetHit
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_AugmentPetHit : public UTgInventoryObject_Listen_PetAbility
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AugmentPetHit");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Unveil
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_Unveil : public UTgInventoryObject_Listen_AugmentPetHit
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Unveil");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_PetAbility_Deploy
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_PetAbility_Deploy : public UTgInventoryObject_Listen_PetAbility
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_PetAbility_Deploy");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_PetAbilityWhileDeployableActive
// 0x0004 (0x00C8 - 0x00C4)
class UTgInventoryObject_Listen_PetAbilityWhileDeployableActive : public UTgInventoryObject_Listen_PetAbility
{
public:
	int                                                m_nActiveDeployableCount;                                 // 0x00C4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_PetAbilityWhileDeployableActive");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_PetDied
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_PetDied : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_PetDied");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_PipConsequential
// 0x0004 (0x00C8 - 0x00C4)
class UTgInventoryObject_Listen_PipConsequential : public UTgInvListener
{
public:
	int                                                s_nHitCounter;                                            // 0x00C4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_PipConsequential");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_RainOfFire
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_RainOfFire : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_RainOfFire");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ReversalEffect
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_ReversalEffect : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ReversalEffect");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_SalvoExplode
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_SalvoExplode : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_SalvoExplode");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Scramble
// 0x0008 (0x00CC - 0x00C4)
class UTgInventoryObject_Listen_Scramble : public UTgInvListener
{
public:
	class ATgDevice_Scramble*                          m_CachedScrambleDevice;                                   // 0x00C4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Scramble");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ShellShieldEffect
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_ShellShieldEffect : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ShellShieldEffect");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ShieldEffect
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_ShieldEffect : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ShieldEffect");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_SizeOfTheFight
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_SizeOfTheFight : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_SizeOfTheFight");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_SmokeScreenEffect
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_SmokeScreenEffect : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_SmokeScreenEffect");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_SomethingToProve
// 0x000C (0x00D0 - 0x00C4)
class UTgInventoryObject_Listen_SomethingToProve : public UTgInvListener
{
public:
	unsigned long                                      m_bAvailable : 1;                                         // 0x00C4(0x0004)
	class ATgDevice_RestoreStamina*                    m_CachedRestoreStaminaDevice;                             // 0x00C8(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_SomethingToProve");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_SpawnTeamHealthNugget
// 0x0010 (0x00D4 - 0x00C4)
class UTgInventoryObject_Listen_SpawnTeamHealthNugget : public UTgInvListener
{
public:
	class UTgSpecialFx*                                m_NuggetSpawnFX;                                          // 0x00C4(0x0008)
	int                                                m_NuggetSpawnFXID;                                        // 0x00CC(0x0004)
	unsigned long                                      m_bUseCV1ForSpawnChance : 1;                              // 0x00D0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_SpawnTeamHealthNugget");
		return ptr;
	}


	void SpawnTeamHealthNugget(class ATgPawn* Target, const struct FVector& SpawnDirection);
};


// Class TgGame.TgInventoryObject_Listen_FirstAidKit
// 0x0000 (0x00D4 - 0x00D4)
class UTgInventoryObject_Listen_FirstAidKit : public UTgInventoryObject_Listen_SpawnTeamHealthNugget
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_FirstAidKit");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_SpringBloom
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_SpringBloom : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_SpringBloom");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Stack
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_Stack : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Stack");
		return ptr;
	}


	void AddStackCount(int nStackCount);
};


// Class TgGame.TgInventoryObject_Listen_Get_Nugget
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_Get_Nugget : public UTgInventoryObject_Listen_Stack
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Get_Nugget");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_StackPerPetAlive
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_StackPerPetAlive : public UTgInventoryObject_Listen_Stack
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_StackPerPetAlive");
		return ptr;
	}


	void STATIC_UpdatePetCountStacks(bool bEmptyStacks);
};


// Class TgGame.TgInventoryObject_Listen_StandingStill
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_StandingStill : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_StandingStill");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_StandingStillSelfEffect
// 0x0010 (0x00D4 - 0x00C4)
class UTgInventoryObject_Listen_StandingStillSelfEffect : public UTgInvListener
{
public:
	float                                              m_fRestTime;                                              // 0x00C4(0x0004)
	unsigned long                                      m_bIsApplied : 1;                                         // 0x00C8(0x0004)
	class ATgPawn*                                     m_CachedPawnOwner;                                        // 0x00CC(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_StandingStillSelfEffect");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_StatusIsOnTarget
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_StatusIsOnTarget : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_StatusIsOnTarget");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_StickyBombDetonate
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_StickyBombDetonate : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_StickyBombDetonate");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_TotemEffect
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_TotemEffect : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_TotemEffect");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_TripWire
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_TripWire : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_TripWire");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_TrueGrit
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_TrueGrit : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_TrueGrit");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_UltChargeFromHealing
// 0x0008 (0x00CC - 0x00C4)
class UTgInventoryObject_Listen_UltChargeFromHealing : public UTgInvListener
{
public:
	class ATgPawn*                                     m_CachedTgPawn;                                           // 0x00C4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_UltChargeFromHealing");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Unyielding
// 0x0008 (0x00CC - 0x00C4)
class UTgInventoryObject_Listen_Unyielding : public UTgInvListener
{
public:
	class ATgDevice_RestoreStamina*                    m_CachedRestoreStaminaDevice;                             // 0x00C4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Unyielding");
		return ptr;
	}

};


// Class TgGame.TgInvListener_ActiveDeployableEffect
// 0x0010 (0x00D4 - 0x00C4)
class UTgInvListener_ActiveDeployableEffect : public UTgInvListener
{
public:
	TArray<int>                                        m_AppliedTargetIds;                                       // 0x00C4(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_ActiveDeployableEffect");
		return ptr;
	}

};


// Class TgGame.TgInvListener_AddHealing
// 0x0000 (0x00C4 - 0x00C4)
class UTgInvListener_AddHealing : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_AddHealing");
		return ptr;
	}

};


// Class TgGame.TgInvListener_AddHealingAboveorBelowHealthPercent
// 0x0000 (0x00C4 - 0x00C4)
class UTgInvListener_AddHealingAboveorBelowHealthPercent : public UTgInvListener_AddHealing
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_AddHealingAboveorBelowHealthPercent");
		return ptr;
	}

};


// Class TgGame.TgInvListener_AddHealingByCombatState
// 0x0000 (0x00C4 - 0x00C4)
class UTgInvListener_AddHealingByCombatState : public UTgInvListener_AddHealing
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_AddHealingByCombatState");
		return ptr;
	}

};


// Class TgGame.TgInvListener_AddHealingMissingHealthPercent
// 0x0000 (0x00C4 - 0x00C4)
class UTgInvListener_AddHealingMissingHealthPercent : public UTgInvListener_AddHealing
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_AddHealingMissingHealthPercent");
		return ptr;
	}

};


// Class TgGame.TgInvListener_ApplyAoeWithHit
// 0x0000 (0x00C4 - 0x00C4)
class UTgInvListener_ApplyAoeWithHit : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_ApplyAoeWithHit");
		return ptr;
	}

};


// Class TgGame.TgInvListener_ApplyHitSpecialOnDamageThreshold
// 0x0000 (0x00C4 - 0x00C4)
class UTgInvListener_ApplyHitSpecialOnDamageThreshold : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_ApplyHitSpecialOnDamageThreshold");
		return ptr;
	}

};


// Class TgGame.TgInvListener_ApplyHitSpecialOnHealingThreshold
// 0x0000 (0x00C4 - 0x00C4)
class UTgInvListener_ApplyHitSpecialOnHealingThreshold : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_ApplyHitSpecialOnHealingThreshold");
		return ptr;
	}

};


// Class TgGame.TgInvListener_ApplyHitSpecialOnKill
// 0x0000 (0x00C4 - 0x00C4)
class UTgInvListener_ApplyHitSpecialOnKill : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_ApplyHitSpecialOnKill");
		return ptr;
	}

};


// Class TgGame.TgInvListener_ApplyHitSpecialOnKillOrElimination
// 0x0000 (0x00C4 - 0x00C4)
class UTgInvListener_ApplyHitSpecialOnKillOrElimination : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_ApplyHitSpecialOnKillOrElimination");
		return ptr;
	}

};


// Class TgGame.TgInvListener_ConsecutiveHitsForDamageBonusByCredits
// 0x0010 (0x00D4 - 0x00C4)
class UTgInvListener_ConsecutiveHitsForDamageBonusByCredits : public UTgInvListener
{
public:
	TArray<struct FTrackedDamagedTargets>              m_Targets;                                                // 0x00C4(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_ConsecutiveHitsForDamageBonusByCredits");
		return ptr;
	}

};


// Class TgGame.TgInvListener_ConsecutiveInhandHits
// 0x0018 (0x00DC - 0x00C4)
class UTgInvListener_ConsecutiveInhandHits : public UTgInvListener
{
public:
	TArray<struct FCIHStack>                           s_Stacks;                                                 // 0x00C4(0x0010) (NeedCtorLink)
	class ATgPawn*                                     s_pLastTargetHit;                                         // 0x00D4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_ConsecutiveInhandHits");
		return ptr;
	}

};


// Class TgGame.TgInvListener_DeployOnElimination
// 0x0000 (0x00C4 - 0x00C4)
class UTgInvListener_DeployOnElimination : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_DeployOnElimination");
		return ptr;
	}

};


// Class TgGame.TgInvListener_DeployOnKill
// 0x0000 (0x00C4 - 0x00C4)
class UTgInvListener_DeployOnKill : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_DeployOnKill");
		return ptr;
	}

};


// Class TgGame.TgInvListener_HitSelfInsteadOfDeath
// 0x0000 (0x00C4 - 0x00C4)
class UTgInvListener_HitSelfInsteadOfDeath : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_HitSelfInsteadOfDeath");
		return ptr;
	}

};


// Class TgGame.TgInvListener_HitSelfOnHeadshot
// 0x0000 (0x00C4 - 0x00C4)
class UTgInvListener_HitSelfOnHeadshot : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_HitSelfOnHeadshot");
		return ptr;
	}

};


// Class TgGame.TgInvListener_ModifyDeployableHealth
// 0x0000 (0x00C4 - 0x00C4)
class UTgInvListener_ModifyDeployableHealth : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_ModifyDeployableHealth");
		return ptr;
	}

};


// Class TgGame.TgInvListener_OnDamageThreshold
// 0x0004 (0x00C8 - 0x00C4)
class UTgInvListener_OnDamageThreshold : public UTgInvListener
{
public:
	float                                              m_fAccumulatedDamage;                                     // 0x00C4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_OnDamageThreshold");
		return ptr;
	}

};


// Class TgGame.TgInvListener_OnShieldDeployableDestroyed
// 0x0000 (0x00C4 - 0x00C4)
class UTgInvListener_OnShieldDeployableDestroyed : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_OnShieldDeployableDestroyed");
		return ptr;
	}

};


// Class TgGame.TgInvListener_RedirectDamageToDeployables
// 0x0010 (0x00D4 - 0x00C4)
class UTgInvListener_RedirectDamageToDeployables : public UTgInvListener
{
public:
	TArray<class ATgDeployable*>                       m_ActiveDeployables;                                      // 0x00C4(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_RedirectDamageToDeployables");
		return ptr;
	}

};


// Class TgGame.TgInvListener_ShieldLifesteal
// 0x0000 (0x00C4 - 0x00C4)
class UTgInvListener_ShieldLifesteal : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_ShieldLifesteal");
		return ptr;
	}

};


// Class TgGame.TgInvListener_SpecialOnDamageEnemyPercent
// 0x0008 (0x00CC - 0x00C4)
class UTgInvListener_SpecialOnDamageEnemyPercent : public UTgInvListener
{
public:
	class ATgPawn*                                     m_CachedTgPawn;                                           // 0x00C4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_SpecialOnDamageEnemyPercent");
		return ptr;
	}

};


// Class TgGame.TgInvListener_TakingHitsForDamageBonusByCredits
// 0x0010 (0x00D4 - 0x00C4)
class UTgInvListener_TakingHitsForDamageBonusByCredits : public UTgInvListener
{
public:
	TArray<struct FTrackedBullies>                     m_Targets;                                                // 0x00C4(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_TakingHitsForDamageBonusByCredits");
		return ptr;
	}

};


// Class TgGame.TgPickupFactory
// 0x0030 (0x03D4 - 0x03A4)
class ATgPickupFactory : public APickupFactory
{
public:
	unsigned long                                      bRotatingPickup : 1;                                      // 0x03A4(0x0004)
	float                                              YawRotationRate;                                          // 0x03A8(0x0004)
	class AController*                                 TeamOwner[0x4];                                           // 0x03AC(0x0008)
	class UPrimitiveComponent*                         BaseMesh;                                                 // 0x03CC(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPickupFactory");
		return ptr;
	}


	bool STATIC_StopsProjectile(class AProjectile* P);
	void STATIC_RespawnEffect();
	void STATIC_UpdateHud(class ATgHUD* H);
	bool ShouldCamp(class ATgAIController* B, float MaxWait);
};


// Class TgGame.TgSeqAct_AIFreeze
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_AIFreeze : public USequenceAction
{
public:
	int                                                TaskForceNumber;                                          // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_AIFreeze");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_AIMoveToActor
// 0x0008 (0x0110 - 0x0108)
class UTgSeqAct_AIMoveToActor : public USequenceAction
{
public:
	class AActor*                                      Destination;                                              // 0x0108(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_AIMoveToActor");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_AITargetActor
// 0x0008 (0x0110 - 0x0108)
class UTgSeqAct_AITargetActor : public USequenceAction
{
public:
	class AActor*                                      CombatTarget;                                             // 0x0108(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_AITargetActor");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_BeginWaitForLookAt
// 0x0010 (0x0118 - 0x0108)
class UTgSeqAct_BeginWaitForLookAt : public USequenceAction
{
public:
	struct FVector                                     LocationToLookAt;                                         // 0x0108(0x000C) (Edit)
	float                                              MinOffsetDistance;                                        // 0x0114(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_BeginWaitForLookAt");
		return ptr;
	}


	void Activated();
};


// Class TgGame.TgSeqAct_ClientLoadDevices
// 0x0014 (0x011C - 0x0108)
class UTgSeqAct_ClientLoadDevices : public USequenceAction
{
public:
	TArray<int>                                        m_DeviceIdList;                                           // 0x0108(0x0010) (Edit, NeedCtorLink)
	unsigned long                                      m_bClearExistingLoads : 1;                                // 0x0118(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_ClientLoadDevices");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_CloseHUDMenus
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_CloseHUDMenus : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_CloseHUDMenus");
		return ptr;
	}


	void Activated();
};


// Class TgGame.TgSeqAct_DefenseWaveSpawner
// 0x000C (0x0114 - 0x0108)
class UTgSeqAct_DefenseWaveSpawner : public USequenceAction
{
public:
	int                                                m_nRoundNumber;                                           // 0x0108(0x0004)
	float                                              m_fSpawnFrequency;                                        // 0x010C(0x0004)
	float                                              m_fNextSpawnTime;                                         // 0x0110(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_DefenseWaveSpawner");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_EndMission
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_EndMission : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_EndMission");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_FillUltimateEnergy
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_FillUltimateEnergy : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_FillUltimateEnergy");
		return ptr;
	}


	void Activated();
};


// Class TgGame.TgSeqAct_ForceClientTutorialAction
// 0x0002 (0x010A - 0x0108)
class UTgSeqAct_ForceClientTutorialAction : public USequenceAction
{
public:
	TEnumAsByte<EeForcedClientTutorialAction>          ForcedAction;                                             // 0x0108(0x0001) (Edit)
	TEnumAsByte<EeTutorialForceableElements>           GameUIElement;                                            // 0x0109(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_ForceClientTutorialAction");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_GetLocalPlayerController
// 0x0008 (0x0110 - 0x0108)
class UTgSeqAct_GetLocalPlayerController : public USequenceAction
{
public:
	class ATgPlayerController*                         LocalPlayerController;                                    // 0x0108(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_GetLocalPlayerController");
		return ptr;
	}


	void Activated();
};


// Class TgGame.TgSeqAct_GetMaterialInst
// 0x001C (0x0124 - 0x0108)
class UTgSeqAct_GetMaterialInst : public USequenceAction
{
public:
	class UMaterialInstance*                           MatInst;                                                  // 0x0108(0x0008) (Edit)
	struct FString                                     MatInstName;                                              // 0x0110(0x0010) (Edit, NeedCtorLink)
	int                                                MaterialIndex;                                            // 0x0120(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_GetMaterialInst");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_GetPlayerCount
// 0x0018 (0x0120 - 0x0108)
class UTgSeqAct_GetPlayerCount : public USequenceAction
{
public:
	int                                                m_nTaskForce;                                             // 0x0108(0x0004) (Edit)
	float                                              m_fPlayerCount;                                           // 0x010C(0x0004)
	float                                              m_fAssaultCount;                                          // 0x0110(0x0004)
	float                                              m_fMedicCount;                                            // 0x0114(0x0004)
	float                                              m_fReconCount;                                            // 0x0118(0x0004)
	float                                              m_fRoboticsCount;                                         // 0x011C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_GetPlayerCount");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_GetTaskForceCount
// 0x000C (0x0114 - 0x0108)
class UTgSeqAct_GetTaskForceCount : public USequenceAction
{
public:
	int                                                Taskforce;                                                // 0x0108(0x0004) (Edit)
	int                                                m_nPlayerCount;                                           // 0x010C(0x0004)
	int                                                m_nBotCount;                                              // 0x0110(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_GetTaskForceCount");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_GiveCredits
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_GiveCredits : public USequenceAction
{
public:
	int                                                CreditsToGive;                                            // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_GiveCredits");
		return ptr;
	}


	void Activated();
};


// Class TgGame.TgSeqAct_GiveFullVitals
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_GiveFullVitals : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_GiveFullVitals");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_MapOutroFinished
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_MapOutroFinished : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_MapOutroFinished");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_NavIndicator
// 0x0008 (0x0110 - 0x0108)
class UTgSeqAct_NavIndicator : public USequenceAction
{
public:
	class AActor*                                      m_NavTarget;                                              // 0x0108(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_NavIndicator");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_PingMinimap
// 0x0008 (0x0110 - 0x0108)
class UTgSeqAct_PingMinimap : public USequenceAction
{
public:
	class AActor*                                      m_PingTarget;                                             // 0x0108(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_PingMinimap");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_PlayFullBodyAnim
// 0x0018 (0x0120 - 0x0108)
class UTgSeqAct_PlayFullBodyAnim : public USequenceAction
{
public:
	struct FName                                       c_AnimName;                                               // 0x0108(0x0008) (Edit)
	float                                              c_fRate;                                                  // 0x0110(0x0004) (Edit)
	float                                              c_fBlendInTime;                                           // 0x0114(0x0004) (Edit)
	float                                              c_fBlendOutTime;                                          // 0x0118(0x0004) (Edit)
	unsigned long                                      c_bLooping : 1;                                           // 0x011C(0x0004) (Edit)
	unsigned long                                      c_bOverride : 1;                                          // 0x011C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_PlayFullBodyAnim");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_ProgressTo
// 0x0008 (0x013C - 0x0134)
class UTgSeqAct_ProgressTo : public USeqAct_Delay
{
public:
	class ATgPawn*                                     m_Instigator;                                             // 0x0134(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_ProgressTo");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_PushMatinee
// 0x000C (0x0228 - 0x021C)
class UTgSeqAct_PushMatinee : public USeqAct_Interp
{
public:
	float                                              m_fCheckpoint1Time;                                       // 0x021C(0x0004) (Edit, Const)
	float                                              m_fCheckpoint2Time;                                       // 0x0220(0x0004) (Edit, Const)
	int                                                m_nDefenderTaskForce;                                     // 0x0224(0x0004) (Edit, Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_PushMatinee");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_RequestMission
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_RequestMission : public USequenceAction
{
public:
	int                                                m_nMapGameId;                                             // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_RequestMission");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_ResetCooldowns
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_ResetCooldowns : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_ResetCooldowns");
		return ptr;
	}


	void Activated();
};


// Class TgGame.TgSeqAct_RespawnAllPlayers
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_RespawnAllPlayers : public USequenceAction
{
public:
	unsigned long                                      bResetLivingPlayers : 1;                                  // 0x0108(0x0004) (Edit)
	unsigned long                                      bResetDeadPlayers : 1;                                    // 0x0108(0x0004) (Edit)
	unsigned long                                      bResetHealth : 1;                                         // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_RespawnAllPlayers");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_SendPlayerTrackingEvent
// 0x001C (0x0124 - 0x0108)
class UTgSeqAct_SendPlayerTrackingEvent : public USequenceAction
{
public:
	int                                                m_nEventId;                                               // 0x0108(0x0004) (Edit)
	int                                                m_nSubEventID;                                            // 0x010C(0x0004) (Edit)
	struct FString                                     m_ReferenceName;                                          // 0x0110(0x0010) (Edit, NeedCtorLink)
	int                                                m_nReferenceValue;                                        // 0x0120(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_SendPlayerTrackingEvent");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_SetCreditGainBlock
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_SetCreditGainBlock : public USequenceAction
{
public:
	int                                                m_bBlockCreditGain;                                       // 0x0108(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_SetCreditGainBlock");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_SetEnergyGainBlock
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_SetEnergyGainBlock : public USequenceAction
{
public:
	int                                                m_bBlockEnergyGain;                                       // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_SetEnergyGainBlock");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_SetHexState
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_SetHexState : public USequenceAction
{
public:
	unsigned long                                      m_bChallengerWon : 1;                                     // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_SetHexState");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_SetInputEnabled
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_SetInputEnabled : public USequenceAction
{
public:
	unsigned long                                      bEnableMoveForward : 1;                                   // 0x0108(0x0004) (Edit)
	unsigned long                                      bEnableMoveBackward : 1;                                  // 0x0108(0x0004) (Edit)
	unsigned long                                      bEnableMoveLeft : 1;                                      // 0x0108(0x0004) (Edit)
	unsigned long                                      bEnableMoveRight : 1;                                     // 0x0108(0x0004) (Edit)
	unsigned long                                      bEnableLookUp : 1;                                        // 0x0108(0x0004) (Edit)
	unsigned long                                      bEnableLookDown : 1;                                      // 0x0108(0x0004) (Edit)
	unsigned long                                      bEnableLookLeft : 1;                                      // 0x0108(0x0004) (Edit)
	unsigned long                                      bEnableLookRight : 1;                                     // 0x0108(0x0004) (Edit)
	unsigned long                                      bEnableJumping : 1;                                       // 0x0108(0x0004) (Edit)
	unsigned long                                      bEnableMounting : 1;                                      // 0x0108(0x0004) (Edit)
	unsigned long                                      bEnableAuto : 1;                                          // 0x0108(0x0004) (Edit)
	unsigned long                                      bEnableAlt : 1;                                           // 0x0108(0x0004) (Edit)
	unsigned long                                      bEnableBattleAbility : 1;                                 // 0x0108(0x0004) (Edit)
	unsigned long                                      bEnableMovementAbility : 1;                               // 0x0108(0x0004) (Edit)
	unsigned long                                      bEnableUltimate : 1;                                      // 0x0108(0x0004) (Edit)
	unsigned long                                      bEnableEmote : 1;                                         // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_SetInputEnabled");
		return ptr;
	}


	void Activated();
};


// Class TgGame.TgSeqAct_SetMapLane
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_SetMapLane : public USequenceAction
{
public:
	int                                                m_nMapLane;                                               // 0x0108(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_SetMapLane");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_SetMissionTime
// 0x000C (0x0114 - 0x0108)
class UTgSeqAct_SetMissionTime : public USequenceAction
{
public:
	float                                              m_fMissionTimeSecs;                                       // 0x0108(0x0004) (Edit)
	float                                              m_fIncrementSecs;                                         // 0x010C(0x0004) (Edit)
	float                                              m_fMissionTimeRemaining;                                  // 0x0110(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_SetMissionTime");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_SetPlayerLevel
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_SetPlayerLevel : public USequenceAction
{
public:
	int                                                m_nLevel;                                                 // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_SetPlayerLevel");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_SetPlayerMesh
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_SetPlayerMesh : public USequenceAction
{
public:
	int                                                m_nMeshAsmId;                                             // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_SetPlayerMesh");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_SetPlayerMeshVisible
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_SetPlayerMeshVisible : public USequenceAction
{
public:
	unsigned long                                      bIs1PMeshVisible : 1;                                     // 0x0108(0x0004) (Edit)
	unsigned long                                      bIs3PMeshVisible : 1;                                     // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_SetPlayerMeshVisible");
		return ptr;
	}


	void Activated();
};


// Class TgGame.TgSeqAct_SetUIClock
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_SetUIClock : public USequenceAction
{
public:
	unsigned long                                      ShowAlarmTexture : 1;                                     // 0x0108(0x0004) (Edit)
	unsigned long                                      UseProgressBar : 1;                                       // 0x0108(0x0004) (Edit)
	unsigned long                                      IsCountingDown : 1;                                       // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_SetUIClock");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_SetUITextBox
// 0x0009 (0x0111 - 0x0108)
class UTgSeqAct_SetUITextBox : public USequenceAction
{
public:
	int                                                TextBox_MessageID;                                        // 0x0108(0x0004) (Edit)
	unsigned long                                      TextBox_TargetSecondary : 1;                              // 0x010C(0x0004) (Edit)
	unsigned long                                      TextBox_UseDuration : 1;                                  // 0x010C(0x0004) (Edit)
	unsigned long                                      TextBox_AllowEscape : 1;                                  // 0x010C(0x0004) (Edit)
	TEnumAsByte<EAlertType>                            TextBox_MessageType;                                      // 0x0110(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_SetUITextBox");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_SpawnProjectile
// 0x0010 (0x0118 - 0x0108)
class UTgSeqAct_SpawnProjectile : public USequenceAction
{
public:
	int                                                m_nFireModeID;                                            // 0x0108(0x0004) (Edit)
	class UTgDeviceFire*                               m_FireMode;                                               // 0x010C(0x0008)
	unsigned long                                      m_bSetupFireMode : 1;                                     // 0x0114(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_SpawnProjectile");
		return ptr;
	}


	void Activated();
	void SetupFireMode();
};


// Class TgGame.TgSeqAct_TemporaryAddDevice
// 0x0008 (0x0110 - 0x0108)
class UTgSeqAct_TemporaryAddDevice : public USequenceAction
{
public:
	int                                                m_nDeviceId;                                              // 0x0108(0x0004) (Edit)
	int                                                m_nEquipPoint;                                            // 0x010C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_TemporaryAddDevice");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_TemporaryRemoveDevice
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_TemporaryRemoveDevice : public USequenceAction
{
public:
	int                                                m_nEquipPoint;                                            // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_TemporaryRemoveDevice");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_ToggleStaticMeshSilhouette
// 0x000C (0x0114 - 0x0108)
class UTgSeqAct_ToggleStaticMeshSilhouette : public USequenceAction
{
public:
	class AStaticMeshActor*                            SMA;                                                      // 0x0108(0x0008) (Edit)
	unsigned long                                      bIsEnabled : 1;                                           // 0x0110(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_ToggleStaticMeshSilhouette");
		return ptr;
	}


	void Activated();
};


// Class TgGame.TgSeqAct_TrainingAwards
// 0x0010 (0x0118 - 0x0108)
class UTgSeqAct_TrainingAwards : public USequenceAction
{
public:
	float                                              m_fGoldTime;                                              // 0x0108(0x0004) (Edit)
	float                                              m_fSilverTime;                                            // 0x010C(0x0004) (Edit)
	float                                              m_fBronzeTime;                                            // 0x0110(0x0004) (Edit)
	float                                              m_fPassTime;                                              // 0x0114(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_TrainingAwards");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_TriggerBots
// 0x0014 (0x011C - 0x0108)
class UTgSeqAct_TriggerBots : public USequenceAction
{
public:
	unsigned long                                      bUseDestination : 1;                                      // 0x0108(0x0004) (Edit)
	class AActor*                                      TargetActor;                                              // 0x010C(0x0008) (Edit)
	class AActor*                                      destActor;                                                // 0x0114(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_TriggerBots");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_TutorialHighlighter
// 0x0001 (0x0109 - 0x0108)
class UTgSeqAct_TutorialHighlighter : public USequenceAction
{
public:
	TEnumAsByte<EeTutorialHighlighterElement>          GameUIElement;                                            // 0x0108(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_TutorialHighlighter");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_TutorialInstruction
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_TutorialInstruction : public USequenceAction
{
public:
	int                                                nMsgId;                                                   // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_TutorialInstruction");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_TutorialTips
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_TutorialTips : public USequenceAction
{
public:
	int                                                nMsgId;                                                   // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_TutorialTips");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_UIAlert
// 0x0024 (0x012C - 0x0108)
class UTgSeqAct_UIAlert : public USequenceAction
{
public:
	int                                                nMsgId;                                                   // 0x0108(0x0004) (Edit)
	TArray<int>                                        Taskforces;                                               // 0x010C(0x0010) (NeedCtorLink)
	TArray<unsigned long>                              Broadcast;                                                // 0x011C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_UIAlert");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_UIElementVisibility
// 0x0024 (0x012C - 0x0108)
class UTgSeqAct_UIElementVisibility : public USequenceAction
{
public:
	unsigned long                                      ShowElement : 1;                                          // 0x0108(0x0004) (Edit)
	struct FString                                     UISceneName;                                              // 0x010C(0x0010) (Edit, NeedCtorLink)
	struct FString                                     UIElementName;                                            // 0x011C(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_UIElementVisibility");
		return ptr;
	}

};


// Class TgGame.TgSeqCond_And
// 0x0000 (0x00EC - 0x00EC)
class UTgSeqCond_And : public USequenceCondition
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqCond_And");
		return ptr;
	}

};


// Class TgGame.TgSeqCond_CompareDamageType
// 0x0000 (0x00EC - 0x00EC)
class UTgSeqCond_CompareDamageType : public USequenceCondition
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqCond_CompareDamageType");
		return ptr;
	}

};


// Class TgGame.TgSeqCond_CompareDeviceId
// 0x000C (0x00F8 - 0x00EC)
class UTgSeqCond_CompareDeviceId : public USequenceCondition
{
public:
	class UObject*                                     Device;                                                   // 0x00EC(0x0008) (Edit)
	int                                                DeviceID;                                                 // 0x00F4(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqCond_CompareDeviceId");
		return ptr;
	}

};


// Class TgGame.TgSeqCond_HasCondition
// 0x0001 (0x00ED - 0x00EC)
class UTgSeqCond_HasCondition : public USequenceCondition
{
public:
	TEnumAsByte<EConditionType>                        ConditionList;                                            // 0x00EC(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqCond_HasCondition");
		return ptr;
	}

};


// Class TgGame.TgSeqCond_IsHuman
// 0x0000 (0x00EC - 0x00EC)
class UTgSeqCond_IsHuman : public USequenceCondition
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqCond_IsHuman");
		return ptr;
	}

};


// Class TgGame.TgSeqCond_IsSecuring
// 0x0000 (0x00EC - 0x00EC)
class UTgSeqCond_IsSecuring : public USequenceCondition
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqCond_IsSecuring");
		return ptr;
	}

};


// Class TgGame.TgSeqCond_IsSpectating
// 0x0000 (0x00EC - 0x00EC)
class UTgSeqCond_IsSpectating : public USequenceCondition
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqCond_IsSpectating");
		return ptr;
	}

};


// Class TgGame.TgSeqCond_Or
// 0x0000 (0x00EC - 0x00EC)
class UTgSeqCond_Or : public USequenceCondition
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqCond_Or");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_ClientGameOver
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_ClientGameOver : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_ClientGameOver");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_DeployableFired
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_DeployableFired : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_DeployableFired");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_EnergyUpdated
// 0x0004 (0x012C - 0x0128)
class UTgSeqEvent_EnergyUpdated : public USequenceEvent
{
public:
	int                                                ResultEnergy;                                             // 0x0128(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_EnergyUpdated");
		return ptr;
	}


	int GetIndex(float CurrentEnergy, float PreviousEnergy);
};


// Class TgGame.TgSeqEvent_Escort_Despawn_Success
// 0x0004 (0x012C - 0x0128)
class UTgSeqEvent_Escort_Despawn_Success : public USequenceEvent
{
public:
	int                                                DefendersTaskForce;                                       // 0x0128(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_Escort_Despawn_Success");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_FiringDevice
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_FiringDevice : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_FiringDevice");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_LevelFadedIn
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_LevelFadedIn : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_LevelFadedIn");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_MissionTimer
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_MissionTimer : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_MissionTimer");
		return ptr;
	}


	void STATIC_UpdateChallengerWonValue(bool bValue);
};


// Class TgGame.TgSeqEvent_MissionTimeRemaining
// 0x0004 (0x012C - 0x0128)
class UTgSeqEvent_MissionTimeRemaining : public USequenceEvent
{
public:
	float                                              SecsRemaining;                                            // 0x0128(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_MissionTimeRemaining");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_Named
// 0x0001 (0x0129 - 0x0128)
class UTgSeqEvent_Named : public USequenceEvent
{
public:
	TEnumAsByte<ETSE_NAME>                             NamedEvent;                                               // 0x0128(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_Named");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_PayloadMissionEvents
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_PayloadMissionEvents : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_PayloadMissionEvents");
		return ptr;
	}


	void STATIC_UpdateTaskForceWonValue(unsigned char iValue);
	void STATIC_UpdateTaskForceAttackValue(unsigned char iValue);
};


// Class TgGame.TgSeqEvent_PlayerMoved
// 0x0004 (0x012C - 0x0128)
class UTgSeqEvent_PlayerMoved : public USequenceEvent
{
public:
	int                                                ResultEnergy;                                             // 0x0128(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_PlayerMoved");
		return ptr;
	}


	int GetIndex(TEnumAsByte<EPlayerCardinalDirection> MovementDirection);
};


// Class TgGame.TgSeqEvent_SpawnLanePusher
// 0x0004 (0x012C - 0x0128)
class UTgSeqEvent_SpawnLanePusher : public USequenceEvent
{
public:
	int                                                Taskforce;                                                // 0x0128(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_SpawnLanePusher");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_SpawnWise
// 0x0004 (0x012C - 0x0128)
class UTgSeqEvent_SpawnWise : public USequenceEvent
{
public:
	int                                                Taskforce;                                                // 0x0128(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_SpawnWise");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_TakeDamage
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_TakeDamage : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_TakeDamage");
		return ptr;
	}


	void HandleDamage(class AActor* InOriginator, class AActor* InInstigator, int inAmount, class UClass* inDamageType, class ATgDevice* InDevice);
};


// Class TgGame.TgSeqEvent_TaskForceInactive
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_TaskForceInactive : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_TaskForceInactive");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_TeamInactive
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_TeamInactive : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_TeamInactive");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_TicketCountUpdated
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_TicketCountUpdated : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_TicketCountUpdated");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_UI_Event
// 0x0008 (0x0130 - 0x0128)
class UTgSeqEvent_UI_Event : public USequenceEvent
{
public:
	int                                                mDeckNum;                                                 // 0x0128(0x0004)
	int                                                mEmptyItemSlots;                                          // 0x012C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_UI_Event");
		return ptr;
	}


	void ItemUpgraded(class AActor* InOriginator, class AActor* InInstigator);
	void ItemPurchased(class AActor* InOriginator, class AActor* InInstigator, int EmptySlots);
	void ItemMenuOpened(class AActor* InOriginator, class AActor* InInstigator);
	void DeckSelected(class AActor* InOriginator, class AActor* InInstigator, int Deck);
	void DeckChanged(class AActor* InOriginator, class AActor* InInstigator, int Deck);
	void DeckMenuOpened(class AActor* InOriginator, class AActor* InInstigator);
	void ItemUIInitialized(class AActor* InOriginator, class AActor* InInstigator);
	void DeckUIInitialized(class AActor* InOriginator, class AActor* InInstigator);
};


// Class TgGame.TgSeqEvent_UpdateLanePusherCount
// 0x0004 (0x012C - 0x0128)
class UTgSeqEvent_UpdateLanePusherCount : public USequenceEvent
{
public:
	int                                                Taskforce;                                                // 0x0128(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_UpdateLanePusherCount");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_Used
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_Used : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_Used");
		return ptr;
	}

};


// Class TgGame.TgSeqOp_MathCalc
// 0x0004 (0x00F0 - 0x00EC)
class UTgSeqOp_MathCalc : public USequenceCondition
{
public:
	float                                              m_fResult;                                                // 0x00EC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqOp_MathCalc");
		return ptr;
	}

};


// Class TgGame.TgSeqVar_DamageType
// 0x0008 (0x00A8 - 0x00A0)
class UTgSeqVar_DamageType : public USequenceVariable
{
public:
	class UClass*                                      DamageTypeValue;                                          // 0x00A0(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqVar_DamageType");
		return ptr;
	}

};


// Class TgGame.TgSeqVar_Player
// 0x0038 (0x0114 - 0x00DC)
class UTgSeqVar_Player : public USeqVar_Player
{
public:
	TArray<class UObject*>                             HumanPlayers;                                             // 0x00DC(0x0010) (Transient, NeedCtorLink)
	TArray<class UObject*>                             BotPlayers;                                               // 0x00EC(0x0010) (Transient, NeedCtorLink)
	TArray<class UObject*>                             PetPlayers;                                               // 0x00FC(0x0010) (Transient, NeedCtorLink)
	unsigned long                                      bAllBots : 1;                                             // 0x010C(0x0004) (Edit)
	unsigned long                                      bAllHumans : 1;                                           // 0x010C(0x0004) (Edit)
	unsigned long                                      bAllHumansAndPets : 1;                                    // 0x010C(0x0004) (Edit)
	int                                                nTaskForceNumber;                                         // 0x0110(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqVar_Player");
		return ptr;
	}

};


// Class TgGame.TgSeqVar_RouteNumber
// 0x0000 (0x00A4 - 0x00A4)
class UTgSeqVar_RouteNumber : public USeqVar_Int
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqVar_RouteNumber");
		return ptr;
	}

};


// Class TgGame.TgTrigger_AIControlledCharacters
// 0x0000 (0x0290 - 0x0290)
class ATgTrigger_AIControlledCharacters : public ATrigger
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgTrigger_AIControlledCharacters");
		return ptr;
	}

};


// Class TgGame.TgTrigger_Instance
// 0x0018 (0x02A8 - 0x0290)
class ATgTrigger_Instance : public ATrigger
{
public:
	int                                                m_nMapId;                                                 // 0x0290(0x0004) (Edit, EditInline)
	unsigned long                                      m_nPreload : 1;                                           // 0x0294(0x0004) (Edit, EditInline)
	unsigned long                                      m_nTaskForce : 1;                                         // 0x0294(0x0004) (Edit, EditInline)
	struct FString                                     m_SpawnPointName;                                         // 0x0298(0x0010) (Edit, NeedCtorLink, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgTrigger_Instance");
		return ptr;
	}


	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_HandleTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgTrigger_PlayerControlledCharacters
// 0x0000 (0x0290 - 0x0290)
class ATgTrigger_PlayerControlledCharacters : public ATrigger
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgTrigger_PlayerControlledCharacters");
		return ptr;
	}

};


// Class TgGame.TgTrigger_Use
// 0x0030 (0x02C0 - 0x0290)
class ATgTrigger_Use : public ATrigger
{
public:
	struct FString                                     m_sDisplayText;                                           // 0x0290(0x0010) (Edit, NeedCtorLink, EditInline)
	struct FString                                     m_sInactiveText;                                          // 0x02A0(0x0010) (Edit, NeedCtorLink, EditInline)
	int                                                m_nInteractDistance;                                      // 0x02B0(0x0004) (Edit, EditInline)
	unsigned long                                      m_bAimToInteract : 1;                                     // 0x02B4(0x0004) (Edit, EditInline)
	int                                                m_nDisplayMsgId;                                          // 0x02B8(0x0004) (Edit, EditInline)
	int                                                m_nInactiveMsgId;                                         // 0x02BC(0x0004) (Edit, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgTrigger_Use");
		return ptr;
	}


	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	int STATIC_GetMsgIdToDisplay();
	bool STATIC_IsUsedEnabled();
	void STATIC_UsedByPawn(class ATgPawn* User);
};


// Class TgGame.Interface_AIAnnotation
// 0x0000 (0x0060 - 0x0060)
class UInterface_AIAnnotation : public UInterface
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.Interface_AIAnnotation");
		return ptr;
	}


	void STATIC_GetAdjustedPosition(class APawn* AnnotationOwner, class AActor* Target, struct FVector* out_Position);
};


// Class TgGame.TgAudioOcclusionActor
// 0x0028 (0x02A8 - 0x0280)
class ATgAudioOcclusionActor : public AActor
{
public:
	struct FPointer                                    VfTable_IInterface_NavigationHandle;                      // 0x0280(0x0008) (Const, Native, NoExport)
	class UClass*                                      m_NavigationHandleClass;                                  // 0x0288(0x0008)
	class UNavigationHandle*                           m_NavigationHandle;                                       // 0x0290(0x0008)
	struct FVector                                     NavMeshPath_SearchExtent_Modifier;                        // 0x0298(0x000C)
	float                                              m_fCurrentMaxPathLength;                                  // 0x02A4(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAudioOcclusionActor");
		return ptr;
	}


	void NotifyPathChanged();
	float CalcOcclusionAmount(class AActor* SourceActor);
	void PostBeginPlay();
};


// Class TgGame.TgLanePylon
// 0x0004 (0x0494 - 0x0490)
class ATgLanePylon : public APylon
{
public:
	int                                                m_nLane;                                                  // 0x0490(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgLanePylon");
		return ptr;
	}

};


// Class TgGame.TgTeamBlocker
// 0x0004 (0x029C - 0x0298)
class ATgTeamBlocker : public ATgMeshAssembly
{
public:
	unsigned long                                      m_bBlockFlagCarrier : 1;                                  // 0x0298(0x0004) (Edit)
	unsigned long                                      m_bBlockFriendlyFire : 1;                                 // 0x0298(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgTeamBlocker");
		return ptr;
	}

};


// Class TgGame.TgDoorMarker
// 0x0020 (0x02BC - 0x029C)
class ATgDoorMarker : public ATgTeamBlocker
{
public:
	TEnumAsByte<EDoorStatus>                           r_eStatus;                                                // 0x029C(0x0001) (Net)
	TEnumAsByte<EDoorStatus>                           m_eInitStatus;                                            // 0x029D(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x2];                                       // 0x029E(0x0002) MISSED OFFSET
	class ATgCollisionProxy*                           s_CollisionProxy;                                         // 0x02A0(0x0008)
	float                                              m_fProximity;                                             // 0x02A8(0x0004) (Edit)
	int                                                m_nTeamThatControlsDoor;                                  // 0x02AC(0x0004) (Edit)
	int                                                m_nMeshAssemblyId;                                        // 0x02B0(0x0004) (Edit)
	class USkeletalMeshComponent*                      m_DoorSMC;                                                // 0x02B4(0x0008) (Edit, ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDoorMarker");
		return ptr;
	}


	void SetDoorStatus(TEnumAsByte<EDoorStatus> eStatus);
	void CalculateDoorStatus();
	bool ShouldDoorBeClosed();
	bool ShouldDoorBeOpened();
	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void ClientOnStatusChange();
	void PostBeginPlay();
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_LoadMesh();
};


// Class TgGame.TgNavigationPoint
// 0x0004 (0x037C - 0x0378)
class ATgNavigationPoint : public ANavigationPoint
{
public:
	int                                                m_nMapObjectId;                                           // 0x0378(0x0004) (Edit, EditConst)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgNavigationPoint");
		return ptr;
	}

};


// Class TgGame.TgActionPoint
// 0x0008 (0x0384 - 0x037C)
class ATgActionPoint : public ATgNavigationPoint
{
public:
	TEnumAsByte<EeActionPointType>                     ActionType;                                               // 0x037C(0x0001) (Edit)
	unsigned char                                      nObjectiveNum;                                            // 0x037D(0x0001) (Edit)
	unsigned char                                      nTaskForce;                                               // 0x037E(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x1];                                       // 0x037F(0x0001) MISSED OFFSET
	unsigned long                                      bUseRotation : 1;                                         // 0x0380(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgActionPoint");
		return ptr;
	}

};


// Class TgGame.TgAIAnnotation
// 0x0014 (0x0390 - 0x037C)
class ATgAIAnnotation : public ATgNavigationPoint
{
public:
	struct FPointer                                    VfTable_IInterface_AIAnnotation;                          // 0x037C(0x0008) (Const, Native, NoExport)
	TEnumAsByte<EAIAnnotationType>                     AnnotationType;                                           // 0x0384(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0385(0x0003) MISSED OFFSET
	class APawn*                                       m_pClaimedBy;                                             // 0x0388(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIAnnotation");
		return ptr;
	}


	void PostBeginPlay();
	void STATIC_GetAdjustedPosition(class APawn* AnnotationOwner, class AActor* Target, struct FVector* out_Position);
	void Initialize();
	void Claim(class APawn* pClaimedBy);
	class APawn* STATIC_GetClaimedBy();
};


// Class TgGame.TgAssaultPoint
// 0x0002 (0x0392 - 0x0390)
class ATgAssaultPoint : public ATgAIAnnotation
{
public:
	TEnumAsByte<EAssaultType>                          AssaultPointType;                                         // 0x0390(0x0001) (Edit)
	TEnumAsByte<ELocationType>                         LocationType;                                             // 0x0391(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAssaultPoint");
		return ptr;
	}

};


// Class TgGame.TgCoverPoint
// 0x0028 (0x03B8 - 0x0390)
class ATgCoverPoint : public ATgAIAnnotation
{
public:
	unsigned long                                      m_bLeanLeft : 1;                                          // 0x0390(0x0004) (Edit)
	unsigned long                                      m_bLeanRight : 1;                                         // 0x0390(0x0004) (Edit)
	unsigned long                                      m_bAllowPopup : 1;                                        // 0x0390(0x0004) (Edit)
	unsigned long                                      m_bAllowMantle : 1;                                       // 0x0390(0x0004) (Edit)
	struct FVector                                     m_vLeanLeft;                                              // 0x0394(0x000C)
	struct FVector                                     m_vLeanRight;                                             // 0x03A0(0x000C)
	struct FVector                                     m_vPopUp;                                                 // 0x03AC(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCoverPoint");
		return ptr;
	}


	void PostBeginPlay();
	void STATIC_GetAdjustedPosition(class APawn* AnnotationOwner, class AActor* Target, struct FVector* out_Position);
};


// Class TgGame.TgNavigationPointSpawnable
// 0x0000 (0x037C - 0x037C)
class ATgNavigationPointSpawnable : public ATgNavigationPoint
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgNavigationPointSpawnable");
		return ptr;
	}

};


// Class TgGame.TgPointOfInterest
// 0x0014 (0x0390 - 0x037C)
class ATgPointOfInterest : public ATgNavigationPoint
{
public:
	int                                                m_nNameMsgId;                                             // 0x037C(0x0004) (Edit)
	struct FString                                     m_sDebugName;                                             // 0x0380(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPointOfInterest");
		return ptr;
	}

};


// Class TgGame.TgNavMeshPath_AlongLane
// 0x0004 (0x007C - 0x0078)
class UTgNavMeshPath_AlongLane : public UNavMeshPathConstraint
{
public:
	int                                                m_nLane;                                                  // 0x0078(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgNavMeshPath_AlongLane");
		return ptr;
	}


	void Recycle();
	bool AlongLane(class UNavigationHandle* NavHandle, int nLane);
};


// Class TgGame.TgPathfinder
// 0x0098 (0x0318 - 0x0280)
class ATgPathfinder : public AActor
{
public:
	struct FPointer                                    VfTable_IInterface_NavigationHandle;                      // 0x0280(0x0008) (Const, Native, NoExport)
	float                                              m_fMaxSpeed;                                              // 0x0288(0x0004) (Edit)
	TArray<struct FVector>                             m_vWaypoints;                                             // 0x028C(0x0010) (AlwaysInit, NeedCtorLink)
	float                                              m_fPathCheckRadius;                                       // 0x029C(0x0004)
	class UHavokNavigationHandle*                      m_NavigationHandle;                                       // 0x02A0(0x0008)
	class ASplineActor*                                m_Spline;                                                 // 0x02A8(0x0008)
	class ASplineActor*                                m_CurrentSpline;                                          // 0x02B0(0x0008)
	float                                              m_fCurrentSplineDist;                                     // 0x02B8(0x0004)
	struct FNavMeshPathParams                          m_NavMeshPathParams;                                      // 0x02BC(0x0038) (Edit, EditInline)
	TArray<class ATgPathfinderWalker*>                 m_ActiveWalkers;                                          // 0x02F4(0x0010) (NeedCtorLink)
	float                                              m_WalkerLifeSpan;                                         // 0x0304(0x0004)
	struct FScriptDelegate                             __OnFinishedPathing__Delegate;                            // 0x0308(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData00[0x4];                                       // 0x0308(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPathfinder");
		return ptr;
	}


	void OnPathfinderWalkerFinishedPathing(class ATgPathfinderWalker* Walker);
	void SpawnWalker();
	void StopWalkerStream();
	void StartWalkerStream(float StreamTime, float WalkerPulseTime, float WalkerLifetime, float WalkerSpeed);
	void Destroyed();
	void SetupPathProperties(float PathCheckRadius, float PathSpeed);
	void NotifyPathChanged();
	bool SetRouteTo(class AActor* destActor, bool bDrawDebugPath);
	void OnFinishedPathing(class ATgPathfinder* Pathfinder);
};


// Class TgGame.TgPathfinderWalker
// 0x0024 (0x02A4 - 0x0280)
class ATgPathfinderWalker : public AActor
{
public:
	class ATgPathfinder*                               m_Pathfinder;                                             // 0x0280(0x0008)
	class ASplineActor*                                m_CurrentSpline;                                          // 0x0288(0x0008)
	float                                              m_fCurrentSplineDist;                                     // 0x0290(0x0004)
	struct FScriptDelegate                             __OnFinishedPathing__Delegate;                            // 0x0294(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData00[0x4];                                       // 0x0294(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPathfinderWalker");
		return ptr;
	}


	void Destroyed();
	void SetPathfinder(class ATgPathfinder* Pathfinder);
	void OnFinishedPathing(class ATgPathfinderWalker* PathfinderWalker);
};


// Class TgGame.TgPathPreviewActor
// 0x0058 (0x02D8 - 0x0280)
class ATgPathPreviewActor : public AActor
{
public:
	struct FPointer                                    VfTable_IInterface_NavigationHandle;                      // 0x0280(0x0008) (Const, Native, NoExport)
	class ATgPathPreviewActor*                         m_Destination;                                            // 0x0288(0x0008) (Edit)
	class ATgPathPreviewActor*                         m_Source;                                                 // 0x0290(0x0008)
	class UHavokNavigationHandle*                      m_NavigationHandle;                                       // 0x0298(0x0008)
	struct FNavMeshPathParams                          m_NavMeshPathParams;                                      // 0x02A0(0x0038) (Edit, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPathPreviewActor");
		return ptr;
	}


	void NotifyPathChanged();
};


// Class TgGame.TgPathPreviewRenderingComponent
// 0x0000 (0x024C - 0x024C)
class UTgPathPreviewRenderingComponent : public UPrimitiveComponent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPathPreviewRenderingComponent");
		return ptr;
	}

};


// Class TgGame.TgSkeletalMeshActor
// 0x0044 (0x032C - 0x02E8)
class ATgSkeletalMeshActor : public ASkeletalMeshActor
{
public:
	struct FMeshAssets                                 c_MeshAssets;                                             // 0x02E8(0x0040) (NeedCtorLink)
	unsigned long                                      c_bLoadMeshAssetts : 1;                                   // 0x0328(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkeletalMeshActor");
		return ptr;
	}


	void DoKismetAttachment(class AActor* Attachment, class USeqAct_AttachToActor* Action);
	void OnParentAnimComponent(class UTgSeqAct_ParentAnimComponent* Action);
	void STATIC_LoadClientOnlyMeshAssets();
	class UMeshComponent* CreateMeshComponent(int MeshAsmId, class UMeshComponent* DestComponent, bool bPartialFixup);
	class UTgStaticMeshComponent* CreateStaticMeshComponent(int MeshAsmId, class UTgStaticMeshComponent* DestComponent);
	class UTgSkeletalMeshComponent* CreateSkeletalMeshComponent(int MeshAsmId, class UTgSkeletalMeshComponent* DestComponent, bool bPartialFixup);
	bool AttachToSocket(class AActor* Attachment, const struct FName& BoneName);
};


// Class TgGame.TgSkeletalMeshActorSpawnable
// 0x0000 (0x032C - 0x032C)
class ATgSkeletalMeshActorSpawnable : public ATgSkeletalMeshActor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkeletalMeshActorSpawnable");
		return ptr;
	}

};


// Class TgGame.TgNavRouteIndicator
// 0x004C (0x0378 - 0x032C)
class ATgNavRouteIndicator : public ATgSkeletalMeshActorSpawnable
{
public:
	struct FPointer                                    VfTable_IInterface_NavigationHandle;                      // 0x032C(0x0008) (Const, Native, NoExport)
	TArray<struct FVector>                             WayPoints;                                                // 0x0334(0x0010) (AlwaysInit, NeedCtorLink)
	int                                                Position;                                                 // 0x0344(0x0004)
	float                                              m_fPositionStartTime;                                     // 0x0348(0x0004)
	float                                              m_fPositionMaxSeekTime;                                   // 0x034C(0x0004)
	float                                              m_fSpinUpTime;                                            // 0x0350(0x0004)
	float                                              m_fSpinDownTime;                                          // 0x0354(0x0004)
	class UTgSpecialFx*                                m_SpinUpFx;                                               // 0x0358(0x0008)
	class UTgSpecialFx*                                m_PathingFx;                                              // 0x0360(0x0008)
	class UTgSpecialFx*                                m_SpinDownFx;                                             // 0x0368(0x0008)
	class UNavigationHandle*                           NavigationHandle;                                         // 0x0370(0x0008) (EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgNavRouteIndicator");
		return ptr;
	}


	void NotifyPathChanged();
	float STATIC_GetMaxSpeed();
	void StartNextPath();
	void StartSeeking();
	void FindNavHandlePath(class AActor* destActor, float Dist);
	TEnumAsByte<EeSetRouteResult> SetRouteTo(class AActor* destActor);
	void Destroyed();
	void PostBeginPlay();
	void STATIC_UpdateRotation(float fDeltaSeconds);
	bool AdvanceWayPoint();
	struct FVector STATIC_GetCurrentWayPoint();
	TEnumAsByte<EeSetRouteResult> SetRoute(class AActor* destActor);
	void DeactivatePathingFx();
	void DeactivateFx();
	void ActivatePathingFx();
	void ActivateSpinDownFx();
	void ActivateSpinUpFx();
};


// Class TgGame.TgSpawnTeleporterExit
// 0x0014 (0x0294 - 0x0280)
class ATgSpawnTeleporterExit : public AActor
{
public:
	int                                                nTaskForce;                                               // 0x0280(0x0004) (Edit)
	int                                                nLane;                                                    // 0x0284(0x0004) (Edit)
	int                                                nGamePhase;                                               // 0x0288(0x0004) (Edit)
	int                                                nPriority;                                                // 0x028C(0x0004) (Edit)
	unsigned long                                      bEnabled : 1;                                             // 0x0290(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSpawnTeleporterExit");
		return ptr;
	}


	bool PawnCanUse(class ATgPawn* TgP);
	void STATIC_OnToggle(class USeqAct_Toggle* Action);
	struct FVector GetTargetLocation(class AActor* RequestedBy, bool bRequestAlternateLoc);
	bool STATIC_HasRoomForPawn(class ATgPawn* TgP);
};


// Class TgGame.TgSplineActor
// 0x0008 (0x02F0 - 0x02E8)
class ATgSplineActor : public ASplineActor
{
public:
	TEnumAsByte<ELanePusherActionPoint>                m_ActionPoint;                                            // 0x02E8(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x02E9(0x0003) MISSED OFFSET
	unsigned long                                      m_bPreview : 1;                                           // 0x02EC(0x0004) (Edit, Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSplineActor");
		return ptr;
	}


	void OnSplineActorReached(class ATgPawn_LanePusherBase* Other);
	float STATIC_DistanceToActionPoint(TEnumAsByte<ELanePusherActionPoint> ActionPoint);
	float STATIC_DistanceToEndOfSplineChain();
	void STATIC_UpdateSplineComponents();
};


// Class TgGame.TgStartPoint
// 0x0034 (0x03BC - 0x0388)
class ATgStartPoint : public APlayerStart
{
public:
	int                                                m_nMapObjectId;                                           // 0x0388(0x0004) (Edit, EditConst)
	int                                                m_nStartGroup;                                            // 0x038C(0x0004) (Edit)
	int                                                m_nReturnMapType;                                         // 0x0390(0x0004) (Edit)
	float                                              m_fStartRating;                                           // 0x0394(0x0004) (Edit)
	float                                              m_fCurrentRating;                                         // 0x0398(0x0004) (Edit)
	float                                              m_fResetRating;                                           // 0x039C(0x0004) (Edit)
	float                                              m_fDecreaseRate;                                          // 0x03A0(0x0004) (Edit)
	TArray<class UClass*>                              m_ArrayOfFloats;                                          // 0x03A4(0x0010) (Edit, NeedCtorLink)
	class ATgTeleporter*                               m_TgTeleporter;                                           // 0x03B4(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgStartPoint");
		return ptr;
	}


	int STATIC_GetStartGroupNumber();
	void AdjustRating();
	float STATIC_GetRating(class AController* Player);
	void PreBeginPlay();
	void STATIC_LoadObjectConfig();
};


// Class TgGame.TgTeamPlayerStart
// 0x0048 (0x0404 - 0x03BC)
class ATgTeamPlayerStart : public ATgStartPoint
{
public:
	unsigned char                                      m_nTaskForce;                                             // 0x03BC(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x03BD(0x0003) MISSED OFFSET
	int                                                m_nPriority;                                              // 0x03C0(0x0004) (Edit)
	int                                                nPrevPriority;                                            // 0x03C4(0x0004) (Edit)
	float                                              m_fMaxDistForEnemyCheckUU;                                // 0x03C8(0x0004) (Edit)
	float                                              m_fMaxDistForHazardCheckUU;                               // 0x03CC(0x0004) (Edit)
	float                                              m_fMaxWeightForEnemyDistanceCheck;                        // 0x03D0(0x0004) (Edit)
	float                                              m_fMaxDistForAllyCheckUU;                                 // 0x03D4(0x0004) (Edit)
	float                                              m_fMinDistForAllyCheckUU;                                 // 0x03D8(0x0004) (Edit)
	float                                              m_fMaxWeightForAllyDistanceCheck;                         // 0x03DC(0x0004) (Edit)
	float                                              m_fRandomRatingWeighting;                                 // 0x03E0(0x0004) (Edit)
	unsigned long                                      m_bInitialSpawnOnly : 1;                                  // 0x03E4(0x0004) (Edit)
	unsigned long                                      m_bDisallowEnemyLOS : 1;                                  // 0x03E4(0x0004) (Edit)
	unsigned long                                      m_bRotateTowardNearestVisibleAlly : 1;                    // 0x03E4(0x0004) (Edit)
	float                                              m_fExtraHeightToTraceTo;                                  // 0x03E8(0x0004)
	int                                                m_nMinLevel;                                              // 0x03EC(0x0004) (EditConst)
	float                                              m_fLastUsedTimeStamp;                                     // 0x03F0(0x0004) (Transient)
	TArray<class ATgRepInfo_Player*>                   s_AssignedPlayers;                                        // 0x03F4(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgTeamPlayerStart");
		return ptr;
	}


	void OnSetTaskforce(class UTgSeqAct_SetTaskforce* Action);
	float STATIC_GetRating(class AController* Player);
	int GetSupportedTaskforce();
	void Destroyed();
	struct FRotator STATIC_GetSpawnRotationFor(class APawn* TgP);
	float NativeGetRating(class AController* Player, float fRating);
	bool AreaUnoccupied();
	bool STATIC_IsAssignedToPlayer();
	void STATIC_LoadObjectConfig();
};


// Class TgGame.TgTeleporter
// 0x000E (0x03B2 - 0x03A4)
class ATgTeleporter : public ATeleporter
{
public:
	int                                                m_nMapObjectId;                                           // 0x03A4(0x0004) (Edit)
	int                                                m_nMapId;                                                 // 0x03A8(0x0004) (Edit)
	unsigned long                                      m_nPreload : 1;                                           // 0x03AC(0x0004) (Edit)
	unsigned long                                      m_bSetTaskForce : 1;                                      // 0x03AC(0x0004) (Edit)
	unsigned long                                      m_bBalanceTaskForce : 1;                                  // 0x03AC(0x0004) (Edit)
	unsigned long                                      m_bIgnoreNonMembers : 1;                                  // 0x03AC(0x0004) (Edit)
	unsigned long                                      m_bUsePlayerStart : 1;                                    // 0x03AC(0x0004) (Edit)
	unsigned long                                      m_bRequestMission : 1;                                    // 0x03AC(0x0004) (Edit)
	unsigned char                                      m_nStartGroup;                                            // 0x03B0(0x0001) (Edit)
	unsigned char                                      m_nTaskForce;                                             // 0x03B1(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgTeleporter");
		return ptr;
	}


	bool UsePlayerStart(class AActor* Other);
	void PostTouch(class AActor* Other);
	void PostBeginPlay();
	void PreBeginPlay();
	void STATIC_LoadObjectConfig();
	bool STATIC_HandlePostTouch(class AActor* Other);
};


// Class TgGame.TgAudioPawnDialogue
// 0x00A4 (0x0104 - 0x0060)
class UTgAudioPawnDialogue : public UObject
{
public:
	TArray<struct FChatterEvent>                       m_ChatterEvents;                                          // 0x0060(0x0010) (NeedCtorLink)
	TArray<struct FDialogueEvent>                      m_DialogueEvents;                                         // 0x0070(0x0010) (NeedCtorLink)
	float                                              m_fCategoryCooldownTimestamps[0xE];                       // 0x0080(0x0004)
	float                                              m_fCategoryCooldownBase[0xE];                             // 0x00B8(0x0004)
	class ATgPawn*                                     m_pOwner;                                                 // 0x00F0(0x0008)
	float                                              m_fLastEmoteTime;                                         // 0x00F8(0x0004)
	unsigned long                                      m_bSpeaking : 1;                                          // 0x00FC(0x0004)
	unsigned long                                      m_bInitialized : 1;                                       // 0x00FC(0x0004)
	int                                                m_nInvokedWeapon;                                         // 0x0100(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAudioPawnDialogue");
		return ptr;
	}


	void Initialize(class ATgPawn* pOwner);
	void OnEmoteEnded();
};


// Class TgGame.TgCombatActor
// 0x0000 (0x0060 - 0x0060)
class UTgCombatActor : public UInterface
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCombatActor");
		return ptr;
	}


	bool STATIC_FindGround(float fCheckDist, float fCheckRadius, const struct FVector& vRayDir, struct FVector* vSourceLocation, struct FVector* vGroundLocation, struct FVector* vGroundNormal);
	float STATIC_GetGroundDistance();
	float NativeGetCollisionRadius();
	float NativeGetCollisionHeight();
	class AActor* STATIC_GetActorFromCombatActor();
	class AActor* STATIC_GetPetOwner();
	bool STATIC_IsPet();
	TEnumAsByte<EGameplayDesignType> STATIC_GetDesignType();
	class ATgEffectManager* STATIC_GetEffectManager();
	float STATIC_GetMarkedPercentInhand(class AActor* InstigatorPawn);
	float STATIC_GetMarkedPercent(class AActor* InstigatorPawn);
	int STATIC_GetPropIndex(int nPropId);
	float STATIC_GetPropCurrentValue(int nPropIndex);
	float STATIC_GetPropBaseValue(int nPropIndex);
	class UTgSpecialFx* STATIC_GetTakeHitFxOverride(class UTgSpecialFx* TakeHit);
	void STATIC_NotifyQueuedLagCompWorldExplosion(class ATgProj_Simulated* Proj, const struct FVector& HitLocation, const struct FVector& HitVelocity);
	bool STATIC_CanQueueLagCompWorldExplosion(class ATgProj_Simulated* Proj, unsigned char* bHideProjectile);
	struct FVector STATIC_GetLocation();
	bool STATIC_LocalPlayerHasLOS();
	void STATIC_HandleNotificationsForAI(float fStatChange, class ATgPawn* InstigatorPawn);
	float STATIC_GetDamageToLeaveStealth();
	void TakeStealthDamage(float fDamage);
	bool ShieldDamageAppliesToHealth();
	int TakePersonalShieldDamage(float fDamage, class AController* InstigatedBy, class UClass* DamageType, const struct FImpactInfo& Impact, const struct FExtraDamageInfo& ExtraInfo, class AActor* DamageCauser);
	bool CanUsePersonalShield();
	bool CanTakeShieldDamage();
	void TakeManaDamage(float fDamage, class AController* InstigatedBy, class UClass* DamageType, const struct FImpactInfo& Impact, const struct FExtraDamageInfo& ExtraInfo, class AActor* DamageCauser);
	bool CanTakeManaDamage();
	bool CanBeLifestealTarget();
	bool CanBeLifestealInstigator();
	void TakeHealthDamage(float fDamage, class AController* InstigatedBy, class UClass* DamageType, const struct FImpactInfo& Impact, const struct FExtraDamageInfo& ExtraInfo, class AActor* DamageCauser);
	void MitigateHealthDamage(class ATgPawn* pInstigator, class UTgEffectDamage* Effect, const struct FImpactInfo& Impact, bool bIsHeadshot, float* NewValue, float* fPercReduction, unsigned char* bWasCapped);
	void STATIC_MitigateExecuteDamage(class ATgPawn* pInstigator, class UTgEffectDamage* Effect, const struct FImpactInfo& Impact, bool bIsHeadshot, float* NewValue, float* fPercReduction);
	float STATIC_GetSpecialDamageTakenPercentAI();
	float STATIC_GetSpecialDamageDealtPercentAI();
	void BuffDamage(class AActor* Target, class UTgEffectDamage* Effect, const struct FImpactInfo& Impact, float fBaseDamage, float* fProratedAmount, struct FExtraDamageInfo* ExtraInfo);
	bool STATIC_IsImmuneToHealing();
	bool CanBeExecuted();
	bool STATIC_IsImmuneToDamageByAbsorption();
	bool STATIC_IsImmuneToDamage();
	bool OnlyTakeHeadShots();
	bool CanTakeHeadShots();
	bool CanDealHeadShots();
	bool CanTakeHealthDamage();
	float STATIC_GetDiminishedGroundSpeed();
	void STATIC_GetAdditionalLifestealMultipliers(struct FDiminishedEffectInfo* DiminishingInfo, struct FImpactInfo* Impact);
	void STATIC_GetAdditionalDamageTakenMultipliers(class ATgDevice* damagingDevice, struct FDiminishedEffectInfo* DiminishingInfo, struct FImpactInfo* Impact);
	float STATIC_GetMaxShield();
	float STATIC_GetShieldHealth();
	float STATIC_GetMaxMana();
	float STATIC_GetMana();
	float STATIC_GetPureHealthPercent();
	float STATIC_GetHealthPercent();
	float STATIC_GetMaxPureHealth();
	float STATIC_GetMaxHealth();
	float STATIC_GetHealth();
};


// Class TgGame.TgControlModule
// 0x000C (0x006C - 0x0060)
class UTgControlModule : public UObject
{
public:
	class ATgPlayerController*                         Controller;                                               // 0x0060(0x0008)
	unsigned long                                      m_bIsActive : 1;                                          // 0x0068(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgControlModule");
		return ptr;
	}


	bool STATIC_InterceptFlashInput(const struct FName& ButtonName, TEnumAsByte<EInputEvent> Event);
	void AdjustAimingView(struct FVector* ViewLocation, struct FRotator* ViewRotation);
	void OnRightMouseReleased();
	void OnRightMousePressed();
	struct FRotator GetBaseAimRotation(class AWeapon* W, bool bIgnoreAutoLock);
	void OnSettingsChanged(class UTgClientSettings* Settings);
	void OnBecomeInActive(class UTgControlModule* NewModule);
	void OnBecomeActive(class UTgControlModule* OldModule);
	void Init();
	void STATIC_PlayerMove(float DeltaTime);
	void STATIC_ProcessMove(float DeltaTime, const struct FVector& newAccel, TEnumAsByte<EDoubleClickDir> DoubleClickMove, const struct FRotator& DeltaRot);
};


// Class TgGame.TgControlModule_BaseEngine
// 0x0000 (0x006C - 0x006C)
class UTgControlModule_BaseEngine : public UTgControlModule
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgControlModule_BaseEngine");
		return ptr;
	}


	void STATIC_PlayerMove(float DeltaTime);
	void STATIC_ProcessMove(float DeltaTime, const struct FVector& newAccel, TEnumAsByte<EDoubleClickDir> DoubleClickMove, const struct FRotator& DeltaRot);
};


// Class TgGame.TgControlModule_Dead
// 0x0004 (0x0070 - 0x006C)
class UTgControlModule_Dead : public UTgControlModule
{
public:
	unsigned long                                      m_bCachedNoDeathCamExperiment : 1;                        // 0x006C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgControlModule_Dead");
		return ptr;
	}


	struct FRotator GetBaseAimRotation(class AWeapon* W, bool bIgnoreAutoLock);
	void STATIC_PlayerMove(float DeltaTime);
	void STATIC_ProcessMove(float DeltaTime, const struct FVector& newAccel, TEnumAsByte<EDoubleClickDir> DoubleClickMove, const struct FRotator& DeltaRot);
	bool STATIC_NoDeathCamCodePath();
};


// Class TgGame.TgControlModule_Free
// 0x0004 (0x0070 - 0x006C)
class UTgControlModule_Free : public UTgControlModule
{
public:
	int                                                CameraYawOffset;                                          // 0x006C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgControlModule_Free");
		return ptr;
	}


	struct FRotator GetBaseAimRotation(class AWeapon* W, bool bIgnoreAutoLock);
	void STATIC_PlayerMove(float DeltaTime);
	void STATIC_ProcessMove(float DeltaTime, const struct FVector& newAccel, TEnumAsByte<EDoubleClickDir> DoubleClickMove, const struct FRotator& DeltaRot);
};


// Class TgGame.TgControlModule_Spectator
// 0x000C (0x0078 - 0x006C)
class UTgControlModule_Spectator : public UTgControlModule
{
public:
	float                                              RotationLimit;                                            // 0x006C(0x0004) (Edit, Config)
	float                                              SpectatorStallZ;                                          // 0x0070(0x0004) (Edit, Const, Config)
	float                                              SpectatorMinStallZ;                                       // 0x0074(0x0004) (Edit, Const, Config)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgControlModule_Spectator");
		return ptr;
	}


	void OnLeftMousePressed();
	void OnRightMouseReleased();
	void OnRightMousePressed();
	bool STATIC_InterceptFlashInput(const struct FName& ButtonName, TEnumAsByte<EInputEvent> Event);
	void STATIC_GetActorListAtCursor(TArray<class AActor*>* ActorList);
	class APawn* STATIC_GetPawnAtCursor();
	struct FRotator GetBaseAimRotation(class AWeapon* W, bool bIgnoreAutoLock);
	void STATIC_PlayerMove(float DeltaTime);
	void STATIC_ProcessMove(float DeltaTime, const struct FVector& newAccel, TEnumAsByte<EDoubleClickDir> DoubleClickMove, const struct FRotator& DeltaRot);
};


// Class TgGame.TgControlModule_SpectatorLockedView
// 0x0008 (0x0080 - 0x0078)
class UTgControlModule_SpectatorLockedView : public UTgControlModule_Spectator
{
public:
	float                                              DirectorModeSpectatorStallZ;                              // 0x0078(0x0004) (Const, Config)
	float                                              DirectorModeSpectatorMinStallZ;                           // 0x007C(0x0004) (Const, Config)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgControlModule_SpectatorLockedView");
		return ptr;
	}


	float STATIC_GetMaxStallZ();
	float STATIC_GetMinStallZ();
	void STATIC_PlayerMove(float DeltaTime);
};


// Class TgGame.TgControlModule_SpectatorOverview
// 0x0008 (0x0080 - 0x0078)
class UTgControlModule_SpectatorOverview : public UTgControlModule_Spectator
{
public:
	float                                              DirectorModeSpectatorStallZ;                              // 0x0078(0x0004) (Edit, Const, Config)
	float                                              DirectorModeSpectatorMinStallZ;                           // 0x007C(0x0004) (Edit, Const, Config)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgControlModule_SpectatorOverview");
		return ptr;
	}


	void OnLeftMousePressed();
	float STATIC_GetMaxStallZ();
	float STATIC_GetMinStallZ();
	void STATIC_PlayerMove(float DeltaTime);
	void STATIC_ProcessMove(float DeltaTime, const struct FVector& newAccel, TEnumAsByte<EDoubleClickDir> DoubleClickMove, const struct FRotator& DeltaRot);
};


// Class TgGame.TgControlModule_TopDown
// 0x0004 (0x007C - 0x0078)
class UTgControlModule_TopDown : public UTgControlModule_Spectator
{
public:
	float                                              DefaultStartHeight;                                       // 0x0078(0x0004) (Const, Config)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgControlModule_TopDown");
		return ptr;
	}


	void STATIC_PlayerMove(float DeltaTime);
	void STATIC_ProcessMove(float DeltaTime, const struct FVector& newAccel, TEnumAsByte<EDoubleClickDir> DoubleClickMove, const struct FRotator& DeltaRot);
};


// Class TgGame.TgControlModule_ThirdPerson
// 0x0060 (0x00CC - 0x006C)
class UTgControlModule_ThirdPerson : public UTgControlModule
{
public:
	int                                                CameraYawOffset;                                          // 0x006C(0x0004)
	float                                              fRotInterpSpeed;                                          // 0x0070(0x0004)
	float                                              fAimPitch;                                                // 0x0074(0x0004)
	struct FInterpCurveFloat                           PitchCurve;                                               // 0x0078(0x0014) (NeedCtorLink)
	struct FInterpCurveFloat                           AimCurve;                                                 // 0x008C(0x0014) (NeedCtorLink)
	class UCameraAnim*                                 m_StrafeCameraAnim;                                       // 0x00A0(0x0008)
	class UCameraAnim*                                 m_CameraAnimStrafeRight;                                  // 0x00A8(0x0008)
	class UCameraAnim*                                 m_CameraAnimStrafeLeft;                                   // 0x00B0(0x0008)
	float                                              fOrientationResetStartPitch;                              // 0x00B8(0x0004)
	float                                              fOrientationResetRemaining;                               // 0x00BC(0x0004)
	float                                              fOrientationResetDuration;                                // 0x00C0(0x0004)
	float                                              fOrientationResetCooldown;                                // 0x00C4(0x0004)
	float                                              fOrientationResetLastUsed;                                // 0x00C8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgControlModule_ThirdPerson");
		return ptr;
	}


	void AdjustAimingView(struct FVector* ViewLocation, struct FRotator* ViewRotation);
	bool STATIC_IsFixedPitchMode();
	void STATIC_UpdateAimPitch();
	void STATIC_ResetViewOrientation();
	struct FRotator GetBaseAimRotation(class AWeapon* W, bool bIgnoreAutoLock);
	void OnBecomeActive(class UTgControlModule* OldModule);
	void STATIC_UpdatePitchCurve();
	void OnSettingsChanged(class UTgClientSettings* Settings);
	void Init();
	void STATIC_PlayerMove(float DeltaTime);
	void STATIC_ProcessMove(float DeltaTime, const struct FVector& newAccel, TEnumAsByte<EDoubleClickDir> DoubleClickMove, const struct FRotator& DeltaRot);
};


// Class TgGame.TgControlModule_Feared
// 0x0014 (0x00E0 - 0x00CC)
class UTgControlModule_Feared : public UTgControlModule_ThirdPerson
{
public:
	float                                              c_fLastSwitchTime;                                        // 0x00CC(0x0004)
	float                                              c_fNextSwitchTime;                                        // 0x00D0(0x0004)
	struct FVector                                     c_vCurrentDirection;                                      // 0x00D4(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgControlModule_Feared");
		return ptr;
	}


	void OnBecomeActive(class UTgControlModule* OldModule);
	void ChangeDirections();
};


// Class TgGame.TgControlModule_FrontFacingCamera
// 0x0000 (0x00CC - 0x00CC)
class UTgControlModule_FrontFacingCamera : public UTgControlModule_ThirdPerson
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgControlModule_FrontFacingCamera");
		return ptr;
	}


	void STATIC_ProcessMove(float DeltaTime, const struct FVector& newAccel, TEnumAsByte<EDoubleClickDir> DoubleClickMove, const struct FRotator& DeltaRot);
};


// Class TgGame.TgControlModule_Koga
// 0x0008 (0x00D4 - 0x00CC)
class UTgControlModule_Koga : public UTgControlModule_ThirdPerson
{
public:
	class ATgPawn_Koga*                                m_CachedKogaPawn;                                         // 0x00CC(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgControlModule_Koga");
		return ptr;
	}


	void STATIC_ProcessMove(float DeltaTime, const struct FVector& newAccel, TEnumAsByte<EDoubleClickDir> DoubleClickMove, const struct FRotator& DeltaRot);
};


// Class TgGame.TgControlModule_Stoker
// 0x0008 (0x00D4 - 0x00CC)
class UTgControlModule_Stoker : public UTgControlModule_ThirdPerson
{
public:
	class ATgPawn_Stoker*                              m_CachedStokerPawn;                                       // 0x00CC(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgControlModule_Stoker");
		return ptr;
	}


	void STATIC_ProcessMove(float DeltaTime, const struct FVector& newAccel, TEnumAsByte<EDoubleClickDir> DoubleClickMove, const struct FRotator& DeltaRot);
};


// Class TgGame.TgControlModule_Stunned
// 0x0000 (0x00CC - 0x00CC)
class UTgControlModule_Stunned : public UTgControlModule_ThirdPerson
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgControlModule_Stunned");
		return ptr;
	}


	void STATIC_ProcessMove(float DeltaTime, const struct FVector& newAccel, TEnumAsByte<EDoubleClickDir> DoubleClickMove, const struct FRotator& DeltaRot);
};


// Class TgGame.TgControlModule_StunDisoriented
// 0x0010 (0x00DC - 0x00CC)
class UTgControlModule_StunDisoriented : public UTgControlModule_Stunned
{
public:
	int                                                m_nInitialYaw;                                            // 0x00CC(0x0004)
	int                                                m_nTargetYaw;                                             // 0x00D0(0x0004)
	float                                              m_fInterpTime;                                            // 0x00D4(0x0004) (Const)
	float                                              m_fRemainingInterpTime;                                   // 0x00D8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgControlModule_StunDisoriented");
		return ptr;
	}


	void OnBecomeActive(class UTgControlModule* OldModule);
};


// Class TgGame.TgControlModule_StunTaunted
// 0x000C (0x00D8 - 0x00CC)
class UTgControlModule_StunTaunted : public UTgControlModule_ThirdPerson
{
public:
	float                                              m_fInitialYaw;                                            // 0x00CC(0x0004)
	float                                              m_fInterpTime;                                            // 0x00D0(0x0004) (Const)
	float                                              m_fRemainingInterpTime;                                   // 0x00D4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgControlModule_StunTaunted");
		return ptr;
	}


	void OnBecomeInActive(class UTgControlModule* NewModule);
	void OnBecomeActive(class UTgControlModule* OldModule);
};


// Class TgGame.TgDropShadowDecalComponent
// 0x0010 (0x0320 - 0x0310)
class UTgDropShadowDecalComponent : public UStaticMeshComponent
{
public:
	float                                              LastCachedZ;                                              // 0x0310(0x0004) (Transient)
	struct FVector                                     LastOwnerPos;                                             // 0x0314(0x000C) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDropShadowDecalComponent");
		return ptr;
	}


	void STATIC_UpdatePosition(class ATgPawn* TgPOwner, bool bIsInitial, struct FVector* OwnerOffset);
};


// Class TgGame.TgMaterialStack
// 0x001C (0x007C - 0x0060)
class UTgMaterialStack : public UObject
{
public:
	class UMeshComponent*                              m_pOwner;                                                 // 0x0060(0x0008) (ExportObject, Component, EditInline)
	int                                                m_nMaterialStackId;                                       // 0x0068(0x0004)
	TArray<struct FMaterialStackInstance>              m_MaterialStack;                                          // 0x006C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMaterialStack");
		return ptr;
	}


	void STATIC_ClearTimelapseMaterials(bool bEnterintTimelapse);
	void STATIC_ClearMaterials();
	bool PopMaterial(int nMaterialHandle);
	int PushMaterialManual(TArray<class UMaterialInstanceConstant*> MICs, int nPriority);
	int PushMaterial(class UMaterialInterface* MI, TEnumAsByte<EMaterialParamHarvestType> eParamHarvestType, int nPriority);
};


// Class TgGame.TgMeshCompInterface_MaterialStack
// 0x0000 (0x0060 - 0x0060)
class UTgMeshCompInterface_MaterialStack : public UInterface
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMeshCompInterface_MaterialStack");
		return ptr;
	}


	void STATIC_ClearTimelapseMaterials(bool bEnterintTimelapse);
	void STATIC_ClearMaterials();
	bool PopMaterial(int nMaterialHandle);
	int PushMaterialManual(TArray<class UMaterialInstanceConstant*> MICs, int nPriority);
	int PushMaterial(class UMaterialInterface* MI, TEnumAsByte<EMaterialParamHarvestType> eParamHarvestType, int nPriority);
	class UTgMaterialStack* STATIC_GetMaterialStack(bool bShouldCreate);
};


// Class TgGame.TgPaladinsController
// 0x0000 (0x0060 - 0x0060)
class UTgPaladinsController : public UInterface
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPaladinsController");
		return ptr;
	}


	int STATIC_GetTaskForceNumber();
	class ATgPawn* STATIC_GetTgPawn();
	class ATgPawn* STATIC_GetOwnedTgPawn();
	void Revive();
	void LiveRespawn(bool bResetHealth, bool bResetDevices);
	void STATIC_PrepareForLiveRespawn();
	void SetRewardValues(int XP, int Currency, class AActor* Source, TEnumAsByte<ERewardValueType> RewardType, bool bFlankKill);
	void ResetUlt();
	void SetCredits(int nCreditsAmount);
	int STATIC_GetCredits();
};


// Class TgGame.TgPawn
// 0x2920 (0x2ECC - 0x05AC)
class ATgPawn : public AGamePawn
{
public:
	struct FPointer                                    VfTable_ITgSkinnableInterface;                            // 0x05AC(0x0008) (Const, Native, NoExport)
	struct FPointer                                    VfTable_ITgCombatActor;                                   // 0x05B4(0x0008) (Const, Native, NoExport)
	struct FPointer                                    VfTable_ITgGrabSource;                                    // 0x05BC(0x0008) (Const, Native, NoExport)
	struct FPointer                                    VfTable_ITgObserver_ViewTargetChanged;                    // 0x05C4(0x0008) (Const, Native, NoExport)
	struct FPointer                                    VfTable_ITgInteractiveAudio;                              // 0x05CC(0x0008) (Const, Native, NoExport)
	struct FPointer                                    VfTable_ITgSoundNotifyActorInterface;                     // 0x05D4(0x0008) (Const, Native, NoExport)
	struct FPointer                                    VfTable_ITgCallbackInterface;                             // 0x05DC(0x0008) (Const, Native, NoExport)
	struct FVector                                     r_vPhysTweenTarget;                                       // 0x05E4(0x000C) (Net)
	TEnumAsByte<ETweenState>                           r_eTweenState;                                            // 0x05F0(0x0001) (Net)
	TEnumAsByte<ETweenState>                           m_eLocalTweenState;                                       // 0x05F1(0x0001)
	TEnumAsByte<EGrabState>                            r_eGrabState;                                             // 0x05F2(0x0001) (Net)
	TEnumAsByte<EGrabState>                            m_eLocalGrabState;                                        // 0x05F3(0x0001)
	TEnumAsByte<EChargeState>                          r_eChargeState;                                           // 0x05F4(0x0001) (Net)
	TEnumAsByte<ETG_DEATH_REASON>                      r_eDeathReason;                                           // 0x05F5(0x0001) (Net)
	TEnumAsByte<ETgMeshVisibilityState>                c_PreviousMeshVisibilityState;                            // 0x05F6(0x0001)
	TEnumAsByte<ETG_REP_DEVICE_STATE>                  r_ReplicatedDeviceState[0x31];                            // 0x05F7(0x0001) (Net)
	TEnumAsByte<ETG_EQUIP_POINT>                       r_eDesiredInHand;                                         // 0x0628(0x0001) (Net)
	TEnumAsByte<ETG_EQUIP_POINT>                       m_eEquippedInHand;                                        // 0x0629(0x0001)
	unsigned char                                      r_nPackedFireMultiRanges[0x14];                           // 0x062A(0x0001) (Net)
	TEnumAsByte<ETG_EQUIP_POINT>                       r_eDesiredAIDevice;                                       // 0x063E(0x0001)
	TEnumAsByte<ESTEALTH_TYPE>                         r_eIsStealthed;                                           // 0x063F(0x0001) (Net)
	TEnumAsByte<ESTEALTH_TYPE>                         c_eIsStealthed;                                           // 0x0640(0x0001)
	unsigned char                                      r_nInCombatNonce;                                         // 0x0641(0x0001) (Net)
	unsigned char                                      c_nInCombatNonceAck;                                      // 0x0642(0x0001)
	TEnumAsByte<EDeployableOverlayIcon>                m_InitHUDOverlayIcon;                                     // 0x0643(0x0001) (Const)
	TEnumAsByte<EDeployableOverlayState>               m_InitHUDOverlayState;                                    // 0x0644(0x0001) (Const)
	TEnumAsByte<ETG_POSTURE>                           m_ePosture;                                               // 0x0645(0x0001)
	TEnumAsByte<ETG_MARKED_TYPES>                      m_MarkedType;                                             // 0x0646(0x0001)
	TEnumAsByte<EStunType>                             r_eCurrentStunType;                                       // 0x0647(0x0001) (Net)
	unsigned char                                      c_nLocalRespawnBeaconHUDState;                            // 0x0648(0x0001)
	TEnumAsByte<EOverlayMICType>                       m_OverlayCurrentTypeBody;                                 // 0x0649(0x0001)
	TEnumAsByte<EOverlayMICType>                       m_OverlayCurrentTypeWeapon;                               // 0x064A(0x0001)
	TEnumAsByte<ESceneDepthPriorityGroup>              m_eCharacterCustom1OverlayDepthGroup;                     // 0x064B(0x0001) (Const)
	TEnumAsByte<EUIHealthBarArmorType>                 m_eUIHealthBarArmorType;                                  // 0x064C(0x0001) (Edit)
	TEnumAsByte<EForcedSilhouetteVisibility>           m_eForcedSilhouetteVisibility;                            // 0x064D(0x0001) (Edit)
	TEnumAsByte<EMountState>                           r_eMountState;                                            // 0x064E(0x0001) (Net)
	TEnumAsByte<EUITargetingType>                      c_UITargetingType;                                        // 0x064F(0x0001)
	TEnumAsByte<EMetaGameState>                        m_eMetaGameState;                                         // 0x0650(0x0001)
	TEnumAsByte<EBotBehaviorState>                     m_eBotBehaviorState;                                      // 0x0651(0x0001)
	unsigned char                                      m_nIsInIntroState;                                        // 0x0652(0x0001)
	TEnumAsByte<EPolymorphType>                        c_LocalPolymorph;                                         // 0x0653(0x0001) (Transient)
	TEnumAsByte<EPolymorphType>                        r_CurrentPolymorph;                                       // 0x0654(0x0001) (Net)
	TEnumAsByte<EThreatLevel>                          c_ThreatLevel;                                            // 0x0655(0x0001)
	TEnumAsByte<EThreatLevel>                          c_LastThreatLevel;                                        // 0x0656(0x0001)
	TEnumAsByte<ELocalViewerRangeState>                m_RangeStateFromLocalViewer;                              // 0x0657(0x0001) (Const)
	TEnumAsByte<EEmote>                                c_eCurrentAudioEmotePlaying;                              // 0x0658(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0659(0x0003) MISSED OFFSET
	float                                              m_fPhysTweenDist;                                         // 0x065C(0x0004)
	float                                              r_fPhysTweenDuration;                                     // 0x0660(0x0004) (Net)
	int                                                m_nPhysTweenPostureId;                                    // 0x0664(0x0004)
	unsigned long                                      r_bPhysTweenInterrupted : 1;                              // 0x0668(0x0004) (Net)
	unsigned long                                      s_bIsInGrass : 1;                                         // 0x0668(0x0004)
	unsigned long                                      r_bIsInItemShop : 1;                                      // 0x0668(0x0004) (Net)
	unsigned long                                      r_bHasLeftItemShop : 1;                                   // 0x0668(0x0004) (Net)
	unsigned long                                      r_bGrabInterrupted : 1;                                   // 0x0668(0x0004) (Net)
	unsigned long                                      r_bCanShootWhileGrabbed : 1;                              // 0x0668(0x0004) (Net)
	unsigned long                                      m_PreGrabCollideActors : 1;                               // 0x0668(0x0004)
	unsigned long                                      m_PreGrabBlockActors : 1;                                 // 0x0668(0x0004)
	unsigned long                                      r_bUsePhysFlyingForCharge : 1;                            // 0x0668(0x0004) (Net)
	unsigned long                                      r_bChargeIgnoreHumanoidBlocking : 1;                      // 0x0668(0x0004) (Net)
	unsigned long                                      m_bWantsCharge : 1;                                       // 0x0668(0x0004)
	unsigned long                                      m_bCanJumpWhileCharging : 1;                              // 0x0668(0x0004)
	unsigned long                                      m_bPostChargeUseWalkSpeed : 1;                            // 0x0668(0x0004)
	unsigned long                                      m_bChargeRespectsMoveSpeedMultipliers : 1;                // 0x0668(0x0004)
	unsigned long                                      c_bShouldUpdateSavedChargeState : 1;                      // 0x0668(0x0004)
	unsigned long                                      m_bIgnoreFriendlyBlocking : 1;                            // 0x0668(0x0004)
	unsigned long                                      m_bIgnoreEnemyBlocking : 1;                               // 0x0668(0x0004)
	unsigned long                                      m_bHasDestroyedMesh : 1;                                  // 0x0668(0x0004) (Const)
	unsigned long                                      m_bDefaultPropsInitialized : 1;                           // 0x0668(0x0004)
	unsigned long                                      m_bReconnectedWhileDead : 1;                              // 0x0668(0x0004)
	unsigned long                                      m_bAffectedByVortices : 1;                                // 0x0668(0x0004)
	unsigned long                                      s_LoadMeshServerSide : 1;                                 // 0x0668(0x0004)
	unsigned long                                      c_bDeviceHiddenDueToFullBodyAnim : 1;                     // 0x0668(0x0004)
	unsigned long                                      c_bMeshHiddenDueToDeath : 1;                              // 0x0668(0x0004)
	unsigned long                                      c_bHideMeshFromCameraPenetration : 1;                     // 0x0668(0x0004)
	unsigned long                                      c_bHideMeshFromKismet : 1;                                // 0x0668(0x0004)
	unsigned long                                      r_bInGlobalOffhandCooldown : 1;                           // 0x0668(0x0004) (Net)
	unsigned long                                      bInGlobalOffhandCooldownClient : 1;                       // 0x0668(0x0004)
	unsigned long                                      m_bInFireLock : 1;                                        // 0x0668(0x0004)
	unsigned long                                      c_bUpdatesWeaponMesh : 1;                                 // 0x0668(0x0004)
	unsigned long                                      c_bIsStealthMaterialOn : 1;                               // 0x0668(0x0004)
	unsigned long                                      c_bShow1PWeaponAsStealthed : 1;                           // 0x0668(0x0004)
	unsigned long                                      r_bIsVolumeStealthed : 1;                                 // 0x066C(0x0004) (Net)
	unsigned long                                      r_bIsVolumeStealthFading : 1;                             // 0x066C(0x0004) (Net)
	unsigned long                                      m_bDisableVolumeStealth : 1;                              // 0x066C(0x0004)
	unsigned long                                      r_bDisableVolumeStealth : 1;                              // 0x066C(0x0004) (Net)
	unsigned long                                      m_bCannotBeVolumeStealthed : 1;                           // 0x066C(0x0004) (Const)
	unsigned long                                      m_bPlayingStealth : 1;                                    // 0x066C(0x0004)
	unsigned long                                      m_bPlayingDetected : 1;                                   // 0x066C(0x0004)
	unsigned long                                      c_bHiddenDueToStealth : 1;                                // 0x066C(0x0004)
	unsigned long                                      c_bHiddenDueToObscuringDeployable : 1;                    // 0x066C(0x0004)
	unsigned long                                      r_bCanStartStealthInCombat : 1;                           // 0x066C(0x0004) (Net)
	unsigned long                                      m_bIsVisionBlocker : 1;                                   // 0x066C(0x0004) (Const)
	unsigned long                                      m_bIsAIVisionBlocker : 1;                                 // 0x066C(0x0004) (Const)
	unsigned long                                      m_bApplyDistanceFade : 1;                                 // 0x066C(0x0004)
	unsigned long                                      r_bIsBot : 1;                                             // 0x066C(0x0004) (Net)
	unsigned long                                      c_bIsFrametestZombie : 1;                                 // 0x066C(0x0004) (Transient)
	unsigned long                                      r_bIsAnimInStrafeMode : 1;                                // 0x066C(0x0004) (Net)
	unsigned long                                      m_ReachedTargetSoKillRootMotion : 1;                      // 0x066C(0x0004)
	unsigned long                                      s_bCanApplyEffects : 1;                                   // 0x066C(0x0004)
	unsigned long                                      m_bInitialized : 1;                                       // 0x066C(0x0004)
	unsigned long                                      m_bUseInterrupted : 1;                                    // 0x066C(0x0004)
	unsigned long                                      c_bIgnoreInterruption : 1;                                // 0x066C(0x0004)
	unsigned long                                      r_bNoEnergyCost : 1;                                      // 0x066C(0x0004) (Net)
	unsigned long                                      m_bCheatUseNoEnergy : 1;                                  // 0x066C(0x0004)
	unsigned long                                      m_bCheatNoRecharge : 1;                                   // 0x066C(0x0004)
	unsigned long                                      m_bIsInvisibleToAI : 1;                                   // 0x066C(0x0004)
	unsigned long                                      r_bInCombatFlag : 1;                                      // 0x066C(0x0004) (Net)
	unsigned long                                      s_bIsStill : 1;                                           // 0x066C(0x0004)
	unsigned long                                      m_bHitWallThisTick : 1;                                   // 0x066C(0x0004)
	unsigned long                                      r_bIsAFK : 1;                                             // 0x066C(0x0004) (Net)
	unsigned long                                      c_bHandIKEnabledFromAnimSet : 1;                          // 0x066C(0x0004)
	unsigned long                                      c_bCanDoTurnInPlaceAnim : 1;                              // 0x066C(0x0004)
	unsigned long                                      c_bIsPlayingTurnInPlaceAnim : 1;                          // 0x066C(0x0004)
	unsigned long                                      m_bShouldApplyCCImmuneOverlay : 1;                        // 0x0670(0x0004)
	unsigned long                                      m_bApplyAltEffects : 1;                                   // 0x0670(0x0004)
	unsigned long                                      m_bCanBeMarked : 1;                                       // 0x0670(0x0004)
	unsigned long                                      m_bCanBeKnockedBack : 1;                                  // 0x0670(0x0004)
	unsigned long                                      m_bCausesPushblock : 1;                                   // 0x0670(0x0004)
	unsigned long                                      m_bPushblockAffectsFriendlies : 1;                        // 0x0670(0x0004)
	unsigned long                                      m_bPushblockAffectsEnemies : 1;                           // 0x0670(0x0004)
	unsigned long                                      m_bIsCrowdControlImmuneKismet : 1;                        // 0x0670(0x0004)
	unsigned long                                      m_bUseSmoothNetReceiveRotation : 1;                       // 0x0670(0x0004)
	unsigned long                                      m_bForceSmoothCorrection : 1;                             // 0x0670(0x0004)
	unsigned long                                      r_bIsRotationLockedForSpectate : 1;                       // 0x0670(0x0004) (Net)
	unsigned long                                      m_bAlwaysUseAccurateRotation : 1;                         // 0x0670(0x0004) (Const)
	unsigned long                                      r_bHasAccurateRotation : 1;                               // 0x0670(0x0004) (Net)
	unsigned long                                      c_bUpdateSkelMeshWhenNotRendered : 1;                     // 0x0670(0x0004)
	unsigned long                                      c_bUpdateSkelMeshWhenNotRenderedServer : 1;               // 0x0670(0x0004)
	unsigned long                                      r_bSilenced : 1;                                          // 0x0670(0x0004) (Net)
	unsigned long                                      r_bDisarmed : 1;                                          // 0x0670(0x0004) (Net)
	unsigned long                                      r_bCrippled : 1;                                          // 0x0670(0x0004) (Net)
	unsigned long                                      r_bIsInStasis : 1;                                        // 0x0670(0x0004) (Net)
	unsigned long                                      r_bCanBePulled : 1;                                       // 0x0670(0x0004) (Net)
	unsigned long                                      s_bHasCrippleEffect : 1;                                  // 0x0670(0x0004)
	unsigned long                                      c_bEnemyMatLoaded : 1;                                    // 0x0670(0x0004)
	unsigned long                                      r_bIsFlashBang : 1;                                       // 0x0670(0x0004) (Net)
	unsigned long                                      r_bIsBanished : 1;                                        // 0x0670(0x0004) (Net)
	unsigned long                                      m_bIsRewinding : 1;                                       // 0x0670(0x0004)
	unsigned long                                      r_bIsJumping : 1;                                         // 0x0670(0x0004) (Net)
	unsigned long                                      r_bIsShortJump : 1;                                       // 0x0670(0x0004) (Net)
	unsigned long                                      m_bIsLanding : 1;                                         // 0x0670(0x0004)
	unsigned long                                      m_bAllowHigherWallJumping : 1;                            // 0x0670(0x0004)
	unsigned long                                      m_bIgnorePhysCheckForJump : 1;                            // 0x0670(0x0004)
	unsigned long                                      m_bHasPlayedDeathAnimation : 1;                           // 0x0670(0x0004)
	unsigned long                                      m_bForceDeathAnim : 1;                                    // 0x0670(0x0004)
	unsigned long                                      m_bDeathFreezeVelocity : 1;                               // 0x0674(0x0004)
	unsigned long                                      r_bHasRespawnBeacon : 1;                                  // 0x0674(0x0004) (Net)
	unsigned long                                      m_bDestroyOnOwnerDeathFlag : 1;                           // 0x0674(0x0004)
	unsigned long                                      r_bNeedPlaySpawnFx : 1;                                   // 0x0674(0x0004) (Net)
	unsigned long                                      c_bSpawnFxPlayed : 1;                                     // 0x0674(0x0004)
	unsigned long                                      c_bTargeted : 1;                                          // 0x0674(0x0004)
	unsigned long                                      c_bTargetedLightup : 1;                                   // 0x0674(0x0004)
	unsigned long                                      c_bApplyDropShadow : 1;                                   // 0x0674(0x0004)
	unsigned long                                      m_bShowNameplate : 1;                                     // 0x0674(0x0004)
	unsigned long                                      c_bShowSpecialHealth : 1;                                 // 0x0674(0x0004)
	unsigned long                                      r_bInitialIsEnemy : 1;                                    // 0x0674(0x0004) (Net)
	unsigned long                                      c_bNeedsAssetLoad : 1;                                    // 0x0674(0x0004)
	unsigned long                                      r_bDebugShowAIDebug : 1;                                  // 0x0674(0x0004) (Net)
	unsigned long                                      m_SwapToDestroyedMeshOnTick : 1;                          // 0x0674(0x0004)
	unsigned long                                      m_bBlockCamera : 1;                                       // 0x0674(0x0004) (Edit)
	unsigned long                                      m_bOverlaysEnabled : 1;                                   // 0x0674(0x0004)
	unsigned long                                      m_b1POverlaysEnabled : 1;                                 // 0x0674(0x0004)
	unsigned long                                      m_b1POverlaysActive : 1;                                  // 0x0674(0x0004)
	unsigned long                                      m_bSilhouettesVisible : 1;                                // 0x0674(0x0004)
	unsigned long                                      m_bUseSilhouettes : 1;                                    // 0x0674(0x0004) (Edit, Const)
	unsigned long                                      m_bIgnoreTearOffMomentum : 1;                             // 0x0674(0x0004) (Edit)
	unsigned long                                      m_bIsFadingOut : 1;                                       // 0x0674(0x0004)
	unsigned long                                      m_bUseDamageTypeForDeathAnim : 1;                         // 0x0674(0x0004)
	unsigned long                                      r_bDemoCanPurchaseItems : 1;                              // 0x0674(0x0004) (Net)
	unsigned long                                      m_bCanPurchaseNimble : 1;                                 // 0x0674(0x0004)
	unsigned long                                      s_bHasInteractedWithStore : 1;                            // 0x0674(0x0004)
	unsigned long                                      s_bAlwaysRelevantExceptRoyale : 1;                        // 0x0674(0x0004)
	unsigned long                                      s_bPetOwnerIsRelevant : 1;                                // 0x0674(0x0004)
	unsigned long                                      m_bDoSmoothCorrectionThisTick : 1;                        // 0x0674(0x0004)
	unsigned long                                      m_bOnlyTakeHeadshotDamage : 1;                            // 0x0674(0x0004)
	unsigned long                                      r_bIsMounted : 1;                                         // 0x0674(0x0004) (Net)
	unsigned long                                      m_bIsEnteringMount : 1;                                   // 0x0674(0x0004)
	unsigned long                                      m_bCreateMountMeshDeferred : 1;                           // 0x0678(0x0004)
	unsigned long                                      m_bUpdateEyeHeight : 1;                                   // 0x0678(0x0004) (Const)
	unsigned long                                      r_bJustJumped : 1;                                        // 0x0678(0x0004) (Net)
	unsigned long                                      m_bStunEnergyRegen : 1;                                   // 0x0678(0x0004)
	unsigned long                                      c_bHealAkEventPlaying : 1;                                // 0x0678(0x0004)
	unsigned long                                      m_bPainAkEventPlaying : 1;                                // 0x0678(0x0004)
	unsigned long                                      r_bIsDazed : 1;                                           // 0x0678(0x0004) (Net)
	unsigned long                                      r_bIsMarked : 1;                                          // 0x0678(0x0004) (Net)
	unsigned long                                      r_bIsBleeding : 1;                                        // 0x0678(0x0004) (Net)
	unsigned long                                      r_bIsOnFire : 1;                                          // 0x0678(0x0004) (Net)
	unsigned long                                      r_bIsRooted : 1;                                          // 0x0678(0x0004) (Net)
	unsigned long                                      r_bIsKnockedBack : 1;                                     // 0x0678(0x0004) (Net)
	unsigned long                                      r_bIsPoisoned : 1;                                        // 0x0678(0x0004) (Net)
	unsigned long                                      r_bIsSlowed : 1;                                          // 0x0678(0x0004) (Net)
	unsigned long                                      r_bIsFrozen : 1;                                          // 0x0678(0x0004) (Net)
	unsigned long                                      r_bIsCCImmune : 1;                                        // 0x0678(0x0004) (Net)
	unsigned long                                      r_bIsRevealed : 1;                                        // 0x0678(0x0004) (Net)
	unsigned long                                      r_bIsWallHacking : 1;                                     // 0x0678(0x0004) (Net)
	unsigned long                                      r_bIsMarkedByDruid : 1;                                   // 0x0678(0x0004) (Net)
	unsigned long                                      r_bIsMarkedByCorvus : 1;                                  // 0x0678(0x0004) (Net)
	unsigned long                                      r_bIsMarkedByLex : 1;                                     // 0x0678(0x0004) (Net)
	unsigned long                                      r_bIsInSelfKnockBack : 1;                                 // 0x0678(0x0004) (Net)
	unsigned long                                      s_bApplyKnockbackHitEffects : 1;                          // 0x0678(0x0004)
	unsigned long                                      s_bApplyGrabbedHitEffects : 1;                            // 0x0678(0x0004)
	unsigned long                                      m_bUseOutlines : 1;                                       // 0x0678(0x0004) (Edit)
	unsigned long                                      m_bIsLeaping : 1;                                         // 0x0678(0x0004)
	unsigned long                                      m_bCanSpawnHealthNuggetsOnDeath : 1;                      // 0x0678(0x0004)
	unsigned long                                      m_bCanAutoMountOnRespawn : 1;                             // 0x0678(0x0004)
	unsigned long                                      c_bShowingDisarm : 1;                                     // 0x0678(0x0004)
	unsigned long                                      r_bFirstSpawnWave : 1;                                    // 0x0678(0x0004) (Net)
	unsigned long                                      m_bWaitForIntroAnimToEnd : 1;                             // 0x0678(0x0004)
	unsigned long                                      m_bIntroAnimFinished : 1;                                 // 0x0678(0x0004)
	unsigned long                                      m_bAllowIntroWhiteOut : 1;                                // 0x067C(0x0004)
	unsigned long                                      m_bIntroWhiteOutActive : 1;                               // 0x067C(0x0004)
	unsigned long                                      m_bAirAccuracyPenalty : 1;                                // 0x067C(0x0004)
	unsigned long                                      c_bInLocalLineOfSightRecently : 1;                        // 0x067C(0x0004)
	unsigned long                                      m_bCanBeHeadShot : 1;                                     // 0x067C(0x0004)
	unsigned long                                      c_bHide3PWeaponMeshWhileMounted : 1;                      // 0x067C(0x0004) (Edit)
	unsigned long                                      m_bShouldBeFirstPersonLastFrame : 1;                      // 0x067C(0x0004) (Transient)
	unsigned long                                      m_bFadeOutOnLifeAfterDeathTimerExpired : 1;               // 0x067C(0x0004)
	unsigned long                                      m_bUsesRecoil : 1;                                        // 0x067C(0x0004)
	unsigned long                                      m_bUsingSecondaryPhysicsAsset : 1;                        // 0x067C(0x0004)
	unsigned long                                      m_bWasKilledByEnvironment : 1;                            // 0x067C(0x0004) (Transient)
	unsigned long                                      m_bShouldSmoothEyeHeight : 1;                             // 0x067C(0x0004)
	unsigned long                                      m_bHasAstroBuff : 1;                                      // 0x067C(0x0004)
	unsigned long                                      m_bHasCorvusBeacon : 1;                                   // 0x067C(0x0004)
	unsigned long                                      r_bIsLifted : 1;                                          // 0x067C(0x0004) (Net)
	unsigned long                                      m_bCameraOverrideLocation : 1;                            // 0x067C(0x0004)
	unsigned long                                      c_bSaveModMoveSpeed : 1;                                  // 0x067C(0x0004)
	unsigned long                                      c_bSaveModGravity : 1;                                    // 0x067C(0x0004)
	unsigned long                                      m_bBehindView : 1;                                        // 0x067C(0x0004)
	unsigned long                                      r_bClientUsingForced3pOption : 1;                         // 0x067C(0x0004) (Net)
	unsigned long                                      c_bHasRequestedFiremodePropModSync : 1;                   // 0x067C(0x0004)
	unsigned long                                      m_bJustForcedVelocity : 1;                                // 0x067C(0x0004)
	unsigned long                                      c_bQueueDeviceStateRecovery : 1;                          // 0x067C(0x0004)
	int                                                r_nPhysTweenFlags;                                        // 0x0680(0x0004) (Net)
	float                                              r_fPhysTweenSpeed;                                        // 0x0684(0x0004) (Net)
	struct FString                                     m_sGameplayPackage;                                       // 0x0688(0x0010) (Edit, NeedCtorLink)
	TScriptInterface<class UTgInteractiveAudio>        m_AsInteractiveAudio;                                     // 0x0698(0x0010)
	class UTgAudioPawnDialogue*                        m_PawnDialogue;                                           // 0x06A8(0x0008)
	float                                              c_fLastAttackAudioCueTimestamp;                           // 0x06B0(0x0004)
	float                                              c_fLastAttackFromBehindAudioCueTimestamp;                 // 0x06B4(0x0004)
	float                                              c_fLastAttackFromAboveAudioCueTimestamp;                  // 0x06B8(0x0004)
	float                                              c_fLastAttackFromSniperAudioCueTimestamp;                 // 0x06BC(0x0004)
	float                                              c_fRequestCooldownEmotePause;                             // 0x06C0(0x0004)
	struct FVector                                     m_vGrabDesiredRelativeLocation;                           // 0x06C4(0x000C)
	class AActor*                                      r_GrabSource;                                             // 0x06D0(0x0008) (Net)
	float                                              r_fGrabDuration;                                          // 0x06D8(0x0004) (Net)
	float                                              r_fGrabInitialYaw;                                        // 0x06DC(0x0004) (Net)
	struct FName                                       r_GrabAttachSocket;                                       // 0x06E0(0x0008) (Net)
	struct FVector                                     r_vGrabLocationOffset;                                    // 0x06E8(0x000C) (Net)
	struct FRotator                                    r_rGrabRotationOffset;                                    // 0x06F4(0x000C) (Net)
	struct FVector                                     m_vGrabDestRelLocation;                                   // 0x0700(0x000C)
	struct FRotator                                    m_rGrabDestRelRotation;                                   // 0x070C(0x000C)
	int                                                m_nPhysGrabPostureId;                                     // 0x0718(0x0004)
	TArray<class ATgPawn*>                             s_GrabbedTargets;                                         // 0x071C(0x0010) (NeedCtorLink)
	int                                                r_nCannotBeGrabSource;                                    // 0x072C(0x0004) (Net)
	struct FVector                                     s_vGrabOffsetDedicatedServer;                             // 0x0730(0x000C)
	TArray<class AActor*>                              m_TeleportNotifyList;                                     // 0x073C(0x0010) (NeedCtorLink)
	float                                              r_fChargeInitialYaw;                                      // 0x074C(0x0004) (Net)
	float                                              r_fChargeInitialPitch;                                    // 0x0750(0x0004) (Net)
	struct FVector                                     r_vChargeInitialLocation;                                 // 0x0754(0x000C) (Net)
	float                                              r_fChargeSpeed;                                           // 0x0760(0x0004) (Net)
	float                                              r_fChargeTime;                                            // 0x0764(0x0004) (Net)
	float                                              r_fChargeTurnRate;                                        // 0x0768(0x0004) (Net)
	float                                              m_fCurrentTimeInCharge;                                   // 0x076C(0x0004)
	float                                              m_fPostChargeVelocityMult;                                // 0x0770(0x0004)
	float                                              m_fPostChargeVelocityCap;                                 // 0x0774(0x0004)
	struct FSavedChargeState                           m_SavedChargeState;                                       // 0x0778(0x002C)
	int                                                m_nCoreMeshAsmId;                                         // 0x07A4(0x0004) (Const)
	struct FPointer                                    m_CoreMeshAssembly;                                       // 0x07A8(0x0008) (Const, Native)
	int                                                m_nBodyMeshAsmId;                                         // 0x07B0(0x0004) (Const)
	struct FPointer                                    m_BodyMeshAssembly;                                       // 0x07B4(0x0008) (Const, Native)
	struct FPointer                                    m_DestroyedMeshAssembly;                                  // 0x07BC(0x0008) (Const, Native)
	int                                                m_n1PHeadMeshId;                                          // 0x07C4(0x0004)
	int                                                r_nPawnId;                                                // 0x07C8(0x0004) (Net)
	float                                              c_fLastUpdateTime;                                        // 0x07CC(0x0004)
	float                                              m_fSimPawnMoveSafetyTime;                                 // 0x07D0(0x0004)
	float                                              m_fNetReceiveLocationTime;                                // 0x07D4(0x0004)
	struct FVector                                     m_NetReceiveLocation;                                     // 0x07D8(0x000C)
	int                                                m_nArchetype;                                             // 0x07E4(0x0004)
	class ATgEffectManager*                            r_EffectManager;                                          // 0x07E8(0x0008) (Net)
	TArray<struct FTgPropertyInstance>                 m_Properties;                                             // 0x07F0(0x0010) (NeedCtorLink)
	float                                              r_CurrentPropValues[0x94];                                // 0x0800(0x0004) (Net)
	float                                              m_LocalPropValues[0x94];                                  // 0x0A50(0x0004)
	float                                              s_PropValuesRepResolution[0x94];                          // 0x0CA0(0x0004)
	float                                              s_DefaultPropValues[0x94];                                // 0x0EF0(0x0004) (Net)
	float                                              r_fCachedMaxHealth;                                       // 0x1140(0x0004) (Net)
	float                                              m_fCachedGroundProximity;                                 // 0x1144(0x0004)
	float                                              m_fCachedGroundProximityTimestamp;                        // 0x1148(0x0004)
	TArray<struct FDebugPropertyMod>                   s_DebugPropertyMods;                                      // 0x114C(0x0010) (NeedCtorLink)
	class ATgAkActorUnoccluded*                        m_AkActorUnoccluded;                                      // 0x115C(0x0008)
	struct FEEmoteCategoryChance                       m_EmoteChances;                                           // 0x1164(0x002C) (Config)
	struct FEEmoteAbilityChance                        m_EmoteChancesAbility;                                    // 0x1190(0x0014) (Config)
	float                                              m_fLastEmoteTime;                                         // 0x11A4(0x0004) (Transient)
	float                                              m_fEmoteGlobalCooldown;                                   // 0x11A8(0x0004)
	TArray<float>                                      m_fLastEmoteCatTimes;                                     // 0x11AC(0x0010) (NeedCtorLink)
	TArray<float>                                      m_fLastPlayerVGSEmoteTimes;                               // 0x11BC(0x0010) (NeedCtorLink)
	float                                              m_fEmoteNonLocalCooldown;                                 // 0x11CC(0x0004)
	float                                              m_fLastNonLocalEmoteTime;                                 // 0x11D0(0x0004)
	float                                              m_fSoftLandVelocityCutoff;                                // 0x11D4(0x0004)
	float                                              m_fHardLandVelocityCutoff;                                // 0x11D8(0x0004)
	float                                              s_nSpawnTime;                                             // 0x11DC(0x0004)
	int                                                r_nPhysicalType;                                          // 0x11E0(0x0004) (Net)
	float                                              r_fReconnectTime;                                         // 0x11E4(0x0004) (Net)
	TArray<class ATgCollisionProxy_Vortex*>            m_CurrentVortexList;                                      // 0x11E8(0x0010) (NeedCtorLink)
	TArray<class ATgDeploy_BlackHole*>                 m_CurrentBlackHoleList;                                   // 0x11F8(0x0010) (NeedCtorLink)
	class UClass*                                      m_DeathDamageType;                                        // 0x1208(0x0008)
	struct FVector                                     m_DeathHitLocation;                                       // 0x1210(0x000C)
	int                                                m_nDeathFXMaterialHandle;                                 // 0x121C(0x0004)
	struct FEquipDeviceInfo                            r_EquipDeviceInfo[0x31];                                  // 0x1220(0x000C) (Net)
	class ATgDevice*                                   m_EquippedDevices[0x31];                                  // 0x146C(0x0008)
	class UTgDeviceForm*                               c_EquipForm[0x31];                                        // 0x15F4(0x0008)
	struct FName                                       c_EquipFormState[0x31];                                   // 0x177C(0x0008)
	struct FName                                       c_nmInHandSocket;                                         // 0x1904(0x0008)
	class ATgDevice*                                   c_CurrentTargetingDevice;                                 // 0x190C(0x0008)
	class ATgDevice*                                   c_CurrentStartActionDevice;                               // 0x1914(0x0008)
	float                                              c_fShouldStartActionTimeStamp;                            // 0x191C(0x0004)
	class ATgDevice*                                   m_CurrentInHandDevice;                                    // 0x1920(0x0008)
	int                                                c_nLockInHandToTargetingDevice;                           // 0x1928(0x0004)
	class UTgSpecialFx*                                c_WorldBracketFX;                                         // 0x192C(0x0008)
	int                                                c_nLastProcessedFlashEventIdx;                            // 0x1934(0x0004)
	int                                                r_nFirstValidFlashEventIdx;                               // 0x1938(0x0004) (Net)
	int                                                r_nFlashQueIndex;                                         // 0x193C(0x0004) (Net)
	int                                                r_nFlashEvent[0x20];                                      // 0x1940(0x0004) (Net)
	struct FVector                                     r_vFlashLocation[0x20];                                   // 0x19C0(0x000C) (Net)
	struct FVector                                     r_vFlashRayDir[0x20];                                     // 0x1B40(0x000C) (Net)
	float                                              r_vFlashRefireTime[0x20];                                 // 0x1CC0(0x0004) (Net)
	class AActor*                                      r_pFlashTarget[0x20];                                     // 0x1D40(0x0008) (Net)
	class UClass*                                      r_pFlashDamageType[0x20];                                 // 0x1E40(0x0008) (Net)
	int                                                r_nFlashFireInfo[0x20];                                   // 0x1F40(0x0004) (Net)
	float                                              r_fFireMultiMaxRange;                                     // 0x1FC0(0x0004) (Net)
	int                                                r_nFireMultiSeed;                                         // 0x1FC4(0x0004) (Net)
	float                                              r_fFireMultiSpreadAngle;                                  // 0x1FC8(0x0004) (Net)
	float                                              s_fTauntAmount;                                           // 0x1FCC(0x0004)
	float                                              m_fLastPainSound;                                         // 0x1FD0(0x0004)
	class ULightEnvironmentComponent*                  LightEnvironment;                                         // 0x1FD4(0x0008) (Edit, Const, ExportObject, Component, EditInline)
	struct FVector                                     FireLocationOffsets[0x31];                                // 0x1FDC(0x000C)
	float                                              BotTurnAcceleration;                                      // 0x2228(0x0004)
	float                                              BotTurnSpeed;                                             // 0x222C(0x0004)
	float                                              m_fMaxAimAssistStacks;                                    // 0x2230(0x0004)
	float                                              c_fStealthStateFxSpamWindow;                              // 0x2234(0x0004)
	struct FName                                       c_nmLastStealthFxGroup;                                   // 0x2238(0x0008)
	float                                              r_fStealthFadeRate;                                       // 0x2240(0x0004) (Net)
	class AActor*                                      r_CurrentVisibilityVolumes[0x2];                          // 0x2244(0x0008) (Net)
	class ATgDeployable*                               r_ObscuringDeployables[0xA];                              // 0x2254(0x0008) (Net)
	class ATgDeployable*                               r_BlindingDeployables[0xA];                               // 0x22A4(0x0008) (Net)
	class AActor*                                      r_VisibleThroughWallsInstigators[0xC];                    // 0x22F4(0x0008) (Net)
	class AActor*                                      r_VisibleThroughStealthInstigators[0xC];                  // 0x2354(0x0008) (Net)
	float                                              m_fVolumeStealthDisableTime;                              // 0x23B4(0x0004) (Const)
	float                                              c_fVolumeFadeValue;                                       // 0x23B8(0x0004) (Transient)
	float                                              c_fDistanceFadeValue;                                     // 0x23BC(0x0004) (Transient)
	float                                              c_fStealthFadeValue;                                      // 0x23C0(0x0004) (Transient)
	float                                              c_fObscuringDeployableFadeValue;                          // 0x23C4(0x0004) (Transient)
	float                                              c_fBlindingDeployableFadeValue;                           // 0x23C8(0x0004) (Transient)
	float                                              c_fCurrentFadeValue;                                      // 0x23CC(0x0004) (Transient)
	float                                              c_fDistanceLastCollidingVisionRange;                      // 0x23D0(0x0004) (Transient)
	float                                              c_fLocalStealthFadeRate;                                  // 0x23D4(0x0004)
	class UTgSpecialFx*                                c_TeleporterEnterFX;                                      // 0x23D8(0x0008)
	class UTgSpecialFx*                                c_TeleporterExitFX;                                       // 0x23E0(0x0008)
	class UTgSpecialFx*                                c_BlinkEnterFX;                                           // 0x23E8(0x0008)
	class UTgSpecialFx*                                c_BlinkExitFX;                                            // 0x23F0(0x0008)
	class UTgSpecialFx*                                c_DetectedFx;                                             // 0x23F8(0x0008)
	class UTgSpecialFx*                                c_PetSuccessfulHitFx;                                     // 0x2400(0x0008)
	float                                              c_fFxScaleSize;                                           // 0x2408(0x0004) (Const)
	float                                              m_fLifeAfterDeathSecs;                                    // 0x240C(0x0004)
	class AActor*                                      r_aDebugTarget;                                           // 0x2410(0x0008) (Net)
	class AActor*                                      r_aDebugDestination;                                      // 0x2418(0x0008) (Net)
	class AActor*                                      r_aDebugNextNav;                                          // 0x2420(0x0008) (Net)
	struct FVector                                     r_vDebugNextNavMeshPoint;                                 // 0x2428(0x000C) (Net)
	struct FVector                                     r_vDebugSpreadoutLocation;                                // 0x2434(0x000C) (Net)
	int                                                r_nDebugHearingRange;                                     // 0x2440(0x0004) (Net)
	int                                                r_nDebugSightRange;                                       // 0x2444(0x0004) (Net)
	int                                                r_nDebugFOV;                                              // 0x2448(0x0004) (Net)
	struct FString                                     r_sDebugAction;                                           // 0x244C(0x0010) (Net, NeedCtorLink)
	struct FString                                     r_sDebugName;                                             // 0x245C(0x0010) (Net, NeedCtorLink)
	struct FString                                     r_sDebugFactory;                                          // 0x246C(0x0010) (Net, NeedCtorLink)
	struct FVector                                     s_vOneWayMovement;                                        // 0x247C(0x000C)
	struct FVector                                     r_vDown;                                                  // 0x2488(0x000C) (Net)
	float                                              m_fMountFrictionMultiplier;                               // 0x2494(0x0004)
	float                                              m_fBackpedalPct;                                          // 0x2498(0x0004)
	float                                              m_fMountBackpedalPct;                                     // 0x249C(0x0004)
	class AActor*                                      r_TargetActor;                                            // 0x24A0(0x0008) (Net)
	class AActor*                                      r_LockedTarget;                                           // 0x24A8(0x0008) (Net)
	int                                                c_TargetMethod;                                           // 0x24B0(0x0004)
	class ATgPawn*                                     s_Pets[0x8];                                              // 0x24B4(0x0008)
	class ATgPawn*                                     m_PetOwner;                                               // 0x24F4(0x0008)
	int                                                c_ActivePets;                                             // 0x24FC(0x0004)
	class AActor*                                      s_LastAttacker;                                           // 0x2500(0x0008)
	class AActor*                                      s_LastAttacked;                                           // 0x2508(0x0008)
	class AActor*                                      m_CurrentMeleeTarget;                                     // 0x2510(0x0008)
	class ATgPawn*                                     r_Owner;                                                  // 0x2518(0x0008) (Net)
	int                                                s_nSpawnerDeviceInstId;                                   // 0x2520(0x0004)
	int                                                s_nSpawnerDeviceModeId;                                   // 0x2524(0x0004)
	struct FDeathInfo                                  r_DeathInfo;                                              // 0x2528(0x0024) (Net)
	int                                                r_nResetCharacter;                                        // 0x254C(0x0004) (Net)
	int                                                r_nLiveRespawn;                                           // 0x2550(0x0004) (Net)
	struct FName                                       DyingStateName;                                           // 0x2554(0x0008)
	int                                                m_nSpawnLocationId;                                       // 0x255C(0x0004)
	int                                                m_nSpawnTableId;                                          // 0x2560(0x0004)
	int                                                m_nSpawnTableDetailId;                                    // 0x2564(0x0004)
	class APlayerStart*                                m_LastPlayerStart;                                        // 0x2568(0x0008)
	float                                              m_fStandingHeight;                                        // 0x2570(0x0004)
	float                                              m_fStandingRadius;                                        // 0x2574(0x0004)
	float                                              m_fTargetCylinderHeight;                                  // 0x2578(0x0004)
	float                                              m_fTargetCylinderRadius;                                  // 0x257C(0x0004)
	int                                                r_nPacingType;                                            // 0x2580(0x0004) (Net)
	class AActor*                                      m_CurrentUseActor;                                        // 0x2584(0x0008)
	float                                              m_fBaseTranslationOffset;                                 // 0x258C(0x0004)
	float                                              m_fCrouchTranslationOffset;                               // 0x2590(0x0004)
	float                                              r_fInCombatTime;                                          // 0x2594(0x0004) (Net)
	float                                              m_fInCombatTime;                                          // 0x2598(0x0004)
	float                                              m_fBaseCombatTime;                                        // 0x259C(0x0004)
	float                                              m_fPhaseChangeTime;                                       // 0x25A0(0x0004)
	float                                              m_fPhaseChangedTimeStamp;                                 // 0x25A4(0x0004)
	float                                              m_PhaseChangeRemainingTime;                               // 0x25A8(0x0004)
	int                                                r_nPhase;                                                 // 0x25AC(0x0004) (Net)
	int                                                c_PreviousPhase;                                          // 0x25B0(0x0004)
	int                                                m_nInitHUDOverlayDisplayMask;                             // 0x25B4(0x0004) (Const)
	float                                              m_InitHUDOverlayEnemyViewDist;                            // 0x25B8(0x0004) (Const)
	TArray<class UTgAnimNodeSimpleTransitioner*>       m_SimpleTransitionerNodes;                                // 0x25BC(0x0010) (NeedCtorLink)
	TArray<class UTgAnimBlendByFire*>                  m_FireBlendNodes;                                         // 0x25CC(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeBlendByCombatWariness*>    m_CombatWarinessBlendNodes;                               // 0x25DC(0x0010) (NeedCtorLink)
	TArray<class UTgAnimBlendByPosture*>               m_PostureBlendNodes;                                      // 0x25EC(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeBlendByIntroduction*>      m_AnimNodeBlendByIntroductions;                           // 0x25FC(0x0010) (NeedCtorLink)
	TArray<class UTgAnimBlendByFireMode*>              m_DeviceModeBlendNodes;                                   // 0x260C(0x0010) (NeedCtorLink)
	TArray<class USkelControlBase*>                    m_SkelControlLocks;                                       // 0x261C(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeHitReactionOffset*>        m_HitReactionAnimNode;                                    // 0x262C(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeAimOffset_Charge*>         m_AimOffSetChargeAnimNode;                                // 0x263C(0x0010) (NeedCtorLink)
	TArray<class UTgSkelCon_MirrorToOtherMesh*>        m_MirroredSkelControls;                                   // 0x264C(0x0010) (NeedCtorLink)
	TArray<struct FName>                               m_SkelControlLockNames;                                   // 0x265C(0x0010) (NeedCtorLink)
	class UTgAnimNodeSlot*                             m_UpperBodyAnimNode;                                      // 0x266C(0x0008)
	class UAnimNodeSequence*                           m_UpperBodyAnimNodeSequence;                              // 0x2674(0x0008)
	class UTgAnimNodeSlot*                             m_FullBodyAnimNode;                                       // 0x267C(0x0008)
	int                                                m_nYawOffset;                                             // 0x2684(0x0004) (Const, Transient)
	struct FPostureStack                               m_PostureStack;                                           // 0x2688(0x0024) (NeedCtorLink)
	int                                                m_nTotalMarkTypes;                                        // 0x26AC(0x0004) (Const)
	float                                              m_fKnockbackMultiplier;                                   // 0x26B0(0x0004)
	float                                              m_fRBPushStrengthMultiplier;                              // 0x26B4(0x0004) (Edit)
	struct FVector2D                                   m_fRBPushStrengthRange;                                   // 0x26B8(0x0008) (Edit)
	struct FRotator                                    m_PreviousNetReceiveRotation;                             // 0x26C0(0x000C)
	struct FRotator                                    m_TargetNetReceiveRotation;                               // 0x26CC(0x000C)
	float                                              m_RotationInterpRate;                                     // 0x26D8(0x0004)
	int                                                m_nNetRotationCount;                                      // 0x26DC(0x0004)
	int                                                m_nSmoothedRemoteViewPitch;                               // 0x26E0(0x0004)
	int                                                m_nPreviousReceivedRemoteViewPitch;                       // 0x26E4(0x0004)
	int                                                m_nTargetRemoteViewPitch;                                 // 0x26E8(0x0004)
	float                                              m_PitchInterpRate;                                        // 0x26EC(0x0004)
	int                                                m_nNetViewPitchCount;                                     // 0x26F0(0x0004)
	float                                              m_fSmoothCorrectionRate;                                  // 0x26F4(0x0004) (Edit)
	int                                                r_nViewYawWhenRotationLocked;                             // 0x26F8(0x0004) (Net)
	int                                                m_UnpackedRemoteViewPitch;                                // 0x26FC(0x0004)
	int                                                r_nPackedPitchYawForSpectate;                             // 0x2700(0x0004) (Net)
	struct FPointer                                    m_pStatsTracker;                                          // 0x2704(0x0008) (Native)
	float                                              m_fRewindEndFailsafeTTL;                                  // 0x270C(0x0004)
	class ATgPawn*                                     m_LastDamager;                                            // 0x2710(0x0008)
	int                                                m_LastDamagerTimeStamp;                                   // 0x2718(0x0004)
	TArray<struct FPawnDamagerStruct>                  s_Damagers;                                               // 0x271C(0x0010) (NeedCtorLink)
	class ATgPawn*                                     m_LastKnockbacker;                                        // 0x272C(0x0008)
	float                                              m_fJumpLandingTime;                                       // 0x2734(0x0004)
	float                                              m_fCeilingTraceDistForWallJumping;                        // 0x2738(0x0004) (Config)
	float                                              m_fHorseJumpHeightIncrease;                               // 0x273C(0x0004) (Const)
	class AActor*                                      r_StunTauntTarget;                                        // 0x2740(0x0008) (Net)
	TArray<class ATgRespawnBeaconExit*>                m_LocalTouchingRespawnBeacons;                            // 0x2748(0x0010) (NeedCtorLink)
	class ATgPlayerController*                         c_LocalPC;                                                // 0x2758(0x0008)
	class UTgDropShadowDecalComponent*                 c_PlayerDropShadow;                                       // 0x2760(0x0008) (ExportObject, Component, EditInline)
	class UMaterial*                                   c_PlayerDropShadowTemplate;                               // 0x2768(0x0008)
	class UMaterialInstanceConstant*                   c_PlayerDropShadowMIC;                                    // 0x2770(0x0008)
	float                                              c_fPlayerDropShadowFade;                                  // 0x2778(0x0004) (Transient)
	struct FName                                       c_PlayerDropShadowSocketName;                             // 0x277C(0x0008)
	class UClass*                                      DefaultControlModuleClass;                                // 0x2784(0x0008) (Const)
	float                                              m_fFaceRotationInterpTime;                                // 0x278C(0x0004)
	float                                              m_fRemainingFaceRotationInterpTime;                       // 0x2790(0x0004)
	int                                                r_nBigTeleportCount;                                      // 0x2794(0x0004) (Net)
	int                                                c_nTickCheckingState;                                     // 0x2798(0x0004)
	class UTgManifestGroup*                            c_AssetManifestGroup;                                     // 0x279C(0x0008) (ExportObject, NeedCtorLink, EditInline)
	class UTgSpecialFx*                                c_LevelUpFX;                                              // 0x27A4(0x0008)
	int                                                c_nLevelUpFxId;                                           // 0x27AC(0x0004)
	int                                                s_nKillCombo;                                             // 0x27B0(0x0004)
	int                                                s_nKillStreak;                                            // 0x27B4(0x0004)
	int                                                r_nProfileId;                                             // 0x27B8(0x0004) (Net)
	int                                                r_nSettingsOverrideId;                                    // 0x27BC(0x0004) (Net)
	int                                                r_nSkinId;                                                // 0x27C0(0x0004) (Net)
	int                                                r_nWeaponSkinId;                                          // 0x27C4(0x0004) (Net)
	int                                                r_nMountSkinId;                                           // 0x27C8(0x0004) (Net)
	int                                                r_nWardSkinId;                                            // 0x27CC(0x0004) (Net)
	int                                                r_nDeathStampSkinId;                                      // 0x27D0(0x0004) (Net)
	int                                                r_nDeathCardId;                                           // 0x27D4(0x0004) (Net)
	int                                                s_nInitialPlayerId;                                       // 0x27D8(0x0004)
	int                                                c_nHeadSkinId;                                            // 0x27DC(0x0004)
	struct FPointer                                    m_pAmBot;                                                 // 0x27E0(0x0008) (Const, Native)
	struct FPointer                                    m_pAmSkin;                                                // 0x27E8(0x0008) (Const, Native)
	struct FPointer                                    m_pAmWeaponSkin;                                          // 0x27F0(0x0008) (Const, Native)
	struct FPointer                                    m_pAmMountSkin;                                           // 0x27F8(0x0008) (Const, Native)
	TArray<struct FPointer>                            m_pAmAllSkins;                                            // 0x2800(0x0010) (Const, Native)
	int                                                c_StunnedPostureID;                                       // 0x2810(0x0004)
	int                                                c_FearedPostureID;                                        // 0x2814(0x0004)
	int                                                c_DisarmedPostureID;                                      // 0x2818(0x0004)
	TArray<class APlayerController*>                   s_Viewers;                                                // 0x281C(0x0010) (NeedCtorLink)
	class ATgCarriedFlag*                              m_CurrentFlag;                                            // 0x282C(0x0008) (Transient)
	float                                              m_fLastCTFVolumeTimestamp;                                // 0x2834(0x0004) (Transient)
	float                                              m_fDamageTakenRTPC;                                       // 0x2838(0x0004)
	float                                              m_fDamageTakenMax;                                        // 0x283C(0x0004)
	float                                              m_fDamageTakenMaxSustainDuration;                         // 0x2840(0x0004)
	float                                              m_fDamageTakenRTPCSustainDuration;                        // 0x2844(0x0004)
	TArray<struct FPawnDamageMitigator>                s_PawnDamageMitigators;                                   // 0x2848(0x0010) (NeedCtorLink)
	TArray<struct FOverlayInfo>                        m_OverlayInfosBody;                                       // 0x2858(0x0010) (Edit, Component, NeedCtorLink)
	TArray<struct FOverlayInfo>                        m_OverlayInfosWeapon;                                     // 0x2868(0x0010) (Edit, Component, NeedCtorLink)
	class UMaterialInstanceConstant*                   m_ExecuteOverlayMaterialFriend;                           // 0x2878(0x0008) (Const)
	class UMaterialInstanceConstant*                   m_ExecuteOverlayMaterialEnemy;                            // 0x2880(0x0008) (Const)
	class UMaterialInstanceConstant*                   m_ShieldOverlayMaterialFriend;                            // 0x2888(0x0008) (Const)
	class UMaterialInstanceConstant*                   m_ShieldOverlayMaterialEnemy;                             // 0x2890(0x0008) (Const)
	class UMaterialInstanceConstant*                   m_ImmortalOverlayMaterialFriend;                          // 0x2898(0x0008) (Const)
	class UMaterialInstanceConstant*                   m_ImmortalOverlayMaterialEnemy;                           // 0x28A0(0x0008) (Const)
	class UMaterialInstanceConstant*                   m_CharacterCustom1OverlayMaterial;                        // 0x28A8(0x0008) (Const)
	class UMaterialInstanceConstant*                   m_FreezeOverlayMaterial;                                  // 0x28B0(0x0008) (Const)
	TArray<struct FSilhouetteInfo>                     m_SilhouetteInfos;                                        // 0x28B8(0x0010) (Transient, Component, NeedCtorLink)
	class UClass*                                      m_SilhouetteClass;                                        // 0x28C8(0x0008) (Edit)
	TArray<int>                                        m_IgnoredHitPulseIndicies;                                // 0x28D0(0x0010) (NeedCtorLink)
	float                                              m_fFadeOutTime;                                           // 0x28E0(0x0004) (Edit)
	float                                              m_fFadeOutSpeed;                                          // 0x28E4(0x0004) (Edit)
	class UTgSpecialFx*                                m_DeathAnimFX;                                            // 0x28E8(0x0008)
	float                                              m_fRemainingHitReactionPulseTime;                         // 0x28F0(0x0004)
	float                                              m_fHitReactionPulseTime;                                  // 0x28F4(0x0004) (Edit)
	float                                              m_fDisorientSpinRate;                                     // 0x28F8(0x0004) (Edit)
	float                                              s_fMaxRelevancyDistanceSquared;                           // 0x28FC(0x0004)
	float                                              m_fMaxSmoothNetUpdateDist;                                // 0x2900(0x0004)
	float                                              m_fNoSmoothNetUpdateDist;                                 // 0x2904(0x0004)
	float                                              m_fSmoothNetUpdateTime;                                   // 0x2908(0x0004)
	struct FVector                                     m_vMeshTranslationOffset;                                 // 0x290C(0x000C)
	float                                              m_fInitialHealthPercent;                                  // 0x2918(0x0004)
	float                                              c_fHUDHealthPercent;                                      // 0x291C(0x0004)
	float                                              m_fDamageDealtPercentAI;                                  // 0x2920(0x0004)
	float                                              m_fDamageTakenPercentAI;                                  // 0x2924(0x0004)
	TArray<struct FHealingInfo>                        s_RecentHealList;                                         // 0x2928(0x0010) (NeedCtorLink)
	float                                              m_fRecentHealExpireTime;                                  // 0x2938(0x0004) (Const)
	int                                                m_nCloneExpirationAttacksCount;                           // 0x293C(0x0004)
	float                                              m_fCloneLeashRange;                                       // 0x2940(0x0004)
	float                                              m_fCloneExpirationTime;                                   // 0x2944(0x0004)
	class ATgRepInfo_Player*                           r_CloneParentPRI;                                         // 0x2948(0x0008) (Net)
	class ATgWeaponMeshActor*                          m_WeaponMesh;                                             // 0x2950(0x0008)
	class UTgSkeletalMeshComponent*                    m_BodyMesh;                                               // 0x2958(0x0008) (ExportObject, Component, EditInline)
	class UTgSkeletalMeshComponent*                    m_HeadMesh;                                               // 0x2960(0x0008) (ExportObject, Component, EditInline)
	int                                                m_HeadSilhouetteIndex;                                    // 0x2968(0x0004)
	int                                                m_HeadOverlayIndex;                                       // 0x296C(0x0004)
	int                                                r_nBodyMeshOverride;                                      // 0x2970(0x0004) (Net)
	int                                                r_nHeadMeshOverride;                                      // 0x2974(0x0004) (Net)
	int                                                c_nCurrentHeadMeshID;                                     // 0x2978(0x0004)
	float                                              m_BobFootstepFactor;                                      // 0x297C(0x0004) (Edit, Const)
	float                                              Bob;                                                      // 0x2980(0x0004)
	float                                              m_fVerticalBob;                                           // 0x2984(0x0004)
	float                                              m_fBobRate;                                               // 0x2988(0x0004)
	float                                              LandBob;                                                  // 0x298C(0x0004)
	float                                              JumpBob;                                                  // 0x2990(0x0004)
	float                                              AppliedBob;                                               // 0x2994(0x0004)
	float                                              BobTime;                                                  // 0x2998(0x0004)
	struct FVector                                     WalkBob;                                                  // 0x299C(0x000C)
	float                                              m_fOldZ;                                                  // 0x29A8(0x0004)
	struct FVector                                     AimSpot;                                                  // 0x29AC(0x000C)
	struct FVector                                     AimNoise;                                                 // 0x29B8(0x000C)
	float                                              m_fAimSpotsetLastRefresh;                                 // 0x29C4(0x0004)
	float                                              m_fAimNoiseLastRefresh;                                   // 0x29C8(0x0004)
	float                                              m_fAimPitch;                                              // 0x29CC(0x0004)
	class UAudioComponent*                             m_TakeHitAudioComponent;                                  // 0x29D0(0x0008) (ExportObject, Component, EditInline)
	class UAudioComponent*                             m_PainAudioComponent;                                     // 0x29D8(0x0008) (ExportObject, Component, EditInline)
	class UAkEvent*                                    m_TakeHitAkEvent;                                         // 0x29E0(0x0008)
	class UAkEvent*                                    m_TakeHeadShotAkEvent;                                    // 0x29E8(0x0008)
	class UAkEvent*                                    c_HealPlayAkEvent;                                        // 0x29F0(0x0008)
	class UAkEvent*                                    c_HealStopAkEvent;                                        // 0x29F8(0x0008)
	class UAkEvent*                                    m_PainAkEvent;                                            // 0x2A00(0x0008)
	float                                              m_fLastPainEvent;                                         // 0x2A08(0x0004)
	float                                              m_fPainEventCooldown;                                     // 0x2A0C(0x0004)
	class UTgAnimNodePlayFireAnim*                     m_FireAnimNode;                                           // 0x2A10(0x0008)
	class UTgEffectGroup*                              m_StealthPulseEffectGroup;                                // 0x2A18(0x0008)
	float                                              m_fStealthPulseTime;                                      // 0x2A20(0x0004)
	float                                              r_fKnockedBackFrictionOverride;                           // 0x2A24(0x0004) (Net)
	struct FVector                                     r_vKnockedBackVelocityOverride;                           // 0x2A28(0x000C) (Net)
	float                                              m_fExtraLifestealOneTime;                                 // 0x2A34(0x0004)
	int                                                r_nIncomingImpactCount;                                   // 0x2A38(0x0004) (Net)
	float                                              r_fReloadScale;                                           // 0x2A3C(0x0004) (Net)
	class ATgPawn*                                     r_HealTarget;                                             // 0x2A40(0x0008) (Net)
	class UTgParticleSystemComponent*                  c_HealingBeamPSC;                                         // 0x2A48(0x0008) (Edit, ExportObject, Component, EditInline)
	class UTgSkeletalMeshComponent*                    m_OutlineMesh;                                            // 0x2A50(0x0008) (ExportObject, Transient, Component, EditInline)
	class UMaterialInstanceConstant*                   m_OutlineMaterial;                                        // 0x2A58(0x0008)
	class ATgNearObjectiveVolume*                      m_NearObjectiveVolume;                                    // 0x2A60(0x0008)
	float                                              r_fLeapAirControl;                                        // 0x2A68(0x0004) (Net)
	float                                              m_fBaseLeapAirControl;                                    // 0x2A6C(0x0004)
	float                                              m_fKnockAirControl;                                       // 0x2A70(0x0004)
	TArray<class ATgDeviceVolume*>                     m_HomeguardVolumes;                                       // 0x2A74(0x0010) (NeedCtorLink)
	float                                              m_LastHomeguardTime;                                      // 0x2A84(0x0004)
	class UTgSkeletalMeshComponent*                    m_MountMesh;                                              // 0x2A88(0x0008) (ExportObject, Component, EditInline)
	int                                                m_nMountPostureId;                                        // 0x2A90(0x0004)
	float                                              s_fEndStealthDamage;                                      // 0x2A94(0x0004) (Config)
	float                                              s_fDamageTakenDuringStealth;                              // 0x2A98(0x0004)
	float                                              m_fHUDOverlayZOffset;                                     // 0x2A9C(0x0004) (Edit)
	float                                              m_fHUDOverlayMorphMountedZOffset;                         // 0x2AA0(0x0004) (Edit)
	int                                                m_lastDamageSourceSlot;                                   // 0x2AA4(0x0004)
	float                                              m_fLastMoveTime;                                          // 0x2AA8(0x0004)
	class ATgDeployable*                               s_AttachedProjBlocker;                                    // 0x2AAC(0x0008)
	float                                              m_fScaleMesh;                                             // 0x2AB4(0x0004) (Edit)
	float                                              m_fScaleMeshChangePerSecond;                              // 0x2AB8(0x0004) (Edit)
	float                                              m_fScaleCollisionHeight;                                  // 0x2ABC(0x0004) (Edit)
	float                                              m_fScaleCollisionHeightChangePerSecond;                   // 0x2AC0(0x0004) (Edit)
	float                                              m_fScaleCollisionRadius;                                  // 0x2AC4(0x0004) (Edit)
	float                                              m_fScaleCollisionRadiusChangePerSecond;                   // 0x2AC8(0x0004) (Edit)
	int                                                m_IntroPostureID;                                         // 0x2ACC(0x0004)
	float                                              r_fIntroTime;                                             // 0x2AD0(0x0004) (Net)
	float                                              r_fIntroOffset;                                           // 0x2AD4(0x0004) (Net)
	float                                              s_fIntroStartTime;                                        // 0x2AD8(0x0004)
	float                                              m_fIntroProgress;                                         // 0x2ADC(0x0004)
	struct FName                                       r_ReplicatedState;                                        // 0x2AE0(0x0008) (Net)
	TArray<class UAnimNodeSequence*>                   m_RespawnNodes;                                           // 0x2AE8(0x0010) (NeedCtorLink)
	TArray<class UTgAnimBlendByBuffMonsterIntro*>      m_BuffCampIntroNodes;                                     // 0x2AF8(0x0010) (NeedCtorLink)
	struct FName                                       m_IntialIntroState;                                       // 0x2B08(0x0008)
	struct FName                                       m_nmIntroWhiteOutParamName;                               // 0x2B10(0x0008)
	float                                              m_fIntroWhiteOutScale;                                    // 0x2B18(0x0004)
	float                                              m_fIntroWhiteOutUpTime;                                   // 0x2B1C(0x0004)
	float                                              m_fIntroWhiteOutDownTime;                                 // 0x2B20(0x0004)
	int                                                r_nInsideTaskForceBase;                                   // 0x2B24(0x0004) (Net)
	class UTgSpecialFx*                                m_HealFX3P;                                               // 0x2B28(0x0008)
	class UTgSpecialFx*                                m_ShieldFX3P;                                             // 0x2B30(0x0008)
	float                                              c_fNextTakeHitDisplayGroupTimestamp;                      // 0x2B38(0x0004)
	float                                              c_fNextTakeHitDisplayDelay;                               // 0x2B3C(0x0004)
	class AActor*                                      r_PolymorphInstigator;                                    // 0x2B40(0x0008) (Net)
	int                                                m_PrePolymorphHealth;                                     // 0x2B48(0x0004)
	int                                                m_PolymorphMaxHealth;                                     // 0x2B4C(0x0004)
	TArray<struct FRigidBodyImpactInfo>                m_RigidBodyImpacts;                                       // 0x2B50(0x0010) (NeedCtorLink)
	float                                              c_fServerTimeStamp;                                       // 0x2B60(0x0004)
	float                                              m_fZoomDistOverride;                                      // 0x2B64(0x0004)
	float                                              m_fZoomDurationOverride;                                  // 0x2B68(0x0004)
	float                                              r_fLastReplicatedInhandAccuracy;                          // 0x2B6C(0x0004) (Net)
	struct FDouble                                     c_fLastUnoccludedWeaponSoundTimestamp;                    // 0x2B70(0x0008)
	float                                              c_fThreatBehind;                                          // 0x2B78(0x0004)
	float                                              c_fThreatInEffectiveRange;                                // 0x2B7C(0x0004)
	float                                              c_fThreatDistanceSquared;                                 // 0x2B80(0x0004)
	float                                              c_fThreatDistance;                                        // 0x2B84(0x0004)
	float                                              c_fThreatFocused;                                         // 0x2B88(0x0004)
	float                                              c_fThreatFocusTarget;                                     // 0x2B8C(0x0004)
	float                                              c_fThreatSeenBy;                                          // 0x2B90(0x0004)
	float                                              c_fThreatDamaged;                                         // 0x2B94(0x0004)
	float                                              c_fThreatOcclusion;                                       // 0x2B98(0x0004)
	float                                              c_fThreatBinnedOcclusion;                                 // 0x2B9C(0x0004)
	float                                              c_fThreatShotAt;                                          // 0x2BA0(0x0004)
	float                                              c_fThreatUlt;                                             // 0x2BA4(0x0004)
	float                                              c_fThreatLevelValue;                                      // 0x2BA8(0x0004)
	float                                              c_fThreatDecayResidual;                                   // 0x2BAC(0x0004)
	float                                              c_fLastThreatLevelValue;                                  // 0x2BB0(0x0004)
	float                                              c_fDBGThreatDistanceFeet;                                 // 0x2BB4(0x0004)
	class UTgGameplayCurves*                           m_GameplayCurves;                                         // 0x2BB8(0x0008)
	int                                                m_nSuccessfulHitSpecialFXId;                              // 0x2BC0(0x0004)
	TArray<struct FName>                               LLegBoneNames;                                            // 0x2BC4(0x0010) (NeedCtorLink)
	TArray<struct FName>                               RLegBoneNames;                                            // 0x2BD4(0x0010) (NeedCtorLink)
	TArray<struct FName>                               LArmBoneNames;                                            // 0x2BE4(0x0010) (NeedCtorLink)
	TArray<struct FName>                               RArmBoneNames;                                            // 0x2BF4(0x0010) (NeedCtorLink)
	TArray<struct FName>                               HeadBoneNames;                                            // 0x2C04(0x0010) (NeedCtorLink)
	struct FName                                       m_HeadShotBoneName;                                       // 0x2C14(0x0008)
	float                                              m_fMountScaleOverride;                                    // 0x2C1C(0x0004) (Edit)
	class UTgCameraShake*                              m_LandCameraShake;                                        // 0x2C20(0x0008)
	class UTgCameraShake*                              m_JumpCameraShake;                                        // 0x2C28(0x0008)
	float                                              m_f1PTransitionFireDelay;                                 // 0x2C30(0x0004)
	float                                              m_f1PTransitionFireDelayRemaining;                        // 0x2C34(0x0004) (Transient)
	float                                              m_fEnergyChargeMultiplier;                                // 0x2C38(0x0004)
	float                                              c_fRecreateTrackedProjectilesTimer;                       // 0x2C3C(0x0004)
	float                                              m_fRecoilSmoothRate;                                      // 0x2C40(0x0004)
	struct FRotator                                    m_rCurrentRecoil;                                         // 0x2C44(0x000C)
	struct FRotator                                    m_rSmoothedRecoil;                                        // 0x2C50(0x000C)
	struct FRotator                                    m_rLastAppliedRecoil;                                     // 0x2C5C(0x000C)
	float                                              m_fSettleDelay;                                           // 0x2C68(0x0004)
	float                                              m_fSettleSpeed;                                           // 0x2C6C(0x0004)
	float                                              m_fRecoilSettleDeltaTimeOverflow;                         // 0x2C70(0x0004)
	float                                              m_fRecoilSmoothDeltaTimeOverflow;                         // 0x2C74(0x0004)
	struct FRotator                                    m_rVisualRecoil;                                          // 0x2C78(0x000C)
	float                                              m_fVisualRecoilApplicationTime;                           // 0x2C84(0x0004)
	float                                              m_fVisualRecoilDuration;                                  // 0x2C88(0x0004)
	class UTgGameplayCurvesSet_RecoilVisual*           m_VisualRecoilApplied;                                    // 0x2C8C(0x0008)
	struct FName                                       r_nmVoicePkg;                                             // 0x2C94(0x0008) (Net)
	struct Fdword                                      r_eVoicePref;                                             // 0x2C9C(0x0004) (Net)
	TArray<struct FKnockbackHit>                       m_vPendingWallKnockbackHits;                              // 0x2CA0(0x0010) (NeedCtorLink)
	TArray<int>                                        m_nPendingPlayerKnockbackHitPawnIds;                      // 0x2CB0(0x0010) (NeedCtorLink)
	float                                              m_fTimeOnNonBaseableSurface;                              // 0x2CC0(0x0004)
	float                                              m_fNonBaseableSurfaceAirControlDuration;                  // 0x2CC4(0x0004)
	float                                              m_fNonBaseableSurfaceLerpTime;                            // 0x2CC8(0x0004)
	float                                              m_fNonBaseableSurfaceRampUpMult;                          // 0x2CCC(0x0004)
	float                                              m_fNonBaseableSurfaceMaxMoveAmount;                       // 0x2CD0(0x0004)
	float                                              m_fNonBaseableSurfaceGraceTime;                           // 0x2CD4(0x0004)
	float                                              m_fNonBaseableSurfaceExitMaxVelocity;                     // 0x2CD8(0x0004)
	float                                              m_fNonBaseableSurfaceControlPercent;                      // 0x2CDC(0x0004)
	TArray<class UMaterialInterface*>                  m_OriginalMaterialsBody;                                  // 0x2CE0(0x0010) (NeedCtorLink)
	TArray<class UMaterialInterface*>                  m_OriginalMaterialsHead;                                  // 0x2CF0(0x0010) (NeedCtorLink)
	TArray<class UMaterialInterface*>                  m_OriginalMaterialsWeapon;                                // 0x2D00(0x0010) (NeedCtorLink)
	TArray<class UMaterialInstanceConstant*>           m_ReplacementMICsBody;                                    // 0x2D10(0x0010) (NeedCtorLink)
	TArray<class UMaterialInstanceConstant*>           m_ReplacementMICsHead;                                    // 0x2D20(0x0010) (NeedCtorLink)
	TArray<class UMaterialInstanceConstant*>           m_ReplacementMICsWeapon;                                  // 0x2D30(0x0010) (NeedCtorLink)
	float                                              m_fEyeHeightSmoothFactor;                                 // 0x2D40(0x0004)
	class UForceFeedbackWaveform*                      m_DeathFFWaveform;                                        // 0x2D44(0x0008)
	class ATgDevice*                                   m_BuffDevice;                                             // 0x2D4C(0x0008)
	class ATgDevice*                                   m_PrincessPresenceDebuffDevice;                           // 0x2D54(0x0008)
	class ATgDevice*                                   m_PrincessPresenceBuffDevice;                             // 0x2D5C(0x0008)
	float                                              m_fFlourishTimeout;                                       // 0x2D64(0x0004)
	int                                                c_nCurrentVGSPlaying;                                     // 0x2D68(0x0004)
	TArray<struct FScriptDelegate>                     m_SingleUseOn3pTransitionDelegates;                       // 0x2D6C(0x0010) (NeedCtorLink)
	TArray<struct FScriptDelegate>                     m_SingleUseOnPhysTweenEndedDelegates;                     // 0x2D7C(0x0010) (NeedCtorLink)
	TArray<struct FScriptDelegate>                     m_SingleUseOnJumpDelegates;                               // 0x2D8C(0x0010) (NeedCtorLink)
	class UTgSpecialFx*                                m_MountCastFX3P;                                          // 0x2D9C(0x0008)
	class UTgSpecialFx*                                m_MountSummonFX3P;                                        // 0x2DA4(0x0008)
	struct FVector                                     c_vForced3pAdditionalOffset;                              // 0x2DAC(0x000C) (Config)
	struct FVector                                     c_v3pOffsetTest;                                          // 0x2DB8(0x000C)
	struct FVector                                     c_v3pOffsetTestMounted;                                   // 0x2DC4(0x000C)
	struct FVector                                     c_vMountCameraOffset[0x3];                                // 0x2DD0(0x000C) (Config)
	struct FVector                                     m_vCameraOverrideLocation;                                // 0x2DF4(0x000C)
	struct FString                                     m_sBotCodeNameOverride;                                   // 0x2E00(0x0010) (Const, NeedCtorLink)
	float                                              m_fHazardDistance;                                        // 0x2E10(0x0004)
	float                                              m_fHazardRating;                                          // 0x2E14(0x0004)
	float                                              c_fSimModMoveSpeedToSave;                                 // 0x2E18(0x0004)
	float                                              c_fSavedSimModMoveSpeed;                                  // 0x2E1C(0x0004)
	float                                              c_fSimModGravityToSave;                                   // 0x2E20(0x0004)
	float                                              c_fSavedSimModGravity;                                    // 0x2E24(0x0004)
	float                                              m_fSteepTerrainWalkableFloorZ;                            // 0x2E28(0x0004)
	float                                              m_fSteepTerrainSlowMultiplierSmall;                       // 0x2E2C(0x0004)
	float                                              m_fSteepTerrainSlowMultiplierMid;                         // 0x2E30(0x0004)
	float                                              m_fSteepTerrainSlowMultiplierLarge;                       // 0x2E34(0x0004)
	float                                              m_fSteepTerrainSlopeZMidBreakpoint;                       // 0x2E38(0x0004)
	class UTgSpecialFx*                                m_CameraInvisFX3P;                                        // 0x2E3C(0x0008)
	TArray<class ATgIndoorVolume*>                     m_TouchingIndoorVolumes;                                  // 0x2E44(0x0010) (NeedCtorLink)
	class UAudioLUT*                                   m_Lut;                                                    // 0x2E54(0x0008) (Transient)
	int                                                s_nMctsPlayerId;                                          // 0x2E5C(0x0004)
	float                                              m_fHitBoneValidation;                                     // 0x2E60(0x0004) (Config)
	TArray<int>                                        m_nExtraTimerBarEqpSlots;                                 // 0x2E64(0x0010) (NeedCtorLink)
	class UPComPositionHistoryServerComponent*         m_CachedPositionHistoryServerComponent;                   // 0x2E74(0x0008) (ExportObject, Component, EditInline)
	class UTgCallbackContainer*                        m_CallbackContainer;                                      // 0x2E7C(0x0008)
	TArray<class UTgPawnMod*>                          m_PawnMods;                                               // 0x2E84(0x0010) (NeedCtorLink)
	struct FName                                       m_nmAppliedBlindPostProcess;                              // 0x2E94(0x0008)
	struct FScriptDelegate                             __On3pTransitionEvent__Delegate;                          // 0x2E9C(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData01[0x4];                                       // 0x2E9C(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY
	struct FScriptDelegate                             __OnPhysTweenEndEvent__Delegate;                          // 0x2EAC(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData02[0x4];                                       // 0x2EAC(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY
	struct FScriptDelegate                             __OnJumpEvent__Delegate;                                  // 0x2EBC(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData03[0x4];                                       // 0x2EBC(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn");
		return ptr;
	}


	void STATIC_TIMER_CANNOT_BE_STUCK();
	void OnPlayerReconnected();
	void STATIC_NotifyResetPawn();
	void ServerRequestFiremodeModifications();
	bool STATIC_IsIndoors();
	void ServerResetDebugPropertyMods(const struct FString& sProperty);
	void ServerApplyDebugPropertyMod(const struct FString& sProperty, bool bPercent, float fModifier1, float fModfier2, float fModifier3, float fModifier4, float fModifier5, float fModifier6);
	float STATIC_GetCameraPenetrationCheckRadius();
	struct FVector STATIC_GetCameraTranslationOverride(const struct FVector& originalTranslation, TEnumAsByte<ECameraPerspectiveType> ePerspectiveType, const struct FRotator& currentOrientation);
	struct FVector STATIC_GetCameraOriginOverride(const struct FVector& originalOrigin, TEnumAsByte<ECameraPerspectiveType> ePerspectiveType);
	void OnEmoteSoundFinished();
	void ServerOnEmoteEnded();
	void OnEmoteSoundPlayed(TEnumAsByte<EEmote> Emote);
	void OnVGSSoundFinished();
	void OnVGSSoundPlayed(int nVgsId);
	void EnableMovementCorrection();
	void DisableMovementCorrection(float fDisableTime);
	void STATIC_InvokeOnJumpDelegates();
	void RegisterForOnJumpCB(const struct FScriptDelegate& EventDelegate);
	void STATIC_InvokePhysTweenEndDelegates();
	void STATIC_UnregisterForPhysTweenEndCB(const struct FScriptDelegate& EventDelegate);
	void RegisterForPhysTweenEndCB(const struct FScriptDelegate& EventDelegate);
	void STATIC_Invoke3pTransitionDelegates();
	void RegisterFor3pTransitionCB(const struct FScriptDelegate& EventDelegate);
	void AppliedEffectRemoved(class UTgEffect* RemovedEffect);
	void StartFlourish();
	void STATIC_FlourishTimeoutFinished();
	void ServerStartFlourish();
	void ResetPermanentEffects();
	void ResetUlt();
	float STATIC_GetEnergyChargeModifier();
	float STATIC_GetReloadScale();
	void STATIC_ForwardEffects(const struct FImpactInfo& Impact, class UTgEffectGroup* effectGroup, class ATgDevice* SourceDevice, bool bRemove, int StackCount);
	void SetFaceRotationToController();
	void ToggleHealAkEvent(bool bEnable);
	void UpdateHUDHealthPercent(float fPercent);
	void SetHUDOverlayEnemyViewDist(float enemyViewDist);
	void SetHUDOverlayState(TEnumAsByte<EDeployableOverlayState> dos);
	void SetHUDOverlayIcon(TEnumAsByte<EDeployableOverlayIcon> doi);
	void SetHUDOverlayDisplayMask(int dodm);
	float CheckOcclusion();
	void SetThreatLevel(TEnumAsByte<EThreatLevel> NewThreatLevel);
	void OnCeaseSpectatorViewTarget();
	void OnBecameSpectatorViewTarget();
	void ForceUpdateAmmoAnim();
	void AllowDeviceToModifyInput(class UTgPlayerInput* tgInput);
	struct FRotator ApplyCameraRotationModifier(const struct FRotator& rCameraRot);
	void OnPolymorphChanged(bool bDead);
	void RecreateTrackedProjectiles();
	void PrepTrackedProjectileRecreation(float recreateTimeOut);
	void PostTimeLapse(bool bPlayOfTheGame);
	void PreTimeLapse(bool bPlayOfTheGame);
	void STATIC_SetAux(const struct FName& AuxBusName, float Level);
	void PlayPolymorphEffects(bool bForceOff);
	int STATIC_GetPolymorphMeshID();
	void SetPolymorph(TEnumAsByte<EPolymorphType> NewPolymorph, class AActor* instigatingActor);
	void Polymorph(TEnumAsByte<EPolymorphType> NewPolymorph);
	struct FVector STATIC_GetCameraOffsetOverride(const struct FVector& originalOffset, TEnumAsByte<ECameraPerspectiveType> ePerspectiveType);
	struct FVector STATIC_GetMountCameraOffset(TEnumAsByte<EMountType> MountType);
	struct FVector STATIC_GetForced3pAdditionalOffset();
	void OnStartTimelapseNewDeviceState();
	void PlayGenericTakeHit(const struct FVector& HitLocation, const struct FVector& HitNormal, class ATgPawn* HitInstigator, float fDamageAmount, struct FExtraDamageInfo* ExtraInfo);
	void PlayFXHoldsBeacon(bool bShouldPlay);
	void ClientUpdateHasRespawnBeacon(bool bHasRespawnBeacon);
	void STATIC_UpdateHasRespawnBeacon(bool bHasRespawnBeacon);
	void TouchingRespawnBeaconExit(class ATgRespawnBeaconExit* RespawnBeacon, bool IsTouching);
	class ATgRespawnBeaconExit* STATIC_GetTouchingRespawnBeacon();
	void SetInitialHUDOverlayInfo();
	void FinishedIntroAnim(class UAnimNode* IntroAnimNode);
	void STATIC_ExitIntroPosture(bool bForceAnimTreeOut);
	void STATIC_EnterIntroPosture();
	void SetupIntroAnimNodesAndTimers();
	void DoIntroduction(bool bUseInitialIntro);
	bool IsPlayingIntro();
	void BeginWhiteOutScaleUp();
	void SetWhiteOutStartTimer();
	void STATIC_IntroTimer();
	void STATIC_EndWhiteOut();
	void STATIC_UpdateWhiteOut();
	void RemoveBlindingDeployable(class ATgDeployable* deployable);
	void AddBlindingDeployable(class ATgDeployable* deployable);
	void RemoveObscuringDeployable(class ATgDeployable* deployable);
	void AddObscuringDeployable(class ATgDeployable* deployable);
	bool STATIC_IsInstigatorStealthRevealed(class AActor* Viewer);
	void RemoveInstigatorStealthReveal(class AActor* Viewer);
	void AddInstigatorStealthReveal(class AActor* Viewer);
	bool IsInstigatorWallRevealed(class AActor* Viewer);
	void RemoveInstigatorWallReveal(class AActor* Viewer);
	void AddInstigatorWallReveal(class AActor* Viewer);
	void STATIC_GetAnimSetStrings(TEnumAsByte<EMountType> MountType, TArray<struct FString>* sPaths);
	void STATIC_UpdateLastPlayerStart(class APlayerStart* NewLastPlayerStart);
	class UTgSpecialFx* TestFx2(int Id);
	void TestFx(float Pct);
	TEnumAsByte<EBotBehaviorState> STATIC_GetBotBehaviorState();
	void STATIC_UpdateBotBehaviorState(TEnumAsByte<EBotBehaviorState> NewState);
	TEnumAsByte<EMetaGameState> STATIC_GetMetaGameState();
	void STATIC_UpdateMetaGameState(TEnumAsByte<EMetaGameState> NewState);
	void ClientSetActiveWeapon(class AWeapon* NewWeapon);
	void AddIncomingImpact(int bNumToAdd);
	void SetUITargetingType(TEnumAsByte<EUITargetingType> NewTargetingType, bool bForceRequiredToSet, TEnumAsByte<EUITargetingType> RequiredToSet);
	float GetDistanceToNearestCapturePoint();
	void InterruptAllMovementDevices();
	void InterruptDeviceFiringByClass(class UClass* DeviceClass, bool bForce);
	class ATgDevice* GetActiveDeviceByClass(const struct FName& DeviceClassName);
	class ATgDevice* GetDeviceByClass(class UClass* DeviceClass);
	bool HasActiveDeviceByClass(const struct FName& DeviceClassName);
	bool HasDeviceByClass(class UClass* DeviceClass);
	bool HasActiveDeviceByID(int DeviceID);
	bool HasDeviceByID(int DeviceID);
	void InterruptInhandReload();
	void STATIC_InterruptAllReloads();
	void PlayRevealedEffects(bool bEnabled);
	void PlaySlowEffects(bool bEnabled);
	void STATIC_CleanUpBlindPostProcess();
	void PlayBlindEffects(bool bEnabled);
	void PlayCrippledEffects(bool bEnabled);
	void PlayPoisonedEffects(bool bEnabled);
	void PlayRootEffects(bool bEnabled);
	void ClientPlayHiddenEffects(bool bEnabled, class UParticleSystem* Template);
	void ClientPlayGrassEffects(bool bEnabled, class UParticleSystem* Template);
	void PlayMarkEffects(bool bEnabled);
	void PlayKnockbackEffects(bool bEnabled);
	void PlayFreezeEffects(bool bEnabled);
	void PlayOnFireEffects(bool bEnabled);
	void PlayCCImmuneEffects(bool bEnabled);
	void PlayDazeEffects(bool bEnabled);
	void PlayBleedEffects(bool bEnabled);
	void RemoveStealthEffects();
	bool IsFirstPerson();
	void SwitchBackToInhandInstantly();
	void OnMountBegin(bool bForceFireDueToRespawn);
	void StopMountingEffects();
	void CreateMountMeshAndEffects();
	struct FName STATIC_GetMountAimProfile();
	void STATIC_CheckMountMeshSocketAttachments(bool bMounting);
	bool DeferCreateMountMesh();
	void PlayMountingEffects();
	bool STATIC_CheckDeviceCancelOffhandSlotPressed(class ATgDevice* newDev);
	bool CanApplyShield();
	bool STATIC_IsRotationLocked();
	bool STATIC_IsInputLocked();
	void OnCameraCutAnimNotify(class UTgAnimNotify_CameraCut* CameraCutNotify);
	void KillCloneTimer();
	void SetMeshDepthPriority(TEnumAsByte<ESceneDepthPriorityGroup> NewDepth);
	TEnumAsByte<ETG_EQUIP_POINT> OverrideOffhandSlot(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	void STATIC_InterruptInhand();
	bool IsInJumpLanding();
	bool CannotJumpNow();
	bool STATIC_IsFiringAny();
	bool CheckPhysicsStateForJumping();
	bool CanFlyWithoutHover();
	void AdjustDevicesForNewDilation(float fPrevDilation, float fNewDilation);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void PostDemoRewind();
	void PreDemoRewind();
	bool AnimNotifySound(class USoundCue* Cue);
	bool EmoteShouldKillAllOtherVox(TEnumAsByte<EEmote> Emote);
	bool IsEmoteOnNonLocalCooldown(TEnumAsByte<EEmote> Emote);
	bool AreEmotesOnGlobalCooldown();
	bool IsEmoteOnInternalCooldown(TEnumAsByte<EEmote> Emote);
	float GetLastEmoteTime(TEnumAsByte<EEmote> Emote);
	void RecordNonLocalEmoteTime();
	void RecordGlobalEmoteTime();
	void RecordInternalEmoteTime(TEnumAsByte<EEmote> Emote);
	float GetEmoteInternalCooldown(TEnumAsByte<EEmote> Emote);
	bool RespectsEmoteGlobalCooldown(TEnumAsByte<EEmote> Emote);
	bool TriggersEmoteGlobalCooldown(TEnumAsByte<EEmote> Emote);
	bool EmoteDiceRoll(TEnumAsByte<EEmote> Emote);
	float GetEmoteChance(TEnumAsByte<EEmote> Emote);
	float GetAbilityEmoteChance(TEnumAsByte<EEmote> Emote);
	TEnumAsByte<EEmoteCategory> GetEmoteCategory(TEnumAsByte<EEmote> Emote);
	bool CanEmoteDuringTimelapse(TEnumAsByte<EEmote> Emote);
	void ClientPlayEmote(TEnumAsByte<EEmote> Emote, int nExtraInfo);
	void PlayEmoteSelfOnly(TEnumAsByte<EEmote> Emote, int nExtraInfo);
	void PlayDeviceEmoteAll(class ATgDevice* Dev, bool bCallOnOwner);
	TEnumAsByte<EEmote> STATIC_GetDeviceEmoteType(class ATgDevice* Dev);
	struct FString STATIC_GetVGSCustomSuffix();
	struct FString STATIC_GetEmoteSuffix(TEnumAsByte<EEmote> Emote, int ExtraInfo);
	class UAkEvent* STATIC_GetVoxKillAkEvent(int BotId, TEnumAsByte<EEmote> Emote, int ExtraInfo);
	class UAkEvent* STATIC_GetEmoteAkEvent(int nSkinId, TEnumAsByte<EEmote> Emote, int ExtraInfo);
	struct FString STATIC_GetBotCodeName();
	struct FString STATIC_GetBotRefName();
	struct FString STATIC_GetBotName();
	int STATIC_GetBotId();
	TEnumAsByte<ETG_EQUIP_POINT> STATIC_GetPerCharacterAltEquipPoint();
	void PostBigTeleport();
	void STATIC_PostTeleport(class ATeleporter* OutTeleporter);
	void ResumeFXFromTeleport();
	void STATIC_HaltFXForTeleport();
	bool STATIC_PreTeleport(class ATeleporter* InTeleporter);
	void OnTeleportNotify(class AActor* TeleportingActor);
	void TeleportNotify();
	void RemoveFromTeleportNotify(class AActor* RemoveActor);
	void AddToTeleportNotify(class AActor* ToBeNotified);
	void ServerChangePhase(int NewPhase);
	void ChangePhase(int NewPhase);
	void Perf2(bool bEnabled);
	void OnPhaseTransitionComplete();
	void OnPhaseChange();
	void OnPhaseEnded(int nPhaseThatEnded);
	void BaseChange();
	bool CanPickupDroppedItem();
	bool STATIC_IsValidMeleeTarget(class ATgPawn* ProspectiveMeleeTarget);
	void SaveDeathInfoForZoomCam(class ATgPawn* KillerOwner, class ATgPawn* Killer, int DeviceID, bool bPetKill);
	void UpdateCooldownsOnDevices();
	void Stun(bool bStunController, TEnumAsByte<EStunType> eType);
	bool Teleport(const struct FVector& vDest, const struct FRotator& rDest, bool bPlayFx, int TeleportEnterState, int TeleportExitState, bool bFailOnNoSafeSpot, bool bFakeTeleport, struct FVector* vTeleportLocation);
	bool STATIC_IsAboveNonbaseableSurface(const struct FVector& vTestLoc, float fTestDist, class AActor** HitActor, struct FVector* HitNormal);
	bool TeleportTraceCheck(const struct FVector& vTestLoc, const struct FVector& vDestLoc);
	class ATgPawn* STATIC_GetCurrentOwnerPawn();
	bool STATIC_WasPlayerSpawned();
	bool STATIC_IsTalentEquipped(int nTalentDeviceId);
	bool IsTargetWithInCone(class AActor* Target);
	void TickTargeting(float DeltaSeconds);
	void STATIC_UpdateBob(float DeltaSeconds);
	void TickScale(float DeltaSeconds);
	float TickScaleVariable(float fDesiredValue, float fOldValue, float fScaleChangePerSecond, float DeltaSeconds);
	void AddRecoil(const struct FRotator& rNewRecoil, float fRecoilSmoothRate, float fSettleDelay, float fSettleSpeed);
	void Tick(float DeltaSeconds);
	void STATIC_DoubleCheckSimulatedProxy();
	void TickFriendlyPush();
	bool ShouldRecharge();
	void STATIC_DisplayMessage(const struct FString& sMessage);
	void ModifyPawnPropertiesVolumeChanged();
	void OnRigidBodySpringOverextension(class URB_BodyInstance* BodyInstance);
	void SetUsePhysicsWithAnimation(bool Enable);
	class ATgPawn* STATIC_FindLocalPlayerPawn();
	void BlendToAnimTreeDeviceType();
	void SetVar(int varId);
	void ServerSetVar(int varId);
	void ApplyTeleportEffects(const struct FVector& StartLocation);
	void STATIC_OnTeleport(class USeqAct_Teleport* Action);
	float STATIC_GetJumpHeightMultiplier();
	void STATIC_FlashJumpEffects();
	bool DoJump(bool bUpdating, float JumpZSpeed);
	void ClientCancelJump();
	void ServerCancelJump();
	void TriggerJump();
	void JumpHeldAltPressed();
	void StartCrouch(float HeightAdjust);
	void EndCrouch(float HeightAdjust);
	struct FRotator GetBaseAimRotation(class AWeapon* W, bool bIgnoreAutoLock);
	void GetAdjustedAimNative(class AWeapon* W, const struct FVector& StartFireLoc, struct FRotator* Rot);
	void GetBaseAimRotationNative(class AWeapon* W, bool bIgnoreAutoLock, struct FRotator* Rot);
	struct FVector GetWeaponStartTraceLocationAlt(const struct FVector& Offset);
	struct FVector GetWeaponStartTraceLocation(class ATgDevice* Dev);
	void STATIC_HideWeaponSwitchProgressBar();
	void STATIC_DisplayWeaponSwitchProgressBar(float Duration);
	void CheckUseDuration(float* fDuration);
	void ClientSetTriggerMessage(class ATgTrigger_Use* newTrigger, int msgId);
	void SetTriggerToUse(class ATgTrigger_Use* Trigger, bool bEnable);
	void InterruptAllDevices(bool bForceInterrupt);
	bool IsUseInterrupted();
	void InterruptUse();
	void EnableFootControls(int foot, bool bDisable);
	void HitWall(const struct FVector& HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp);
	bool CanBeRewound();
	bool CanBeGrabbed();
	bool CanBePulled();
	void Stasis(bool bStasised);
	void Banished(bool bIsBanished);
	void FlashBang(bool bIsFlashBang);
	void Cripple(bool bCrippled);
	void TriggerInstantCripple();
	void Knock(bool bKnocked, float fKnockbackFrictionOverride, const struct FVector& vKnockbackVelocityOverride);
	void StopDisarmFX();
	void PlayDisarmFX();
	void Disarm(bool bDisarmed);
	void Silence(bool bSilenced);
	void ResetStunnedBehavior(class ATgPlayerController* PC, class ATgAIController* aic);
	bool STATIC_ShouldSetStunPosture();
	void STATIC_ResetStunPosture();
	void ClientSetStun();
	void StopFullBodyAnimation(float BlendOutTime);
	void OnAnimEnd(class UAnimNodeSequence* SeqNode, float PlayedTime, float ExcessTime);
	void OnAnimPlay(class UAnimNodeSequence* SeqNode);
	void gibbedBy(class AActor* Other);
	void DetachConeComponent(class UDrawConeComponent* ConeComponent);
	class UDrawConeComponent* AttachConeComponent(class UDrawConeComponent* ConeComponent, float fRadius, float fAngle);
	void PlayInitialSpawnFX();
	void TriggerKismetPlayerInitialized();
	void OnPawnInitialized();
	void OnWaitingForPawnDone();
	void WaitForInventoryThenDoPostPawnSetup();
	void HandleClientPostPawnSetup();
	void PropertySet(int nPropertyId, float fPreviousValue, float fNewValue);
	void AttachDevice();
	void DetachDevice();
	void STATIC_UpdateHealingBeamEffects();
	void OnLifeAfterDeathTimerExpired();
	void BeginFadeOut();
	void DropFlag(class AController* C);
	void HoldFlag(class ATgCarriedFlag* NewFlag);
	void DelayedRagdollConstraintBreak();
	bool InitRagdoll();
	void STATIC_TurnOff();
	void KilledBy(class APawn* EventInstigator);
	void OutsideWorldBounds();
	void FellOutOfWorld(class UClass* dmgType);
	void STATIC_FlushDebug();
	void STATIC_PlayHit(float Damage, class AController* InstigatedBy, const struct FVector& HitLocation, class UClass* dmgType, const struct FVector& Momentum, const struct FTraceHitInfo& HitInfo);
	void OnJumpPenaltyEnded();
	void Landed(const struct FVector& HitNormal, class AActor* FloorActor);
	bool IsDying();
	void ApplyPawnShadows(bool bOn);
	float GetEnergyPercent();
	bool InCombat();
	void Combat(bool bInCombat);
	void STATIC_InCombatTimer();
	void ExitCombat();
	void EnterCombat(class AActor* aInstigator, class AActor* ATarget, float fLength);
	float STATIC_GetBaseCombatDuration();
	void STATIC_IsStillTimer();
	void BeginMoving();
	void ClientEnterCombat(class AActor* aInstigator, class AActor* ATarget, float fLength);
	void STATIC_UpdateBlindingDeployableState();
	void STATIC_UpdateObscuringDeployableState();
	void STATIC_EnableVolumeStealth();
	void STATIC_DisableVolumeStealth();
	void STATIC_GrassOff();
	void STATIC_GrassOn(class AActor* Vol);
	void ClearStealthDamage();
	void STATIC_VolumeStealthOff();
	void STATIC_VolumeStealthOn(class AActor* Vol, bool bFull);
	void STATIC_VolumeStealthFadeComplete();
	void RemoveVisibilityVolume(class AActor* Vol);
	void AddVisibilityVolume(class AActor* Vol);
	void FixUpVisibilityVolumes();
	void ApplyStealthClient();
	void STATIC_UpdateStealthClientFx(bool bIsHardRevealed);
	void STATIC_ActivateClientStealthFx();
	bool ShouldShowAsStealthed(bool bDetected);
	void InterruptLift(class ATgDevice* OriginatingDevice);
	void InterruptStealth(class ATgDevice* OriginatingDevice);
	void ApplyStealthServer(TEnumAsByte<ESTEALTH_TYPE> eStealthed, float fRate, bool bForce);
	void ReceivedCachedMaxHealth();
	void ReceivedPropValues();
	void ReplicatedEvent(const struct FName& VarName);
	void UpdateFirstValidFlashEventIdx();
	void UpdateWeaponMesh();
	void TgPawnControllerSet();
	void DisplayDebug(class AHUD* HUD, float* out_YL, float* out_YPos);
	struct FName GetDefaultCameraMode(class APlayerController* RequestedBy);
	void LockTargetingDeviceToInHand(bool bEnable);
	TEnumAsByte<ETG_EQUIP_POINT> STATIC_GetEquipSlotOfDevice(class ATgDevice* Dev);
	void SetTargetingDevice(class ATgDevice* Dev, const struct FWeaponMeshSwapStrategy& SwapStrategy);
	void ClientSetTargetingDevice(class ATgDevice* Dev, const struct FWeaponMeshSwapStrategy& SwapStrategy);
	bool SetActiveWeapon(class AWeapon* NewWeapon, bool bForceFastClear);
	bool IsInFriendlyItemShop();
	void SetPawnState(const struct FName& NewState);
	void RemoveDeathEffects();
	void SyncClientEnergy(float energy);
	void LiveRespawn(bool bResetHealth, bool bResetDevices);
	void ClientOnCrowdControlBreak();
	void ClientPrepareForEndMission();
	void ClientPrepareForLiveRespawn();
	void STATIC_PrepareForLiveRespawn();
	void AutoMount(bool bShouldBeMounted, bool bToggleMount);
	void STATIC_DrawPawnEncroachmentFire(bool bDraw);
	void SetMountOnRespawn();
	bool OnLiveRespawn();
	void STATIC_RecentRespawn();
	void OnRespawn();
	void EquipBestInHandDevice(bool bForceFastClear);
	void TimerDestroy();
	void StopAllAnimations();
	bool VerifyChargeHit(const struct FVector& HitLocation, const struct FVector& HitNormal, const struct FVector& TargetLocation, class AActor* Other);
	bool PredictChargeHit(const struct FVector& ChargeDir, const struct FVector& ChargeStart, float fChargeRange, const struct FVector& HitLocation, const struct FVector& HitNormal, const struct FVector& TargetLocation, class AActor* Other);
	void STATIC_GetHitLocationForProximityTouch(class AActor* Target, struct FVector* HitLocation, struct FVector* HitNormal);
	void STATIC_HandlePostChargeVelocity(float fVelocityMult, float fVelocityCap, bool bUseWalkSpeed);
	void EndPhysCharge(bool bInterrupted);
	void STATIC_ForceEndCharge();
	void StartPhysCharge(TEnumAsByte<EChargeState> newChargeType, const struct FRotator& InitialDirection, float fChargeSpeed, float fChargeTime, bool bIngoreHumanoidBlocking, bool bUsePhysFlyingForCharge, float fPostChargeVelocityMult, float fPostChargeVelocityCap, bool bPostChargeUseWalkSpeed, bool bChargeRespectsMoveSpeedMultipliers);
	bool IsGrabSourceValid(class AActor* Target, bool bAllowTurrets, bool bAllowStealthed);
	void DecrementCannotBeGrabSource();
	void IncrementCannotBeGrabSource(bool bBreakGrabs);
	void NativeTickGrab();
	void TickGrab(float DeltaSeconds);
	void STATIC_SetMovementPhysics();
	bool CanBeBaseForPawn(class APawn* aPawn);
	void AddVelocity(const struct FVector& NewVelocity, const struct FVector& HitLocation, class UClass* DamageType, const struct FTraceHitInfo& HitInfo);
	void STATIC_DisableShootingDuringGrab();
	void BaselessGrabEnd(bool bInterrupted);
	void BaselessGrabStart(bool bRemoveRoots);
	void DefaultGrabEnd(bool bInterrupted);
	void STATIC_PullGrabStart(TEnumAsByte<EGrabState> newGrabState, bool bRemoveRoots);
	void STATIC_EndGrab(TEnumAsByte<EGrabState> endingGrabState, bool bInterrupted);
	void BeginGrab(TEnumAsByte<EGrabState> newGrabState);
	bool IsBaselessGrab(TEnumAsByte<EGrabState> grabState);
	void STATIC_GetPullGrabSourceLocation(struct FVector* vSourceLoc);
	void STATIC_GetPullGrabOffsetFromSource(class ATgPawn* pGrabbedPawn, struct FVector* vOffset, struct FRotator* rRotation);
	void OnGrabTargetDetach(TEnumAsByte<EGrabState> endingGrabState, class ATgPawn* Target, bool bInterrupted);
	void OnGrabTargetAttach(TEnumAsByte<EGrabState> newGrabState, class ATgPawn* Target);
	void EndPhysGrab(bool bInterrupted);
	void StartPhysGrab(class AActor* Source, float fTime, TEnumAsByte<EGrabState> grabState, const struct FName& grabSocket, const struct FVector& grabLocOffset, const struct FRotator& grabRotOffset, bool bCanShootDuringGrab);
	void STATIC_LiftTweenEnd(bool bInterrupted);
	void DefaultTweenEnd(bool bInterrupted);
	void STATIC_PullGrabTweenEnd(bool bInterrupted);
	void SuspendTweenEnd(bool bInterrupted);
	void STATIC_EndTween(TEnumAsByte<ETweenState> endingTweenState, bool bInterrupted);
	void DefaultTweenStart(bool bCanBeHit, bool bRemoveRoots, bool bCollideWithWorld);
	void BeginTween(TEnumAsByte<ETweenState> newTweenState, bool bCollideWithWorld);
	void EndPhysTween(bool bInterrupted);
	void UpdatePhysTweenTargetLocation(const struct FVector& NewTarget, float updatedTime);
	void StartPhysTween(const struct FVector& Target, float fTime, TEnumAsByte<ETweenState> tweenState, bool bCollideWithWorld, bool bRotateTowardsTarget, float fTweenSpeed, bool bKeepPitch);
	struct FVector GetPhysTweenTargetLocation(bool bFinalLocation);
	void RemoveAllEffectsOnDeath();
	void CleanUpDyingEffects();
	void OnSwapToDestroyedMesh();
	void AttachDeathAnimationFX(int SpecialFXId, const struct FName& SocketName);
	struct FName GetDeathAnimName();
	void RagdollPawn();
	void STATIC_HideMeshForDeath();
	void PlayDeathAnimation();
	void STATIC_FreezeOnDeath();
	bool AllowRagdoll();
	void PlayDyingEffects();
	void STATIC_FindNewTargetTimer();
	void STATIC_PlayDying(class UClass* dmgType, const struct FVector& HitLoc);
	class UClass* STATIC_GetDamageTypeOverride(class UClass* dmgType);
	bool STATIC_IsFiringMelee();
	void ClientTriggerGlobalEventClass(class UClass* InEventClass, class AActor* InInstigator, int ActivateIndex);
	struct FName STATIC_GetFootStepOverride();
	void PlayFootStepSound(int FootDown, TEnumAsByte<EFootstepTypes> FootStepType);
	bool STATIC_IsTooFarForFootstepSounds();
	void PlayLandingSound(const struct FVector& LandingVelocity);
	void CalculateMaterialSwitch(const struct FVector& TraceStart, const struct FVector& TraceEnd);
	void StopSpecialJumpFx();
	void PlaySpecialJumpFx();
	void StopJumpFx();
	void PlayJumpFx();
	void PlayTeleportEffects(const struct FVector& OriginLocation);
	void PlayPreTeleportEffects();
	void PlayJumpSound();
	struct FString GetDebugName();
	void PostureTransitionEnded(TEnumAsByte<ETG_POSTURE> PostureThatEnded);
	void FaceRotation(const struct FRotator& NewRotation, float DeltaTime);
	void STATIC_GetCameraZoomOverride(float* fZoom, float* fZoomDuration);
	bool CalcCamera(float fDeltaTime, struct FVector* out_CamLoc, struct FRotator* out_CamRot, float* out_FOV);
	void EndViewTarget(class APlayerController* PC);
	void BecomeViewTarget(class APlayerController* PC);
	float GetPlayerHealthForRender();
	struct FString GetPlayerTagForRender();
	struct FString GetPlayerNameForRender();
	struct FColor STATIC_GetTargetBoxColor(class ATgPawn* LocalPlayerPawn);
	void OnGroupChange();
	void STATIC_NotifyLocalPlayerTeamReceived();
	void STATIC_NotifyTeamChanged();
	int STATIC_GetColumnBasedOnIndex(int nIndex);
	int STATIC_GetRowBasedOnIndex(int nIndex);
	int STATIC_GetY2CoordBasedOnIndex(int nIndex);
	int STATIC_GetX2CoordBasedOnIndex(int nIndex);
	int STATIC_GetY1CoordBasedOnIndex(int nIndex);
	int STATIC_GetX1CoordBasedOnIndex(int nIndex);
	class ATgPawn* STATIC_GetLocalPlayerPawn();
	void DamageTakenRTPCReset();
	void DamageTakenMaxReset();
	bool STATIC_LoadPlayerIcons();
	void DrawMultiLineText(class UCanvas* Canvas, const struct FString& Text, int X, int Y, int LineHeight);
	void ModifyHealthProp(int nDamage);
	void SetHealth(int NewHealth);
	void STATIC_AdjustDamage(class AController* InstigatedBy, const struct FVector& HitLocation, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser, int* InDamage, struct FVector* Momentum);
	void EndPulseStealth();
	void PulseStealth();
	int TakeShieldDamage(int fDamage, class UClass* DamageType);
	void TakeDamage(int Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void DrawAIDebug(class UCanvas* Canvas, const struct FVector& ScreenLoc);
	void STATIC_NotifyTakeHit(class AController* InstigatedBy, const struct FVector& HitLocation, int Damage, class UClass* DamageType, const struct FVector& Momentum, class AActor* DamageCauser);
	void SendNotifyTakeHit(class AController* InstigatedBy, const struct FVector& HitLocation, int Damage, class UClass* DamageType, const struct FVector& Momentum);
	void PlayTakeHit(const struct FVector& Direction, int Damage, class UClass* dmgType, struct FExtraDamageInfo* ExtraInfo);
	void PlayTakeHitEmote(int Damage, TEnumAsByte<EHitAudioCue> eCue);
	void PlayHitReactionMaterialPulse();
	void STATIC_EndHeal3P();
	void PlayHeal3P();
	void RememberPlayerAttackerExpired();
	void StopPlayFiring();
	void ClearFlashLocation(class AWeapon* Who);
	void ClearFlashCount(class AWeapon* Who);
	void IncrementFlashCount(class AWeapon* Who, unsigned char FireModeNum);
	void PawnGeneric3Flashed();
	void PawnGeneric2Flashed();
	void PawnGeneric1Flashed();
	void STATIC_ForceUpdate1PMeshes();
	bool CanApplyEffects();
	void OnDeviceFormInterruptFire(int nEquipSlot);
	bool ShouldStopWeaponMeshFireEffectsOnDeviceFormStopFire(int nEquipSlot);
	void OnDeviceFormStopFire(int nEquipSlot, int nFireModeNum);
	void PostRecallTimerToKillParticles();
	void OnDeviceFormHit(int nEquipSlot, class AActor* Target, float DamageAmount, const struct FVector& HitLocation, const struct FVector& HitNormal, struct FExtraDamageInfo* ExtraInfo);
	void OnDeviceFormFire(int nEquipSlot, float fRefireTime, int nFireMode);
	void AddVisualRecoil(int nEquipSlot, float fFireDuration);
	bool STATIC_GetCamLocationOffsetOverride(const struct FRotator& vInCameraRotation, float fZoomFactor, TEnumAsByte<ECameraPerspectiveType> ePerspective, struct FVector* vOutCameraSpaceTranslation, struct FVector* vOutCameraPivotLocation);
	void OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode, int nAmmoRemaining);
	void OnDeviceFormBuildup(int nEquipSlot, float fBuildupTime);
	bool STATIC_HasLeftItemShop();
	bool STATIC_IsInItemShop();
	void SyncDeviceTimers(class ATgDevice* SourceDevice, class ATgDevice* DestinationDevice);
	void SwapEquippedDevices(class ATgDevice* newDev, int nEqpSlot);
	void RestartAllDevices(bool bPostRevive);
	void ClientStopFiringAllDevices(bool bClearEquipEffectFlag, bool bResetCooldowns, bool bKeepFiringMount, bool bServerDeviceLockout);
	void PutAllCardsOnCooldown();
	void StopFiringAllDevices(bool bClearEquipEffectFlag, bool bResetCooldowns, bool bKeepFiringMount, bool bServerDeviceLockout);
	void StopAction(class ATgDevice* Dev);
	bool StartAction(class ATgDevice* Dev, bool bUpdateTimeStamp, TEnumAsByte<EDeviceFailType>* failType);
	void AnimSwapDevice();
	void STATIC_UIH();
	void OnDeviceFormExitedTargetingMode(class UTgDeviceForm* form);
	void OnDeviceFormEnteredTargetingMode(class UTgDeviceForm* form);
	void STATIC_EquipPendingDeviceTimer(bool SkipPlayAnim);
	void ShowAnimSets();
	void PutInHandDeviceAwayFast(class UTgDeviceForm* form);
	bool CanChangeInHandDeviceOrMode();
	void KillAllOwnedPets(bool bGameModeSource);
	void Destroyed();
	void ShutDown();
	bool Died(class AController* Killer, class UClass* dmgType, const struct FVector& HitLocation);
	bool ShouldScoreKill();
	void UpdateDeathReason();
	void STATIC_TakeFallingDamage();
	void OnJoinTeam(class UTgSeqAct_JoinTeam* Action);
	void DespawnOnReconnect();
	void Despawn();
	void Suicide();
	void SetDeathZoomInfo(class ATgPawn* theKiller, class ATgRepInfo_Player* theKillerPRI, int nHealthPct, int nDeviceId, class ATgRepInfo_Player* OwnerPRI);
	void PreRender(class UCanvas* Canvas);
	bool IsCustomCharacter();
	void MissionTimeUpdate();
	bool PostPawnSetup();
	void CrushedBy(class APawn* OtherPawn);
	void SetupPIEMesh(TEnumAsByte<EPIEPawnMeshTypes> PIEPawnType, int BotId);
	void ClearSpawnFxTimer();
	void PostBeginPlay();
	void SetLocalPlayer();
	void PreBeginPlay();
	void AllManifestsLoaded(int PassthroughData);
	class UTgSkelCon_MirrorToOtherMesh* STATIC_GetMirroredSkelControl(const struct FName& nmIdentifier);
	void ToggleSkelControlLocks(bool bOn);
	void CacheSkelControlLocks(class UTgSkeletalMeshComponent* smcomp);
	void CacheMultiMeshAnimNodeReferences(class UTgSkeletalMeshComponent* smcomp);
	void ClearMultiMeshAnimNodeReferences();
	void CacheMainMeshReferences(class UTgSkeletalMeshComponent* smcomp);
	void STATIC_CacheMountMeshAnimNodeReferences(class UTgSkeletalMeshComponent* smcomp);
	void PostInitAnimTree(class USkeletalMeshComponent* SkelComp);
	void OnDespawnBots(class UTgSeqAct_DespawnBots* inAction);
	void OnKillpawns(class UTgSeqAct_Killpawns* Action);
	void Falling();
	void CollisionChanged();
	void OnSetCrowdControlImmune(class UTgSeqAct_SetCrowdControlImmune* inAction);
	void OnUIAlert(class UTgSeqAct_UIAlert* Action);
	void OnSetTaskforce(class UTgSeqAct_SetTaskforce* Action);
	void OnGetTaskForceNumber(class UTgSeqAct_GetTaskForceNumber* Action);
	void OnGetTeamIndex(class UTgSeqAct_GetTeamIndex* Action);
	void STATIC_UnPossessed();
	void STATIC_PossessedBy(class AController* C, bool bVehicleTransition);
	void STATIC_HandleDisconnectedPlayer();
	bool PopPostureByType(TEnumAsByte<ETG_POSTURE> Posture);
	bool PopPosture(int PostureID);
	int PushPosture(TEnumAsByte<ETG_POSTURE> Posture);
	void STATIC_ActivateCharacterMusic();
	void Play3dSprayFx(int nSlot);
	int NativeGetFxOverrideFor(int nFxID);
	bool CreateSpecialFxForPawn(int nSpecialFxId, const struct FName& nmSocket, class UTgSpecialFx** pFxStorage);
	void OnMarkedTarget(int nTargetPawnId, int nMarkCountChange);
	void RemovePawnDiedFXMaterials();
	void PlayPawnDiedFX();
	bool ShouldSwapAltAndInhandInputs();
	void OnDismount();
	void STATIC_OnAutoMount();
	void OnLeaveItemShop();
	void OnEnterItemShop();
	void STATIC_EndLocalDeathRTPC();
	void BeginLocalDeathRTPC();
	void STATIC_EndLocalKillRTPC();
	void BeginLocalKillRTPC();
	void FxActivateIndependant(const struct FName& nmGroup, int nMode, const struct FVector& HitLocation, const struct FVector& HitNormal, int nSocketIndex, int nEquipSlot, bool bUseSocketOverride, bool bBody, bool bHead, bool bWeapon1p, bool bWeapon3p);
	void STATIC_FxDeactivateGroupWeapon3P(const struct FName& nmGroup, int nMode, int nSocketIndex, int nEquipSlot);
	class UObject* STATIC_FxReactivateGroupWeapon3P(const struct FName& nmGroup, int nMode, int nSocketIndex, int nEquipSlot, bool bIgnoreRelevancy, bool bFromEffectForm);
	class UObject* STATIC_FxActivateGroupWeapon3P(const struct FName& nmGroup, int nMode, int nSocketIndex, int nEquipSlot, bool bIgnoreRelevancy, bool bFromEffectForm);
	void STATIC_FxDeactivateGroupWeapon1P(const struct FName& nmGroup, int nMode, int nSocketIndex, int nEquipSlot);
	class UObject* STATIC_FxReactivateGroupWeapon1P(const struct FName& nmGroup, int nMode, int nSocketIndex, int nEquipSlot, bool bIgnoreRelevancy, bool bFromEffectForm);
	class UObject* STATIC_FxActivateGroupWeapon1P(const struct FName& nmGroup, int nMode, int nSocketIndex, int nEquipSlot, bool bIgnoreRelevancy, bool bFromEffectForm);
	void STATIC_FxDeactivateGroupWeapon(const struct FName& nmGroup, int nMode, int nSocketIndex, int nEquipSlot);
	void STATIC_FxReactivateGroupWeapon(const struct FName& nmGroup, int nMode, int nSocketIndex, int nEquipSlot, bool bIgnoreRelevancy, bool bFromEffectForm);
	void STATIC_FxActivateGroupWeapon(const struct FName& nmGroup, int nMode, int nSocketIndex, int nEquipSlot, bool bIgnoreRelevancy, bool bFromEffectForm);
	void STATIC_FxDeactivateGroupHead(const struct FName& nmGroup, int nMode, int nSocketIndex, int nEquipSlot);
	class UObject* STATIC_FxReactivateGroupHead(const struct FName& nmGroup, int nMode, int nSocketIndex, int nEquipSlot, bool bIgnoreRelevancy, bool bFromEffectForm);
	class UObject* STATIC_FxActivateGroupHead(const struct FName& nmGroup, int nMode, int nSocketIndex, int nEquipSlot, bool bIgnoreRelevancy, bool bFromEffectForm);
	void STATIC_FxDeactivateGroupBody(const struct FName& nmGroup, int nMode, int nSocketIndex, int nEquipSlot);
	class UObject* STATIC_FxReactivateGroupBody(const struct FName& nmGroup, int nMode, int nSocketIndex, int nEquipSlot, bool bIgnoreRelevancy, bool bFromEffectForm);
	class UObject* STATIC_FxActivateGroupBody(const struct FName& nmGroup, int nMode, int nSocketIndex, int nEquipSlot, bool bIgnoreRelevancy, bool bFromEffectForm);
	void STATIC_FxDeactivateGroupSelf(const struct FName& nmGroup, int nMode, int nSocketIndex, int nEquipSlot);
	void STATIC_FxReactivateGroupSelf(const struct FName& nmGroup, int nMode, int nSocketIndex, int nEquipSlot, bool bIgnoreRelevancy, bool bFromEffectForm);
	void STATIC_FxActivateGroupSelf(const struct FName& nmGroup, int nMode, int nSocketIndex, int nEquipSlot, bool bIgnoreRelevancy, bool bFromEffectForm);
	void STATIC_FxDeactivateGroupAllMesh(const struct FName& nmGroup, int nMode, int nSocketIndex, int nEquipSlot, bool bSkipWeaponMesh);
	void STATIC_FxActivateGroupAllMesh(const struct FName& nmGroup, int nMode, int nSocketIndex, int nEquipSlot, bool bIgnoreRelevancy, bool bFromEffectForm, bool bSkipWeaponMesh);
	void STATIC_DropHealthNuggetTeamOnly(int nTaskForce, const struct FVector& SpawnVelocity, float fHealOverride, float fHoTOverride);
	void STATIC_DropHealthNugget(const struct FVector& SpawnVelocity, float fHealOverride, float fHoTOverride);
	void ToggleSilhouetteVisibility(bool bVisible, bool bDead);
	void SetSilhouetteState(class UMeshComponent* ParentMesh, TEnumAsByte<EOverlayState> NewState);
	bool RemoveSilhouetteInfo(class UMeshComponent* ParentMesh);
	int STATIC_FindSilhouetteInfo(class UMeshComponent* ParentMesh);
	void ReinitializeSilhouettes();
	int InitializeSilhouetteComponent(class UMeshComponent* InMesh);
	void ClearReplacementMaterial();
	void ReplaceMaterial(class UMaterialInstanceConstant* materialToUse);
	void ReplaceMaterialWithDisplayGroup(struct FName* nmDisplayGroup);
	void SetParamOnReplacementMats(float fVal, struct FName* nmParam);
	bool ShouldForceHideOverlaysWeapon();
	bool ShouldForceHideOverlaysBody();
	void ToggleOverlay1P3P(bool bActivate1P);
	void STATIC_UpdateOverlayVisibilityWeapon();
	void STATIC_UpdateOverlayVisibilityBody();
	void SwapOverlayMICsWeapon(TEnumAsByte<EOverlayMICType> Type);
	void SwapOverlayMICsBody(TEnumAsByte<EOverlayMICType> Type);
	bool RemoveOverlayInfo(class USkeletalMeshComponent* ParentMesh);
	void ReinitializeOverlays();
	bool STATIC_Is3PWeaponOverlay(TEnumAsByte<EOverlayMICType> Type);
	bool STATIC_Is3PBodyOverlay(TEnumAsByte<EOverlayMICType> Type);
	bool STATIC_Is1PWeaponOverlay(TEnumAsByte<EOverlayMICType> Type);
	bool STATIC_Is1PBodyOverlay(TEnumAsByte<EOverlayMICType> Type);
	TEnumAsByte<ESceneDepthPriorityGroup> STATIC_GetOverlayDepthPriority(TEnumAsByte<EOverlayMICType> Type);
	class UMaterialInstanceConstant* STATIC_GetOverlayMaterial(TEnumAsByte<EOverlayMICType> Type);
	class UMaterialInstanceConstant* STATIC_InitializeOverlayInfo(TEnumAsByte<EOverlayMICType> Type, class UTexture* NormalMap, class UTexture* MaskMap);
	int STATIC_InitializeOverlayIndexWeapon(class USkeletalMeshComponent* ParentMesh, bool bIs1POverlay);
	int STATIC_InitializeOverlayIndexBody(class USkeletalMeshComponent* ParentMesh, bool bIs1POverlay);
	int STATIC_InitializeOverlayMeshComponent(class USkeletalMeshComponent* InMesh, bool bIs1POverlay);
	void PostPawnSetupServer();
	void OnMeshSwapped();
	void SwapToLiveMesh();
	void SwapToDestroyedMesh();
	void AddBodyMesh();
	void RetouchAllVolumes();
	void STATIC_OnApplyArmor(float fArmorChange, bool bMaxIncreased);
	void STATIC_EffectGroupOnSetActive(bool bActive, bool bRemoving, class UTgEffectGroup* effectGroup);
	void DeployableOnRemoveEffect(class ATgDeployable* dep, class AActor* HitActor);
	void DeployableOnApplyEffect(class ATgDeployable* dep, class AActor* HitActor);
	void DeployableOnDestroyed(class ATgDeployable* dep);
	void DeployableOnDeployed(class ATgDeployable* dep);
	class UClass* DeviceOnOverrideDamageType(class ATgDevice* Dev, class UTgEffectGroup* effectGroup);
	void DeviceOnSetFireMode(class ATgDevice* Dev);
	bool DeviceHasEnoughPowerPool(class ATgDevice* Dev, unsigned char FireModeNum);
	void DeviceAdjustHeal(struct FAdjustHealParams* Params, float* fHeal);
	void DeviceAdjustDamage(struct FAdjustDamageParams* Params, float* fDamage);
	void DeviceOnKilled(class ATgDevice* Dev, float fDamage, struct FImpactInfo* Impact);
	void DeviceOnHealed(struct FOnHealedParams* Params);
	void DeviceOnDamaged(struct FOnDamagedParams* Params);
	void DeviceOnHitSpecial(class ATgDevice* Dev, int nHitSpecialSituationalType, struct FImpactInfo* Impact);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void DeviceOnPostHit(class ATgDevice* Dev);
	void DeviceOnStopCooldown(class ATgDevice* Dev);
	void DeviceOnStartCooldown(class ATgDevice* Dev, float fCooldownTime);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnStartFire(class ATgDevice* Dev);
	void ProjectileOnFire(class ATgProjectile* Proj);
	void DeviceOnFire(class ATgDevice* Dev);
	void DeviceOnStopBuildup(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnStartBuildup(class ATgDevice* Dev);
	void PawnOnTeleported(class ATgSpawnTeleporterEntrance* From, class ATgSpawnTeleporterExit* To, const struct FVector& OriginalPawnLocation);
	void PawnOnPetDied(class ATgPawn* pet, class ATgPawn* PetOwner);
	void PawnOnPetAdded(class ATgPawn* pet, class ATgPawn* PetOwner);
	void PawnOnDamageInterruptedStealth();
	void PawnOnLandAfterLeap();
	void PawnOnLandAfterJump();
	void PawnOnLand();
	void PawnOnPetSuccessfulHit(int nFxID);
	void PawnOnEndSprint();
	void PawnOnStartSprint();
	bool PawnCanDisplayImmuneMessage();
	void PawnOnModifyEffectLifeTime(class UTgEffectGroup* eg, float* fLifetime);
	void PawnOnTaskforceAdd(class ATgRepInfo_TaskForce* tf);
	void PawnOnTaskforceRemove(class ATgRepInfo_TaskForce* tf);
	void PawnOnCurrency(class AActor* Source, int* nCurrency);
	void PawnOnXp(class AActor* Source, int* nXp);
	void PawnOnEndStill();
	void PawnOnBecomeStill();
	void PawnOnExitCombat();
	void PawnOnEnterCombat();
	void PawnOnRevive();
	void STATIC_PawnOnDied(class AController* pKilller);
	void STATIC_PawnOnKilledGlobal(class AActor* Victim, class AActor* Killer, TArray<class ATgRepInfo_Player*> AssistingPlayers);
	void PawnOnAssisted(class AActor* pVictim, class AActor* pKiller);
	void PawnOnKilled(class AActor* pVictim);
	void PawnOnHealed(struct FOnHealedParams* Params);
	void STATIC_PawnOnExecuteMitigation(class ATgPawn* attacker, class UTgEffectGroup* eg, int nPropertyId, float* fDamage);
	void PawnOnDamageMitigation(class ATgPawn* attacker, class UTgEffectGroup* eg, int nPropertyId, float* fDamage);
	void PawnOnPreDamageMitigation(class ATgPawn* attacker, class UTgEffectGroup* eg, int nPropertyId, float* fDamage);
	void PawnOnDamaged(struct FOnDamagedParams* Params);
	void STATIC_PawnMitigateDamageOther(class ATgPawn* Other, TEnumAsByte<EPawnDamageMitigatorReason> eReason, class ATgPawn* attacker, class UTgEffectGroup* eg, int nPropertyId, float* fDamage);
	void STATIC_RemovePawnDamageMitigatorByReason(TEnumAsByte<EPawnDamageMitigatorReason> eReason);
	void STATIC_RemovePawnDamageMitigator(class ATgPawn* PawnMitigator, TEnumAsByte<EPawnDamageMitigatorReason> eReason);
	void STATIC_AddPawnDamageMitigator(class ATgPawn* PawnMitigator, TEnumAsByte<EPawnDamageMitigatorReason> eReason);
	void SetSpawnEnergy();
	void SetSpawnMana();
	void SetSpawnHealth();
	float STATIC_GetProcChanceMultiplier();
	float STATIC_GetUIGroundSpeed();
	float STATIC_GetBackpedalPercent();
	bool STATIC_GetMinimapRequireLOS();
	float STATIC_GetHealBlock();
	float STATIC_GetDamageDealtFlat();
	float STATIC_GetDamageDealtToFrontlinePerc();
	float STATIC_GetDamageDealtPercShieldTarget();
	float STATIC_GetDamageDealtPercDeployableTarget();
	float STATIC_GetDamageDealtPerc(int nDamageType, bool bInHand);
	float STATIC_GetHealingCapHP();
	bool STATIC_HasHealingCapHP();
	float STATIC_GetDamageCapHP();
	bool STATIC_HasDamageCapHP();
	float STATIC_GetDamageCapPercCurHP();
	float STATIC_GetDamageCapPercMaxHP();
	float STATIC_GetProtectionCC();
	bool STATIC_ShouldNeverBeHealed();
	bool STATIC_IsHealingDisabled();
	float STATIC_GetHealingTakenOthersScale();
	float STATIC_GetHealingTakenScale();
	float STATIC_GetHealingDealtScale();
	float STATIC_GetVisionRange();
	float STATIC_GetMaxShieldHealth();
	float STATIC_GetMaxHealthWithoutPercentBuff();
	float STATIC_GetMaxEnergy();
	float STATIC_GetEnergy();
	float STATIC_GetEnergyRegen();
	float STATIC_GetManaRegen();
	float STATIC_GetHealthRegen();
	float STATIC_GetCombatDurationReduction();
	bool STATIC_IsLifeStealTarget(class ATgPawn* Target);
	float STATIC_GetUtilityPowerItem();
	float STATIC_GetMagicalPowerItem();
	float STATIC_GetPhysicalPowerItem();
	float STATIC_GetUtilityPowerBot();
	float STATIC_GetMagicalPowerBot();
	float STATIC_GetPhysicalPowerBot();
	float STATIC_GetUtilityPower();
	float STATIC_GetMagicalPower();
	float STATIC_GetPhysicalPower();
	void STATIC_UpdateMountScale(bool bIsMounted);
	bool ShouldRagdollOnDeath(class UClass* m_DamageType);
	bool STATIC_HasDeathPostureAnimation();
	bool ServerUpdateLockedTarget(class AActor* Locked);
	float STATIC_GetMaxPowerPoolValue(int nPacingType);
	float STATIC_GetCurrentPowerPoolValue(int nPacingType);
	void ConsumePowerPool(class ATgDevice* Dev, int nPacingType, float fAmount);
	bool STATIC_IsInFireLock();
	bool CanKnockbackAffectAC();
	float GetAirControl();
	void OnSetPlayerLevel(class UTgSeqAct_SetPlayerLevel* Action);
	bool STATIC_FindGround(float fCheckDist, float fCheckRadius, const struct FVector& vRayDir, struct FVector* vSourceLocation, struct FVector* vGroundLocation, struct FVector* vGroundNormal);
	float STATIC_GetGroundDistance();
	float NativeGetCollisionRadius();
	float NativeGetCollisionHeight();
	void OnPostureChange();
	void OnProjectileHitTarget(class ATgProjectile* HittingProjectile, const struct FVector& HitLocation, const struct FVector& HitNormal, unsigned char* bDestroyProjectile);
	void OnProjectileExploded(class ATgProjectile* ExplodedProjectile, class AActor* HitActor, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void OnLevelUp();
	bool NativeReplicatedEvent(const struct FName& VarName);
	struct FVector STATIC_GetTargetCenter();
	void CheckUiVolumeTriggers();
	void STATIC_NotifyQueuedLagCompWorldExplosion(class ATgProj_Simulated* Proj, const struct FVector& HitLocation, const struct FVector& HitVelocity);
	bool STATIC_CanQueueLagCompWorldExplosion(class ATgProj_Simulated* Proj, unsigned char* bHideProjectile);
	class AActor* STATIC_GetActorFromCombatActor();
	class AActor* STATIC_GetPetOwner();
	bool STATIC_IsPet();
	TEnumAsByte<EGameplayDesignType> STATIC_GetDesignType();
	class ATgEffectManager* STATIC_GetEffectManager();
	void DisplayDebugProperty(TArray<struct FString>* sPropertyStrings, struct FString* sPropText, struct FString* sValueText);
	bool STATIC_IsMarkedForMarkShot();
	float STATIC_GetMarkedPercentInhand(class AActor* InstigatorPawn);
	float STATIC_GetMarkedPercent(class AActor* InstigatorPawn);
	int STATIC_GetPropIndex(int nPropId);
	float STATIC_GetPropCurrentValueByName(const struct FString& propName);
	float STATIC_GetPropCurrentValue(int nPropIndex);
	float STATIC_GetPropBaseValue(int nPropIndex);
	void STATIC_HandleNotificationsForAI(float fStatChange, class ATgPawn* InstigatorPawn);
	float STATIC_GetDamageToLeaveStealth();
	void TakeStealthDamage(float fDamage);
	bool ShieldDamageAppliesToHealth();
	int TakePersonalShieldDamage(float fDamage, class AController* InstigatedBy, class UClass* DamageType, const struct FImpactInfo& Impact, const struct FExtraDamageInfo& ExtraInfo, class AActor* DamageCauser);
	bool CanUsePersonalShield();
	bool CanTakeShieldDamage();
	void TakeManaDamage(float fDamage, class AController* InstigatedBy, class UClass* DamageType, const struct FImpactInfo& Impact, const struct FExtraDamageInfo& ExtraInfo, class AActor* DamageCauser);
	bool CanTakeManaDamage();
	bool CanBeLifestealTarget();
	bool CanBeLifestealInstigator();
	bool STATIC_WillHitSuccessfully(class AActor* aInstigator, const struct FImpactInfo& Impact);
	void TakeHealthDamage(float fDamage, class AController* InstigatedBy, class UClass* DamageType, const struct FImpactInfo& Impact, const struct FExtraDamageInfo& ExtraInfo, class AActor* DamageCauser);
	void MitigateHealthDamage(class ATgPawn* pInstigator, class UTgEffectDamage* Effect, const struct FImpactInfo& Impact, bool bIsHeadshot, float* NewValue, float* fPercReduction, unsigned char* bWasCapped);
	void STATIC_MitigateExecuteDamage(class ATgPawn* pInstigator, class UTgEffectDamage* Effect, const struct FImpactInfo& Impact, bool bIsHeadshot, float* NewValue, float* fPercReduction);
	float STATIC_GetSpecialDamageTakenPercentAI();
	float STATIC_GetSpecialDamageDealtPercentAI();
	void BuffDamage(class AActor* Target, class UTgEffectDamage* Effect, const struct FImpactInfo& Impact, float fBaseDamage, float* fProratedAmount, struct FExtraDamageInfo* ExtraInfo);
	void TakeHealing(float fHealAmount, bool bSelf, int nHealingDeviceId);
	bool STATIC_IsImmuneToHealing();
	bool CanBeExecuted();
	bool STATIC_IsPawnOutOfPlane();
	bool STATIC_IsImmuneToDamageByAbsorption();
	bool STATIC_IsImmuneToDamage();
	bool OnlyTakeHeadShots();
	bool CanTakeHeadShots();
	bool CanDealHeadShots();
	bool CanTakeHealthDamage();
	float STATIC_GetDiminishedGroundSpeed();
	void STATIC_GetAdditionalLifestealMultipliers(struct FDiminishedEffectInfo* DiminishingInfo, struct FImpactInfo* Impact);
	void STATIC_GetAdditionalDamageTakenMultipliers(class ATgDevice* damagingDevice, struct FDiminishedEffectInfo* DiminishingInfo, struct FImpactInfo* Impact);
	float STATIC_GetMaxShield();
	float STATIC_GetShieldHealth();
	float STATIC_GetMaxMana();
	float STATIC_GetMana();
	float STATIC_GetMissingPureHealth();
	float STATIC_GetMaxPureHealth();
	float STATIC_GetCurrentArmor();
	float STATIC_GetMaxArmor();
	float STATIC_GetMaxHealth();
	float STATIC_GetHealth();
	void STATIC_ForceAllGrabTargetsDetach(TEnumAsByte<EGrabState> eState);
	class AActor* STATIC_GetGrabSourceAsActor();
	void STATIC_RemoveGrabbedPawn(class ATgPawn* pTarget);
	void STATIC_AddGrabbedPawn(class ATgPawn* pTarget);
	class USkeletalMeshComponent* STATIC_GetGrabSourceSkeletalMesh();
	bool STATIC_IsCinematicMode();
	void PostEmoteAkEvent(class UAkEvent* InAkEvent, TEnumAsByte<EEmote> Emote);
	void STATIC_PostAkEvent(class UAkEvent* InAkEvent);
	class AReverbVolume* STATIC_GettReverbVolumeForAudioAltitude();
	class AReverbVolume* STATIC_GetCurrentReverbVolume();
	void STATIC_UpdateReverbVolume(const struct FVector& WorldLocation, class AReverbVolume* VolumeTouched);
	void SetAkPlayerHealthPercent(float fPercent);
	bool MySpawnGatesAreOpen();
	class UPhysicalMaterial* TraceWorldPhysicalGeometry(const struct FVector& StartLoc, const struct FVector& EndLoc, struct FVector* TraceHitLocation);
	struct FVector STATIC_GetChargeDirection();
	void ReloadMeshAssemblies();
	void STATIC_GetMeshAssemblyToUse(int* nBodyAsmId, int* nCoreAsmId);
	void STATIC_ForceUpdateUncompressedRemoteYaw();
	void SetUncompressedRemoteViewPitch(int Pitch);
	void SmoothCorrectionTranslationTick(float DeltaSeconds, bool bForce);
	void TryToPlayPainAkEvent();
	void STATIC_UpdateRespawnBeaconReticule(bool bForce);
	bool AllowBoostedJump();
	void STATIC_GiveEnergy(float energy);
	bool ShouldBeFirstPersonThisTick(TEnumAsByte<ECameraPerspectiveType>* ePersectiveType);
	bool STATIC_IsThirdPersonForced();
	bool STATIC_IsConfused();
	bool STATIC_IsInOffensiveTween();
	bool STATIC_IsTweenBreakable(TEnumAsByte<ETweenState> tweenState);
	bool STATIC_IsRewinding();
	bool STATIC_IsPerformingOffensiveGrab();
	bool STATIC_IsInOffensiveGrab();
	bool STATIC_IsGrabBreakable(TEnumAsByte<EGrabState> tweenState);
	void ResetSkelControls(class USkeletalMeshComponent* SkelComp);
	void STATIC_NativeDefaultGrabEnd(bool bInterrupted);
	void STATIC_NativeDefaultGrabStart(bool bRemoveRoots);
	bool STATIC_SetRelativeGrabLocation(const struct FVector& NewLocation, bool bDeferUpdate);
	struct FRotator STATIC_TweenRelRotation(float fDeltaSeconds, const struct FRotator& currRel, const struct FRotator& targetRel);
	bool STATIC_IsStatTrackable();
	bool STATIC_IsGodDecoy();
	bool STATIC_IsGod();
	float AdjustRespawnTime(float InRespawnTime);
	void ForceUpdateComponents(bool bCollisionUpdate, bool bTransformOnly);
	void STATIC_UpdateSpectatorStatUI();
	void STATIC_UpdatePlayerStatUI();
	void PlayCustomAnimation(int nAnimResId, bool bFullBody, float fTime);
	bool STATIC_IsNonCombat();
	bool CanMove();
	void PlayUpperBodyAnim(const struct FName& AnimName, float Rate, float BlendInTime, float BlendOutTime, bool bLooping);
	float PlayFullBodyLoopingAnimWithTransition(const struct FName& TransitionAnimName, const struct FName& LoopingAnimName, float Rate, float BlendInTime, float BlendOutTime);
	bool PlayFullBodyAnim(const struct FName& AnimName, float Rate, float BlendInTime, float BlendOutTime, bool bLooping, bool bOverride, bool bBlendOutIfVelocityIsGreaterThanZero, bool bHideInHandDevice);
	bool IsFriendlyWithLocalPawn();
	void RegainEnergyPool(float fDelta);
	void RegainManaPool(float fDelta);
	void RegainPools(float fDelta);
	void SyncMana();
	float STATIC_GetManaPercent();
	float STATIC_GetPureHealthPercent();
	float STATIC_GetHealthPercent();
	void SetMeshComponentVectorValue(class UMeshComponent* theMesh, const struct FName& ScalarParam, struct FLinearColor* ColorValue);
	void SetMeshComponentScalarValue(class UMeshComponent* theMesh, const struct FName& ScalarParam, float ScalarValue);
	void SetMeshVectorValue(const struct FName& ScalarParam, struct FLinearColor* ColorValue);
	void SetMeshScalarValue(const struct FName& ScalarParam, float ScalarValue);
	void STATIC_KillDeployables(bool bAll, bool bNoKillProtected);
	class UTgSpecialFx* STATIC_GetTakeHitFxOverride(class UTgSpecialFx* TakeHit);
	struct FVector STATIC_GetLocation();
	bool STATIC_LocalPlayerHasLOS();
	bool STATIC_AreObscuringDeployablesOverriden(class ATgPawn* Viewer, class ATgPawn* Viewed, bool bViewerInside);
	bool STATIC_IsDeployableBlindedTo(class AActor* Viewed);
	bool STATIC_IsDeployableIgnoringStealthInterrupts();
	bool STATIC_IsDeployableObscuredFrom(class ATgPawn* Viewer);
	bool STATIC_IsInEnemyObscuringDeployable(class ATgPawn* Viewer);
	bool STATIC_IsInCommonEnemyObscuringDeployable(class ATgPawn* Viewer);
	bool STATIC_IsInFriendlyObscuringDeployable();
	class AActor* STATIC_GetATouchingVisibilityVolume();
	bool STATIC_IsInSameVisibilityVolumeBeacon(class ATgRespawnBeaconExit* Other);
	bool STATIC_IsInSameVisibilityVolume(class ATgPawn* Other);
	int STATIC_FindVisibilityVolume(class AActor* VisVolume);
	int NumVisibilityVolumesTouching();
	void RemoveDetectedFx();
	void PlayDetectedFx();
	bool STATIC_IsDetector();
	bool STATIC_IsHardRevealed(class ATgRepInfo_Player* Viewer);
	bool STATIC_IsHardStealthed();
	bool STATIC_IsStealthedByDeployableOnly(class ATgRepInfo_Player* Viewer);
	bool STATIC_IsStealthed(class ATgRepInfo_Player* Viewer);
	class ATgDevice* STATIC_GetCurrentInhandDevice();
	bool ShouldBlockFiringFrom1pSwitch();
	class ATgDevice* STATIC_GetDeviceById(int nDeviceId);
	class ATgDevice* STATIC_GetDeviceByInstanceId(int nDeviceInstanceId);
	void STATIC_UpdatePhysicsAsset();
	void OnPawnDied();
	void PlaySpawnFx();
	void PrepareIntro();
	void PlaySpecialEffectEvent(int PlaySpecialEffectIndex, const struct FVector& vLoc, const struct FVector& vHitNormal, class AActor* inActor);
	void PlayTeleportFx(int nTeleportState, const struct FVector& vLoc);
	float STATIC_GetDeviceMoveSpeedMultiplier(bool bUpdateSavedMove);
	float GetTerminalVelocity();
	void STATIC_UpdateStealthMaterialBasedOnNearbyEnemies();
	void STATIC_UpdateDropShadow();
	void STATIC_RecalculateMaterial(bool bIsFriendlyWithLocalPawn, bool bForce);
	void ForceRecalculateMaterial();
	bool STATIC_HandleAutofireDevices();
	bool CanBeAffectedByVortices();
	bool ShouldShowHudOverlay(class ATgPawn* PlayerPawn);
	bool OverrideDistanceFadeRange();
	void CalcBlindingDeployableFadeValue(float fDeltaTime);
	void CalcObscuringDeployableFadeValue(float fDeltaTime);
	void CalcStealthFadeValue(float fDeltaTime);
	void CalcDistanceFadeValue(float fDeltaTime);
	void CalcVolumeFadeValue(float fDeltaTime);
	bool STATIC_IsHittable();
	bool IsInvisibleToAI();
	bool STATIC_ShouldPreventCameraPenetration();
	bool ShouldInHandDeviceBeHiddenThisTick();
	TEnumAsByte<ETgMeshVisibilityState> STATIC_GetMeshVisibilityStateThisTick();
	void PlaySoundCue(int nSoundCueId);
	void SetPhase(int nNewPhase);
	void STATIC_UpdateHUDScores();
	void TrackDeath();
	void TrackKill(class ATgPawn* Killer);
	void STATIC_UpdateEnemyAssists(class ATgPawn* Assister);
	void STATIC_UpdateDamagers(class ATgPawn* Damager);
	void TrackDamageMitigated(int nAmount);
	void TrackDamageTaken(class ATgPawn* theInstigator, int nDamage, int nDamageType);
	void TrackSelfKill(int nDeviceModeID);
	void TrackTeamKill(int nDeviceModeID);
	void TrackSelfDamage(int nDeviceModeID, int nDamage);
	void TrackTeamDamage(int nDeviceModeID, int nDamage);
	void TrackReleaseTime(int nDeviceModeID, float fReleaseTime);
	void TrackHit(int nDeviceModeID, float fDistance, bool bHitPlayer);
	void RemoveTrackFired(int nDeviceModeID);
	void TrackCompleteKillInfo(int nKillerCharacterID, int nKillerDeviceModeID, int nVictimCharacterID, int nVictimDeviceModeID, const struct FVector& KillerLocation, const struct FVector& VictimLocation, const struct FVector& PetLocation, bool bPetKill);
	void TrackFired(int nDeviceModeID);
	void TrackBotHealing(int nDeviceModeID, float fDamage, float fMissingHealth, int nMaxHealth);
	void TrackSelfHealing(float fMissingHealth, int nMaxHealth, struct FOnHealedParams* Params);
	void TrackHealing(int nDeviceModeID, float fMissingHealth, int nMaxHealth, struct FOnHealedParams* Params);
	void TrackKilledBot(int nDeviceModeID);
	void TrackFromPlayerDeath(int nDeviceModeID);
	void TrackKilledPlayer(int nDeviceModeID);
	void TrackDamagedBot(class ATgPawn* TargetPawn, int nDeviceModeID, int nDamage, int nDamageType, bool bIsGod);
	void TrackDamagedPlayer(class ATgPawn* TargetPawn, int nDeviceModeID, int nDamage, int nDamageType, bool bInHand);
	void STATIC_EndStats();
	void BeginStats();
	void StatsCleanup();
	void STATIC_ValidateStatsTracker();
	void ModifyAccuracyForReticleBloom(float* fAccuracy);
	float STATIC_GetAccuracyModifier(float ClientMovementTimeStamp);
	class ATgRepInfo_Player* STATIC_GetPRI();
	unsigned char STATIC_GetTaskForceNumber();
	void SetTaskForceNumber(int nTaskForce);
	void AdjustMeshTranslation();
	void STATIC_KillOwnedBots();
	void ReportPetDeath(class ATgPawn* PetPawn);
	bool STATIC_IsMyPet(class AActor* Other);
	void STATIC_KillPets();
	void STATIC_KillPet(class ATgPawn* PetPawn);
	void SetPetOwner(class ATgPawn* PetOwner);
	void AddPet(class ATgPawn* PetPawn);
	class UMeshComponent* CreateMeshComponent(int nMeshId, class UMeshComponent* DestComponent, bool bPartialFixup);
	class UTgSpecialFx* STATIC_GetSpecialFx(int nSpecialFxId);
	void SetMeshVisibility(bool bVisible);
	bool CanSeeActor(class AActor* Other);
	bool STATIC_IsJumpDisabled();
	float GetGravityZ();
	void AddRemoveAnimSetList(TArray<class UAnimSet*> AnimSetList, bool bAdd);
	bool STATIC_TermRagdoll();
	void OnSpawnGatesOpened();
	void ShowCombo(int nPawnId, bool bCrit);
	void STATIC_DrawClientDebug();
	bool bIsEditor();
	void ReapplyLoadoutEffects(bool bKeepFiringMount, bool bPostRevive);
	void ReapplyLevelEffectGroups(int nPrevLevel, int nCurrentLevel, bool bPreserveParams);
	void STATIC_PawnMod3Flashed(int nPawnModIndex, int nParamA, int nParamB);
	void STATIC_PawnMod2Flashed(int nPawnModIndex, int nParamA, int nParamB);
	void STATIC_PawnMod1Flashed(int nPawnModIndex, int nParamA, int nParamB);
	void STATIC_FlashedEventCooldown(int nIndex, int nMode, float fCooldown);
	void STATIC_FlashPawnHealed(struct FOnHealedParams* Params);
	void STATIC_FlashKillOrAssist(class AActor* Target, bool bIsKill, int nComboCount);
	void STATIC_FlashHHPickup();
	void STATIC_FlashHitDirection(const struct FVector& vLocation, int nDamageAmount, class UClass* DamageType, const struct FVector& vInstigatorLocation, struct FExtraDamageInfo* ExtraInfo);
	void STATIC_FlashTransitionOut(int nDeviceInstanceId, int nFireModeNum, float fTransitionPercent, float fTotalTransitionTime);
	void STATIC_FlashTransitionIn(int nDeviceInstanceId, int nFireModeNum, float fTransitionPercent, float fTotalTransitionTime);
	void STATIC_FlashPawnMod3(int nPawnModIndex, int nParamA, int nParamB);
	void STATIC_FlashPawnMod2(int nPawnModIndex, int nParamA, int nParamB);
	void STATIC_FlashPawnMod1(int nPawnModIndex, int nParamA, int nParamB);
	void STATIC_FlashPawnGeneric3(bool bIsSimulated);
	void STATIC_FlashPawnGeneric2(bool bIsSimulated);
	void STATIC_FlashPawnGeneric1(bool bIsSimulated);
	void STATIC_FlashGeneric5(int nDeviceInstanceId, int nFireModeNum, bool bIsSimulated, unsigned char byExtraData);
	void STATIC_FlashGeneric4(int nDeviceInstanceId, int nFireModeNum, bool bIsSimulated, unsigned char byExtraData);
	void STATIC_FlashGeneric3(int nDeviceInstanceId, int nFireModeNum, bool bIsSimulated, unsigned char byExtraData);
	void STATIC_FlashGeneric2(int nDeviceInstanceId, int nFireModeNum, bool bIsSimulated, unsigned char byExtraData);
	void STATIC_FlashGeneric1(int nDeviceInstanceId, int nFireModeNum, bool bIsSimulated, unsigned char byExtraData);
	void STATIC_FlashPetSuccessfulHit(int nFxID);
	void STATIC_FlashPlayFXSpray(int nSpraySlot);
	void STATIC_FlashSpawnSpecialFX(int nFxID, const struct FVector& vLocation, const struct FVector& vNormal);
	void STATIC_FlashPlaySpecialEffect(int PlaySpecialEffectIndex, const struct FVector& vLocation, const struct FVector& vHitNormal, class AActor* inActor, bool bIsSimulated);
	void STATIC_FlashLevelupFx();
	void FlashTeleportFx(int nTeleportState, const struct FVector& vLocation);
	void STATIC_FlashChangeMesh();
	void STATIC_FlashDestruct(int nDeviceInstanceId, const struct FVector& vLocation);
	void STATIC_FlashModeEquipDone(int nDeviceInstanceId, int nFireModeNum);
	void STATIC_FlashEventUpdate();
	void STATIC_FlashSuccessfulHit(int nDeviceInstanceId, int nFireModeNum, class AActor* Target, float DamageAmount, const struct FVector& HitLocation, const struct FVector& HitNormal, const struct FExtraDamageInfo& ExtraInfo);
	void STATIC_FlashInterrupt(int nDeviceInstanceId);
	void STATIC_FlashBlockDone(int nDeviceInstanceId, int nFireModeNum);
	void STATIC_FlashBlockFx(int nDeviceInstanceId, int nFireModeNum);
	void STATIC_FlashBlock(int nDeviceInstanceId, int nFireModeNum);
	void STATIC_FlashCooldownDone(int nDeviceInstanceId, int nFireModeNum);
	void STATIC_FlashCooldown(int nDeviceInstanceId, int nFireModeNum, float fCooldownTime);
	void STATIC_FlashReload(int nDeviceInstanceId, float fReloadTime, int nAmmoRemaining, int nReloadAnimType);
	void STATIC_FlashStartFire(int nDeviceInstanceId, int nFireModeNum, float RefireTime, class AActor* Target, int nAmmoRemaining);
	void STATIC_FlashStopFire(int nDeviceInstanceId, int nFireModeNum);
	void STATIC_FlashArcing(int nDeviceInstanceId, int nFireModeNum, const struct FVector& vNewLoc, const struct FVector& vOldLoc, class AActor* Target, int nEquipSlot, int nSocketIndex, bool bsuccesfulhit);
	void STATIC_FlashFireNoSim(int nDeviceInstanceId, int nFireModeNum, const struct FVector& vNewLoc, int nEquipSlot, int nSocketIndex, bool bsuccesfulhit, float RefireTime);
	void STATIC_FlashFireMulti(int nDeviceInstanceId, int nFireModeNum, const struct FVector& vAimStart, const struct FVector& vAimDir, TArray<float> hitRanges, float fMaxRange, int nSeed, float fSpreadAngle, int nEquipSlot, int nSocketIndex, bool bsuccesfulhit, float RefireTime);
	void STATIC_FlashFire(int nDeviceInstanceId, int nFireModeNum, const struct FVector& vNewLoc, int nEquipSlot, int nSocketIndex, bool bsuccesfulhit, float RefireTime);
	void STATIC_FlashPlayEmoteExcludeOwner(TEnumAsByte<EEmote> Emote, int ExtraInfo);
	void STATIC_FlashPlayEmote(TEnumAsByte<EEmote> Emote, int ExtraInfo);
	void STATIC_FlashBuildUp(int nDeviceInstanceId, int nFireModeNum, int nEquipSlot, int nSocketIndex, float fBuildupTime);
	void STATIC_FlashTargeting(int nDeviceInstanceId, int nFireModeNum, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit);
	void STATIC_FlashFireMode(int nDeviceInstanceId, int nFireModeNum);
	void STATIC_FlashResetReplication();
	struct FVector NativeCanvasProject(class UCanvas* CanvasToUse, const struct FVector& vLocation);
	int STATIC_DrawNameText(class UCanvas* CanvasToUse, float StartX, float StartY, const struct FString& NameString, class UFont* NameFont, const struct FColor& NameColor, float Scale);
	int STATIC_DrawScaledString(class UCanvas* CanvasToUse, float StartX, float StartY, const struct FString& NameString, class UFont* NameFont, const struct FColor& NameColor, float Scale);
	bool SpecialAOEImmunity(const struct FVector& AOECenter, class UTgDeviceFire* instigatingFiremode);
	void STATIC_OnCrowdControlBreak();
	void CrowdControlBreak();
	bool STATIC_IsMounted();
	bool STATIC_IsInYagorathGrab();
	bool STATIC_IsInSoftCrowdControl();
	bool STATIC_IsInHardCrowdControl();
	bool STATIC_IsCrowdControlImmune();
	bool STATIC_IsSuperiorCrowdControlImmune();
	bool STATIC_IsPolymorphImmune();
	bool STATIC_IsLiftImmune();
	bool STATIC_IsDamageOverTimeImmune();
	bool STATIC_IsHealingDebuffImmune();
	bool STATIC_IsDebuffImmune();
	void ResetProperties();
	void SetPropCurrentValue(int nPropIndex, float nNewValue);
	void SetProperty(int nPropIndex, float fNewValue);
	struct FTgPropertyInstance STATIC_GetPropertyById(int nPropId);
	struct FTgPropertyInstance STATIC_GetProperty(int nPropIndex);
	void AddProperty(int nPropId, float fBase, float fRaw, float FMin, float FMax);
	void InitializeDefaultProps();
	bool ApplyPawnSetup();
	void DeviceFormChanged(bool bForceReload);
	class UTgDeviceForm* CreateDeviceForm(const struct FEquipDeviceInfo& Info);
	class ATgDevice* STATIC_FindEquippedTalentById(int nDeviceId);
	class ATgDevice* STATIC_FindEquippedTalentByType(class UClass* DeviceClass);
	class ATgDevice* STATIC_GetCardByClass(class UClass* DeviceClass);
	class ATgDevice* STATIC_GetDeviceByEqPoint(int eEqPoint);
	void STATIC_UpdateClientDevices(bool bForce);
	bool AreAnyOtherOffhandsLockingFiring(class ATgDevice* CurrentDevice);
	bool STATIC_IsDeviceFiring(TEnumAsByte<ETG_EQUIP_POINT> eSlot);
	void STATIC_UpdateShieldFX();
	float STATIC_GetInhandAccuracy();
	void ReplicateInhandAccuracy(float fAccuracy);
	void SetTargetActor(class AActor* Target);
	class ATgPawn* STATIC_GetTargetPawn();
	class AActor* STATIC_GetTargetActor();
	float STATIC_GetUnclampedLagPredictionTime();
	float STATIC_GetLagPredictionTime();
	void PlayNotifySound(TEnumAsByte<ENotifySound> eSound);
	void PlayNotifySound_Internal(TEnumAsByte<ENotifySound> eSound);
	void PlayMessageAkEvent(const struct Fdword& dwMsgId);
	bool STATIC_IsChatMuted();
	void ServerRequestEmote(TEnumAsByte<EEmote> Emote, int ExtraInfo, int nPriority, float fRelevance, float fPause);
	void RequestEmote(TEnumAsByte<EEmote> Emote, int ExtraInfo, int nPriority, float fRelevance, float fPause);
	bool STATIC_ShouldDisallowTeamPassThroughFrom(class ATgPawn* pOther);
	bool STATIC_CanPawnParticipateInCapture();
	bool STATIC_CanSpawnScalableShields();
	bool STATIC_CanPawnMountUp();
	void STATIC_GotBurnCard(int BurnCardId);
	void STATIC_UpdateDeathCardItem(int nItemId);
	bool CheckIsInItemShop();
	int STATIC_GetUISkillEqpSlotOverrideStaticDefault(int nEquipSlot, TEnumAsByte<EUI_SKILL_EQUIP_SLOT> eUISlot);
	int STATIC_GetUISkillEqpSlotOverride(int nEquipSlot, TEnumAsByte<EUI_SKILL_EQUIP_SLOT> eUISlot, bool bBaseSkillOnly, bool bGamepadUI);
	float STATIC_GetUIUltChargePercent();
	void QueueSoundShutdown();
	void OnViewTargetChanged(class AActor* aNewViewTarget);
	class AActor* STATIC_GetViewTargetOverride();
	bool STATIC_GetTurnRotatorOverride(int* nYawOffset);
	int STATIC_GetHealFeedIconOverrideId();
	int STATIC_GetDefaultSkinId();
	struct FName STATIC_GetStealthFxGroup();
	void STATIC_OnRewindEnded();
	void STATIC_OnRewindStarted(float fDurationRealTime);
	void STATIC_OnPrepareForLiveRespawn();
	void STATIC_PrepareForEndMission();
	void FindBase();
	void OnJumpEvent();
	void OnPhysTweenEndEvent();
	void On3pTransitionEvent();
};


// Class TgGame.TgPawn_Biped
// 0x0130 (0x2FFC - 0x2ECC)
class ATgPawn_Biped : public ATgPawn
{
public:
	struct FName                                       m_nmLeftFootBone;                                         // 0x2ECC(0x0008) (Edit)
	struct FName                                       m_nmRightFootBone;                                        // 0x2ED4(0x0008) (Edit)
	struct FName                                       m_nmLeftFootControlName;                                  // 0x2EDC(0x0008) (Edit)
	struct FName                                       m_nmRightFootControlName;                                 // 0x2EE4(0x0008) (Edit)
	float                                              m_fOldLocationZ;                                          // 0x2EEC(0x0004)
	unsigned long                                      m_bEnableRightFootPlacement : 1;                          // 0x2EF0(0x0004)
	unsigned long                                      m_bEnableLeftFootPlacement : 1;                           // 0x2EF0(0x0004)
	unsigned long                                      m_bMayDisableFootIKFromAnimNodes : 1;                     // 0x2EF0(0x0004)
	unsigned long                                      m_bInitializedFootIKCachedNodeList : 1;                   // 0x2EF0(0x0004)
	unsigned long                                      m_bApplyLeftHandWeaponIK : 1;                             // 0x2EF0(0x0004)
	unsigned long                                      m_bSetHandIKStrengthFromAnimNodes : 1;                    // 0x2EF0(0x0004)
	unsigned long                                      m_bInitializedHandIKCachedNodeList : 1;                   // 0x2EF0(0x0004)
	unsigned long                                      c_bPlayingRefire : 1;                                     // 0x2EF0(0x0004)
	unsigned long                                      c_bRefireIsUpperBody : 1;                                 // 0x2EF0(0x0004)
	float                                              m_fZSmoothingRate;                                        // 0x2EF4(0x0004) (Const)
	float                                              m_fMaxFootPlacementDistSquared;                           // 0x2EF8(0x0004)
	class USkelControlFootPlacement*                   m_LeftLegControl;                                         // 0x2EFC(0x0008)
	class USkelControlFootPlacement*                   m_RightLegControl;                                        // 0x2F04(0x0008)
	TArray<struct FName>                               m_FootIKZeroStrengthAnimNodeNameList;                     // 0x2F0C(0x0010) (NeedCtorLink)
	TArray<class UAnimNode*>                           m_FootIKZeroStrengthCachedNodeList;                       // 0x2F1C(0x0010) (NeedCtorLink)
	struct FVector                                     m_vPreviousRightFootPosition;                             // 0x2F2C(0x000C)
	struct FVector                                     m_vPreviousLeftFootPosition;                              // 0x2F38(0x000C)
	float                                              m_fCachedRightTracedFloor;                                // 0x2F44(0x0004)
	float                                              m_fCachedLeftTracedFloor;                                 // 0x2F48(0x0004)
	float                                              m_fCachedRightFloorNormalZ;                               // 0x2F4C(0x0004)
	float                                              m_fCachedLeftFloorNormalZ;                                // 0x2F50(0x0004)
	int                                                m_nCachedLeftFootBoneIndex;                               // 0x2F54(0x0004)
	int                                                m_nCachedRightFootBoneIndex;                              // 0x2F58(0x0004)
	struct FName                                       m_SkelControl_LeftHandName;                               // 0x2F5C(0x0008)
	class USkelControlLimb*                            m_SkelControl_LeftHand;                                   // 0x2F64(0x0008)
	class USkelControlSingleBone*                      m_SkelControl_LeftHandRotate;                             // 0x2F6C(0x0008)
	struct FName                                       m_SkelControl_RightHandName;                              // 0x2F74(0x0008)
	class USkelControlLimb*                            m_SkelControl_RightHand;                                  // 0x2F7C(0x0008)
	class USkelControlSingleBone*                      m_SkelControl_RightHandRotate;                            // 0x2F84(0x0008)
	class USkelControlSingleBone*                      m_SkelControl_RightToLeftPropSwitch;                      // 0x2F8C(0x0008)
	TArray<struct FName>                               m_HandIKFullStrengthAnimNodeNameList;                     // 0x2F94(0x0010) (NeedCtorLink)
	TArray<struct FName>                               m_HandIKZeroStrengthAnimNodeNameList;                     // 0x2FA4(0x0010) (NeedCtorLink)
	TArray<class UAnimNode*>                           m_HandIKFullStengthCachedNodeList;                        // 0x2FB4(0x0010) (NeedCtorLink)
	TArray<class UAnimNode*>                           m_HandIKZeroStrengthCachedNodeList;                       // 0x2FC4(0x0010) (NeedCtorLink)
	class UMaterialInstanceConstant*                   m_FadeMaterialControllerBody;                             // 0x2FD4(0x0008)
	struct FName                                       c_RefireBeginBlendAnimationName;                          // 0x2FDC(0x0008)
	struct FName                                       c_RefireEndBlendAnimationName;                            // 0x2FE4(0x0008)
	class UAnimSet*                                    c_RefireAnimSet;                                          // 0x2FEC(0x0008)
	float                                              c_fRefireDuration;                                        // 0x2FF4(0x0004)
	float                                              c_fRefireEndDuration;                                     // 0x2FF8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Biped");
		return ptr;
	}


	void Landed(const struct FVector& HitNormal, class AActor* FloorActor);
	bool CanTrackATarget();
	void SetAimTarget(float X, float Y, float Z);
	void EnableFootControls(int foot, bool bDisable);
	void STATIC_zpivot(float F);
	void CacheMainMeshReferences(class UTgSkeletalMeshComponent* smcomp);
	void PostBeginPlay();
	void STATIC_EndRefireTimer();
	void STATIC_EndRefire();
	void BeginRefire();
	void STATIC_ResetCooldownsOnRespawn();
	bool STATIC_InitializeFootIKZeroStrengthAnimNodes(class USkeletalMeshComponent* SkelComp);
	bool STATIC_InitializeLeftHandIKAnimNodes(class USkeletalMeshComponent* SkelComp);
};


// Class TgGame.TgPawn_Character
// 0x02DC (0x32D8 - 0x2FFC)
class ATgPawn_Character : public ATgPawn_Biped
{
public:
	unsigned long                                      c_bUpdatePlayerStatUI : 1;                                // 0x2FFC(0x0004)
	unsigned long                                      m_bInHandFiring : 1;                                      // 0x2FFC(0x0004)
	unsigned long                                      r_bNearCapturePoint : 1;                                  // 0x2FFC(0x0004) (Net)
	unsigned long                                      r_bNearPayload : 1;                                       // 0x2FFC(0x0004) (Net)
	unsigned long                                      r_bNearSiegeMonster : 1;                                  // 0x2FFC(0x0004)
	unsigned long                                      r_bVisibleToEnemies : 1;                                  // 0x2FFC(0x0004) (Net)
	unsigned long                                      s_bAmmoReloadCheat : 1;                                   // 0x2FFC(0x0004)
	unsigned long                                      s_bAutomountProtection : 1;                               // 0x2FFC(0x0004)
	unsigned long                                      m_bRecalcMoveSpeed : 1;                                   // 0x2FFC(0x0004)
	unsigned long                                      m_bAttemptingAirJump : 1;                                 // 0x2FFC(0x0004)
	unsigned long                                      m_bDelayingStopSpecialJumpFx : 1;                         // 0x2FFC(0x0004)
	unsigned long                                      m_bPendingBounce : 1;                                     // 0x2FFC(0x0004)
	unsigned long                                      s_bInitiatingJoin : 1;                                    // 0x2FFC(0x0004)
	unsigned long                                      r_bJoinForceView : 1;                                     // 0x2FFC(0x0004) (Net)
	unsigned long                                      c_bInterpolatingFOV : 1;                                  // 0x2FFC(0x0004)
	unsigned long                                      s_bReplicateInhandAmmo : 1;                               // 0x2FFC(0x0004) (Const)
	unsigned long                                      m_bPendingPawnModScan : 1;                                // 0x2FFC(0x0004)
	unsigned long                                      m_bInSpawnRoom : 1;                                       // 0x2FFC(0x0004)
	unsigned long                                      c_bShouldTickThisFrame : 1;                               // 0x2FFC(0x0004)
	unsigned long                                      r_bCanChangeLoadout : 1;                                  // 0x2FFC(0x0004) (Net)
	float                                              m_fLastCapturePointReclaimedTime;                         // 0x3000(0x0004) (Transient)
	float                                              m_fMinReclaimPointTime;                                   // 0x3004(0x0004)
	float                                              c_fUpdateAltitudeRTPCDelay;                               // 0x3008(0x0004)
	float                                              m_fInHandStartFireTime;                                   // 0x300C(0x0004) (Transient)
	float                                              m_fInHandStopFireTime;                                    // 0x3010(0x0004) (Transient)
	float                                              m_fWallDamagePercent;                                     // 0x3014(0x0004)
	float                                              m_fSiegeDamagePercent;                                    // 0x3018(0x0004)
	float                                              r_fZoomAmt;                                               // 0x301C(0x0004) (Net)
	unsigned char                                      r_nCriticalHit;                                           // 0x3020(0x0001) (Net)
	unsigned char                                      UnknownData00[0x3];                                       // 0x3021(0x0003) MISSED OFFSET
	float                                              m_fMountZoomOverride;                                     // 0x3024(0x0004) (Edit)
	class ATgDeploy_BombKingStickyBomb*                r_StuckBombs[0x6];                                        // 0x3028(0x0008) (Net)
	int                                                m_nCharacterRole;                                         // 0x3058(0x0004)
	class UTgCustomCharacterComponent*                 m_CustomCharacterComponent;                               // 0x305C(0x0008) (Edit, ExportObject, Component, EditInline)
	class UPrimitiveComponent*                         m_MountedCollisionComponent;                              // 0x3064(0x0008) (Edit, ExportObject, Component, EditInline)
	class UPrimitiveComponent*                         m_MeshEncompassingCollisionComponent;                     // 0x306C(0x0008) (Edit, ExportObject, Component, EditInline)
	TArray<TScriptInterface<class UTgDeviceInterface_MoveSpeedMultiplier>> m_CachedMoveSpeedModDevices;                              // 0x3074(0x0010) (NeedCtorLink)
	TArray<TScriptInterface<class UTgDeviceInterface_AccelMultiplier>> m_CachedAccelModDevices;                                  // 0x3084(0x0010) (NeedCtorLink)
	TArray<TScriptInterface<class UTgDeviceInterface_DeployMod>> m_CachedDeployModDevices;                                 // 0x3094(0x0010) (NeedCtorLink)
	int                                                m_nAirJumps;                                              // 0x30A4(0x0004)
	float                                              m_fAirJumpZSpeed;                                         // 0x30A8(0x0004) (Edit)
	struct FVector                                     m_vBounceVelocity;                                        // 0x30AC(0x000C)
	class ATgPawn_Character*                           m_JoinTargetLocal;                                        // 0x30B8(0x0008)
	class ATgPawn_Character*                           m_JoinSourceLocal;                                        // 0x30C0(0x0008)
	class ATgPawn_Character*                           r_JoinTarget;                                             // 0x30C8(0x0008) (Net)
	struct FVector                                     r_vJoinSourceLocation;                                    // 0x30D0(0x000C) (Net)
	struct FVector                                     r_vJoinTargetLocation;                                    // 0x30DC(0x000C) (Net)
	float                                              r_fJoinTweenDuration;                                     // 0x30E8(0x0004) (Net)
	float                                              c_fFOVInterpStartTimestamp;                               // 0x30EC(0x0004)
	float                                              c_fFOVInterpStartValue;                                   // 0x30F0(0x0004)
	float                                              c_fFOVInterpEndTimestamp;                                 // 0x30F4(0x0004)
	float                                              c_fLastAppliedFOV;                                        // 0x30F8(0x0004)
	class ATgPawn_Character*                           r_JoinSource;                                             // 0x30FC(0x0008) (Net)
	TArray<struct FForceFaceTargetActor>               m_ForceFaceActors;                                        // 0x3104(0x0010) (NeedCtorLink)
	float                                              m_fForceFaceRotationTime;                                 // 0x3114(0x0004)
	struct FRotator                                    m_rForcedRotation;                                        // 0x3118(0x000C)
	float                                              m_fForceFaceRotationRate;                                 // 0x3124(0x0004)
	int                                                r_nInHandCurrentAmmo;                                     // 0x3128(0x0004) (Net)
	int                                                r_nInHandMaxAmmo;                                         // 0x312C(0x0004) (Net)
	int                                                s_nOppressorMineStackCount;                               // 0x3130(0x0004)
	float                                              c_fTickCatchup;                                           // 0x3134(0x0004)
	float                                              m_fEmoteMoveSpeedCeiling;                                 // 0x3138(0x0004)
	int                                                r_nEquippedEmotes[0x4];                                   // 0x313C(0x0004) (Net, AlwaysInit)
	int                                                r_nEquippedSprays[0x4];                                   // 0x314C(0x0004) (Net, AlwaysInit)
	int                                                m_DefaultFlankItemStore1Items[0x4];                       // 0x315C(0x0004)
	int                                                m_DefaultFlankItemStore2Items[0xC];                       // 0x316C(0x0004)
	int                                                m_DefaultTankItemStore1Items[0x4];                        // 0x319C(0x0004)
	int                                                m_DefaultTankItemStore2Items[0xC];                        // 0x31AC(0x0004)
	int                                                m_DefaultDamageItemStore1Items[0x4];                      // 0x31DC(0x0004)
	int                                                m_DefaultDamageItemStore2Items[0xC];                      // 0x31EC(0x0004)
	int                                                m_DefaultSupportItemStore1Items[0x4];                     // 0x321C(0x0004)
	int                                                m_DefaultSupportItemStore2Items[0xC];                     // 0x322C(0x0004)
	int                                                m_OverrideItemStore1Items[0x4];                           // 0x325C(0x0004)
	int                                                m_OverrideItemStore2Items[0xC];                           // 0x326C(0x0004)
	struct FWeaponDOF                                  m_CurrentDOFSettings;                                     // 0x329C(0x0028) (Edit)
	float                                              m_fOverriddenFOV;                                         // 0x32C4(0x0004)
	class ATgCollisionProxy_Capture*                   s_pCaptureProxy;                                          // 0x32C8(0x0008)
	float                                              fMatchPrepareAnnouncer;                                   // 0x32D0(0x0004) (Const)
	float                                              fMatchPrepareAnnouncerTDM;                                // 0x32D4(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Character");
		return ptr;
	}


	void CollisionChanged();
	void CreateCaptureProxy();
	bool ShouldCreateCaptureProxy();
	void Destroyed();
	int GetAICard(int WhichStore, int WhichSlot);
	void ApplyFOVModification(float* FOV);
	float STATIC_GetFOVInterpZoomPct();
	void STATIC_InterpolateFOV(float NewFOV, float InterpolationTime);
	void STATIC_SetFOV(float NewFOV);
	void STATIC_ResetFOV();
	void ReenableFallAccelLimit();
	void TemporarilyDisableFallAccelLimit(float fTime);
	struct FVector STATIC_GetPullGrabLocation();
	struct FVector GetPhysTweenTargetLocation(bool bFinalLocation);
	void STATIC_EndGrab(TEnumAsByte<EGrabState> endingGrabState, bool bInterrupted);
	void StartGrabFromPull(bool bInterrupted);
	void STATIC_EndTween(TEnumAsByte<ETweenState> endingTweenState, bool bInterrupted);
	void BeginTween(TEnumAsByte<ETweenState> newTweenState, bool bCollideWithWorld);
	void RestartMovementReplication();
	void StartPullToGrabTransition(class AActor* Source, const struct FName& nmSourceSocket, float fPullSpeed, float fGrabTime, const struct FVector& vServerGrabOffset, bool bEnableCollision, bool bFreeRotation, bool bEnableShooting);
	void SetCanChangeLoadout(bool bCanChangeLoadout);
	bool AdvancedTeleport(bool bFakeTeleport, struct FTeleportParams* Params, struct FVector* vTeleportLocation);
	void STATIC_UpdateJoinSourceLocal();
	void RemoveJoinForcedView(class ATgPawn_Character* Source, class ATgPawn_Character* Target);
	void AddJoinForcedView(class ATgPawn_Character* Source, class ATgPawn_Character* Target);
	void STATIC_TweenForJoinFinished();
	void STATIC_TweenForJoin();
	void ClientUnjoinFromTarget();
	void ClientJoinToTarget();
	void UnjoinFromTarget();
	void JoinToTarget(class ATgPawn_Character* Target, const struct FVector& SourceLocation, const struct FVector& TargetLocation, float TweenDuration, bool bForceView);
	void StartPhysTween(const struct FVector& Target, float fTime, TEnumAsByte<ETweenState> tweenState, bool bCollideWithWorld, bool bRotateTowardsTarget, float fTweenSpeed, bool bKeepPitch);
	void AbortJoin();
	void UpdateForcedRotation(float DeltaTime, TEnumAsByte<EForceFaceActorReason> eReason);
	void AddForcedViewRotation(const struct FRotator& rTargetRotation, float fTime, float fRate);
	void ClearOldForcedViewTargets();
	void RemoveForcedViewTarget(class UObject* ForceRotationInstigator);
	void RemoveForcedViewTargetsByReason(TEnumAsByte<EForceFaceActorReason> eReason);
	void STATIC_ClientRemoveForcedViewTargetsByReason(TEnumAsByte<EForceFaceActorReason> eReason);
	void ClientRemoveForcedViewTarget(class UObject* ForceRotationInstigator);
	void AddForcedViewTarget(class AActor* TargetActor, float InterpTime, float Duration, class UObject* ForceRotationInstigator, float HeightOffset, const struct FName& nmSocketName, TEnumAsByte<EForceFaceActorReason> eReason);
	void ClientAddForcedViewTarget(class AActor* TargetActor, float InterpTime, float Duration, class UObject* ForceRotationInstigator, float HeightOffset, const struct FName& nmSocketName, TEnumAsByte<EForceFaceActorReason> eReason);
	bool CanAddForcedViewTarget();
	int GetNumAirJumps();
	void StopSpecialJumpFx();
	void STATIC_FlashJumpEffects();
	bool DoJump(bool bUpdating, float JumpZSpeed);
	bool CanAirJump();
	bool CheckPhysicsStateForJumping();
	bool CannotJumpNow();
	void AutomountProtectionTimer();
	void StartAutomountProtectionTimer();
	void RemoveStickyBombs();
	void OnCeaseSpectatorViewTarget();
	void OnBecameSpectatorViewTarget();
	void PreTimeLapse(bool bPlayOfTheGame);
	void OnStartTimelapseNewDeviceState();
	void STATIC_UpdateWeaponZoomEffects(float fZoomAmt);
	void SetWeaponZoom(float fZoomAmt);
	void ForceUpdateAmmoAnim();
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool AllowRagdoll();
	void STATIC_GetCameraZoomOverride(float* fZoom, float* fZoomDuration);
	void SetMountedCollision(bool IsActive);
	void ComposeCharacter(int Idx, int MeshAsmId);
	bool Died(class AController* Killer, class UClass* dmgType, const struct FVector& HitLocation);
	void STATIC_PossessedBy(class AController* C, bool bVehicleTransition);
	void OnInhandAmmoCountUpdated();
	void TickAchievements(float fDelta);
	void Tick(float DeltaSeconds);
	void STATIC_RescanPawnMods();
	void ReplicatedEvent(const struct FName& VarName);
	bool STATIC_IsViewPawn();
	void ReceivedPropValues();
	void STATIC_HideHeadMesh();
	void ShowHeadMesh();
	void PostPawnSetupServer();
	bool PostPawnSetup();
	void OnRespawn();
	void CharacterPawnControllerSet();
	void ResetKillCombo();
	void TakeDamage(int Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void PlayAnnouncerMatchStartCue();
	void PlaySpawnFx();
	void PlayIntroAnims();
	void PrepareIntro();
	void PostBeginPlay();
	void STATIC_ClientPlaybackRewind(float fDuration, float fRate, float fDelay, bool bIsBuff);
	void PlaybackRewind(float fDuration, float fRate, float fDelay, bool bIsBuff);
	bool STATIC_IsJoined();
	bool STATIC_HasForcedRotation(TEnumAsByte<EForceFaceActorReason> eReason);
	bool STATIC_AddRequiredPawnMods();
	void STATIC_InvokeRewind(float fDuration, float fRate, float fDelay, bool bIsBuff);
	void Play3dSprayFx(int nSlot);
	void STATIC_UpdateMountMeshCollision(int nMeshId);
	void QueueBounce(struct FVector* vBounceVelocity);
	void TakeHealthDamage(float fDamage, class AController* InstigatedBy, class UClass* DamageType, const struct FImpactInfo& Impact, const struct FExtraDamageInfo& ExtraInfo, class AActor* DamageCauser);
	int STATIC_GetRole();
	int STATIC_GetDefaultHeadMeshId();
	bool OverrideDistanceFadeRange();
	float STATIC_GetBaseSpeed();
	float STATIC_GetGroundSpeed();
	float STATIC_GetDiminishedGroundSpeed();
	float STATIC_GetDeviceMoveSpeedMultiplier(bool bUpdateSavedMove);
	float STATIC_GetJumpSpeedMultiplier();
	void STATIC_UpdateAltitudeRTPC();
	void STATIC_DropHealthNuggetTeamOnly(int nTaskForce, const struct FVector& SpawnVelocity, float fHealOverride, float fHoTOverride);
	void STATIC_DropHealthNugget(const struct FVector& SpawnVelocity, float fHealOverride, float fHoTOverride);
	void DeviceAdjustHeal(struct FAdjustHealParams* Params, float* fHeal);
	void DeviceAdjustDamage(struct FAdjustDamageParams* Params, float* fDamage);
	void DeviceOnMiss(class ATgDevice* Dev);
	void DeviceOnReload(class ATgDevice* Dev);
	void DeviceOnKilled(class ATgDevice* Dev, float fDamage, struct FImpactInfo* Impact);
	void DeviceOnHealed(struct FOnHealedParams* Params);
	void DeviceOnDamaged(struct FOnDamagedParams* Params);
	void DeviceOnHitSpecial(class ATgDevice* Dev, int nHitSpecialSituationalType, struct FImpactInfo* Impact);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnStartFire(class ATgDevice* Dev);
	void ProjectileOnFire(class ATgProjectile* Proj);
	void DeviceOnFire(class ATgDevice* Dev);
	void DeviceOnStopBuildup(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnStartBuildup(class ATgDevice* Dev);
	void PawnOnTeleported(class ATgSpawnTeleporterEntrance* From, class ATgSpawnTeleporterExit* To, const struct FVector& OriginalPawnLocation);
	void PawnOnLeaveCapturePoint(class ATgChaosCapturePoint* CapturePoint);
	void PawnOnEnterCapturePoint(class ATgChaosCapturePoint* CapturePoint);
	void PawnOnGetHealthNugget(class ATgDeploy_HealthNugget* nugget);
	void PawnOnExitCombat();
	void PawnOnEnterCombat();
	void PawnOnRevive();
	void STATIC_PawnOnKilledGlobal(class AActor* Victim, class AActor* Killer, TArray<class ATgRepInfo_Player*> AssistingPlayers);
	void PawnOnAssisted(class AActor* pVictim, class AActor* pKiller);
	void PawnOnKilled(class AActor* pVictim);
	void PawnOnHealed(struct FOnHealedParams* Params);
	void PawnOnDamaged(struct FOnDamagedParams* Params);
	void STATIC_GlobalOnPlayerDied(class ATgPawn_Character* Player);
	void CheckWaitForTeam();
	void TankRequestsHelp();
	void PlayMatchStartCue();
	void SpawnGuard();
	void OnPawnDied();
	bool ApplyItemEffects(class UTgInventoryObject* pItem, bool bRemove);
	void AddSpray(int nSlot, int nDeviceId);
	void AddEmote(int nSlot, int nDeviceId);
	void OnHealingWell(bool bTouched);
	void STATIC_LoadDisconnectedPlayerState();
	void SetSpawnMana();
	bool ApplyPawnSetup();
};


// Class TgGame.TgPawn_LanePusherBase
// 0x0058 (0x3054 - 0x2FFC)
class ATgPawn_LanePusherBase : public ATgPawn_Biped
{
public:
	float                                              s_fSpeedMultiplierToCatchUpToSquad;                       // 0x2FFC(0x0004)
	class ATgPawn_Character*                           s_PlayerAttacker;                                         // 0x3000(0x0008)
	class ATgSplineActor*                              r_StartSpline;                                            // 0x3008(0x0008) (Const, Net)
	class ATgSplineActor*                              r_ServerSyncSpline;                                       // 0x3010(0x0008) (Const, Net)
	struct FServerSplineSync                           r_ServerSync;                                             // 0x3018(0x0008) (Const, Net)
	unsigned long                                      m_bMoving : 1;                                            // 0x3020(0x0004) (Const)
	unsigned long                                      c_bServerSync : 1;                                        // 0x3020(0x0004)
	unsigned long                                      m_bDoNotScaleCollisionBoxWithDatabase : 1;                // 0x3020(0x0004) (Const)
	unsigned long                                      m_bApplySplinePitchToActor : 1;                           // 0x3020(0x0004) (Const)
	unsigned long                                      c_bApplySplinePitchToMesh : 1;                            // 0x3020(0x0004) (Const)
	unsigned long                                      m_bFullStopWhenNoDesiredSpeed : 1;                        // 0x3020(0x0004) (Const)
	unsigned long                                      s_bStopBackpeddlingAtCheckpoints : 1;                     // 0x3020(0x0004) (Const)
	unsigned long                                      m_bAllowBackpeddling : 1;                                 // 0x3020(0x0004)
	unsigned long                                      m_bDestroyed : 1;                                         // 0x3020(0x0004)
	unsigned long                                      r_bAsleep : 1;                                            // 0x3020(0x0004) (Net)
	class ATgSplineActor*                              m_Spline;                                                 // 0x3024(0x0008)
	class UStaticMeshComponent*                        m_CollisionBox;                                           // 0x302C(0x0008) (ExportObject, Component, EditInline)
	float                                              m_fSplineDist;                                            // 0x3034(0x0004)
	float                                              c_fSplineDistCorrection;                                  // 0x3038(0x0004)
	float                                              c_fClientSideMovementFudgeFactor;                         // 0x303C(0x0004)
	float                                              c_fClientCorrectionTolerance;                             // 0x3040(0x0004)
	float                                              c_fClientCorrectionRate;                                  // 0x3044(0x0004)
	float                                              m_fGroundSpeedScaleLastTick;                              // 0x3048(0x0004)
	float                                              r_fTrackGroundSpeed;                                      // 0x304C(0x0004) (Net)
	float                                              m_fAcceleration;                                          // 0x3050(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_LanePusherBase");
		return ptr;
	}


	float STATIC_GetDistanceToEndOfSpline();
	void DestroyIt(bool bSkipFx);
	void Tick(float DeltaTime);
	void STATIC_SetMovementPhysics();
	void PropertySet(int nPropertyId, float fPreviousValue, float fNewValue);
	void ClientUpdateMoving();
	void PlayDeathAnimation();
	void ToggleAggroAlert(bool bOn);
	void TargetActorUpdated();
	void RememberPlayerAttackerExpired();
	void TakeDamage(int Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void Despawn();
	void ReplicatedEvent(const struct FName& VarName);
	bool STATIC_IsImmuneToHealing();
	bool STATIC_IsImmuneToDamage();
	void SnapToServerSync();
	void ReceiveServerSync();
	void STATIC_UpdateServerSync();
	void STATIC_UpdateMoving();
	void SetSpline(class ATgSplineActor* NewSpline, bool bSnapToStart);
	void SendPing();
	void SetTargetActor(class AActor* Target);
	void PostPawnSetupServer();
	void SetInitialLevel();
};


// Class TgGame.TgPawn_LanePusher
// 0x0034 (0x3088 - 0x3054)
class ATgPawn_LanePusher : public ATgPawn_LanePusherBase
{
public:
	unsigned long                                      m_bInIntroduction : 1;                                    // 0x3054(0x0004)
	unsigned long                                      r_bIsInsideBase : 1;                                      // 0x3054(0x0004) (Net)
	unsigned long                                      m_bHarvestTexturesForFadeMIC : 1;                         // 0x3054(0x0004)
	unsigned long                                      m_bBroadcastDeath : 1;                                    // 0x3054(0x0004)
	TEnumAsByte<EDestroyedAnimStages>                  c_eDestroyedAnimStage;                                    // 0x3058(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x3059(0x0003) MISSED OFFSET
	class UTgSpecialFx*                                c_BeamFX;                                                 // 0x305C(0x0008) (Transient)
	float                                              m_fBaseWheelSpeed;                                        // 0x3064(0x0004) (Edit)
	int                                                m_nMaxLevel;                                              // 0x3068(0x0004) (Const)
	int                                                m_nFriendlyFadeMaterialFXId;                              // 0x306C(0x0004)
	int                                                m_nEnemyFadeMaterialFXId;                                 // 0x3070(0x0004)
	TArray<class UMaterialInstanceConstant*>           m_FadeMICs;                                               // 0x3074(0x0010) (NeedCtorLink)
	float                                              m_fDamageScaleWhileTraveling;                             // 0x3084(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_LanePusher");
		return ptr;
	}


	void ClearFromGRI();
	bool Died(class AController* Killer, class UClass* dmgType, const struct FVector& HitLocation);
	void Destroyed();
	struct FVector GetWeaponStartTraceLocation(class ATgDevice* Dev);
	void OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode, int nAmmoRemaining);
	int GetPowerScalingValue();
	int GetHPScalingValue();
	void TakeDamage(int Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void PlayDeathAnimation();
	void ReceivedPropValues();
	void Tick(float DeltaSeconds);
	void PostInitAnimTree(class USkeletalMeshComponent* SkelComp);
	void ModifyHealthProp(int nDamage);
	void STATIC_IntroTimer();
	void PlayInitialSpawnFX();
	void STATIC_UpdateMaterialFade();
	void STATIC_InitializeFadeInMaterial();
	void PostBeginPlay();
	bool STATIC_IsImmuneToDamage();
	void PostPawnSetupServer();
	void SetSpline(class ATgSplineActor* NewSpline, bool bSnapToStart);
	void CalcDistanceFadeValue(float fDeltaTime);
	void ReapplyLevelEffectGroups(int nPrevLevel, int nCurrentLevel, bool bPreserveParams);
	void PawnOnPreDamageMitigation(class ATgPawn* attacker, class UTgEffectGroup* eg, int nPropertyId, float* fDamage);
	void STATIC_DropHealthNuggetTeamOnly(int nTaskForce, const struct FVector& SpawnVelocity, float fHealOverride, float fHoTOverride);
	void STATIC_DropHealthNugget(const struct FVector& SpawnVelocity, float fHealOverride, float fHoTOverride);
	void OnPawnDied();
	void SetInitialLevel();
};


// Class TgGame.TgPawn_Juggernaut
// 0x0004 (0x308C - 0x3088)
class ATgPawn_Juggernaut : public ATgPawn_LanePusher
{
public:
	unsigned long                                      m_bNextLaserLeft : 1;                                     // 0x3088(0x0004)
	unsigned long                                      m_bInGenericFirePosture : 1;                              // 0x3088(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Juggernaut");
		return ptr;
	}


	bool Died(class AController* Killer, class UClass* dmgType, const struct FVector& HitLocation);
	void OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode, int nAmmoRemaining);
	void ChangeFirePosture();
	bool PostPawnSetup();
	void PawnOnPreDamageMitigation(class ATgPawn* attacker, class UTgEffectGroup* eg, int nPropertyId, float* fDamage);
	bool STATIC_IsDebuffImmune();
	void DeviceAdjustDamage(struct FAdjustDamageParams* Params, float* fDamage);
};


// Class TgGame.TgPawn_SiegeEngine_Payload
// 0x0064 (0x30F0 - 0x308C)
class ATgPawn_SiegeEngine_Payload : public ATgPawn_Juggernaut
{
public:
	float                                              s_fTotalSplineLength;                                     // 0x308C(0x0004)
	float                                              s_fPreviousSplineLength;                                  // 0x3090(0x0004)
	unsigned long                                      r_bEnable : 1;                                            // 0x3094(0x0004) (Net)
	unsigned long                                      m_bRequireLineOfSightForNearby : 1;                       // 0x3094(0x0004) (Const)
	unsigned long                                      m_bShouldAccelerateLOSChecks : 1;                         // 0x3094(0x0004)
	unsigned long                                      r_bMovingBackwards : 1;                                   // 0x3094(0x0004) (Net)
	unsigned long                                      r_bCanAutoPushForward : 1;                                // 0x3094(0x0004) (Net)
	float                                              r_fBaseSpeedScale;                                        // 0x3098(0x0004) (Net)
	float                                              m_fNearbyProximityDistance;                               // 0x309C(0x0004) (Const)
	class ATgCollisionProxy*                           m_NearbyCollisionProxy;                                   // 0x30A0(0x0008)
	TArray<class ATgPawn*>                             m_TouchingPlayers;                                        // 0x30A8(0x0010) (NeedCtorLink)
	TArray<class ATgPawn*>                             m_VisiblePlayers;                                         // 0x30B8(0x0010) (NeedCtorLink)
	float                                              m_fSpeedScaleIncreasePerFriendly;                         // 0x30C8(0x0004) (Const)
	float                                              m_fLineOfSightUpdatePeriod;                               // 0x30CC(0x0004) (Const)
	float                                              m_fLineOfSightUpdatePeriodAccelerated;                    // 0x30D0(0x0004) (Const)
	float                                              m_fNextLineOfSightUpdateTime;                             // 0x30D4(0x0004)
	float                                              s_fTimeUntilMoveBackwards;                                // 0x30D8(0x0004) (Const)
	float                                              m_fMoveBackSpeedScale;                                    // 0x30DC(0x0004) (Const)
	TEnumAsByte<EAutoMovePayload>                      r_eMoveWithoutAllies;                                     // 0x30E0(0x0001) (Net)
	TEnumAsByte<EPayloadControlState>                  m_eControlState;                                          // 0x30E1(0x0001)
	unsigned char                                      r_nFriends;                                               // 0x30E2(0x0001) (Net)
	unsigned char                                      r_nEnemies;                                               // 0x30E3(0x0001) (Net)
	float                                              m_fAutoPushForwardDelay;                                  // 0x30E4(0x0004) (Const)
	float                                              r_fAutoPushForwardSpeedScale;                             // 0x30E8(0x0004) (Const, Net)
	float                                              m_fStopAutoPushDelay;                                     // 0x30EC(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_SiegeEngine_Payload");
		return ptr;
	}


	void Destroyed();
	void Tick(float DeltaSeconds);
	void STATIC_UpdateAutoPushState();
	void ToggleCanAutoPushFoward(bool bEnable);
	void StopMovingBackwards();
	void StartMovingBackwards();
	void STATIC_UpdateBackwardsTimers();
	void SetMoveWithoutAllies(TEnumAsByte<EAutoMovePayload> eMove, bool bSkipFullUpdate);
	void StopAutoMoveForward(bool bSkipUpdate);
	void StartAutoMoveForward(bool bSkipUpdate);
	void SetPayloadControlState(TEnumAsByte<EPayloadControlState> NextControlState);
	void STATIC_UpdateAlliesNearbyBehavior(bool bSkipCountUpdate);
	TEnumAsByte<EPayloadControlState> STATIC_GetNextControlState();
	void RemoveNearbyPlayer(class AActor* Other);
	void AddNearbyPlayer(class AActor* Other);
	void ProxyUnTouch(class AActor* Other);
	void ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool STATIC_IsContested();
	bool STATIC_HasEnemyPlayersNearby();
	bool STATIC_HasFriendlyPlayersNearby();
	bool STATIC_CanTriggerOvertime();
	void STATIC_FullUpdate();
	void OnEnableChanged();
	void SetEnable(bool bEnable);
	void OnGroupChange();
	bool PostPawnSetup();
	void ReplicatedEvent(const struct FName& VarName);
	bool STATIC_IsImmuneToDamage();
	void STATIC_UpdateFriendEnemyCounts();
	bool STATIC_VisibilityCheck(class AActor* Target);
	bool NativeIsMovingBackwards();
	bool NativeIsContested();
	bool STATIC_IsNonCombat();
	void UpdatePayloadProgress();
	void SetSpline(class ATgSplineActor* NewSpline, bool bSnapToStart);
	void CreateCollisionProxy();
	void PostPawnSetupServer();
};


// Class TgGame.TgPawn_SiegeBeyond_Payload
// 0x0070 (0x3160 - 0x30F0)
class ATgPawn_SiegeBeyond_Payload : public ATgPawn_SiegeEngine_Payload
{
public:
	float                                              m_fBaseBuffFXRadius;                                      // 0x30F0(0x0004) (Const)
	float                                              m_fBuffFXRadiusScaleMultiplierOffset;                     // 0x30F4(0x0004) (Const)
	struct FName                                       m_nmOffensiveTypeName;                                    // 0x30F8(0x0008) (Const)
	struct FName                                       m_nmDefensiveTypeName;                                    // 0x3100(0x0008) (Const)
	float                                              m_fLastRepairedTimeStamp;                                 // 0x3108(0x0004)
	float                                              r_fAccumulatedRepairTime;                                 // 0x310C(0x0004) (Net)
	float                                              r_fRepairTimeNecessary;                                   // 0x3110(0x0004) (Net)
	float                                              r_fAllyMovementScale;                                     // 0x3114(0x0004) (Net)
	float                                              r_fEnemyMovementScale;                                    // 0x3118(0x0004) (Net)
	float                                              r_fDestroyedMovementScale;                                // 0x311C(0x0004) (Net)
	float                                              r_fCloseToBaseThreshold;                                  // 0x3120(0x0004) (Net)
	float                                              r_fCloseSlowdownFactor;                                   // 0x3124(0x0004) (Net)
	unsigned long                                      r_bInDestroyedState : 1;                                  // 0x3128(0x0004) (Net)
	unsigned long                                      r_bCanRepairSelf : 1;                                     // 0x3128(0x0004) (Net)
	unsigned long                                      r_bDefensiveBuffActive : 1;                               // 0x3128(0x0004) (Net)
	unsigned long                                      r_bOffensiveBuffActive : 1;                               // 0x3128(0x0004) (Net)
	unsigned long                                      r_bExplodeOnDestroyed : 1;                                // 0x3128(0x0004) (Net)
	float                                              m_fAccumulatedOffensiveCrystalRepairTime;                 // 0x312C(0x0004)
	float                                              m_fAccumulatedDefensiveCrystalRepairTime;                 // 0x3130(0x0004)
	float                                              m_fCrystalBuffProgressThreshold;                          // 0x3134(0x0004) (Const)
	TArray<class ATgPawn*>                             m_BuffedPawns;                                            // 0x3138(0x0010) (NeedCtorLink)
	class ATgDevice*                                   m_CachedPassiveDevice;                                    // 0x3148(0x0008)
	class UTgDeviceFire*                               m_CachedBuffMode;                                         // 0x3150(0x0008)
	class UTgDeviceFire*                               m_CachedExplosionMode;                                    // 0x3158(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_SiegeBeyond_Payload");
		return ptr;
	}


	bool STATIC_HasFriendlyPlayersNearby();
	bool STATIC_CanTriggerOvertime();
	TEnumAsByte<EPayloadControlState> STATIC_GetNextControlState();
	void RemoveNearbyPlayer(class AActor* Other);
	void AddNearbyPlayer(class AActor* Other);
	bool Died(class AController* Killer, class UClass* dmgType, const struct FVector& HitLocation);
	void ExplodeAt(const struct FVector& vLoc);
	void STATIC_PlayExplosion(const struct FVector& vLoc);
	void Destroyed();
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_UpdateBuffFX();
	void STATIC_ActivateBuff(const struct FName& nmType);
	void STATIC_ResetBuffs();
	void STATIC_ClearAllPlayerBuffs();
	void STATIC_RemovePlayerBuffs(class ATgPawn* Pawn);
	void STATIC_ApplyPlayerBuffs(class ATgPawn* Pawn);
	bool STATIC_AreAnyBuffsActive();
	bool NativeIsContested();
	void STATIC_GainRepairProgress(float fProgress, const struct FName& nmType);
	void STATIC_FullRepairCart();
	void PawnOnDamageMitigation(class ATgPawn* attacker, class UTgEffectGroup* eg, int nPropertyId, float* fDamage);
	bool CanBeLifestealTarget();
	bool STATIC_IsImmuneToHealing();
	bool STATIC_IsDamageOverTimeImmune();
	bool STATIC_IsImmuneToDamage();
	bool STATIC_IsNonCombat();
	class UTgDeviceFire* STATIC_RetrieveExplosionFiremode();
	class UTgDeviceFire* STATIC_RetrieveBuffFiremode();
	class ATgDevice* STATIC_RetrievePassiveDevice();
};


// Class TgGame.TgPawn_SiegeEngine_CaptureAndPayload
// 0x0010 (0x3100 - 0x30F0)
class ATgPawn_SiegeEngine_CaptureAndPayload : public ATgPawn_SiegeEngine_Payload
{
public:
	float                                              r_fMinimumPayloadTravelTime;                              // 0x30F0(0x0004) (Const, Net)
	float                                              r_fTravelSpeedScaleBeforeBase;                            // 0x30F4(0x0004) (Const, Net)
	TEnumAsByte<ELanePusherActionPoint>                r_eSpeedScaledTravelPoint;                                // 0x30F8(0x0001) (Const, Net)
	unsigned char                                      UnknownData00[0x3];                                       // 0x30F9(0x0003) MISSED OFFSET
	unsigned long                                      r_bIsPassedSpeedScaledTravelPoint : 1;                    // 0x30FC(0x0004) (Const, Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_SiegeEngine_CaptureAndPayload");
		return ptr;
	}


	void SetSpline(class ATgSplineActor* NewSpline, bool bSnapToStart);
};


// Class TgGame.TgPawn_SiegeEngine_Wedge
// 0x0004 (0x3104 - 0x3100)
class ATgPawn_SiegeEngine_Wedge : public ATgPawn_SiegeEngine_CaptureAndPayload
{
public:
	int                                                m_nCollisionMeshId;                                       // 0x3100(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_SiegeEngine_Wedge");
		return ptr;
	}

};


// Class TgGame.TgPawn_SiegeEngine_Payload_Crusade
// 0x0000 (0x30F0 - 0x30F0)
class ATgPawn_SiegeEngine_Payload_Crusade : public ATgPawn_SiegeEngine_Payload
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_SiegeEngine_Payload_Crusade");
		return ptr;
	}

};


// Class TgGame.TgPawn_LanePusherRace
// 0x000C (0x3060 - 0x3054)
class ATgPawn_LanePusherRace : public ATgPawn_LanePusherBase
{
public:
	float                                              s_fTotalSplineLength;                                     // 0x3054(0x0004) (Const)
	float                                              s_fPreviousSplineLength;                                  // 0x3058(0x0004) (Const)
	float                                              r_fProgressPercent;                                       // 0x305C(0x0004) (Const, Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_LanePusherRace");
		return ptr;
	}


	void Destroyed();
	bool Died(class AController* Killer, class UClass* dmgType, const struct FVector& HitLocation);
	void ClearFromGRI();
	void STATIC_UpdateTeamScore();
	bool STATIC_IsNonCombat();
	void SetSpline(class ATgSplineActor* NewSpline, bool bSnapToStart);
	void PostPawnSetupServer();
};


// Class TgGame.TgPawn_HHGate
// 0x0004 (0x2ED0 - 0x2ECC)
class ATgPawn_HHGate : public ATgPawn
{
public:
	unsigned long                                      s_bRegistered : 1;                                        // 0x2ECC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_HHGate");
		return ptr;
	}

};


// Class TgGame.TgPawn_Pet
// 0x005C (0x2F28 - 0x2ECC)
class ATgPawn_Pet : public ATgPawn
{
public:
	float                                              m_fOwnerPhysPowerItemPercent;                             // 0x2ECC(0x0004)
	float                                              m_fOwnerMagicalPowerItemPercent;                          // 0x2ED0(0x0004)
	float                                              m_fOwnerUltilityPowerItemPercent;                         // 0x2ED4(0x0004)
	TEnumAsByte<EPetPhase>                             s_PetPhase;                                               // 0x2ED8(0x0001)
	TEnumAsByte<EPetPosition>                          s_PetPosition;                                            // 0x2ED9(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x2EDA(0x0002) MISSED OFFSET
	struct FRotator                                    s_LastPositionAdjustmentRotation;                         // 0x2EDC(0x000C)
	struct FVector                                     s_InterpolatedPetPosition;                                // 0x2EE8(0x000C)
	struct FVector                                     s_InterpolatedPetOwnerPosition;                           // 0x2EF4(0x000C)
	float                                              s_fPetPositionDistanceMultiplier;                         // 0x2F00(0x0004)
	float                                              s_fOwnerVelocityTime;                                     // 0x2F04(0x0004)
	float                                              s_fSmoothedMaxSpeed;                                      // 0x2F08(0x0004)
	class UTgSpecialFx*                                c_BeamFX;                                                 // 0x2F0C(0x0008) (Transient)
	struct FRotator                                    r_InitialOrientation;                                     // 0x2F14(0x000C) (Net)
	class UParticleSystemComponent*                    c_AimVisibilityMesh;                                      // 0x2F20(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Pet");
		return ptr;
	}


	void PlayDeathAnimation();
	void PlayDyingEffects();
	bool ShouldScoreKill();
	void SetAimVisibilityMesh();
	void ReplicatedEvent(const struct FName& VarName);
	void PostBeginPlay();
	void STATIC_PossessedBy(class AController* C, bool bVehicleTransition);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void DeviceOnDamaged(struct FOnDamagedParams* Params);
	void DeviceAdjustDamage(struct FAdjustDamageParams* Params, float* fDamage);
	void DeviceOnKilled(class ATgDevice* Dev, float fDamage, struct FImpactInfo* Impact);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	bool CanSeeActor(class AActor* Other);
	void STATIC_DirtyAttachmentTransforms();
	float STATIC_GetDefaultMeshScale();
	void CorrectLocationWhileChangingSize(float HeightDelta);
	void STATIC_GetSmallCollisionCylinderSize(float* Radius, float* Height);
	void STATIC_GetGiantCollisionCylinderSize(float* Radius, float* Height);
	bool STATIC_IsDamageOverTimeImmune();
	float STATIC_GetUtilityPowerItem();
	float STATIC_GetMagicalPowerItem();
	float STATIC_GetPhysicalPowerItem();
};


// Class TgGame.TgPawn_Turret
// 0x0020 (0x2F48 - 0x2F28)
class ATgPawn_Turret : public ATgPawn_Pet
{
public:
	unsigned long                                      r_bLockdownIsOn : 1;                                      // 0x2F28(0x0004) (Net)
	unsigned long                                      r_bHasHealingStation : 1;                                 // 0x2F28(0x0004) (Net)
	unsigned long                                      m_bFirstAidNuggetOverride : 1;                            // 0x2F28(0x0004)
	int                                                m_nLockdownPostureID;                                     // 0x2F2C(0x0004)
	class ATgDevice*                                   m_SpawningDevice;                                         // 0x2F30(0x0008)
	class UAkEvent*                                    m_TargetingNotificationAkEvent;                           // 0x2F38(0x0008)
	class AActor*                                      m_PrevTargetActor;                                        // 0x2F40(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Turret");
		return ptr;
	}


	bool Died(class AController* Killer, class UClass* dmgType, const struct FVector& HitLocation);
	void RagdollPawn();
	void PlayDeathAnimation();
	void ReplicatedEvent(const struct FName& VarName);
	void PlayTargetingSound();
	void SetTargetActor(class AActor* Target);
	void ToggleHealingStationFX();
	void ToggleLockdownFX();
	void ToggleLockdownMode(bool bSetActive);
	void STATIC_DropHealthNuggetTeamOnly(int nTaskForce, const struct FVector& SpawnVelocity, float fHealOverride, float fHoTOverride);
	void PostPawnSetupServer();
};


// Class TgGame.TgPawn_Turret_Flamethrower
// 0x0000 (0x2F48 - 0x2F48)
class ATgPawn_Turret_Flamethrower : public ATgPawn_Turret
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Turret_Flamethrower");
		return ptr;
	}

};


// Class TgGame.TgPawn_Turret_Flamethrower_Mini
// 0x0004 (0x2F4C - 0x2F48)
class ATgPawn_Turret_Flamethrower_Mini : public ATgPawn_Turret_Flamethrower
{
public:
	float                                              m_fExtraTranslationOffsetZ;                               // 0x2F48(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Turret_Flamethrower_Mini");
		return ptr;
	}

};


// Class TgGame.TgPawn_Turret_Mega
// 0x0000 (0x2F48 - 0x2F48)
class ATgPawn_Turret_Mega : public ATgPawn_Turret
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Turret_Mega");
		return ptr;
	}

};


// Class TgGame.TgPawn_VoodooTotem
// 0x005C (0x2F84 - 0x2F28)
class ATgPawn_VoodooTotem : public ATgPawn_Pet
{
public:
	class ATgPawn*                                     r_linkedEnemies[0x5];                                     // 0x2F28(0x0008) (Net)
	int                                                nBreakDist;                                               // 0x2F50(0x0004)
	int                                                m_nBeamFXID;                                              // 0x2F54(0x0004)
	class UTgSpecialFx*                                m_BeamFXs[0x5];                                           // 0x2F58(0x0008)
	float                                              fDamageAmount;                                            // 0x2F80(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_VoodooTotem");
		return ptr;
	}


	bool CanBeGrabbed();
	bool CanBePulled();
	void STATIC_SetMovementPhysics();
	void DestroyIt(bool bSkipFx);
	void STATIC_ForwardEffects(const struct FImpactInfo& Impact, class UTgEffectGroup* effectGroup, class ATgDevice* SourceDevice, bool bRemove, int StackCount);
	bool ShouldShowHudOverlay(class ATgPawn* PlayerPawn);
	void PawnOnDamaged(struct FOnDamagedParams* Params);
	void STATIC_UpdateAllBeams();
	void STATIC_UpdateLinkedEnemies();
	void PostPawnSetupServer();
};


// Class TgGame.TgPawn_Structure
// 0x0008 (0x2ED4 - 0x2ECC)
class ATgPawn_Structure : public ATgPawn
{
public:
	float                                              s_fLastDamageTime;                                        // 0x2ECC(0x0004)
	float                                              s_fDamageNotificationDelay;                               // 0x2ED0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Structure");
		return ptr;
	}


	void STATIC_SetMovementPhysics();
	void PostDemoRewind();
	void PlayDeathAnimation();
	bool Died(class AController* Killer, class UClass* dmgType, const struct FVector& HitLocation);
	void TakeDamage(int Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void SendDeathAlert();
	void SendAttackAlert();
	bool CanMove();
};


// Class TgGame.TgPawn_TowerBase
// 0x0034 (0x2F08 - 0x2ED4)
class ATgPawn_TowerBase : public ATgPawn_Structure
{
public:
	TArray<struct FNavMeshBorderEdges>                 BorderEdges;                                              // 0x2ED4(0x0010) (AlwaysInit, NeedCtorLink)
	class UTgSpecialFx*                                c_BeamFX;                                                 // 0x2EE4(0x0008) (Transient)
	class UTgMarkComponent*                            s_DamageScaler;                                           // 0x2EEC(0x0008) (ExportObject, Component, EditInline)
	int                                                m_nNumGuardianLevels;                                     // 0x2EF4(0x0004)
	unsigned long                                      r_bLocked : 1;                                            // 0x2EF8(0x0004) (Net)
	unsigned long                                      m_bShouldBeFaded : 1;                                     // 0x2EF8(0x0004) (Transient)
	float                                              m_fTransparentFadeSpeed;                                  // 0x2EFC(0x0004)
	float                                              m_fMaxFadeTransparency;                                   // 0x2F00(0x0004)
	float                                              m_fFadeDistance2D;                                        // 0x2F04(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_TowerBase");
		return ptr;
	}


	bool Died(class AController* Killer, class UClass* dmgType, const struct FVector& HitLocation);
	struct FVector STATIC_GetPositionOnBorderEdge(const struct FVector& FromPosition);
	void QueryBorderEdges(const struct FVector& BoundsExtent, bool bUseObb);
	void SetTransparencyFaded(bool bShouldBeFaded);
	void CalcDistanceFadeValue(float fDeltaTime);
	void PawnOnDamageMitigation(class ATgPawn* attacker, class UTgEffectGroup* eg, int nPropertyId, float* fDamage);
	void DeviceAdjustDamage(struct FAdjustDamageParams* Params, float* fDamage);
	void DeviceOnDamaged(struct FOnDamagedParams* Params);
	void SendTargetedAlert(class ATgPawn* Target);
	void SetTargetActor(class AActor* Target);
};


// Class TgGame.TgPawn_Tower
// 0x0050 (0x2F58 - 0x2F08)
class ATgPawn_Tower : public ATgPawn_TowerBase
{
public:
	float                                              m_TimeSinceDeath;                                         // 0x2F08(0x0004)
	TArray<class UMaterialInstanceConstant*>           m_DestroyedMICs;                                          // 0x2F0C(0x0010) (NeedCtorLink)
	float                                              m_fFadeOutStartTime;                                      // 0x2F1C(0x0004)
	float                                              m_fFadeOutEndTime;                                        // 0x2F20(0x0004)
	struct FVector                                     r_vInitialRotation;                                       // 0x2F24(0x000C) (Net)
	unsigned long                                      m_bUseDestruction : 1;                                    // 0x2F30(0x0004)
	unsigned long                                      r_bSide0Destroyed : 1;                                    // 0x2F30(0x0004) (Net)
	unsigned long                                      r_bSide1Destroyed : 1;                                    // 0x2F30(0x0004) (Net)
	unsigned long                                      r_bSide2Destroyed : 1;                                    // 0x2F30(0x0004) (Net)
	unsigned long                                      r_bSide3Destroyed : 1;                                    // 0x2F30(0x0004) (Net)
	unsigned char                                      r_PlaySide0Destruction;                                   // 0x2F34(0x0001) (Net)
	unsigned char                                      r_PlaySide1Destruction;                                   // 0x2F35(0x0001) (Net)
	unsigned char                                      r_PlaySide2Destruction;                                   // 0x2F36(0x0001) (Net)
	unsigned char                                      r_PlaySide3Destruction;                                   // 0x2F37(0x0001) (Net)
	int                                                m_nSide0MeshId;                                           // 0x2F38(0x0004)
	int                                                m_nSide1MeshId;                                           // 0x2F3C(0x0004)
	int                                                m_nSide2MeshId;                                           // 0x2F40(0x0004)
	int                                                m_nSide3MeshId;                                           // 0x2F44(0x0004)
	int                                                m_nSide0Health;                                           // 0x2F48(0x0004)
	int                                                m_nSide1Health;                                           // 0x2F4C(0x0004)
	int                                                m_nSide2Health;                                           // 0x2F50(0x0004)
	int                                                m_nSide3Health;                                           // 0x2F54(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Tower");
		return ptr;
	}


	void PostDemoRewind();
	void OnSwapToDestroyedMesh();
	bool Died(class AController* Killer, class UClass* dmgType, const struct FVector& HitLocation);
	void CheckSideDestructionSkelControls(int ForceSideIndexHidden);
	void PlaySideDestructionAnim(int SideIndex);
	void TakeDamage(int Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void ReplicatedEvent(const struct FName& VarName);
	bool PostPawnSetup();
	void PostBeginPlay();
	int STATIC_GetMeshOverrideForScript(int MeshId);
	void BroadcastDiedToGame();
	void SwapToBrokenMesh();
	void SendTargetedAlert(class ATgPawn* Target);
	void SendDeathAlert();
	void SendAttackAlert();
};


// Class TgGame.TgPawn_SiegeWall
// 0x002C (0x2F84 - 0x2F58)
class ATgPawn_SiegeWall : public ATgPawn_Tower
{
public:
	float                                              m_fImpactEffectXRange;                                    // 0x2F58(0x0004) (Edit)
	float                                              m_fImpactEffectYRange;                                    // 0x2F5C(0x0004) (Edit)
	struct FVector                                     r_vNextImpactEffectLocation;                              // 0x2F60(0x000C) (Net)
	float                                              m_fImpactRecoveryTime;                                    // 0x2F6C(0x0004) (Edit)
	float                                              m_fRemainingImpactRecoveryTime;                           // 0x2F70(0x0004)
	float                                              m_fMaxImpactSize;                                         // 0x2F74(0x0004) (Edit)
	class UMaterialInstanceConstant*                   m_ImpactMIC;                                              // 0x2F78(0x0008)
	unsigned long                                      c_bIsVulnerable : 1;                                      // 0x2F80(0x0004)
	unsigned long                                      m_bHasRegisteredObstacle : 1;                             // 0x2F80(0x0004)
	unsigned long                                      m_bSpawnedThisFrame : 1;                                  // 0x2F80(0x0004)
	unsigned long                                      m_bQueriedBorderEdges : 1;                                // 0x2F80(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_SiegeWall");
		return ptr;
	}


	void TakeDamage(int Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	bool Died(class AController* Killer, class UClass* dmgType, const struct FVector& HitLocation);
	int GetHPScalingValue();
	void PlayWallImpact();
	struct FName STATIC_GetWallImpactKismetName();
	void STATIC_UnRegisterWithGRI();
	void RegisterWithGRI();
	void PostBeginPlay();
	bool STATIC_IsVulnerable();
	bool ApplyPawnSetup();
	void STATIC_UnRegisterObstacle();
	void STATIC_RegisterObstacle();
	void PostPawnSetupServer();
	void SendDeathAlert();
	void SendAttackAlert();
	void PlaySpecialEffectEvent(int PlaySpecialEffectIndex, const struct FVector& vLoc, const struct FVector& vHitNormal, class AActor* inActor);
	void STATIC_GenerateNewImpactEffectLocation();
	bool STATIC_IsDebuffImmune();
};


// Class TgGame.TgPawn_SiegeWall_Base
// 0x0008 (0x2F8C - 0x2F84)
class ATgPawn_SiegeWall_Base : public ATgPawn_SiegeWall
{
public:
	unsigned long                                      m_bHasAlertedLowHealth : 1;                               // 0x2F84(0x0004)
	float                                              m_fLowHealthTrigger;                                      // 0x2F88(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_SiegeWall_Base");
		return ptr;
	}


	void STATIC_UnRegisterWithGRI();
	void RegisterWithGRI();
	int GetHPScalingValue();
	bool Died(class AController* Killer, class UClass* dmgType, const struct FVector& HitLocation);
	struct FName STATIC_GetWallImpactKismetName();
	void PostBeginPlay();
	void SendLowHealthAlert();
	void SendAttackAlert();
};


// Class TgGame.TgPawn_SiegeWall_Inner
// 0x0000 (0x2F84 - 0x2F84)
class ATgPawn_SiegeWall_Inner : public ATgPawn_SiegeWall
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_SiegeWall_Inner");
		return ptr;
	}


	void STATIC_UnRegisterWithGRI();
	void RegisterWithGRI();
	int GetHPScalingValue();
	struct FName STATIC_GetWallImpactKismetName();
	void PostBeginPlay();
	void SendAttackAlert();
};


// Class TgGame.TgPawn_SiegeWall_Outer
// 0x0000 (0x2F84 - 0x2F84)
class ATgPawn_SiegeWall_Outer : public ATgPawn_SiegeWall
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_SiegeWall_Outer");
		return ptr;
	}


	void STATIC_UnRegisterWithGRI();
	void RegisterWithGRI();
	int GetHPScalingValue();
	struct FName STATIC_GetWallImpactKismetName();
	void PostBeginPlay();
	void SendAttackAlert();
};


// Class TgGame.TgPawn_Tower_FA
// 0x0018 (0x2F70 - 0x2F58)
class ATgPawn_Tower_FA : public ATgPawn_Tower
{
public:
	TEnumAsByte<ETowerType>                            m_TowerType;                                              // 0x2F58(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x2F59(0x0003) MISSED OFFSET
	struct FRotator                                    r_InitialOrientation;                                     // 0x2F5C(0x000C) (Net)
	class UParticleSystemComponent*                    c_AimVisibilityMesh;                                      // 0x2F68(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Tower_FA");
		return ptr;
	}


	void OnDeviceFormFire(int nEquipSlot, float fRefireTime, int nFireMode);
	struct FVector GetWeaponStartTraceLocation(class ATgDevice* Dev);
	void ReplicatedEvent(const struct FName& VarName);
	void PostBeginPlay();
	void PlayDyingEffects();
	void SetAimVisibilityMesh();
	bool CanSeeActor(class AActor* Other);
};


// Class TgGame.TgPawnMod
// 0x0010 (0x0070 - 0x0060)
class UTgPawnMod : public UObject
{
public:
	struct FPointer                                    VfTable_ITgCallbackInterface;                             // 0x0060(0x0008) (Const, Native, NoExport)
	class UTgCallbackContainer*                        m_CallbackContainer;                                      // 0x0068(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawnMod");
		return ptr;
	}


	void Generic3(class AActor* Owner, int nParamA, int nParamB);
	void Generic2(class AActor* Owner, int nParamA, int nParamB);
	void Generic1(class AActor* Owner, int nParamA, int nParamB);
	void Initialize(class AActor* Owner);
};


// Class TgGame.TgPawnMod_FxAudio
// 0x003C (0x00AC - 0x0070)
class UTgPawnMod_FxAudio : public UTgPawnMod
{
public:
	TArray<struct FModFxAudioValues>                   m_AudioValues;                                            // 0x0070(0x0010) (Edit, NeedCtorLink)
	float                                              m_fTimeSinceBeat;                                         // 0x0080(0x0004)
	int                                                m_nNumSegments;                                           // 0x0084(0x0004) (Edit)
	float                                              m_fDampenedVal;                                           // 0x0088(0x0004)
	unsigned long                                      m_bActivateCharacterMusic : 1;                            // 0x008C(0x0004)
	unsigned long                                      m_bQueuedPlayMusic : 1;                                   // 0x008C(0x0004)
	int                                                m_nPlayingId;                                             // 0x0090(0x0004)
	int                                                m_nSwitchQueryId;                                         // 0x0094(0x0004)
	int                                                m_nRTPCQueryId;                                           // 0x0098(0x0004)
	struct FName                                       m_nmLobbySwitchName;                                      // 0x009C(0x0008)
	struct FName                                       m_nmGameSwitchGroupName;                                  // 0x00A4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawnMod_FxAudio");
		return ptr;
	}


	void AdjustMusicBankValues(float fDeltaSeconds, float fRawInput, TArray<struct FModFxAudioValues>* AudioValues);
	void Initialize(class AActor* Owner);
};


// Class TgGame.TgSpectatorController
// 0x024C (0x1874 - 0x1628)
class ATgSpectatorController : public ATgPlayerController
{
public:
	TEnumAsByte<ESpectatorCameraMode>                  m_CameraMode;                                             // 0x1628(0x0001) (Transient)
	TEnumAsByte<ESpectatorCameraCycle>                 m_CurrentCycle;                                           // 0x1629(0x0001) (Transient)
	TEnumAsByte<ESpectatorCameraCycle>                 m_PendingCycle;                                           // 0x162A(0x0001) (Transient)
	TEnumAsByte<ESpecFlightMode>                       m_eHelicopterFlight;                                      // 0x162B(0x0001) (Transient)
	TEnumAsByte<ESpectatorMode>                        m_CurrentSpectatorMode;                                   // 0x162C(0x0001) (Transient)
	TEnumAsByte<EZoomState>                            m_CurrentZoomState;                                       // 0x162D(0x0001) (Transient)
	unsigned char                                      UnknownData00[0x2];                                       // 0x162E(0x0002) MISSED OFFSET
	class ATgSpectatorTempCam*                         m_BookmarkCamera;                                         // 0x1630(0x0008) (Transient)
	struct FSpectatorBookmark                          m_Bookmarks[0xA];                                         // 0x1638(0x0030) (Transient)
	float                                              m_fDefaultTweenTime;                                      // 0x1818(0x0004)
	unsigned long                                      m_bOutlineCharacters : 1;                                 // 0x181C(0x0004) (Transient)
	unsigned long                                      m_bIsMapSquashed : 1;                                     // 0x181C(0x0004) (Transient)
	unsigned long                                      m_bIgnoreCullDistanceVolumes : 1;                         // 0x181C(0x0004) (Edit, Config)
	float                                              m_fNameplateFadeMinDist;                                  // 0x1820(0x0004) (Edit)
	float                                              m_fNameplateFadeMaxDist;                                  // 0x1824(0x0004) (Edit)
	float                                              m_fNameplateFadeMaxAmount;                                // 0x1828(0x0004) (Edit)
	float                                              m_fNameplateScaleMinDist;                                 // 0x182C(0x0004) (Edit)
	float                                              m_fNameplateScaleMaxDist;                                 // 0x1830(0x0004) (Edit)
	float                                              m_fNameplateScaleMaxAmount;                               // 0x1834(0x0004) (Edit)
	float                                              m_fInterpolateCameraDistance;                             // 0x1838(0x0004) (Edit)
	struct FBroadcastChannel                           m_BroadcastChannels[0x4];                                 // 0x183C(0x0008)
	struct FVector                                     c_vMouseClickDeprojectionExtent;                          // 0x185C(0x000C) (Config)
	float                                              m_fOverviewCenterpointOffset;                             // 0x1868(0x0004) (Edit, Config)
	float                                              m_fMouseCursorVisibleTime;                                // 0x186C(0x0004) (Edit, Config)
	float                                              m_fRemainingCursorVisibleTime;                            // 0x1870(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSpectatorController");
		return ptr;
	}


	void SetViewTarget(class AActor* NewViewTarget, const struct FViewTargetTransitionParams& TransitionParams);
	class ATgPawn* STATIC_GetTgPawn();
	void SpectatePlayerIndex(int TaskForceNum, int PlayerIndex);
	void STATIC_UpdateBroadcastChannels();
	void ChangeZoomState(TEnumAsByte<EZoomState> NewZoomState);
	void SpectateZoomOut(bool bEnabled);
	void SpectateZoomIn(bool bEnabled);
	void STATIC_GetActorListFrom2DCoordinate(const struct FVector2D& Coordinate, TArray<class AActor*>* ActorList);
	class APawn* STATIC_GetPawnFrom2DCoordinate(const struct FVector2D& Coordinate);
	void STATIC_FlipOverviewSides();
	void SpecTest();
	void SquashMap();
	float GetFOVAngle();
	void SetOutlineCharacters(bool bNewOutlineCharacters);
	void ToggleOutlineCharacters();
	struct FString StripClanTag(const struct FString& PlayerName);
	void DecreaseCameraSpeed();
	void STATIC_IncreaseCameraSpeeed();
	void CameraSpeed(float NewSpeed);
	void STATIC_GotoCinematicCam(const struct FString& sCamName);
	void SpecSetFlightMode(TEnumAsByte<ESpecFlightMode> sfm);
	void RecallSpectatorBookmark(int nNum);
	void SetSpectatorBookmark(int nNum);
	struct FViewTargetTransitionParams STATIC_GetSnapBlendParams();
	struct FViewTargetTransitionParams STATIC_GetDefaultBlendParams();
	struct FViewTargetTransitionParams STATIC_GetBlendParams(class AActor* Target);
	void SpecViewPlayer(const struct FString& PlayerName);
	void SpecViewAction();
	TEnumAsByte<ESpectatorCameraMode> STATIC_GetDefaultModeFor(class AActor* Target);
	TArray<class AActor*> STATIC_GetActionList();
	TArray<class AActor*> STATIC_GetOutermostTowerList();
	TArray<class AActor*> STATIC_GetPlayerList();
	TArray<class AActor*> STATIC_GetViewTargetListForMode(TEnumAsByte<ESpectatorCameraCycle> cycle);
	void CycleNext(bool bSkipIfPresent, bool bReverse);
	void SnapViewToLocation(const struct FVector& WorldLocation, bool bUseFocalPoint);
	void SetPendingOnDirectorMode();
	bool PingMap(const struct FVector& WorldLocation, TEnumAsByte<EPING_TYPE> Type, TArray<class AReplicationInfo*>* worldActorRepInfo);
	void SnapViewToHoverTarget(bool bUseAltView);
	void STATIC_LockedViewCam(bool bEnabled);
	bool STATIC_InterceptFlashInput(const struct FName& ButtonName, TEnumAsByte<EInputEvent> Event);
	void ClearPendingSpecCycle();
	void SetPendingSpecCycle(TEnumAsByte<ESpectatorCameraCycle> Mode);
	void ClientSetReadyState(bool bReadyToPlay);
	void ToggleSpectatorPlayerIcons();
	void SetSpectatorCameraMode(TEnumAsByte<ESpectatorCameraMode> Mode, bool bCameraTween);
	void SetNewSpectatorMode(TEnumAsByte<ESpectatorMode> NewMode);
	void STATIC_UpdateViewTargetUI();
	void SpectatorSetViewTarget(class AActor* VT, const struct FViewTargetTransitionParams& TransitionParams);
	void SwitchCamera(const struct FString& sCamera);
	void SpectatorClearViewViewTarget();
	void ClientForwardToSpectatingMatch();
	void STATIC_ForwardToSpectatingMatch();
	void PostBeginPlay();
	void STATIC_ReplicateMove(float DeltaTime, const struct FVector& newAccel, TEnumAsByte<EDoubleClickDir> DoubleClickMove, const struct FRotator& DeltaRot);
	void SetNetTarget(const struct FQWord& qwId, int nTaskForce);
	class UClass* STATIC_GetHudClass(class UClass* pNewHudType);
};


// Class TgGame.TgDemoRecSpectator
// 0x0088 (0x18FC - 0x1874)
class ATgDemoRecSpectator : public ATgSpectatorController
{
public:
	TArray<struct FSpectatorCommand>                   PendingCommands;                                          // 0x1874(0x0010) (NeedCtorLink)
	int                                                m_TimeIndex;                                              // 0x1884(0x0004)
	TArray<struct FDilationData>                       m_TimeDilations;                                          // 0x1888(0x0010) (NeedCtorLink)
	struct FPointer                                    m_pTgCallbackDevice;                                      // 0x1898(0x0008) (Native)
	int                                                m_1xTimeIndex;                                            // 0x18A0(0x0004) (Transient)
	unsigned long                                      m_bIsPaused : 1;                                          // 0x18A4(0x0004) (Transient)
	unsigned long                                      m_bInStasis : 1;                                          // 0x18A4(0x0004) (Transient)
	unsigned long                                      m_bSpectatorMaster : 1;                                   // 0x18A4(0x0004) (Transient)
	unsigned long                                      m_bSyncWithMasterEnabled : 1;                             // 0x18A4(0x0004) (Transient)
	unsigned long                                      m_bIsSyncingWithMaster : 1;                               // 0x18A4(0x0004) (Transient)
	unsigned long                                      m_bAutoSlomo : 1;                                         // 0x18A4(0x0004) (Transient, Config)
	unsigned long                                      m_bReceiveCamSync : 1;                                    // 0x18A4(0x0004) (Transient, Config)
	int                                                m_nLastReceivedMasterFrame;                               // 0x18A8(0x0004) (Transient)
	float                                              m_fLastReceivedMasterTimeDilation;                        // 0x18AC(0x0004) (Transient)
	float                                              m_fLastReceievedRealTimeStamp;                            // 0x18B0(0x0004) (Transient)
	int                                                m_nSyncFrameThreshold;                                    // 0x18B4(0x0004) (Const, Config)
	int                                                m_nSyncFrameCheckThreshold;                               // 0x18B8(0x0004) (Const, Config)
	int                                                m_nSyncAheadFrameThreshold;                               // 0x18BC(0x0004) (Const, Config)
	int                                                m_nLastTimerValue;                                        // 0x18C0(0x0004) (Transient)
	class ATgSpectatorDirector*                        m_SpectatorDirector;                                      // 0x18C4(0x0008)
	class ATgCollisionProxy_SpectatorActionListener*   m_ActionListener;                                         // 0x18CC(0x0008) (Transient)
	float                                              m_fActionListenerRadius;                                  // 0x18D4(0x0004) (Transient, Config)
	float                                              m_fActionListenerHeight;                                  // 0x18D8(0x0004) (Transient, Config)
	int                                                m_nCurrentActionListenerRating;                           // 0x18DC(0x0004) (Transient)
	int                                                m_nActionListenerRatingThreshold;                         // 0x18E0(0x0004) (Transient, Config)
	float                                              m_fRemainingAutoSlomoTime;                                // 0x18E4(0x0004)
	float                                              m_fAutoSlomoExpirationTime;                               // 0x18E8(0x0004) (Transient, Config)
	int                                                m_nAutoSlomoSpeedIndex;                                   // 0x18EC(0x0004) (Transient, Config)
	int                                                m_nAutoSlomoNearbyPlayersNum;                             // 0x18F0(0x0004) (Transient, Config)
	float                                              m_fAutoSlomoFrequency;                                    // 0x18F4(0x0004) (Transient, Config)
	float                                              m_fRemainingAutoSlomoTimeoutTime;                         // 0x18F8(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDemoRecSpectator");
		return ptr;
	}


	void ReceiveCamSyncTarget(int PawnId, int SourcePlayerId);
	void SendCamSyncTarget();
	void SpectatorReceivedViewTarget(class AActor* VT);
	void SpectatorSetViewTarget(class AActor* VT, const struct FViewTargetTransitionParams& TransitionParams);
	void STATIC_EnableCamSync(bool bEnabled);
	void TriggerAutoSlomo(float SlomoTime);
	void OnActionListenerStartFire(class ATgPawn* FiringPawn, int nEquipSlot);
	void STATIC_EnableAutoSlomo(bool bEnabled);
	void ToggleAutoSlomo();
	void SpecViewPlayer(const struct FString& PlayerName);
	bool PingMap(const struct FVector& WorldLocation, TEnumAsByte<EPING_TYPE> Type, TArray<class AReplicationInfo*>* worldActorRepInfo);
	void SetNewSpectatorMode(TEnumAsByte<ESpectatorMode> NewMode);
	void FindNextClosestAssistedViewTarget();
	void FindNearbyAssistedViewTarget();
	void STATIC_DirectorModeToggle();
	void PostDemoRewind();
	void CheckSpectatorMasterSlave();
	void ToggleSync();
	void STATIC_EnableSync(bool bEnabled);
	bool STATIC_IsSyncedWithMaster(int Threshold);
	int STATIC_GetSyncTargetFrame();
	void SetSyncTargetFrame(int FrameNum, float TimeDilation);
	void RewindGraphs();
	void PauseEx();
	bool SetSpectatorMasterSlave();
	bool CanFastForward();
	void STATIC_GoToFrame(float fPercent);
	void Rewind(int JumpAmount, int FrameNum);
	void STATIC_DilateTime(float Amount, bool bForceReset);
	void Pause();
	void STATIC_Slomo(float NewTimeDilation);
	void PostBeginPlay();
	void ReceivedPlayer();
	int STATIC_GetSpectatorTaskforceNumber();
	void StartAutoCombatLog();
	void ToggleThirdPersonView();
	void CreateManualRewindPoint();
	class UClass* STATIC_GetHudClass(class UClass* pNewHudType);
	void STATIC_UnregisterEngineCallbacks();
	void RegisterEngineCallbacks();
	void STATIC_UpdateCameraModeUI();
	bool STATIC_UpdateSyncingUI();
	void STATIC_UpdateTimeDilation();
	void RequestSync();
	void OnSynced();
};


// Class TgGame.TgDemoRecSpectator_Debug
// 0x0010 (0x190C - 0x18FC)
class ATgDemoRecSpectator_Debug : public ATgDemoRecSpectator
{
public:
	class UPlayer*                                     m_OriginalPlayer;                                         // 0x18FC(0x0008)
	class APlayerController*                           m_OriginalPlayerController;                               // 0x1904(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDemoRecSpectator_Debug");
		return ptr;
	}

};


// Class TgGame.TgPlayerInput
// 0x00C4 (0x03BC - 0x02F8)
class UTgPlayerInput : public UPComPlayerInput
{
public:
	class ATgPlayerController*                         c_TgPC;                                                   // 0x02F8(0x0008)
	unsigned long                                      c_bASKeyCapture : 1;                                      // 0x0300(0x0004)
	unsigned long                                      c_bASSpecKeyCapture : 1;                                  // 0x0300(0x0004)
	unsigned long                                      c_bMiniMapPinging : 1;                                    // 0x0300(0x0004)
	unsigned long                                      c_bAutoRun : 1;                                           // 0x0300(0x0004)
	unsigned long                                      GyroAimAssist : 1;                                        // 0x0300(0x0004) (Config, GlobalConfig)
	unsigned long                                      bEnableAimAssist : 1;                                     // 0x0300(0x0004)
	float                                              GamepadSensitivityX;                                      // 0x0304(0x0004) (Config, GlobalConfig)
	float                                              GamepadSensitivityY;                                      // 0x0308(0x0004) (Config, GlobalConfig)
	float                                              GyroSensitivityX;                                         // 0x030C(0x0004) (Config, GlobalConfig)
	float                                              GyroSensitivityY;                                         // 0x0310(0x0004) (Config, GlobalConfig)
	float                                              GyroTuningConstant;                                       // 0x0314(0x0004) (Config, GlobalConfig)
	float                                              fScopeSensitivity;                                        // 0x0318(0x0004) (Config, GlobalConfig)
	float                                              m_fMinScopeSensitivityMult;                               // 0x031C(0x0004)
	float                                              m_fMaxScopeSensitivityMult;                               // 0x0320(0x0004)
	float                                              m_fSecondsBetweenMixedInputAllowed;                       // 0x0324(0x0004)
	int                                                nAimAccelerationSet;                                      // 0x0328(0x0004) (Config, GlobalConfig)
	int                                                nAimAccelerationBoost;                                    // 0x032C(0x0004) (Config, GlobalConfig)
	float                                              fTurnSpeedAccelAmt;                                       // 0x0330(0x0004) (Transient)
	float                                              fLookUpSpeedAccelAmt;                                     // 0x0334(0x0004) (Transient)
	int                                                nAimAccelerationAlgorithm;                                // 0x0338(0x0004)
	int                                                nInnerDeadZoneSize;                                       // 0x033C(0x0004) (Config, GlobalConfig)
	int                                                nOuterDeadZoneSize;                                       // 0x0340(0x0004) (Config, GlobalConfig)
	class AActor*                                      BestAimAssistTarget;                                      // 0x0344(0x0008) (Transient)
	float                                              fAimAssistMultiTargetMult;                                // 0x034C(0x0004) (Transient)
	float                                              m_fStacksRequiredForMultiTarget;                          // 0x0350(0x0004)
	float                                              m_fAimAssistMultiTargetMaxMult;                           // 0x0354(0x0004)
	class UTgGameplayCurves*                           m_AimAssistCurves;                                        // 0x0358(0x0008)
	TArray<struct FAimAssistTargetWeight>              m_AimAssistTargets;                                       // 0x0360(0x0010) (Transient, NeedCtorLink)
	struct FAimAssistTargetWeightVars                  TargetWeightVars;                                         // 0x0370(0x001C)
	struct FScriptDelegate                             __OnRawInputKey__Delegate;                                // 0x038C(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData00[0x4];                                       // 0x038C(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY
	struct FScriptDelegate                             __OnInputAxis__Delegate;                                  // 0x039C(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData01[0x4];                                       // 0x039C(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY
	struct FScriptDelegate                             __OnInputChar__Delegate;                                  // 0x03AC(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData02[0x4];                                       // 0x03AC(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPlayerInput");
		return ptr;
	}


	void STATIC_FlushPressedKey(const struct FName& Key);
	void UnbindCommand(const struct FString& Command, bool bGamepad, int nAlternate);
	void UnbindCommandAll(const struct FString& Command);
	void SetCommandBind(const struct FString& Command, bool bGamepad, int nAlternate, const struct FString& ExtendedBinding);
	void SetBindExtended(const struct FString& ExtendedBinding, const struct FString& Command);
	void SetMouseInput(bool bInvert, bool bSmooth, float fSensitivity);
	void CancelAutoRun();
	void ToggleAutoRun();
	void SetAimAccelerationSet(int AimSet);
	void SetAimAccelerationAlgorithm(int Algorithm);
	struct FRotator ApplyAimVectorModification(class ATgDevice* InDevice, const struct FRotator& InRotation);
	bool ShouldUseAimAssist();
	void Duck();
	bool InputChar(int ControllerId, const struct FString& Unicode);
	void PlayerInput(float DeltaTime);
	bool STATIC_IsGyroInputAllowed();
	struct FKeyBind STATIC_GenerateKeybindFromButton(const struct FName& ButtonName);
	void SetKeyCaptureState(bool bSpectator, bool bCaptureKey);
	void ResetKeysToDefault();
	void ReadMouseSettings();
	void StoreMouseSettings();
	bool OnInputChar(int ControllerId, const struct FString& Unicode);
	bool OnInputAxis(int ControllerId, const struct FName& Key, float Delta, float DeltaTime);
	bool OnRawInputKey(int ControllerId, const struct FName& Key, TEnumAsByte<EInputEvent> Event, float AmountDepressed);
};


// Class TgGame.TgSpectatorInput
// 0x0004 (0x03C0 - 0x03BC)
class UTgSpectatorInput : public UTgPlayerInput
{
public:
	float                                              SpectatorSensitivity;                                     // 0x03BC(0x0004) (Config)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSpectatorInput");
		return ptr;
	}


	void PlayerInput(float DeltaTime);
	void CheckIdleBreak();
};


// Class TgGame.TgPropActor
// 0x0011 (0x0291 - 0x0280)
class ATgPropActor : public AActor
{
public:
	class UMeshComponent*                              c_Mesh;                                                   // 0x0280(0x0008) (ExportObject, Component, EditInline)
	float                                              m_fTickPostDeactivate;                                    // 0x0288(0x0004)
	unsigned long                                      m_bDeactivateOnPhysNone : 1;                              // 0x028C(0x0004)
	unsigned long                                      m_bIsActive : 1;                                          // 0x028C(0x0004)
	unsigned long                                      m_bForceHidden : 1;                                       // 0x028C(0x0004)
	TEnumAsByte<EPhysics>                              m_ePhysicsOnActive;                                       // 0x0290(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPropActor");
		return ptr;
	}


	void STATIC_VolumeBasedDestroy(class APhysicsVolume* PV);
	void OutsideWorldBounds();
	void FellOutOfWorld(class UClass* dmgType);
	void FxDeactivateGroup(const struct FName& nmGroup);
	void FxActivateGroup(const struct FName& nmGroup);
	void STATIC_SetForceHidden(bool bForceHidden);
	void StopTicking();
	void STATIC_ChangeActivation(bool bActive, bool bNoFX);
	void STATIC_InitMesh(int nMeshAsmId);
};


// Class TgGame.TgSkeletalMeshActor_Loader
// 0x0184 (0x04B0 - 0x032C)
class ATgSkeletalMeshActor_Loader : public ATgSkeletalMeshActor
{
public:
	struct FPointer                                    VfTable_ITgSkinnableInterface;                            // 0x032C(0x0008) (Const, Native, NoExport)
	struct FPointer                                    VfTable_ITgCallbackInterface;                             // 0x0334(0x0008) (Const, Native, NoExport)
	class UTgMenuMeshInfo*                             m_PendingMeshInfo;                                        // 0x033C(0x0008) (Transient)
	class UTgMenuMeshInfo*                             m_CurrentMeshInfo;                                        // 0x0344(0x0008) (Transient)
	class UTgManifestGroup*                            c_AssetManifestGroup;                                     // 0x034C(0x0008) (ExportObject, NeedCtorLink, EditInline)
	struct FPointer                                    m_PendingBot;                                             // 0x0354(0x0008) (Native)
	struct FPointer                                    m_PendingSkin;                                            // 0x035C(0x0008) (Native)
	struct FPointer                                    m_PendingDevice;                                          // 0x0364(0x0008) (Native)
	struct FPointer                                    m_PendingDeviceSkin;                                      // 0x036C(0x0008) (Native)
	TEnumAsByte<ELobbyAnimPose>                        m_PendingPose;                                            // 0x0374(0x0001) (Transient)
	TEnumAsByte<ELobbyAnimPose>                        m_CurrentPose;                                            // 0x0375(0x0001) (Transient)
	TEnumAsByte<EModelHighlightType>                   m_HighlightType;                                          // 0x0376(0x0001) (Transient)
	unsigned char                                      UnknownData00[0x1];                                       // 0x0377(0x0001) MISSED OFFSET
	struct FPointer                                    m_PendingMVPDevice;                                       // 0x0378(0x0008) (Native)
	struct FPointer                                    m_CurrentBot;                                             // 0x0380(0x0008) (Native)
	struct FPointer                                    m_CurrentSkin;                                            // 0x0388(0x0008) (Native)
	struct FPointer                                    m_CurrentDevice;                                          // 0x0390(0x0008) (Native)
	struct FPointer                                    m_CurrentDeviceSkin;                                      // 0x0398(0x0008) (Native)
	struct FPointer                                    m_CurrentMVPDevice;                                       // 0x03A0(0x0008) (Native)
	unsigned long                                      m_bIsActive : 1;                                          // 0x03A8(0x0004)
	unsigned long                                      m_bWaitingForTextures : 1;                                // 0x03A8(0x0004) (Transient)
	unsigned long                                      m_bIsAsyncLoading : 1;                                    // 0x03A8(0x0004) (Transient)
	unsigned long                                      m_bIsAsyncSimulating : 1;                                 // 0x03A8(0x0004) (Transient)
	unsigned long                                      m_bDeferAsyncSwap : 1;                                    // 0x03A8(0x0004) (Edit)
	unsigned long                                      m_bWaitingForAsyncSwap : 1;                               // 0x03A8(0x0004) (Transient)
	unsigned long                                      m_bAllowOverlays : 1;                                     // 0x03A8(0x0004) (Edit)
	unsigned long                                      m_bUsesPreviewMesh : 1;                                   // 0x03A8(0x0004) (Edit)
	unsigned long                                      m_bOverrideLightingChannels : 1;                          // 0x03A8(0x0004) (Edit)
	float                                              m_fAsyncSwapDelay;                                        // 0x03AC(0x0004) (Edit)
	float                                              m_fAsyncSwapTimer;                                        // 0x03B0(0x0004) (Transient)
	int                                                m_nAsyncLoadDelayTicksDefault;                            // 0x03B4(0x0004)
	int                                                m_nAsyncLoadDelayTicks;                                   // 0x03B8(0x0004) (Transient)
	class UPointLightComponent*                        m_PointLight;                                             // 0x03BC(0x0008) (ExportObject, Transient, Component, EditInline)
	TArray<class UTgSkeletalMeshComponent*>            m_ChildMeshes;                                            // 0x03C4(0x0010) (ExportObject, Transient, Component, NeedCtorLink, EditInline)
	TArray<class UTgSkeletalMeshComponent*>            m_SkinMeshes;                                             // 0x03D4(0x0010) (ExportObject, Transient, Component, NeedCtorLink, EditInline)
	class UTgSkeletalMeshComponent*                    m_BodyMesh;                                               // 0x03E4(0x0008) (ExportObject, Transient, Component, EditInline)
	class UTgSkeletalMeshComponent*                    m_HeadMesh;                                               // 0x03EC(0x0008) (ExportObject, Transient, Component, EditInline)
	class UTgSkeletalMeshComponent*                    m_WeaponMesh;                                             // 0x03F4(0x0008) (ExportObject, Transient, Component, EditInline)
	class ULightEnvironmentComponent*                  m_AlternateLightEnvironmentTemplate;                      // 0x03FC(0x0008) (ExportObject, Transient, Component, EditInline)
	TArray<class ULightEnvironmentComponent*>          m_AlternateLightEnvironments;                             // 0x0404(0x0010) (ExportObject, Transient, Component, NeedCtorLink, EditInline)
	class UMaterialInterface*                          m_OverlayMaterial;                                        // 0x0414(0x0008)
	class UTgCustomCharacterComponent*                 m_CustomCharacterComponent;                               // 0x041C(0x0008) (Edit, ExportObject, Component, EditInline)
	TArray<class UMaterialInstanceConstant*>           m_MeshReplacementMICs;                                    // 0x0424(0x0010) (NeedCtorLink)
	TArray<struct FLobbySMAMeterBus>                   m_MeterBusses;                                            // 0x0434(0x0010) (NeedCtorLink)
	struct FLightingChannelContainer                   m_LightingChannels;                                       // 0x0444(0x0004) (Edit, Const)
	class UMaterialInstanceConstant*                   NonHighlightMaterial;                                     // 0x0448(0x0008)
	class UAnimSet*                                    m_EmoteAnimSet;                                           // 0x0450(0x0008) (Transient)
	class UAnimSet*                                    m_MVPAnimSet;                                             // 0x0458(0x0008) (Transient)
	float                                              m_fBaseCollisionRadius;                                   // 0x0460(0x0004) (Transient)
	float                                              m_fBaseCollisionHeight;                                   // 0x0464(0x0004) (Transient)
	TArray<class UTgPawnMod*>                          m_PawnMods;                                               // 0x0468(0x0010) (Transient, NeedCtorLink)
	class UTgCallbackContainer*                        m_CallbackContainer;                                      // 0x0478(0x0008)
	struct FCharacterSpecificData                      m_CharacterSpecificData;                                  // 0x0480(0x001C)
	float                                              m_fDigitizedSkinFaceSwapDelayTimer;                       // 0x049C(0x0004) (Transient)
	struct FScriptDelegate                             __OnMeshUpdated__Delegate;                                // 0x04A0(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData01[0x4];                                       // 0x04A0(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkeletalMeshActor_Loader");
		return ptr;
	}


	bool PlayParticleEffect(class UAnimNotify_PlayParticleEffect* AnimNotifyData);
	void PlayChildAnim(class UTgSkeletalMeshComponent* notifySource, const struct FName& AnimSeqName);
	void EndTransition();
	void BeginTransition(bool bPlayFx);
	void PreBeginPlay();
	void PlayMVPTimer();
	void PlayEmoteTimer();
	void STATIC_FinishAsyncSwap();
	void STATIC_BeginAsyncSwap();
	void STATIC_SimulateAsyncLoading();
	void STATIC_DelayedBeginAsyncSwapFinished();
	void DelayedBeginAsyncSwap(float fDelayTime);
	void STATIC_TestLoadingEffectsIntroFinished();
	void TestLoadingEffects(float fIntroTime);
	void TeardownMeterBusses();
	void ReplaceMaterialInstances();
	void SetMaterialScalarParameterValue(const struct FName& szParameterName, float fValue, bool bSkin, bool bHead, bool bWeapon);
	void StopMVP();
	void PlayMVP(int nDeviceId, bool bInstant);
	void StopEmote();
	void PlayEmote(int nDeviceId);
	void PlayLobbyAnim(TEnumAsByte<ELobbyAnimState> NewAnimState);
	void STATIC_RecalculateMaterial(bool bIsFriendlyWithLocalPawn, bool bForce);
	void ForceRecalculateMaterial();
	void CleanupForAssetSwap(bool bReset);
	void STATIC_SetActive(bool bActive);
	void AllManifestsLoaded(int PassthroughData);
	void ResetAnims();
	void Destroyed();
	void OnMeshUpdated();
};


// Class TgGame.TgSkeletalMeshActor_FlagStand
// 0x0020 (0x04D0 - 0x04B0)
class ATgSkeletalMeshActor_FlagStand : public ATgSkeletalMeshActor_Loader
{
public:
	struct FString                                     m_FlagContentDataClassName;                               // 0x04B0(0x0010) (NeedCtorLink)
	class UTgFlagContentData*                          m_FlagContentData;                                        // 0x04C0(0x0008) (Transient)
	int                                                m_nGameTaskForce;                                         // 0x04C8(0x0004) (Edit)
	int                                                m_nTeamIndex;                                             // 0x04CC(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkeletalMeshActor_FlagStand");
		return ptr;
	}


	void PostBeginPlay();
	void PreBeginPlay();
	void ChangeTaskForceFlag(int nTaskForce, int nTeamIndex);
};


// Class TgGame.TgSkeletalMeshActor_LobbyBase
// 0x0028 (0x04D8 - 0x04B0)
class ATgSkeletalMeshActor_LobbyBase : public ATgSkeletalMeshActor_Loader
{
public:
	unsigned long                                      m_bPlayTransitionOutro : 1;                               // 0x04B0(0x0004) (Transient)
	struct FString                                     m_TransitionActorClassName;                               // 0x04B4(0x0010) (Edit, NeedCtorLink)
	int                                                m_nCharacterMastery;                                      // 0x04C4(0x0004) (Transient)
	struct FName                                       m_nmAnimationTag;                                         // 0x04C8(0x0008) (Edit)
	class ATgMenuTransitionActor*                      m_TransitionActor;                                        // 0x04D0(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkeletalMeshActor_LobbyBase");
		return ptr;
	}


	void Destroyed();
	void EndTransition();
	void BeginTransition(bool bPlayFx);
	void PostBeginPlay();
	void PreBeginPlay();
};


// Class TgGame.TgSkeletalMeshActor_Lobby
// 0x0090 (0x0568 - 0x04D8)
class ATgSkeletalMeshActor_Lobby : public ATgSkeletalMeshActor_LobbyBase
{
public:
	float                                              m_fSpawnOffsetYaw;                                        // 0x04D8(0x0004)
	float                                              m_fMaxSpawnRotation;                                      // 0x04DC(0x0004)
	float                                              m_fMinSpawnRotation;                                      // 0x04E0(0x0004)
	unsigned long                                      m_bAdjustMeshToGround : 1;                                // 0x04E4(0x0004) (Edit)
	unsigned long                                      m_bHideDuringPostureChanges : 1;                          // 0x04E4(0x0004) (Edit)
	unsigned long                                      m_bCanBeRotated : 1;                                      // 0x04E4(0x0004) (Edit)
	unsigned long                                      m_bForceActiveForVideo : 1;                               // 0x04E4(0x0004) (Edit)
	unsigned long                                      m_bInTransition : 1;                                      // 0x04E4(0x0004) (Transient)
	unsigned long                                      m_bAwaitingPostureChange : 1;                             // 0x04E4(0x0004) (Transient)
	unsigned long                                      m_bEnablePostures : 1;                                    // 0x04E4(0x0004) (Edit)
	int                                                m_CardMICBotIdPending;                                    // 0x04E8(0x0004) (Transient)
	float                                              m_CardMICTransitionDesiredAlpha;                          // 0x04EC(0x0004) (Transient)
	float                                              m_CardMICTransitionAlpha;                                 // 0x04F0(0x0004) (Transient)
	class ATgSkeletalMeshActor_FlagStand*              m_FlagStandActor;                                         // 0x04F4(0x0008) (Edit)
	class ATgSkeletalMeshActor_Pedestal*               m_PedestalActor;                                          // 0x04FC(0x0008) (Edit)
	TArray<class UMaterialInstanceConstant*>           m_CardMICs;                                               // 0x0504(0x0010) (Edit, NeedCtorLink)
	TEnumAsByte<ETG_POSTURE>                           r_CurrentPosture;                                         // 0x0514(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0515(0x0003) MISSED OFFSET
	float                                              m_fRotationAmount;                                        // 0x0518(0x0004) (Transient)
	float                                              m_fDesiredRotationAmount;                                 // 0x051C(0x0004) (Transient)
	struct FRotator                                    m_rOriginalRotation;                                      // 0x0520(0x000C) (Transient)
	struct FVector                                     m_vOriginalLocation;                                      // 0x052C(0x000C) (Transient)
	class UTgSpecialFx*                                m_Spray3dSpecialFx;                                       // 0x0538(0x0008) (Transient)
	float                                              m_fSpray3dTriggerTime;                                    // 0x0540(0x0004) (Transient)
	float                                              m_fSpray3dTriggerTimer;                                   // 0x0544(0x0004) (Transient)
	int                                                m_nSkinId;                                                // 0x0548(0x0004) (Edit)
	int                                                m_nDeviceSkinId;                                          // 0x054C(0x0004) (Edit)
	float                                              m_fSelectionGlowRemainingTime;                            // 0x0550(0x0004) (Transient)
	float                                              m_fSelectionGlowTotalTime;                                // 0x0554(0x0004)
	TArray<class UTgAnimBlendByPosture*>               m_PostureBlendNodes;                                      // 0x0558(0x0010) (Transient, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkeletalMeshActor_Lobby");
		return ptr;
	}


	void STATIC_OnSetLobbyMeshSkin(class UTgSeqAct_SetLobbyMeshSkin* tgSeqAct);
	void OnSetSkelPosture(class UTgSeqAct_SetSkelPosture* Action);
	void SetActivePosture(TEnumAsByte<ETG_POSTURE> Posture);
	void BeginTransition(bool bPlayFx);
	void InitPostureNodes();
	void PostInitAnimTree(class USkeletalMeshComponent* SkelComp);
	float STATIC_GetSpawnRotation();
	void Destroyed();
	void EndTransition();
	void PostBeginPlay();
	void PreBeginPlay();
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_SetSkin(int nSkinId, int nDeviceSkinId);
	void STATIC_SetSkinFromMessage(int nMsgSkinId, int nMsgDeviceSkinId);
	void STATIC_FinishAsyncSwap();
	void AllManifestsLoaded(int PassthroughData);
	void AdjustMeshToGround();
	void RotateModel(float fValue, bool bSnap);
	void STATIC_SetActive(bool bActive);
};


// Class TgGame.TgSkeletalMeshActor_Pedestal
// 0x001D (0x0585 - 0x0568)
class ATgSkeletalMeshActor_Pedestal : public ATgSkeletalMeshActor_Lobby
{
public:
	struct FPointer                                    m_DefaultBot;                                             // 0x0568(0x0008) (Native, Transient)
	TArray<class AActor*>                              m_DefaultPedestalActors;                                  // 0x0570(0x0010) (Edit, NeedCtorLink)
	unsigned long                                      m_bUsingDefaultPedestal : 1;                              // 0x0580(0x0004) (Transient)
	TEnumAsByte<EPedestalType>                         m_PedestalType;                                           // 0x0584(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkeletalMeshActor_Pedestal");
		return ptr;
	}


	void EndTransition();
	void SwitchToDefaultPedestal(TEnumAsByte<ELobbyAnimPose> animPose);
};


// Class TgGame.TgSkeletalMeshActor_Leash
// 0x0030 (0x035C - 0x032C)
class ATgSkeletalMeshActor_Leash : public ATgSkeletalMeshActorSpawnable
{
public:
	class USkeletalMeshComponent*                      m_StartMesh;                                              // 0x032C(0x0008) (ExportObject, Component, EditInline)
	struct FName                                       m_StartBoneName;                                          // 0x0334(0x0008)
	class USkeletalMeshComponent*                      m_EndMesh;                                                // 0x033C(0x0008) (ExportObject, Component, EditInline)
	struct FName                                       m_EndBoneName;                                            // 0x0344(0x0008)
	class USkelControlSingleBone*                      m_StartControl;                                           // 0x034C(0x0008)
	class USkelControlSingleBone*                      m_EndControl;                                             // 0x0354(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkeletalMeshActor_Leash");
		return ptr;
	}

};


// Class TgGame.TgSkeletalMeshComponent
// 0x00B4 (0x0868 - 0x07B4)
class UTgSkeletalMeshComponent : public USkeletalMeshComponent
{
public:
	struct FPointer                                    VfTable_ITgMeshCompInterface_MaterialStack;               // 0x07B4(0x0008) (Const, Native, NoExport)
	unsigned long                                      c_bFxApplied : 1;                                         // 0x07BC(0x0004)
	unsigned long                                      c_bAttachFxToOwner : 1;                                   // 0x07BC(0x0004)
	unsigned long                                      c_bIsFemale : 1;                                          // 0x07BC(0x0004)
	TArray<class UTgSpecialFx*>                        c_FxList;                                                 // 0x07C0(0x0010) (NeedCtorLink)
	TArray<class UTgSpecialFx*>                        c_DatabaseFxList;                                         // 0x07D0(0x0010) (NeedCtorLink)
	int                                                m_nAssemblyId;                                            // 0x07E0(0x0004)
	TArray<class UTgSkeletalMeshComponent*>            m_ChildMeshes;                                            // 0x07E4(0x0010) (ExportObject, Component, NeedCtorLink, EditInline)
	struct FVector                                     FPCTranslation;                                           // 0x07F4(0x000C)
	struct FRotator                                    FPCRotation;                                              // 0x0800(0x000C)
	struct FVector                                     FPCScale;                                                 // 0x080C(0x000C)
	int                                                c_AudioGroupId;                                           // 0x0818(0x0004)
	int                                                c_nForceUpdateAttachmentsInTick;                          // 0x081C(0x0004)
	class UTgMaterialStack*                            m_MaterialStackManager;                                   // 0x0820(0x0008)
	TArray<struct FAnimNotifyParticleCacheEntry>       AnimNotifyPlayParticleEffectEntries;                      // 0x0828(0x0010) (Transient, Component, AlwaysInit, NeedCtorLink)
	TArray<struct FMeshAccessoryStorage>               m_MeshAccessoryStorage;                                   // 0x0838(0x0010) (Component, NeedCtorLink)
	TArray<struct FMICScalarParamMetaDataStorage>      m_MICScalarParamExtendedStorage;                          // 0x0848(0x0010) (Component, AlwaysInit, NeedCtorLink)
	TArray<struct FMICStateParamInterpData>            m_MICStateParamInterpData;                                // 0x0858(0x0010) (AlwaysInit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkeletalMeshComponent");
		return ptr;
	}


	void CachePSC(class UParticleSystemComponent* PSC, const struct FAnimNotifyParticleCacheEntry& CacheEntry, class UAnimNotify_PlayParticleEffect* AnimNotifyData);
	class UParticleSystemComponent* GetPSCForPlayParticleEffect(class UAnimNotify_PlayParticleEffect* AnimNotifyData);
	bool STATIC_GetAnimNotifyParticleCacheEntryFor(class UAnimNotify_PlayParticleEffect* AnimNotifyData, struct FAnimNotifyParticleCacheEntry* CacheEntry);
	void STATIC_SetMaterialParamStateInterp(const struct FName& nmToStateName, const struct FName& nmFromStateName, float fInterpAmt, bool bApplyToChildMeshes, int nMaterialIndex);
	void STATIC_SetMaterialParamState(const struct FName& nmToStateName, const struct FName& nmFromStateName, float fInterpDuration, bool bApplyToChildMeshes, int nMaterialIndex);
	void STATIC_ClearTimelapseMaterials(bool bEnterintTimelapse);
	void STATIC_ClearMaterials();
	bool PopMaterial(int nMaterialHandle);
	int PushMaterialManual(TArray<class UMaterialInstanceConstant*> MICs, int nPriority);
	int PushMaterial(class UMaterialInterface* MI, TEnumAsByte<EMaterialParamHarvestType> eParamHarvestType, int nPriority);
	class UTgMaterialStack* STATIC_GetMaterialStack(bool bShouldCreate);
	void SetForceUpdateAttachmentsInTick(bool bSet);
	class UAnimTree* STATIC_GetAnimTree();
	void STATIC_SetParentAnimComponent(class USkeletalMeshComponent* NewParentAnimComp);
	void STATIC_OnMeshSetHidden(bool bHidden);
	void STATIC_RecalculateFx();
	void ActivateWhileAliveFx(bool bOn, const struct FName& nmDisplayGroup);
	void ActivateOnWhenDeployedFx(bool bOn);
	float STATIC_GetCurrentDeployPercentage();
	void STATIC_SwapMaterial(class UMaterialInterface* MI, bool bNoParamReaping);
	class UMaterialInterface* GetDefaultMaterial(int nIndex);
	void STATIC_SetDefaultSkin(int nIndex);
	class UObject* FxActivateIndependant(const struct FName& nmGroup, int nMode, const struct FVector& HitLocation, const struct FVector& HitNormal, int nSocketIndex, int nEquipSlot, bool bUseSocketOverride, TArray<struct FParticleSysParam> Params);
	void FxSpawnSound(const struct FName& nmGroup, int nMode, const struct FVector& SoundLocation, int nSocketIndex, int nEquipSlot);
	void FxSpawnEmitter(const struct FName& nmGroup, int nMode, const struct FVector& HitLocation, const struct FVector& HitNormal, int nSocketIndex, int nEquipSlot);
	void FxSpawnTracer(const struct FName& nmGroup, int nMode, const struct FVector& HitLocation, int nSocketIndex, int nEquipSlot);
	void FxDeactivateAll(int nEquipSlot);
	void FxDeactivateGroup(const struct FName& nmGroup, int nMode, int nSocketIndex, int nEquipSlot);
	class UObject* FxActivateGroup(const struct FName& nmGroup, int nMode, int nSocketIndex, int nEquipSlot, bool bIgnoreRelevancy, bool bFromEffectForm, bool bSkipWeapon);
	TArray<class UObject*> FxGetAll(const struct FName& nmGroup, int nMode, int nIndex, int nSocketIndex, int nEquipSlot);
	class UObject* FxGet(const struct FName& nmGroup, int nMode, int nIndex, int nSocketIndex, int nEquipSlot);
	void FxRemove(class UObject* Fx);
	void FxAdd(class UObject* Fx);
	void STATIC_EndRagdoll();
	void InitRagdoll();
};


// Class TgGame.TgSkeletalMeshComponent_Weapon
// 0x0030 (0x0898 - 0x0868)
class UTgSkeletalMeshComponent_Weapon : public UTgSkeletalMeshComponent
{
public:
	struct FName                                       m_nmFire;                                                 // 0x0868(0x0008) (Const)
	struct FName                                       m_nmFireLoop;                                             // 0x0870(0x0008) (Const)
	struct FName                                       m_nmFireLoopTailSound;                                    // 0x0878(0x0008) (Const)
	unsigned long                                      m_bDoNotPlayFireParticlesIfHidden : 1;                    // 0x0880(0x0004)
	unsigned long                                      m_bKillFiringLoopParticlesOnHidden : 1;                   // 0x0880(0x0004) (Const)
	unsigned long                                      m_bCanPlayFireParticles : 1;                              // 0x0880(0x0004) (Const)
	unsigned long                                      m_bCanPlayFireLoopParticles : 1;                          // 0x0880(0x0004) (Const)
	unsigned long                                      m_bCanPlayFireSounds : 1;                                 // 0x0880(0x0004) (Const)
	unsigned long                                      m_bCanPlayFireLoopSounds : 1;                             // 0x0880(0x0004) (Const)
	int                                                m_nFireLoopActiveBitMask[0x5];                            // 0x0884(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkeletalMeshComponent_Weapon");
		return ptr;
	}


	void STATIC_SetParentAnimComponent(class USkeletalMeshComponent* NewParentAnimComp);
	void StopFireLoop(int nEquipSlot, int nFireMode);
	void PlayFireLoop(int nEquipSlot, int nFireMode);
	void STATIC_GetAllFireLoopParticleSystemComponents(int nEquipSlot, int nFireMode, TArray<class UParticleSystemComponent*>* FireLoopParticles);
	void SetFireLoopActivated(bool bActive, int nEquipSlot, int nFireMode);
	bool STATIC_IsAnyFireLoopActivated();
	bool STATIC_IsFireLoopActivated(int nEquipSlot, int nFireMode);
	bool STATIC_IsFireLoopPSCActive(int nEquipSlot, int nFireMode);
	void StopFire(bool bForce, int nEquipSlot, int nFireMode);
	void PlayFire(int nEquipSlot, int nFireMode);
	void PlayFireSpecial(const struct FName& nmFire, int nEquipSlot, int nFireMode);
	void SetCanPlaySoundFlags(bool bFire, bool bFireLoop);
	void SetCanPlayParticleFlags(bool bFire, bool bFireLoop, bool bDoNotPlayIfHidden);
	void SetFireLoopDisplayGroup(const struct FName& nmFire, const struct FName& nmFireLoopTail);
	void SetFireDisplayGroup(const struct FName& nmFire);
	void CompleteInitialization();
};


// Class TgGame.TgStaticMeshActor
// 0x0000 (0x02A4 - 0x02A4)
class ATgStaticMeshActor : public AStaticMeshActor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgStaticMeshActor");
		return ptr;
	}

};


// Class TgGame.TgStaticMeshActor_PantheonMIC
// 0x0048 (0x02EC - 0x02A4)
class ATgStaticMeshActor_PantheonMIC : public ATgStaticMeshActor
{
public:
	class UMaterialInstanceConstant*                   MICOverrides[0x8];                                        // 0x02A4(0x0008) (Edit)
	int                                                m_nGameTaskForce;                                         // 0x02E4(0x0004) (Edit)
	int                                                m_nTeamIndex;                                             // 0x02E8(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgStaticMeshActor_PantheonMIC");
		return ptr;
	}


	void PreBeginPlay();
	void ChangePantheonMIC(int nTaskForce, int nTeamIndex);
};


// Class TgGame.TgStaticMeshActor_BoostedTextures
// 0x0038 (0x02DC - 0x02A4)
class ATgStaticMeshActor_BoostedTextures : public AStaticMeshActor
{
public:
	TEnumAsByte<ELobbyCameraTag>                       m_CameraTag;                                              // 0x02A4(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x02A5(0x0003) MISSED OFFSET
	class UMaterialInterface*                          m_LoadingMaterial;                                        // 0x02A8(0x0008) (Edit)
	float                                              m_fFadeInTime;                                            // 0x02B0(0x0004) (Edit)
	unsigned long                                      m_bMaterialRelevant : 1;                                  // 0x02B4(0x0004)
	unsigned long                                      m_bWaitingForTextures : 1;                                // 0x02B4(0x0004)
	unsigned long                                      m_bLoadingMaterialApplied : 1;                            // 0x02B4(0x0004)
	float                                              m_fFadeInTimeRemaining;                                   // 0x02B8(0x0004)
	TArray<class UMaterialInterface*>                  m_BaseMaterials;                                          // 0x02BC(0x0010) (NeedCtorLink)
	TArray<class UMaterialInstanceConstant*>           m_LoadingMaterials;                                       // 0x02CC(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgStaticMeshActor_BoostedTextures");
		return ptr;
	}


	void PreBeginPlay();
	void STATIC_InitRelevance();
	void STATIC_LoadingFX();
	void STATIC_FadeInFX(bool bTransitionNow);
	void STATIC_AdjustToVisibility(TArray<TEnumAsByte<ELobbyCameraTag>> camTags);
};


// Class TgGame.TgStaticMeshActor_CapturePoint
// 0x005C (0x0300 - 0x02A4)
class ATgStaticMeshActor_CapturePoint : public AStaticMeshActor
{
public:
	struct FLinearColor                                UncontestedCaptureColor;                                  // 0x02A4(0x0010) (Edit, Const)
	struct FLinearColor                                FriendlyCaptureColor;                                     // 0x02B4(0x0010) (Edit, Const)
	struct FLinearColor                                EnemyCaptureColor;                                        // 0x02C4(0x0010) (Edit, Const)
	struct FName                                       EmissiveColorParameterName;                               // 0x02D4(0x0008) (Edit, Const)
	struct FName                                       CapturePercentParameterName;                              // 0x02DC(0x0008) (Edit, Const)
	TArray<class UMaterialInterface*>                  InitialMaterialList;                                      // 0x02E4(0x0010) (Transient, NeedCtorLink)
	unsigned long                                      bInstancedAllMaterials : 1;                               // 0x02F4(0x0004) (Const)
	int                                                CurrentCaptureStatus;                                     // 0x02F8(0x0004)
	float                                              CurrentCapturePercent;                                    // 0x02FC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgStaticMeshActor_CapturePoint");
		return ptr;
	}


	void SetCaptureStatus(int nCaptureStatus, float fPercent);
	void SetCapturePercent(float fNewPercent, float bRampTime);
	void SetEmissiveColor(const struct FLinearColor& NewColor, float fPercent, float fRampTime);
};


// Class TgGame.TgStaticMeshActor_TeamColor
// 0x0024 (0x02C8 - 0x02A4)
class ATgStaticMeshActor_TeamColor : public AStaticMeshActor
{
public:
	int                                                nTaskForce;                                               // 0x02A4(0x0004) (Edit, Const)
	struct FName                                       TeamColoringParameterName;                                // 0x02A8(0x0008) (Edit, Const)
	unsigned long                                      bInvertColoringParameter : 1;                             // 0x02B0(0x0004) (Edit, Const)
	unsigned long                                      bInstancedAllMaterials : 1;                               // 0x02B0(0x0004) (Const)
	unsigned char                                      bFriendlyWithLocalPlayer;                                 // 0x02B4(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x02B5(0x0003) MISSED OFFSET
	TArray<class UMaterialInterface*>                  InitialMaterialList;                                      // 0x02B8(0x0010) (Transient, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgStaticMeshActor_TeamColor");
		return ptr;
	}


	void STATIC_NotifyLocalPlayerTeamReceived();
	void STATIC_UpdateFriendlyFlag();
	void STATIC_RecalculateMaterial(bool bIsFriendlyWithLocalPawn, bool bForce);
	void ForceRecalculateMaterial();
};


// Class TgGame.TgStaticMeshActorTargeting
// 0x0000 (0x02A4 - 0x02A4)
class ATgStaticMeshActorTargeting : public AStaticMeshActor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgStaticMeshActorTargeting");
		return ptr;
	}

};


// Class TgGame.TgStaticMeshComponent
// 0x0048 (0x0358 - 0x0310)
class UTgStaticMeshComponent : public UStaticMeshComponent
{
public:
	struct FPointer                                    VfTable_ITgMeshCompInterface_MaterialStack;               // 0x0310(0x0008) (Const, Native, NoExport)
	unsigned long                                      c_bFxApplied : 1;                                         // 0x0318(0x0004)
	TArray<class UTgSpecialFx*>                        c_FxList;                                                 // 0x031C(0x0010) (NeedCtorLink)
	TArray<class UTgSpecialFx*>                        c_DatabaseFxList;                                         // 0x032C(0x0010) (NeedCtorLink)
	TArray<struct FFx_AssemblyData>                    c_FxAssemblyData;                                         // 0x033C(0x0010) (NeedCtorLink)
	int                                                m_nAssemblyId;                                            // 0x034C(0x0004)
	class UTgMaterialStack*                            m_MaterialStackManager;                                   // 0x0350(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgStaticMeshComponent");
		return ptr;
	}


	void STATIC_ClearTimelapseMaterials(bool bEnterintTimelapse);
	void STATIC_ClearMaterials();
	bool PopMaterial(int nMaterialHandle);
	int PushMaterialManual(TArray<class UMaterialInstanceConstant*> MICs, int nPriority);
	int PushMaterial(class UMaterialInterface* MI, TEnumAsByte<EMaterialParamHarvestType> eParamHarvestType, int nPriority);
	class UTgMaterialStack* STATIC_GetMaterialStack(bool bShouldCreate);
	void STATIC_RecalculateFx();
	void STATIC_OnMeshSetHidden(bool bHidden);
	class UMaterialInterface* GetDefaultMaterial(int nIndex);
	void STATIC_SetDefaultSkin(int nIndex);
	void STATIC_SwapMaterial(class UMaterialInterface* MI, bool bNoParamReaping);
	class UObject* FxActivateIndependant(const struct FName& nmGroup, int nMode, const struct FVector& HitLocation, const struct FVector& HitNormal, int nSocketIndex, int nEquipSlot, bool bUseSocketOverride, TArray<struct FParticleSysParam> Params);
	void FxSpawnSound(const struct FName& nmGroup, int nMode, const struct FVector& SoundLocation, int nSocketIndex, int nEquipSlot);
	void FxSpawnEmitter(const struct FName& nmGroup, int nMode, const struct FVector& HitLocation, const struct FVector& HitNormal, int nSocketIndex, int nEquipSlot);
	void FxSpawnTracer(const struct FName& nmGroup, int nMode, const struct FVector& HitLocation, int nSocketIndex, int nEquipSlot);
	void FxDeactivateAll(int nEquipSlot);
	void FxDeactivateGroup(const struct FName& nmGroup, int nMode, int nSocketIndex, int nEquipSlot);
	class UObject* FxActivateGroup(const struct FName& nmGroup, int nMode, int nSocketIndex, int nEquipSlot, bool bIgnoreRelevancy, bool bFromEffectForm, bool bSkipWeapon);
	TArray<class UObject*> FxGetAll(const struct FName& nmGroup, int nMode, int nIndex, int nSocketIndex, int nEquipSlot);
	class UObject* FxGet(const struct FName& nmGroup, int nMode, int nIndex, int nSocketIndex, int nEquipSlot);
	void FxRemove(class UObject* Fx);
	void FxAdd(class UObject* Fx);
};


// Class TgGame.TgSubtitledMessages
// 0x004C (0x00AC - 0x0060)
class UTgSubtitledMessages : public UObject
{
public:
	struct FQueuedSubtitle                             CurrentSubtitle;                                          // 0x0060(0x0024) (NeedCtorLink)
	TArray<struct FQueuedSubtitle>                     QueuedSubtitles;                                          // 0x0084(0x0010) (NeedCtorLink)
	class ATgPlayerController*                         OwnerPC;                                                  // 0x0094(0x0008) (Transient)
	class UAudioComponent*                             PlayingSubtitleAC;                                        // 0x009C(0x0008) (ExportObject, Transient, Component, EditInline)
	unsigned long                                      bFinishedSubtitle : 1;                                    // 0x00A4(0x0004)
	float                                              SubtitleFailsafeTime;                                     // 0x00A8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSubtitledMessages");
		return ptr;
	}


	void PlaySubtitleSoundCue(class USoundCue* CueToPlay);
	void Destroyed();
	void Init();
	void SubtitleFailsafe();
	void SubtitledCueEnded(class UAudioComponent* AC);
	void PlaySubtitledMessage(int MessageId, bool PlayImmediately, bool FlushOthers, class UAkEvent* CustomShutdownEvent);
};


// Class TgGame.TgAIBehaviorObject
// 0x0004 (0x0064 - 0x0060)
class UTgAIBehaviorObject : public UObject
{
public:
	int                                                NodeToken;                                                // 0x0060(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorObject");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorComment
// 0x0000 (0x0064 - 0x0064)
class UTgAIBehaviorComment : public UTgAIBehaviorObject
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorComment");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorNode
// 0x0030 (0x0094 - 0x0064)
class UTgAIBehaviorNode : public UTgAIBehaviorObject
{
public:
	class UTgAIBehaviorNode*                           Parent;                                                   // 0x0064(0x0008) (DuplicateTransient)
	float                                              InvTickFrequency;                                         // 0x006C(0x0004)
	struct FString                                     TitleName;                                                // 0x0070(0x0010) (NeedCtorLink)
	struct FString                                     FriendlyName;                                             // 0x0080(0x0010) (Edit, AlwaysInit, NeedCtorLink)
	unsigned long                                      bShownInMenu : 1;                                         // 0x0090(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorNode");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction : public UTgAIBehaviorNode
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_PlayVGS
// 0x0008 (0x009C - 0x0094)
class UTgAIBehaviorAction_PlayVGS : public UTgAIBehaviorAction
{
public:
	int                                                VoicePackId;                                              // 0x0094(0x0004) (Edit)
	int                                                VgsId;                                                    // 0x0098(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_PlayVGS");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorComposite
// 0x0024 (0x00B8 - 0x0094)
class UTgAIBehaviorComposite : public UTgAIBehaviorNode
{
public:
	TArray<class UTgAIBehaviorNode*>                   Children;                                                 // 0x0094(0x0010) (EditFixedSize, AlwaysInit, NeedCtorLink, EditInline)
	TArray<int>                                        ChildrenIndices;                                          // 0x00A4(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	unsigned long                                      bCompleteOnAll : 1;                                       // 0x00B4(0x0004) (Edit, Const, EditConst)
	unsigned long                                      bFailsOnAll : 1;                                          // 0x00B4(0x0004) (Edit, Const, EditConst)
	unsigned long                                      bRetryFailedChild : 1;                                    // 0x00B4(0x0004) (Edit, Const, EditConst)
	unsigned long                                      bFixedChildrenSize : 1;                                   // 0x00B4(0x0004) (Const, EditConst)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorComposite");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorComposite_Gated
// 0x0000 (0x00B8 - 0x00B8)
class UTgAIBehaviorComposite_Gated : public UTgAIBehaviorComposite
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorComposite_Gated");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorComposite_Random
// 0x0018 (0x00D0 - 0x00B8)
class UTgAIBehaviorComposite_Random : public UTgAIBehaviorComposite
{
public:
	TArray<float>                                      ChildWeights;                                             // 0x00B8(0x0010) (Edit, EditFixedSize, NeedCtorLink, EditInline)
	float                                              ChildFreezeTime;                                          // 0x00C8(0x0004) (Edit)
	unsigned long                                      bRandomizeOnComplete : 1;                                 // 0x00CC(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorComposite_Random");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorComposite_Sequence
// 0x0004 (0x00BC - 0x00B8)
class UTgAIBehaviorComposite_Sequence : public UTgAIBehaviorComposite
{
public:
	unsigned long                                      bStopOnRunningChild : 1;                                  // 0x00B8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorComposite_Sequence");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorComposite_Parallel
// 0x0000 (0x00BC - 0x00BC)
class UTgAIBehaviorComposite_Parallel : public UTgAIBehaviorComposite_Sequence
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorComposite_Parallel");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorComposite_SequenceScripted
// 0x0004 (0x00BC - 0x00B8)
class UTgAIBehaviorComposite_SequenceScripted : public UTgAIBehaviorComposite
{
public:
	unsigned long                                      bFreezeOnLast : 1;                                        // 0x00B8(0x0004) (Edit)
	unsigned long                                      bIsLooping : 1;                                           // 0x00B8(0x0004) (Edit)
	unsigned long                                      bFirstChildIsResetTest : 1;                               // 0x00B8(0x0004) (Edit)
	unsigned long                                      bResetSequenceOnFailure : 1;                              // 0x00B8(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorComposite_SequenceScripted");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorComposite_SubTree
// 0x0008 (0x00C0 - 0x00B8)
class UTgAIBehaviorComposite_SubTree : public UTgAIBehaviorComposite
{
public:
	class UTgAIBehaviorTree*                           ChildTree;                                                // 0x00B8(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorComposite_SubTree");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition
// 0x0001 (0x0095 - 0x0094)
class UTgAIBehaviorCondition : public UTgAIBehaviorNode
{
public:
	TEnumAsByte<EBehaviorComparison>                   ComparisonOperator;                                       // 0x0094(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_CombatTargetHasEffectCategory
// 0x000F (0x00A4 - 0x0095)
class UTgAIBehaviorCondition_CombatTargetHasEffectCategory : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	unsigned long                                      bEffectGroupCategoryCheckInstigator : 1;                  // 0x0098(0x0004) (Edit)
	int                                                EffectCategoryId;                                         // 0x009C(0x0004) (Edit)
	int                                                EffectGroupId;                                            // 0x00A0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_CombatTargetHasEffectCategory");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_HasEffectCategory
// 0x000B (0x00A0 - 0x0095)
class UTgAIBehaviorCondition_HasEffectCategory : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	int                                                EffectCategoryId;                                         // 0x0098(0x0004) (Edit)
	int                                                EffectGroupId;                                            // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_HasEffectCategory");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorSensor
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorSensor : public UTgAIBehaviorNode
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorSensor");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorTree
// 0x0028 (0x00BC - 0x0094)
class UTgAIBehaviorTree : public UTgAIBehaviorNode
{
public:
	class UTgAIBehaviorComposite*                      ChildNode;                                                // 0x0094(0x0008)
	TArray<class UTgAIBehaviorSensor*>                 SensorNodes;                                              // 0x009C(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<class UTgAIUtilitySet*>                     UtilitySets;                                              // 0x00AC(0x0010) (AlwaysInit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorTree");
		return ptr;
	}

};


// Class TgGame.TgAIUtility
// 0x0028 (0x00BC - 0x0094)
class UTgAIUtility : public UTgAIBehaviorNode
{
public:
	TEnumAsByte<EUtilityType>                          UtilityType;                                              // 0x0094(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TArray<TEnumAsByte<EBotBehaviorState>>             IgnoreBehaviorState;                                      // 0x0098(0x0010) (Edit, AlwaysInit, NeedCtorLink)
	TArray<TEnumAsByte<EBotBehaviorState>>             RejctBehaviorState;                                       // 0x00A8(0x0010) (Edit, AlwaysInit, NeedCtorLink)
	int                                                ParentIndex;                                              // 0x00B8(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIUtility");
		return ptr;
	}

};


// Class TgGame.TgAIUtilitySet
// 0x0024 (0x00B8 - 0x0094)
class UTgAIUtilitySet : public UTgAIBehaviorNode
{
public:
	TEnumAsByte<EAIAnnotationType>                     AnnotationType;                                           // 0x0094(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TArray<class UTgAIUtility*>                        Functions;                                                // 0x0098(0x0010) (EditFixedSize, AlwaysInit, NeedCtorLink, EditInline)
	TArray<class UTgAIUtility*>                        Filters;                                                  // 0x00A8(0x0010) (EditFixedSize, AlwaysInit, NeedCtorLink, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIUtilitySet");
		return ptr;
	}

};


// Class TgGame.TgAIController
// 0x0164 (0x0644 - 0x04E0)
class ATgAIController : public AGameAIController
{
public:
	class ATgPawn*                                     m_pOwner;                                                 // 0x04E0(0x0008) (Transient)
	struct FVector                                     m_vSpawnLocation;                                         // 0x04E8(0x000C) (Transient)
	struct FRotator                                    m_rSpawnDirection;                                        // 0x04F4(0x000C) (Transient)
	class ATgBotFactory*                               m_pFactory;                                               // 0x0500(0x0008) (Transient)
	int                                                m_nFactorySpawnGroup;                                     // 0x0508(0x0004) (Transient)
	struct FPointer                                    m_pBot;                                                   // 0x050C(0x0008) (Const, Native, Transient)
	struct FPointer                                    m_pSettings;                                              // 0x0514(0x0008) (Const, Native, Transient)
	struct FPointer                                    m_pSkin;                                                  // 0x051C(0x0008) (Const, Native, Transient)
	int                                                m_iAssignedLane;                                          // 0x0524(0x0004) (Transient)
	unsigned char                                      UnknownData00[0x48];                                      // 0x0528(0x0048) UNKNOWN PROPERTY: MapProperty TgGame.TgAIController.m_SeePawnCache
	float                                              LastSeePawnCacheTime;                                     // 0x0570(0x0004) (Transient)
	float                                              SeePawnClearTime;                                         // 0x0574(0x0004) (Transient)
	class ATgPawn*                                     m_pLastAttacker;                                          // 0x0578(0x0008) (Transient)
	class UTgAISquad*                                  m_Squad;                                                  // 0x0580(0x0008) (Transient)
	float                                              LastDamageTakenTime;                                      // 0x0588(0x0004) (Transient)
	struct FVector                                     LastDamageTakenPosition;                                  // 0x058C(0x000C) (Transient)
	unsigned char                                      UnknownData01[0x48];                                      // 0x0598(0x0048) UNKNOWN PROPERTY: MapProperty TgGame.TgAIController.m_LoSCache
	float                                              LastLoSCacheTime;                                         // 0x05E0(0x0004) (Transient)
	TEnumAsByte<EHavokNavigationMeshType>              m_eNavmeshType;                                           // 0x05E4(0x0001) (Transient)
	TEnumAsByte<EPhysics>                              WalkingPhysics;                                           // 0x05E5(0x0001)
	unsigned char                                      UnknownData02[0x2];                                       // 0x05E6(0x0002) MISSED OFFSET
	float                                              m_fAILevelUpSecs;                                         // 0x05E8(0x0004)
	float                                              VisionDistance;                                           // 0x05EC(0x0004)
	float                                              VisionDistanceBonus;                                      // 0x05F0(0x0004)
	unsigned long                                      bUsesObstacleAvoidance : 1;                               // 0x05F4(0x0004)
	unsigned long                                      bIsPaused : 1;                                            // 0x05F4(0x0004) (Transient)
	unsigned long                                      bIsAIFrozen : 1;                                          // 0x05F4(0x0004) (Transient)
	class UTgAIObstacleAvoidance*                      ObstacleAvoidance;                                        // 0x05F8(0x0008) (Transient)
	float                                              ObstacleAvoidanceGridPointSize;                           // 0x0600(0x0004)
	float                                              ObstacleAvoidanceGridExtents;                             // 0x0604(0x0004)
	struct FVector                                     SpreadLocation;                                           // 0x0608(0x000C) (Transient)
	class ATgRepInfo_Player*                           CachedPRI;                                                // 0x0614(0x0008) (Transient)
	float                                              LastCheckStuckTime;                                       // 0x061C(0x0004) (Transient)
	float                                              CheckStuckTime;                                           // 0x0620(0x0004) (Transient)
	struct FVector                                     LastCachedStuckPosition;                                  // 0x0624(0x000C) (Transient)
	float                                              LastCheckFlungTime;                                       // 0x0630(0x0004) (Transient)
	float                                              CheckFlungTime;                                           // 0x0634(0x0004) (Transient)
	struct FVector                                     LastCachedFlungPosition;                                  // 0x0638(0x000C) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIController");
		return ptr;
	}


	void STATIC_NotifyWeaponFired(class AWeapon* W, unsigned char FireMode);
	void NotifyDamagedTarget(class ATgPawn* TargetPawn);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void ProjectileOnFire(class ATgProjectile* Proj);
	void DeviceOnFire(class ATgDevice* Dev);
	void DeviceOnStartFire(class ATgDevice* Dev);
	void DeviceOnStopBuildup(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnStartBuildup(class ATgDevice* Dev);
	void OnEnterCombat();
	void OnExitCombat();
	void STATIC_NotifyTakeHit(class AController* InstigatedBy, const struct FVector& HitLocation, int Damage, class UClass* DamageType, const struct FVector& Momentum);
	void NotifyKilledBy(class AController* Killer);
	void SetActionlessPause(bool bOn);
	void OnSetTaskforce(class UTgSeqAct_SetTaskforce* Action);
	void OnTriggerBots(class UTgSeqAct_TriggerBots* Action);
	void PawnDied(class APawn* P);
	void Suicide();
	void Despawn();
	void Destroyed();
	void CleanupPRI();
	void InitPlayerReplicationInfo();
	void Possess(class APawn* inPawn, bool bVehicleTransition);
	void PostBeginPlay();
	bool CanSpreadOut();
	void ClearSpreadLocation();
	void SetSpreadLocation(struct FVector* SpreadLoc);
	void STATIC_Evade();
	void SquadEvade();
	void SquadTargetChanged();
	float STATIC_GetMaxDeviceRange();
	float STATIC_GetVisionDistance();
	struct FVector CalculateLobIntersection(const struct FVector& targetPos, const struct FVector& targetVel, const struct FVector& sourcePos, const struct FVector& sourceVel, float projVel);
	bool STATIC_LineCheckPassThrough(const struct FVector& vLocation, class AActor* pTarget, const struct FVector& vTarget);
	bool STATIC_LineCheckEx(const struct FVector& vLocation, class AActor* pTarget, const struct FVector& vTarget);
	bool LineCheck(const struct FVector& vLocation, class AActor* pTarget);
	bool STATIC_LineCheckVisibility(class AActor* pTarget, class AActor* pSource);
	bool STATIC_LineCheckMovement(class AActor* pTarget, class AActor* pSource);
	void SetTaskForceNumber(int nTaskForce);
	int STATIC_GetTaskForceNumber();
	void AddThreat(class ATgPawn* attacker, float fAmount);
	bool STATIC_IsDeviceReady(TEnumAsByte<ETG_EQUIP_POINT> DeviceSlot);
	bool STATIC_AtLocation(const struct FVector& vLocation);
};


// Class TgGame.TgAIController_Behavior
// 0x02EC (0x0930 - 0x0644)
class ATgAIController_Behavior : public ATgAIController
{
public:
	TArray<struct FDeferredNode>                       DeferredNodes;                                            // 0x0644(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	int                                                BlackboardType;                                           // 0x0654(0x0004) (Transient)
	struct FName                                       BehaviorTreeAsName;                                       // 0x0658(0x0008)
	struct FPointer                                    SensorTree;                                               // 0x0660(0x0008) (Native, Transient)
	struct FPointer                                    SensorDynamicMemory;                                      // 0x0668(0x0008) (Native, Transient)
	struct FPointer                                    SensorStaticMemory;                                       // 0x0670(0x0008) (Native, Transient)
	struct FPointer                                    WorkerTree;                                               // 0x0678(0x0008) (Native, Transient)
	struct FPointer                                    WorkerTreeCachedStatus;                                   // 0x0680(0x0008) (Native, Transient)
	struct FPointer                                    WorkerDynamicMemory;                                      // 0x0688(0x0008) (Native, Transient)
	struct FPointer                                    WorkerStaticMemory;                                       // 0x0690(0x0008) (Native, Transient)
	int                                                SensorNodeCount;                                          // 0x0698(0x0004) (Transient)
	int                                                WorkerNodeCount;                                          // 0x069C(0x0004) (Transient)
	float                                              LastUpdateTime;                                           // 0x06A0(0x0004) (Transient)
	TArray<struct FBehaviorStateData>                  CachedNodeData;                                           // 0x06A4(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	float                                              m_fCooldownModifier;                                      // 0x06B4(0x0004)
	float                                              m_fLeadAccuracy;                                          // 0x06B8(0x0004)
	float                                              m_fDegreeMissedMagnitude;                                 // 0x06BC(0x0004)
	float                                              m_fMissLikelihood;                                        // 0x06C0(0x0004)
	class UTgAILocalPositionSolver*                    LocalRepulsorSolver;                                      // 0x06C4(0x0008) (Transient)
	class UClass*                                      LocalRepulsorSolverClass;                                 // 0x06CC(0x0008)
	struct FNavigationQueueEntry                       CurrentNavigation;                                        // 0x06D4(0x002C) (Transient)
	float                                              NavigationSearchModifier;                                 // 0x0700(0x0004) (Transient)
	float                                              NavigationSearchModifier_Max;                             // 0x0704(0x0004)
	float                                              NavigationSearchModifier_Min;                             // 0x0708(0x0004)
	float                                              TimeStuck;                                                // 0x070C(0x0004) (Transient)
	struct FFollowLaneState                            FollowLaneForwardState;                                   // 0x0710(0x0008)
	struct FFollowLaneState                            FollowLaneReverseState;                                   // 0x0718(0x0008)
	unsigned long                                      bIsAlive : 1;                                             // 0x0720(0x0004) (Transient)
	unsigned long                                      m_bPaused : 1;                                            // 0x0720(0x0004) (Transient)
	unsigned long                                      bIsStunned : 1;                                           // 0x0720(0x0004) (Transient)
	unsigned long                                      bInHostileAbility : 1;                                    // 0x0720(0x0004) (Transient)
	unsigned long                                      bIsSafeToRecall : 1;                                      // 0x0720(0x0004) (Transient)
	unsigned long                                      bInEnemyTowerRadius : 1;                                  // 0x0720(0x0004) (Transient)
	unsigned long                                      bInFriendlyTowerRadius : 1;                               // 0x0720(0x0004) (Transient)
	unsigned long                                      bInEnemyMinotaurRadius : 1;                               // 0x0720(0x0004) (Transient)
	unsigned long                                      bInFriendlyMinotaurRadius : 1;                            // 0x0720(0x0004) (Transient)
	unsigned long                                      bIsTargetOfEnemyTowerOrMinotaur : 1;                      // 0x0720(0x0004) (Transient)
	unsigned long                                      bCombatTargetInEnemyTowerRadius : 1;                      // 0x0720(0x0004) (Transient)
	unsigned long                                      bCombatTargetInFriendlyTowerRadius : 1;                   // 0x0720(0x0004) (Transient)
	unsigned long                                      bCombatTargetInEnemyMinotaurRadius : 1;                   // 0x0720(0x0004) (Transient)
	unsigned long                                      bCombatTargetInFriendlyMinotaurRadius : 1;                // 0x0720(0x0004) (Transient)
	unsigned long                                      bCombatTargetIsTargetOfFriendlyTowerOrMinotaur : 1;       // 0x0720(0x0004) (Transient)
	unsigned long                                      m_bDroppedDown : 1;                                       // 0x0720(0x0004) (Transient)
	unsigned long                                      bIsAtFortress : 1;                                        // 0x0720(0x0004) (Transient)
	unsigned long                                      bIsAtEnemyFortress : 1;                                   // 0x0720(0x0004) (Transient)
	unsigned long                                      bIsAtCachedRallyPoint : 1;                                // 0x0720(0x0004) (Transient)
	unsigned long                                      bBtDebugSpawnPaused : 1;                                  // 0x0720(0x0004)
	unsigned long                                      bBtDebugPaused : 1;                                       // 0x0720(0x0004) (Transient)
	unsigned long                                      bBtDebugStep : 1;                                         // 0x0720(0x0004) (Transient)
	unsigned long                                      bBtDebugClientOverlay : 1;                                // 0x0720(0x0004) (Transient)
	struct FVector                                     NextFearDirection;                                        // 0x0724(0x000C) (Transient)
	float                                              PawnCollisionHeight;                                      // 0x0730(0x0004) (Transient)
	float                                              PawnCollisionRadius;                                      // 0x0734(0x0004) (Transient)
	float                                              DeviceRanges[0x31];                                       // 0x0738(0x0004) (Transient)
	class AActor*                                      CombatTarget;                                             // 0x07FC(0x0008) (Transient)
	class ATgPawn*                                     CombatTargetAsPawn;                                       // 0x0804(0x0008) (Transient)
	int                                                EnemyMinionsInEnemyTowerRadius;                           // 0x080C(0x0004) (Transient)
	int                                                FriendlyMinionsInEnemyTowerRadius;                        // 0x0810(0x0004) (Transient)
	int                                                EnemyMinionsInFriendlyTowerRadius;                        // 0x0814(0x0004) (Transient)
	int                                                FriendlyMinionsInFriendlyTowerRadius;                     // 0x0818(0x0004) (Transient)
	int                                                EnemyGodsInEnemyTowerRadius;                              // 0x081C(0x0004) (Transient)
	int                                                FriendlyGodsInEnemyTowerRadius;                           // 0x0820(0x0004) (Transient)
	int                                                EnemyGodsInFriendlyTowerRadius;                           // 0x0824(0x0004) (Transient)
	int                                                FriendlyGodsInFriendlyTowerRadius;                        // 0x0828(0x0004) (Transient)
	float                                              HealthOfNearestEnemyTower;                                // 0x082C(0x0004) (Transient)
	float                                              HealthOfNearestFriendlyTower;                             // 0x0830(0x0004) (Transient)
	class AActor*                                      LaneMoveTarget;                                           // 0x0834(0x0008) (Transient)
	TArray<class AActor*>                              VisibleActorsToAvoid;                                     // 0x083C(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	TArray<class ATgPawn*>                             CachedTowers;                                             // 0x084C(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	TArray<class ATgPawn_Character*>                   CachedGods;                                               // 0x085C(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	TArray<class AController*>                         EnemyControllersInSightRadius;                            // 0x086C(0x0010) (Transient, NeedCtorLink)
	TArray<class AController*>                         FriendlyControllersInSightRadius;                         // 0x087C(0x0010) (Transient, NeedCtorLink)
	TEnumAsByte<EBotDifficultyLevel>                   Difficulty;                                               // 0x088C(0x0001) (Transient)
	TEnumAsByte<EUseDeviceAimType>                     LastUseDeviceAimType;                                     // 0x088D(0x0001) (Transient)
	unsigned char                                      UnknownData00[0x2];                                       // 0x088E(0x0002) MISSED OFFSET
	struct FVector                                     TargetLastKnownLocation;                                  // 0x0890(0x000C) (Transient)
	class ATgAIAnnotation*                             CurrentAssaultPoint;                                      // 0x089C(0x0008) (Transient)
	float                                              m_fUnstuckJumpFrequency;                                  // 0x08A4(0x0004)
	float                                              m_fLastUnstuckJumpTime;                                   // 0x08A8(0x0004) (Transient)
	TArray<struct FIncomingDamageEntry>                IncomingDamage;                                           // 0x08AC(0x0010) (Transient, NeedCtorLink)
	class ATgAIVolume*                                 CachedRallyVolume;                                        // 0x08BC(0x0008) (Transient)
	int                                                RandomRallyPointIndex;                                    // 0x08C4(0x0004) (Transient)
	class ATgPawn_SiegeWall*                           FortressObjective;                                        // 0x08C8(0x0008) (Transient)
	struct FVector                                     AlliedFortressLookDir;                                    // 0x08D0(0x000C) (Transient)
	struct FVector                                     EnemyFortressLookDir;                                     // 0x08DC(0x000C) (Transient)
	class ATgFortressVolume*                           AlliedFortress;                                           // 0x08E8(0x0008) (Transient)
	class ATgFortressVolume*                           EnemyFortress;                                            // 0x08F0(0x0008) (Transient)
	struct FVector                                     StrafeDir;                                                // 0x08F8(0x000C) (Transient)
	float                                              LastStrafeDirUpdate;                                      // 0x0904(0x0004) (Transient)
	float                                              StrafeDirUpdateTime;                                      // 0x0908(0x0004) (Transient)
	class UClass*                                      UtilityHandleClass;                                       // 0x090C(0x0008)
	class UTgAIUtilityHandle*                          UtilityHandle;                                            // 0x0914(0x0008) (Transient)
	class AActor*                                      EscortActor;                                              // 0x091C(0x0008) (Transient)
	float                                              EscortMinDistance;                                        // 0x0924(0x0004) (Transient)
	float                                              EscortMaxDistance;                                        // 0x0928(0x0004) (Transient)
	int                                                m_nDevicesLockingInput;                                   // 0x092C(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIController_Behavior");
		return ptr;
	}


	void UnpauseFromDuration();
	void PauseForDuration(float PauseDuration);
	bool IsPaused();
	void SetPaused(bool bPaused);
	void GameHasEnded(class AActor* EndGameFocus, bool bIsWinner);
	void PawnDied(class APawn* P);
	struct FRotator GetAdjustedAimFor(class AWeapon* W, const struct FVector& StartFireLoc);
	struct FRotator CalcGaussianInaccuracy(float StdDev);
	struct FRotator CalcUniformInaccuracy(float DegMissed);
	float STATIC_GetLeadAccuracy();
	float STATIC_GetAngleToTarget();
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	bool StopFireDevice(TEnumAsByte<ETG_EQUIP_POINT> DeviceSlot, bool bForce);
	bool CancelFiring();
	bool FireDevice(TEnumAsByte<ETG_EQUIP_POINT> DeviceSlot, bool bContinuousFire, TEnumAsByte<EUseDeviceAimType> aimType);
	struct FVector CalculateAim(bool bHeadShot);
	float STATIC_GetCooldownIncrease();
	void Stun(bool bStun, TEnumAsByte<EStunType> eType);
	void STATIC_UpdateDeviceRanges();
	void STATIC_OnPathfindTerminated();
	void STATIC_OnPathfindFailed();
	void StopNavigation();
	void ClearNavigation();
	void AddLocationToNavigationQueue(int NodeToken, const struct FVector& TargetLocation, bool bLookAtTarget, bool bMustHaveLOS, float DistanceTolerance);
	void AddActorToNavigationQueue(int NodeToken, class AActor* TargetActor, bool bLookAtTarget, bool bMustHaveLOS, float DistanceTolerance, bool bStopNavOnReachedDestination);
	bool STATIC_HasVisibilityToPoint(struct FVector* TestPoint);
	void ResetBlackboard();
	void Possess(class APawn* inPawn, bool bVehicleTransition);
	void Destroyed();
	void PostBeginPlay();
	void PreBeginPlay();
	float STATIC_GetCooldownModifier();
	void STATIC_LoadBehaviorTree(const struct FName& TreeName);
	void ResetBehaviorTree();
	void CleanupBehaviorTree();
	void SpawnDebuggerWindow();
	void Debug_Reset();
	void Debug_Resume();
	void Debug_Step();
	void Debug_Pause();
	void UpdatePawnDebug();
};


// Class TgGame.TgAIController_BehaviorGod
// 0x0030 (0x0960 - 0x0930)
class ATgAIController_BehaviorGod : public ATgAIController_Behavior
{
public:
	struct FPointer                                    VfTable_ITgPaladinsController;                            // 0x0930(0x0008) (Const, Native, NoExport)
	float                                              WaitForSpawnSecs;                                         // 0x0938(0x0004)
	int                                                PlayerID;                                                 // 0x093C(0x0004) (Transient)
	unsigned long                                      bCanPurchaseItems : 1;                                    // 0x0940(0x0004) (Transient)
	unsigned long                                      bCanPurchaseSkills : 1;                                   // 0x0940(0x0004) (Transient)
	unsigned long                                      bRespawnAtOriginalLocation : 1;                           // 0x0940(0x0004)
	float                                              CurrentGoldRemainder;                                     // 0x0944(0x0004) (Transient)
	int                                                CurrentGold;                                              // 0x0948(0x0004) (Transient)
	float                                              CurrentXPRemainder;                                       // 0x094C(0x0004) (Transient)
	int                                                CurrentXP;                                                // 0x0950(0x0004) (Transient)
	struct FVector                                     GeometricMean;                                            // 0x0954(0x000C) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIController_BehaviorGod");
		return ptr;
	}


	class ATgPawn* STATIC_GetTgPawn();
	class ATgPawn* STATIC_GetOwnedTgPawn();
	void ResetUlt();
	void SetCredits(int nCreditsAmount);
	int STATIC_GetCredits();
	void PostBeginPlay();
	struct FRotator GetAdjustedAimFor(class AWeapon* Weap, const struct FVector& StartFireLoc);
	void CopyPropertiesTo(class AController* C);
	void PawnDied(class APawn* P);
	void Possess(class APawn* inPawn, bool bVehicleTransition);
	void LiveRespawn(bool bResetHealth, bool bResetDevices);
	void STATIC_PrepareForLiveRespawn();
	void Revive();
	void InitPlayerReplicationInfo();
	int STATIC_GetTaskForceNumber();
	void SetRewardValues(int XP, int nCredits, class AActor* Source, TEnumAsByte<ERewardValueType> RewardType, bool bFlankKill);
	void SetStartingProperties();
	void SetBotPlayerId();
	bool OnRespawnRuleChanged();
	float StartReviveTimer();
	void PurchaseSkills();
	int STATIC_GetSkillPointsAvailable();
	bool STATIC_HaveBasicSkillsBeenActivated();
	bool CanAllocateSkillPoint(int DeviceID, class ATgDevice* aDevice);
	void PurchaseItems();
};


// Class TgGame.TgAIController_BehaviorGodDisconnected
// 0x0004 (0x0964 - 0x0960)
class ATgAIController_BehaviorGodDisconnected : public ATgAIController_BehaviorGod
{
public:
	unsigned long                                      bInitialController : 1;                                   // 0x0960(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIController_BehaviorGodDisconnected");
		return ptr;
	}


	void UnPossess();
	void Possess(class APawn* inPawn, bool bVehicleTransition);
	void InitPlayerReplicationInfo();
};


// Class TgGame.TgAIController_BehaviorGodDisconnectedStillBot
// 0x0000 (0x0964 - 0x0964)
class ATgAIController_BehaviorGodDisconnectedStillBot : public ATgAIController_BehaviorGodDisconnected
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIController_BehaviorGodDisconnectedStillBot");
		return ptr;
	}

};


// Class TgGame.TgAIController_BehaviorLaneNpc
// 0x000C (0x093C - 0x0930)
class ATgAIController_BehaviorLaneNpc : public ATgAIController_Behavior
{
public:
	class AActor*                                      GoalTarget;                                               // 0x0930(0x0008) (Transient)
	unsigned long                                      bDespawnOnLoseCombatTarget : 1;                           // 0x0938(0x0004) (Transient)
	unsigned long                                      bIsBehindSquad : 1;                                       // 0x0938(0x0004) (Transient)
	unsigned long                                      bTooFarFromLane : 1;                                      // 0x0938(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIController_BehaviorLaneNpc");
		return ptr;
	}


	bool CanSpreadOut();
};


// Class TgGame.TgAIController_BehaviorMapNpc
// 0x0030 (0x0960 - 0x0930)
class ATgAIController_BehaviorMapNpc : public ATgAIController_Behavior
{
public:
	TArray<struct FThreatEntry>                        ThreatList;                                               // 0x0930(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	unsigned long                                      bThreatListDecays : 1;                                    // 0x0940(0x0004) (Transient)
	unsigned long                                      bOutsideLeash : 1;                                        // 0x0940(0x0004) (Transient)
	unsigned long                                      bHadCombatTarget : 1;                                     // 0x0940(0x0004) (Transient)
	float                                              LeashDistance;                                            // 0x0944(0x0004) (Transient)
	class AVolume*                                     LeashVolume;                                              // 0x0948(0x0008) (Transient)
	TArray<class ATgPawn*>                             LeashActors;                                              // 0x0950(0x0010) (Transient, AlwaysInit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIController_BehaviorMapNpc");
		return ptr;
	}


	void NotifyKilledBy(class AController* Killer);
	void SquadTargetChanged();
	void SquadEvade();
	void STATIC_Evade();
	bool CanSpreadOut();
	void ClearThreatList();
	void AddThreat(class ATgPawn* attacker, float ThreatLevel);
};


// Class TgGame.TgAIController_BehaviorChaosJuggernaut
// 0x0000 (0x0960 - 0x0960)
class ATgAIController_BehaviorChaosJuggernaut : public ATgAIController_BehaviorMapNpc
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIController_BehaviorChaosJuggernaut");
		return ptr;
	}

};


// Class TgGame.TgAIController_BehaviorPet
// 0x0008 (0x0938 - 0x0930)
class ATgAIController_BehaviorPet : public ATgAIController_Behavior
{
public:
	class AActor*                                      OwnerCombatTarget;                                        // 0x0930(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIController_BehaviorPet");
		return ptr;
	}

};


// Class TgGame.TgAIController_BehaviorPet_LongTerm
// 0x0000 (0x0938 - 0x0938)
class ATgAIController_BehaviorPet_LongTerm : public ATgAIController_BehaviorPet
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIController_BehaviorPet_LongTerm");
		return ptr;
	}

};


// Class TgGame.TgAIController_BehaviorPetRanged
// 0x0000 (0x0938 - 0x0938)
class ATgAIController_BehaviorPetRanged : public ATgAIController_BehaviorPet
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIController_BehaviorPetRanged");
		return ptr;
	}

};


// Class TgGame.TgAIInfluenceMap
// 0x0038 (0x0098 - 0x0060)
class UTgAIInfluenceMap : public UObject
{
public:
	struct FPointer                                    VfTable_FTickableObject;                                  // 0x0060(0x0008) (Const, Native, NoExport)
	TArray<int>                                        Influences;                                               // 0x0068(0x0010) (Transient, NeedCtorLink)
	struct FPointer                                    FalloffTable;                                             // 0x0078(0x0008) (Native, Transient)
	class UHavokNavMeshGrid*                           InfluenceGrid;                                            // 0x0080(0x0008) (Const, Native, Transient)
	float                                              TickFrequency;                                            // 0x0088(0x0004)
	float                                              InvTickFrequency;                                         // 0x008C(0x0004) (Transient)
	float                                              Decay;                                                    // 0x0090(0x0004)
	float                                              Momentum;                                                 // 0x0094(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIInfluenceMap");
		return ptr;
	}


	void RegisterInfluence(const struct FVector& StartPosition, int PackedInfluence, bool Additive, float Radius);
	void Init();
};


// Class TgGame.TgAIInfluenceMapRenderingComponent
// 0x0010 (0x0260 - 0x0250)
class UTgAIInfluenceMapRenderingComponent : public UHavokNavigationRenderingComponent
{
public:
	class UTgAIInfluenceMap*                           InfluenceMap;                                             // 0x0250(0x0008) (Transient)
	class UTexture2DDynamic*                           InfluenceMapTexture;                                      // 0x0258(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIInfluenceMapRenderingComponent");
		return ptr;
	}

};


// Class TgGame.TgAILocalPositionSolver
// 0x0040 (0x00A0 - 0x0060)
class UTgAILocalPositionSolver : public UObject
{
public:
	struct FPointer                                    VfTable_IInterface_ActorPathConstraints;                  // 0x0060(0x0008) (Const, Native, NoExport)
	TArray<struct FDefaultRepulsorData>                DefaultWeights;                                           // 0x0068(0x0010) (NeedCtorLink)
	class ATgAIController_Behavior*                    OuterController;                                          // 0x0078(0x0008) (Transient)
	float                                              LastQueryTime;                                            // 0x0080(0x0004) (Transient)
	struct FVector                                     LastQueryPoint;                                           // 0x0084(0x000C) (Transient)
	struct FVector                                     LastSolvePoint;                                           // 0x0090(0x000C) (Transient)
	unsigned long                                      bSolveDistanceThreshold : 1;                              // 0x009C(0x0004)
	unsigned long                                      bSolveWeights : 1;                                        // 0x009C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAILocalPositionSolver");
		return ptr;
	}


	void STATIC_SolveConstraints(const struct FVector& InitialPosition, float MaxDistance, struct FVector* OutDesiredPosition);
};


// Class TgGame.TgAIObstacleAvoidance
// 0x0060 (0x00C0 - 0x0060)
class UTgAIObstacleAvoidance : public UObject
{
public:
	struct FPointer                                    ObstacleGrid;                                             // 0x0060(0x0008) (Native, Transient)
	struct FObstacleQueryCache                         CachedAvoidance;                                          // 0x0068(0x002C) (Transient, NeedCtorLink)
	TArray<class ABlockingVolume*>                     CachedBlockers;                                           // 0x0094(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	TArray<class ALandscape*>                          CachedLandscapes;                                         // 0x00A4(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	class ATgAIController_Behavior*                    OuterController;                                          // 0x00B4(0x0008) (Transient)
	unsigned long                                      bRenderingIsDirty : 1;                                    // 0x00BC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIObstacleAvoidance");
		return ptr;
	}


	void TestObstacleAvoidance(int TestType);
	void Reset();
	void Init(float GridPointSize, float GridExtents);
	TEnumAsByte<EObstacleAvoidanceStatus> GetNextMoveLocation(struct FVector* TargetPoint, struct FVector* IntermediatePoint, float* ArrivalDistance);
	bool FindPath(TArray<class AActor*>* ActorsToAvoid, struct FVector* TargetPoint, struct FVector* UpdatedTargetPoint);
};


// Class TgGame.TgAIObstacleAvoidanceRenderingComponent
// 0x0008 (0x0254 - 0x024C)
class UTgAIObstacleAvoidanceRenderingComponent : public UPrimitiveComponent
{
public:
	class UTgAIObstacleAvoidance*                      ObstacleAvoidance;                                        // 0x024C(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIObstacleAvoidanceRenderingComponent");
		return ptr;
	}

};


// Class TgGame.TgAISquad
// 0x0048 (0x00A8 - 0x0060)
class UTgAISquad : public UObject
{
public:
	struct FPointer                                    VfTable_FTickableObject;                                  // 0x0060(0x0008) (Const, Native, NoExport)
	unsigned long                                      s_bOpen : 1;                                              // 0x0068(0x0004)
	unsigned long                                      s_bShouldSpread : 1;                                      // 0x0068(0x0004)
	TArray<class ATgAIController*>                     s_MemberList;                                             // 0x006C(0x0010) (NeedCtorLink)
	class ATgBotFactory*                               s_Factory;                                                // 0x007C(0x0008)
	class AActor*                                      s_CurrentTarget;                                          // 0x0084(0x0008)
	TArray<class AActor*>                              s_TargetList;                                             // 0x008C(0x0010) (NeedCtorLink)
	class AController*                                 s_LastKiller;                                             // 0x009C(0x0008)
	float                                              s_fNextSpreadTime;                                        // 0x00A4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAISquad");
		return ptr;
	}


	void OnSquadCreated();
	void NotifyEvade();
	void NotifyTargetChanged();
	void STATIC_Evade();
	void SuggestEvade();
	void STATIC_UpdateTargetList(float DeltaTime);
	void STATIC_DropTarget(class AActor* TargetToDrop);
	void SuggestDropTarget(class AActor* TargetToDrop, class ATgAIController* requester);
	class ATgPawn* STATIC_GetTargetPawn();
	class AActor* STATIC_GetTarget();
	void SetTarget(class AActor* NewTarget);
	void SuggestTarget(class AActor* NewTarget, class ATgAIController* requester);
	struct FBox STATIC_GetSquadBounds();
	void SpreadSquad();
	void SquadDied();
	bool MergeWith(class UTgAISquad* squad);
	void MemberKilledBy(class AController* Killer);
	void RemoveMember(class ATgAIController* aic, bool bDied);
	void AddMember(class ATgAIController* aic);
	bool STATIC_IsOpen();
	void CloseSquad();
	void OpenSquad();
};


// Class TgGame.TgAISquad_Minion
// 0x0008 (0x00B0 - 0x00A8)
class UTgAISquad_Minion : public UTgAISquad
{
public:
	float                                              s_fNextClusterTime;                                       // 0x00A8(0x0004)
	float                                              s_fNextMergeTime;                                         // 0x00AC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAISquad_Minion");
		return ptr;
	}


	void CheckForMerge();
	void ClusterSquad();
};


// Class TgGame.TgAISquad_Monster
// 0x0000 (0x00A8 - 0x00A8)
class UTgAISquad_Monster : public UTgAISquad
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAISquad_Monster");
		return ptr;
	}


	void STATIC_DropTarget(class AActor* TargetToDrop);
};


// Class TgGame.TgAISquad_MonsterBehaviorTree
// 0x0010 (0x00B8 - 0x00A8)
class UTgAISquad_MonsterBehaviorTree : public UTgAISquad
{
public:
	struct FName                                       BehaviorTreeAsName;                                       // 0x00A8(0x0008)
	class ATgAIController_BehaviorMapNpc*              Controller;                                               // 0x00B0(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAISquad_MonsterBehaviorTree");
		return ptr;
	}


	void OnSquadCreated();
	class ATgPawn* STATIC_GetTargetPawn();
	class AActor* STATIC_GetTarget();
	void STATIC_Evade();
	void SquadDied();
	void STATIC_UpdateTargetList(float DeltaTime);
	void STATIC_DropTarget(class AActor* TargetToDrop);
	void SuggestDropTarget(class AActor* TargetToDrop, class ATgAIController* requester);
	void SetTarget(class AActor* NewTarget);
	void SuggestTarget(class AActor* NewTarget, class ATgAIController* requester);
	class ATgAIController_BehaviorMapNpc* SpawnController();
};


// Class TgGame.TgAIUtilityHandle
// 0x0122 (0x0182 - 0x0060)
class UTgAIUtilityHandle : public UObject
{
public:
	struct FUtilitySet                                 UtilitySets[0x2];                                         // 0x0060(0x0048)
	struct FUtilityPair                                FilteredAnnotationPoints[0x2];                            // 0x00F0(0x0048)
	TEnumAsByte<EBotBehaviorState>                     eBehaviorState;                                           // 0x0180(0x0001)
	TEnumAsByte<ERangeType>                            AssaultRangeType;                                         // 0x0181(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIUtilityHandle");
		return ptr;
	}


	void ComputeUtilities();
	class ATgAIAnnotation* STATIC_GetBestAnnotationPoint(TEnumAsByte<EAIAnnotationType> AnnotationType);
};


// Class TgGame.TgMinionGoal
// 0x0014 (0x038C - 0x0378)
class ATgMinionGoal : public ANavigationPoint
{
public:
	int                                                m_nLaneNum;                                               // 0x0378(0x0004) (Edit)
	int                                                m_nTaskForce;                                             // 0x037C(0x0004) (Edit)
	class ATgActionPoint*                              m_EndPoint;                                               // 0x0380(0x0008) (Edit)
	unsigned long                                      m_bUseForFinalDestination : 1;                            // 0x0388(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMinionGoal");
		return ptr;
	}


	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgMinionGoal_Aphrodite
// 0x0000 (0x038C - 0x038C)
class ATgMinionGoal_Aphrodite : public ATgMinionGoal
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMinionGoal_Aphrodite");
		return ptr;
	}


	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgCameraModifier_LobbyCameraTransition
// 0x0018 (0x0098 - 0x0080)
class UTgCameraModifier_LobbyCameraTransition : public UCameraModifier
{
public:
	class ATgLobbyCamera*                              SourceCamera;                                             // 0x0080(0x0008)
	class ATgLobbyCamera*                              DestinationCamera;                                        // 0x0088(0x0008)
	TEnumAsByte<ECameraTransType>                      TransitionType;                                           // 0x0090(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0091(0x0003) MISSED OFFSET
	float                                              fSlideDistance;                                           // 0x0094(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModifier_LobbyCameraTransition");
		return ptr;
	}


	bool STATIC_RemoveCameraModifier(class ACamera* Camera);
	void DisableModifier(bool bImmediate);
	void RemoveCameraModifierAsEvent(class ACamera* Cam);
	void AddCameraModifierAsEvent(class ACamera* Cam);
	bool STATIC_ModifyCamera(class ACamera* Camera, float DeltaTime, struct FTPOV* OutPOV);
};


// Class TgGame.TgCameraModifier_LobbyFade
// 0x0000 (0x0080 - 0x0080)
class UTgCameraModifier_LobbyFade : public UCameraModifier
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModifier_LobbyFade");
		return ptr;
	}


	bool STATIC_ModifyCamera(class ACamera* Camera, float DeltaTime, struct FTPOV* OutPOV);
};


// Class TgGame.TgCameraModule
// 0x0008 (0x0068 - 0x0060)
class UTgCameraModule : public UObject
{
public:
	class ATgPlayerCamera*                             PlayerCamera;                                             // 0x0060(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule");
		return ptr;
	}


	void STATIC_ZoomOut();
	void STATIC_ZoomIn();
	void BecomeViewTarget(class ATgPlayerController* PC);
	void UpdateCamera(class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT);
	void OnTweenOutEnd();
	void OnBecomeInActive(class UTgCameraModule* NewCamera);
	void OnBecomeActive(class UTgCameraModule* OldCamera);
	void Init();
};


// Class TgGame.TgCameraModule_Free
// 0x0018 (0x0080 - 0x0068)
class UTgCameraModule_Free : public UTgCameraModule
{
public:
	float                                              CamAltitude;                                              // 0x0068(0x0004)
	float                                              DesiredCamAltitude;                                       // 0x006C(0x0004)
	float                                              MaxCamAltitude;                                           // 0x0070(0x0004)
	float                                              MinCamAltitude;                                           // 0x0074(0x0004)
	float                                              CamZoomIncrement;                                         // 0x0078(0x0004)
	unsigned long                                      m_bCachedNoDeathCamExperiment : 1;                        // 0x007C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_Free");
		return ptr;
	}


	void STATIC_ZoomOut();
	void STATIC_ZoomIn();
	void BecomeViewTarget(class ATgPlayerController* PC);
	void UpdateCamera(class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT);
	bool STATIC_NoDeathCamCodePath();
	struct FVector STATIC_GetCamLocationOffset(class APawn* P);
};


// Class TgGame.TgCameraModule_GroundTarget
// 0x0000 (0x0080 - 0x0080)
class UTgCameraModule_GroundTarget : public UTgCameraModule_Free
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_GroundTarget");
		return ptr;
	}


	void STATIC_ZoomOut();
	void STATIC_ZoomIn();
	void UpdateCamera(class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT);
	struct FVector STATIC_GetCamLocationOffset(class APawn* P);
};


// Class TgGame.TgCameraModule_Server
// 0x0000 (0x0068 - 0x0068)
class UTgCameraModule_Server : public UTgCameraModule
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_Server");
		return ptr;
	}

};


// Class TgGame.TgCameraModule_Spectator
// 0x0034 (0x009C - 0x0068)
class UTgCameraModule_Spectator : public UTgCameraModule
{
public:
	int                                                WorldViewPitch;                                           // 0x0068(0x0004) (Edit)
	struct FTPOV                                       OldViewpoint;                                             // 0x006C(0x0024) (Transient)
	float                                              RemainingBlendTime;                                       // 0x0090(0x0004) (Transient)
	float                                              TotalBlendTime;                                           // 0x0094(0x0004) (Transient)
	unsigned long                                      bCollideWorld : 1;                                        // 0x0098(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_Spectator");
		return ptr;
	}


	void BlendCameraToLocation(const struct FVector& NewLocation, float BlendTime, bool bUseFocalPoint);
	void OnBecomeInActive(class UTgCameraModule* NewCamera);
	void OnBecomeActive(class UTgCameraModule* OldCamera);
	void DecreaseCameraSpeed();
	void STATIC_IncreaseCameraSpeeed();
	void STATIC_ZoomOut();
	void STATIC_ZoomIn();
	float GetFOVAngle();
	void UpdateCamera(class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT);
};


// Class TgGame.TgCameraModule_SpectatorOverview
// 0x00AC (0x0148 - 0x009C)
class UTgCameraModule_SpectatorOverview : public UTgCameraModule_Spectator
{
public:
	struct FRotator                                    WorldViewRotation;                                        // 0x009C(0x000C) (Edit)
	float                                              FOV;                                                      // 0x00A8(0x0004) (Edit, Config)
	float                                              TargetZoomedFOV;                                          // 0x00AC(0x0004)
	float                                              ZoomIncrement;                                            // 0x00B0(0x0004) (Edit, Config)
	float                                              MinZoom;                                                  // 0x00B4(0x0004) (Edit, Config)
	float                                              MaxZoom;                                                  // 0x00B8(0x0004) (Edit, Config)
	float                                              ZoomInterpTime;                                           // 0x00BC(0x0004) (Edit, Config)
	struct FVector                                     CurrentSpringLocation;                                    // 0x00C0(0x000C)
	float                                              PawnTargetSpringDamping;                                  // 0x00CC(0x0004) (Edit, Config)
	float                                              FreeCamSpringDamping;                                     // 0x00D0(0x0004) (Edit, Config)
	float                                              IgnoreSpringDistance;                                     // 0x00D4(0x0004) (Edit, Config)
	TArray<struct FCameraPitchInfo>                    CameraPitchData;                                          // 0x00D8(0x0010) (Edit, NeedCtorLink)
	unsigned long                                      bFlippedSides : 1;                                        // 0x00E8(0x0004) (Edit)
	unsigned long                                      bJustBecameActive : 1;                                    // 0x00E8(0x0004)
	unsigned long                                      bAutoZoomEnabled : 1;                                     // 0x00E8(0x0004) (Edit, Config)
	float                                              OverviewCameraInfluenceDist;                              // 0x00EC(0x0004) (Edit)
	TArray<class ATgOverviewCameraActor*>              OverviewCameras;                                          // 0x00F0(0x0010) (NeedCtorLink)
	TArray<class ATgPawn_TowerBase*>                   TransparentTowerList;                                     // 0x0100(0x0010) (NeedCtorLink)
	struct FVector                                     ObstacleTransparentExtent;                                // 0x0110(0x000C) (Edit)
	float                                              fMinAutoZoomFOVAngle;                                     // 0x011C(0x0004) (Edit, Config)
	float                                              fMaxAutoZoomFOVAngle;                                     // 0x0120(0x0004) (Edit, Config)
	float                                              fMinAutoZoomDistance;                                     // 0x0124(0x0004) (Edit, Config)
	float                                              fMaxAutoZoomDistance;                                     // 0x0128(0x0004) (Edit, Config)
	float                                              fAutoZoomDetectionRadius;                                 // 0x012C(0x0004) (Edit, Config)
	float                                              fAutoZoomInSpeed;                                         // 0x0130(0x0004) (Edit, Config)
	float                                              fAutoZoomOutSpeed;                                        // 0x0134(0x0004) (Edit, Config)
	float                                              fAutoZoomInLockOutTime;                                   // 0x0138(0x0004) (Edit, Config)
	float                                              fAutoZoomOutLockOutTime;                                  // 0x013C(0x0004) (Edit, Config)
	float                                              m_RemainingAutoZoomInLockOutTime;                         // 0x0140(0x0004) (Transient)
	float                                              m_RemainingAutoZoomOutLockOutTime;                        // 0x0144(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_SpectatorOverview");
		return ptr;
	}


	void STATIC_FlipSides();
	float GetFOVAngle();
	void STATIC_ZoomOut();
	void STATIC_ZoomIn();
	void UpdateCamera(class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT);
	void OverridePawnTargetLocation(class ATgPawn* TgP, struct FVector* TargetLocation);
	void BlendCameraToLocation(const struct FVector& NewLocation, float BlendTime, bool bUseFocalPoint);
	void OnBecomeInActive(class UTgCameraModule* NewCamera);
	void OnBecomeActive(class UTgCameraModule* OldCamera);
	void ClearObstacleTransparency();
	void CheckObstacleTransparency();
	bool STATIC_UpdateAutoZoom(float DeltaTime);
	struct FRotator STATIC_GetWorldViewRotation();
};


// Class TgGame.TgCameraModule_TopDown
// 0x000C (0x00A8 - 0x009C)
class UTgCameraModule_TopDown : public UTgCameraModule_Spectator
{
public:
	struct FRotator                                    WorldViewRotation;                                        // 0x009C(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_TopDown");
		return ptr;
	}


	void BlendToTarget(float BlendTime);
	void OnBecomeInActive(class UTgCameraModule* NewCamera);
	void OnBecomeActive(class UTgCameraModule* OldCamera);
	void UpdateCamera(class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT);
};


// Class TgGame.TgCameraModule_ThirdPerson
// 0x00B0 (0x0118 - 0x0068)
class UTgCameraModule_ThirdPerson : public UTgCameraModule
{
public:
	struct FVector                                     vBaseCameraOffset;                                        // 0x0068(0x000C)
	struct FVector                                     vForcedCameraOffset;                                      // 0x0074(0x000C)
	struct FVector                                     vCurrentCameraOffset;                                     // 0x0080(0x000C)
	struct FVector                                     vPreviousCameraOffset;                                    // 0x008C(0x000C)
	float                                              fCameraOffsetLerpDuration;                                // 0x0098(0x0004)
	float                                              fCameraOffsetLerpTimer;                                   // 0x009C(0x0004)
	float                                              fZoomFactorInterp;                                        // 0x00A0(0x0004)
	float                                              fZoomFactor;                                              // 0x00A4(0x0004)
	float                                              fZoomStep;                                                // 0x00A8(0x0004)
	float                                              fZoomMax;                                                 // 0x00AC(0x0004)
	float                                              fMountZoomMax;                                            // 0x00B0(0x0004)
	float                                              fZoomMin;                                                 // 0x00B4(0x0004)
	struct FVector2D                                   fZoom3pPercentFromTo;                                     // 0x00B8(0x0008)
	float                                              fZoomDuration;                                            // 0x00C0(0x0004)
	float                                              fZoomDurationOverride;                                    // 0x00C4(0x0004)
	float                                              fZoomUsedTime;                                            // 0x00C8(0x0004) (Transient)
	TEnumAsByte<ECameraPerspectiveType>                ePreviousPerspectiveType;                                 // 0x00CC(0x0001)
	TEnumAsByte<ECameraPerspectiveType>                ePerspectiveType;                                         // 0x00CD(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x00CE(0x0002) MISSED OFFSET
	unsigned long                                      bForce3PView : 1;                                         // 0x00D0(0x0004)
	struct FVector                                     vServerCorrectionDelta;                                   // 0x00D4(0x000C)
	struct FVector                                     vAvgServerCorrectionDelta;                                // 0x00E0(0x000C)
	struct FVector                                     vLastDesiredLocation;                                     // 0x00EC(0x000C)
	struct FServerCorrectionSmoothingParams            CorrectionSmoothing;                                      // 0x00F8(0x0020)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_ThirdPerson");
		return ptr;
	}


	void BecomeViewTarget(class ATgPlayerController* PC);
	void STATIC_UpdateAverageServerCorrection(float DeltaTime);
	void STATIC_UpdateServerCorrectionFromMovement(const struct FVector& DesiredLocation);
	struct FVector SmoothServerCorrection(class ATgPawn* TgP, const struct FVector& DesiredLocation, float DeltaTime);
	void UpdateCamera(class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT);
	struct FVector STATIC_GetCamLocationWithOffset(class ATgPawn* ViewPawn, float DeltaTime, class ATgPlayerCamera* CameraActor, struct FTViewTarget* OutVT);
	void STATIC_UpdateCameraZoom(class ATgPawn* TgP, float DeltaTime);
	float STATIC_GetZoomDuration();
	float STATIC_GetCurrent3pPercent();
	struct FRotator STATIC_GetWorldRotation(class ATgPlayerCamera* CameraActor);
	void ApplyAdditionalCameraRotation(class ATgPawn* ViewPawn, struct FRotator* rCameraRotation);
	void Apply3pCamTranslationOffsets(const struct FVector& vCamAttachLocation, class ATgPawn* ViewPawn, struct FVector* vPivotLocation, struct FVector* vCameraSpaceTranslation);
	bool Set3pCamAttachLocation(class ATgPawn* ViewPawn, struct FVector* vCamAttachLocation);
	void Apply1pCamTranslationOffsets(const struct FVector& vCamAttachLocation, class ATgPawn* ViewPawn, struct FVector* vPivotLocation, struct FVector* vCameraSpaceTranslation);
	bool Set1pCamAttachLocation(class ATgPawn* ViewPawn, struct FVector* vCamAttachLocation);
	struct FVector STATIC_GetCamLocationOffset(const struct FRotator& PawnRot, const struct FVector& vInCameraSpaceTranslation);
	struct FVector STATIC_GetCamRawOffset(class AActor* ViewTarget, bool bIsFirstPerson);
	void OnTweenOutEnd();
	void OnBecomeActive(class UTgCameraModule* OldCamera);
	bool STATIC_IsUsingFirstPersonCam();
};


// Class TgGame.TgCameraShake
// 0x0015 (0x010D - 0x00F8)
class UTgCameraShake : public UCameraShake
{
public:
	float                                              m_fShakeScale;                                            // 0x00F8(0x0004) (Edit)
	unsigned long                                      m_bDoControllerVibration : 1;                             // 0x00FC(0x0004) (Edit)
	unsigned long                                      m_bRadialShake : 1;                                       // 0x00FC(0x0004) (Edit)
	unsigned long                                      m_bOrientTowardRadialEpicenter : 1;                       // 0x00FC(0x0004) (Edit)
	float                                              m_fRadialShake_InnerRadius;                               // 0x0100(0x0004) (Edit)
	float                                              m_fRadialShake_OuterRadius;                               // 0x0104(0x0004) (Edit)
	float                                              m_fRadialShake_Falloff;                                   // 0x0108(0x0004) (Edit)
	TEnumAsByte<ECameraAnimPlaySpace>                  m_PlaySpace;                                              // 0x010C(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraShake");
		return ptr;
	}

};


// Class TgGame.TgLobbyCamera
// 0x00A5 (0x04C5 - 0x0420)
class ATgLobbyCamera : public ACameraActor
{
public:
	class ATgSkeletalMeshActor_Lobby*                  m_ViewTarget;                                             // 0x0420(0x0008) (Edit)
	TArray<class ATgSkeletalMeshActor_Lobby*>          m_FriendlyTargets;                                        // 0x0428(0x0010) (Edit, NeedCtorLink)
	TArray<class ATgSkeletalMeshActor_Lobby*>          m_EnemyTargets;                                           // 0x0438(0x0010) (Edit, NeedCtorLink)
	struct FVector                                     m_RenderCenterPointOffset;                                // 0x0448(0x000C) (Edit)
	unsigned long                                      m_bActive : 1;                                            // 0x0454(0x0004) (Transient)
	unsigned long                                      m_bAdjustCameraToTarget : 1;                              // 0x0454(0x0004) (Edit)
	unsigned long                                      m_bAdjustZoomByTargetHeight : 1;                          // 0x0454(0x0004) (Edit)
	unsigned long                                      m_bFirstCameraEyeCheck : 1;                               // 0x0454(0x0004)
	int                                                m_nPosition;                                              // 0x0458(0x0004) (Transient)
	float                                              m_fRemainingTweenTime;                                    // 0x045C(0x0004)
	float                                              m_fTotalTweenTime;                                        // 0x0460(0x0004)
	struct FTPOV                                       m_TweenSourcePOV;                                         // 0x0464(0x0024) (Transient)
	float                                              m_fLateralOffsetMultiplier;                               // 0x0488(0x0004) (Edit)
	float                                              m_fHorizontalOffsetMultiplier;                            // 0x048C(0x0004) (Edit)
	float                                              m_fViewLateralOffsetMultiplier;                           // 0x0490(0x0004) (Edit)
	float                                              m_fViewHorizontalOffsetMultiplier;                        // 0x0494(0x0004) (Edit)
	float                                              m_fMaxAdjustSpeedTranslation;                             // 0x0498(0x0004) (Edit)
	float                                              m_fMaxAdjustSpeedRotation;                                // 0x049C(0x0004) (Edit)
	struct FVector                                     m_vViewOffset;                                            // 0x04A0(0x000C) (Edit)
	struct FVector                                     m_vOriginalViewOffset;                                    // 0x04AC(0x000C) (Edit)
	float                                              m_fZoomAdjustBaseHeight;                                  // 0x04B8(0x0004) (Edit)
	float                                              m_fZoomAdjustMultiplier;                                  // 0x04BC(0x0004) (Edit)
	float                                              m_fFirstCameraEyeCheckTimestamp;                          // 0x04C0(0x0004)
	TEnumAsByte<ELobbyCameraTag>                       m_CameraTag;                                              // 0x04C4(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgLobbyCamera");
		return ptr;
	}


	void GetCameraView(float DeltaTime, bool bOnlyFOV, struct FTPOV* OutPOV);
	void GetActorEyesViewPoint(struct FVector* out_Location, struct FRotator* out_Rotation);
	float STATIC_GetTargetSizeMultiplier();
	void StartTween(float TweenTime);
	void PreBeginPlay();
	void SetPosition(int nPosition);
	void TriggerKismetActivationEvent(bool bActive, int nPosition);
	void ClearEnemyTargets();
	void ClearFriendlyTargets();
	void STATIC_SetActive(bool bActive);
};


// Class TgGame.TgLobbyCaptureActor
// 0x0008 (0x0298 - 0x0290)
class ATgLobbyCaptureActor : public ASceneCapture2DActor
{
public:
	class ATgSkeletalMeshActor_Lobby*                  m_ViewTarget;                                             // 0x0290(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgLobbyCaptureActor");
		return ptr;
	}

};


// Class TgGame.TgObserver_ViewTargetChanged
// 0x0000 (0x0060 - 0x0060)
class UTgObserver_ViewTargetChanged : public UInterface
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgObserver_ViewTargetChanged");
		return ptr;
	}


	void OnViewTargetChanged(class AActor* aNewViewTarget);
};


// Class TgGame.TgOverviewCameraActor
// 0x0004 (0x0424 - 0x0420)
class ATgOverviewCameraActor : public ACameraActor
{
public:
	unsigned long                                      m_bFlipped : 1;                                           // 0x0420(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgOverviewCameraActor");
		return ptr;
	}

};


// Class TgGame.TgPlayerCamera
// 0x029C (0x08A0 - 0x0604)
class ATgPlayerCamera : public ACamera
{
public:
	class ATgPlayerController*                         PlayerOwner;                                              // 0x0604(0x0008)
	class UTgCameraModule*                             CurrentCameraMod;                                         // 0x060C(0x0008) (Edit, EditInline)
	class UClass*                                      DefaultCameraModuleClass;                                 // 0x0614(0x0008)
	TArray<class UTgCameraModule*>                     CameraModuleList;                                         // 0x061C(0x0010) (NeedCtorLink)
	struct FRotator                                    CamAngle;                                                 // 0x062C(0x000C)
	unsigned long                                      m_bIsLowHealth : 1;                                       // 0x0638(0x0004)
	unsigned long                                      bTweening : 1;                                            // 0x0638(0x0004)
	unsigned long                                      m_bPlayingHeal : 1;                                       // 0x0638(0x0004)
	struct FVector                                     CameraLocationLocalToTarget;                              // 0x063C(0x000C)
	unsigned char                                      UnknownData00[0x8];                                       // 0x0648(0x0008) MISSED OFFSET
	struct FQuat                                       CameraRotationLocalToTarget;                              // 0x0650(0x0010)
	float                                              fTweenStart;                                              // 0x0660(0x0004)
	float                                              fTweenDuration;                                           // 0x0664(0x0004)
	class UTgCameraModule*                             LastCameraMod;                                            // 0x0668(0x0008)
	float                                              m_fCollisionTraceExtent;                                  // 0x0670(0x0004)
	class ATgEmitter_CameraEffect_LowHealth*           m_LowHealthCameraEffect;                                  // 0x0674(0x0008)
	class ATgEmitter_CameraEffect_Bleed*               m_BleedCameraEffect;                                      // 0x067C(0x0008)
	class ATgEmitter_CameraEffect_Daze*                m_DazeCameraEffect;                                       // 0x0684(0x0008)
	class ATgEmitter_CameraEffect_Fire*                m_FireCameraEffect;                                       // 0x068C(0x0008)
	class ATgEmitter_CameraEffect_Freeze*              m_FreezeCameraEffect;                                     // 0x0694(0x0008)
	class ATgEmitter_CameraEffect_Heal*                m_HealCameraEffect;                                       // 0x069C(0x0008)
	class ATgEmitter_CameraEffect_Knockback*           m_KnockbackCameraEffect;                                  // 0x06A4(0x0008)
	class ATgEmitter_CameraEffect_Mark*                m_MarkCameraEffect;                                       // 0x06AC(0x0008)
	class ATgEmitter_CameraEffect_Poison*              m_PoisonCameraEffect;                                     // 0x06B4(0x0008)
	class ATgEmitter_CameraEffect_Venom*               m_VenomCameraEffect;                                      // 0x06BC(0x0008)
	class ATgEmitter_CameraEffect_Root*                m_RootCameraEffect;                                       // 0x06C4(0x0008)
	class ATgEmitter_CameraEffect_Slow*                m_SlowCameraEffect;                                       // 0x06CC(0x0008)
	class ATgEmitter_CameraEffect_Stun*                m_StunCameraEffect;                                       // 0x06D4(0x0008)
	class ATgEmitter_CameraEffect_Hidden*              m_HiddenCameraEffect;                                     // 0x06DC(0x0008)
	class ATgEmitter_CameraEffect_Hidden*              m_GrassCameraEffect;                                      // 0x06E4(0x0008)
	class ATgEmitter_CameraEffect_Teleport*            m_TeleportCameraEffect;                                   // 0x06EC(0x0008)
	class ATgEmitter_CameraEffect_PreTeleport*         m_PreTeleportCameraEffect;                                // 0x06F4(0x0008)
	class ATgEmitter_CameraEffect_CCImmune*            m_CCImmuneCameraEffect;                                   // 0x06FC(0x0008)
	class ATgEmitter_CameraEffect_Cripple*             m_CrippleCameraEffect;                                    // 0x0704(0x0008)
	class ATgEmitter_CameraEffect_Revealed*            m_RevealedCameraEffect;                                   // 0x070C(0x0008)
	class ATgEmitter_CameraEffect*                     m_WeatherCameraEffect;                                    // 0x0714(0x0008)
	class ATgWeatherVolume*                            m_CurrentWeatherVolume;                                   // 0x071C(0x0008)
	TArray<class ATgEmitter_CameraEffect*>             m_CameraEffects;                                          // 0x0724(0x0010) (Transient, NeedCtorLink)
	int                                                m_nCameraEffectIdCounter;                                 // 0x0734(0x0004)
	class UClass*                                      m_HealthDamageCameraEffectClasses[0x8];                   // 0x0738(0x0008)
	class UClass*                                      m_ShieldDamageCameraEffectClasses[0x8];                   // 0x0778(0x0008)
	struct FPropertyDecayState                         m_HealthDamageFXState[0x8];                               // 0x07B8(0x000C)
	struct FPropertyDecayState                         m_HealingFXState;                                         // 0x0818(0x000C)
	struct FPropertyDecayParams                        m_HealthDamageFXParams;                                   // 0x0824(0x0014)
	struct FPropertyDecayParams                        m_HealingFXParams;                                        // 0x0838(0x0014)
	float                                              m_fAccumulateHealing;                                     // 0x084C(0x0004)
	float                                              m_fSecondsSinceLastHealFXUpdate;                          // 0x0850(0x0004)
	float                                              m_fHealFXUpdatePeriod;                                    // 0x0854(0x0004)
	float                                              m_fBloodHazeIntensity;                                    // 0x0858(0x0004)
	int                                                m_nSerisDefaultShadowTravelFX;                            // 0x085C(0x0004) (Const)
	int                                                m_LillithUltFX[0x4];                                      // 0x0860(0x0004)
	float                                              m_fHealingFXHalflifeAccumulation;                         // 0x0870(0x0004)
	float                                              m_fHealingFXHalflifeImpulse;                              // 0x0874(0x0004)
	float                                              m_fHealingFXReliefFactor;                                 // 0x0878(0x0004)
	float                                              m_fHealingFXAccumulationMix;                              // 0x087C(0x0004)
	float                                              m_fHealingFXVisibleThreshold;                             // 0x0880(0x0004)
	float                                              m_fHealingCritFXThreshold;                                // 0x0884(0x0004)
	float                                              m_fHealthDamageFXHalflifeAccumulation;                    // 0x0888(0x0004)
	float                                              m_fHealthDamageFXHalflifeImpulse;                         // 0x088C(0x0004)
	float                                              m_fHealthDamageFXPainFactor;                              // 0x0890(0x0004)
	float                                              m_fHealthDamageFXAccumulationMix;                         // 0x0894(0x0004)
	float                                              m_fHealthDamageCritFXThreshold;                           // 0x0898(0x0004)
	float                                              m_fHealthDamageCritFXAccumulationMix;                     // 0x089C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPlayerCamera");
		return ptr;
	}


	void TakeHit(const struct FVector& Direction, float fDamageAmount, class UClass* DamageType, struct FExtraDamageInfo* ExtraInfo);
	bool CheckCrit(int ScreenLocation);
	float MixProperty(const struct FPropertyDecayState& PropState, const struct FPropertyDecayParams& PropParams);
	void STATIC_UpdateDecay(const struct FPropertyDecayParams& PropParams, float fPropertyCurrent, struct FPropertyDecayState* PropState);
	void PlayDamageCameraEffect(TEnumAsByte<EDamageEffectScreenLocation> ScreenLocation, float fDamageAmount, bool bCritical);
	class ATgEmitter_CameraEffect* STATIC_FindCameraEffect(class UClass* CameraEffectClass);
	void RemoveCameraEffect(class ATgEmitter_CameraEffect* CameraEffect);
	class ATgEmitter_CameraEffect* AddCameraEffect(class UParticleSystem* Template, int nSourceFxId, TArray<struct FFx_Sound> SoundList, TEnumAsByte<ECameraEffectVisiblity> EffectVisibility, class ATgPawn* OwningPawn);
	bool STATIC_IsBlockedByExistingEffects(class ATgEmitter_CameraEffect* CameraEffect);
	void STATIC_RemoveConflictingEffects(class ATgEmitter_CameraEffect* CameraEffect);
	void PlayWeather(class UParticleSystem* Template, class ATgWeatherVolume* SourceVolume);
	void PlayRevealed(bool bEnabled);
	void PlayGrass(bool bEnabled, class UParticleSystem* Template);
	void PlayHidden(bool bEnabled, class UParticleSystem* Template);
	void PlayTeleportFx();
	void PlayPreTeleportFX();
	void PlayMark(bool bEnabled);
	void PlayDaze(bool bEnabled);
	void PlayStun(bool bEnabled);
	void PlaySlow(bool bEnabled);
	void PlayRoot(bool bEnabled);
	void PlayCrippled(bool bEnabled);
	void PlayVenom(bool bEnabled);
	void PlayPoisoned(bool bEnabled);
	void PlayKnockback(bool bEnabled);
	void PlayHeal(float fHealAmount);
	void Tick(float DeltaSeconds);
	void PlayCCImmuneEffects(bool bEnabled);
	void PlayFreeze(bool bEnabled);
	void PlayOnFire(bool bEnabled);
	void PlayBleed(bool bEnabled);
	void PlayLowHealth(bool bEnabled);
	void FillCameraCache(struct FTPOV* NewPOV);
	void STATIC_UpdateCameraLocalToTarget();
	void GetViewLocalToTarget(class AActor* InViewTarget, struct FVector* LocalViewLocation, struct FQuat* LocalViewRotation);
	void UpdateCamera(float DeltaTime);
	void STATIC_ZoomOut();
	void STATIC_ZoomIn();
	void ProcessInput(class UPlayerInput* PlayerInput, float DeltaTime);
	void STATIC_EndLastCameraTween();
	void STATIC_UpdateViewTarget(float DeltaTime, struct FTViewTarget* OutVT);
	class UTgCameraModule* CreateCamera(class UClass* CameraClass);
	class UTgCameraModule* SwitchCameras(class UClass* CameraClass, float fTweenTime);
	void STATIC_SetFOV(float NewFOV);
	void STATIC_ResetFOV();
	void InitializeFor(class APlayerController* PC);
	void PostBeginPlay();
	float STATIC_LambdaFromHalflife(float fHalflife);
	void CheckViewTarget(struct FTViewTarget* VT);
	void ClearPenetrationList();
	void CheckPenetration(const struct FVector& CheckLocation, float CheckRadius);
	void CameraTrace(const struct FVector& End, const struct FVector& Start, class AActor* Target, struct FVector* HitLocation, struct FVector* HitNormal);
};


// Class TgGame.TgSpectatorCamera
// 0x0030 (0x08D0 - 0x08A0)
class ATgSpectatorCamera : public ATgPlayerCamera
{
public:
	struct FViewTargetTransitionParams                 m_DefaultBlendParams;                                     // 0x08A0(0x0010)
	struct FViewTargetTransitionParams                 m_SnapBlendParams;                                        // 0x08B0(0x0010)
	class UCameraAnim*                                 m_CinematicAnim;                                          // 0x08C0(0x0008)
	class UCameraAnimInst*                             m_AnimInstance;                                           // 0x08C8(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSpectatorCamera");
		return ptr;
	}


	void STATIC_EndCinematicAnim();
	void StartCinematicAnim();
	void DoUpdateCamera(float DeltaTime);
};


// Class TgGame.TgPlayOfTheGameCamera
// 0x0068 (0x0488 - 0x0420)
class ATgPlayOfTheGameCamera : public ACameraActor
{
public:
	class ATgSkeletalMeshActor_Loader*                 m_ViewTarget;                                             // 0x0420(0x0008) (Edit)
	unsigned long                                      m_bActive : 1;                                            // 0x0428(0x0004) (Transient)
	float                                              m_fRemainingTweenTime;                                    // 0x042C(0x0004)
	float                                              m_fTotalTweenTime;                                        // 0x0430(0x0004)
	struct FTPOV                                       m_TweenSourcePOV;                                         // 0x0434(0x0024) (Transient)
	struct FVector                                     m_vRelativeLocation;                                      // 0x0458(0x000C)
	struct FVector                                     m_vRelativeRotation;                                      // 0x0464(0x000C)
	struct FVector                                     m_vRelativeLocationOffset;                                // 0x0470(0x000C) (Edit)
	struct FVector                                     m_vRelativeRotationOffset;                                // 0x047C(0x000C) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPlayOfTheGameCamera");
		return ptr;
	}


	void ApplyPostProcessOverrides();
	void GetCameraView(float DeltaTime, bool bOnlyFOV, struct FTPOV* OutPOV);
	void StartTween(float TweenTime);
	void STATIC_UpdateTransform();
	void STATIC_SetActive(bool bActive);
};


// Class TgGame.TgBlockingVolume
// 0x0000 (0x02C0 - 0x02C0)
class ATgBlockingVolume : public ABlockingVolume
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBlockingVolume");
		return ptr;
	}

};


// Class TgGame.TgBossBlockDynamicVolume
// 0x0000 (0x02C4 - 0x02C4)
class ATgBossBlockDynamicVolume : public ADynamicBlockingVolume
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBossBlockDynamicVolume");
		return ptr;
	}

};


// Class TgGame.TgBossBlockVolume
// 0x0000 (0x02C0 - 0x02C0)
class ATgBossBlockVolume : public ABlockingVolume
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBossBlockVolume");
		return ptr;
	}

};


// Class TgGame.TgBotEncounterVolume
// 0x0014 (0x02D0 - 0x02BC)
class ATgBotEncounterVolume : public AVolume
{
public:
	TArray<class ATgBotFactory*>                       m_Factories;                                              // 0x02BC(0x0010) (Edit, Const, NeedCtorLink)
	int                                                m_nPlayers;                                               // 0x02CC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBotEncounterVolume");
		return ptr;
	}


	void CheckTouching();
	void PostBeginPlay();
};


// Class TgGame.TgCameraVolume
// 0x0008 (0x02C4 - 0x02BC)
class ATgCameraVolume : public AVolume
{
public:
	class ACameraActor*                                AssociatedCamera;                                         // 0x02BC(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraVolume");
		return ptr;
	}

};


// Class TgGame.TgDeviceVolume
// 0x0025 (0x02E1 - 0x02BC)
class ATgDeviceVolume : public AVolume
{
public:
	unsigned long                                      bPainCausing : 1;                                         // 0x02BC(0x0004) (Edit)
	unsigned long                                      BACKUP_bPainCausing : 1;                                  // 0x02BC(0x0004)
	unsigned long                                      s_bDeviceActive : 1;                                      // 0x02BC(0x0004)
	class AInfo*                                       PainTimer;                                                // 0x02C0(0x0008)
	class AController*                                 DamageInstigator;                                         // 0x02C8(0x0008)
	int                                                m_nMapObjectId;                                           // 0x02D0(0x0004) (Edit, EditConst)
	int                                                s_nDeviceId;                                              // 0x02D4(0x0004) (Edit)
	class UTgDeviceFire*                               s_DeviceFireMode;                                         // 0x02D8(0x0008)
	unsigned char                                      s_nTaskForce;                                             // 0x02E0(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceVolume");
		return ptr;
	}


	int GetSupportedTaskforce();
	void OnSetTaskforce(class UTgSeqAct_SetTaskforce* Action);
	void ApplyHit(class AActor* Target);
	void STATIC_OnSetDamageInstigator(class USeqAct_SetDamageInstigator* Action);
	bool CanCausePainTo(class AActor* Other);
	void CausePainTo(class AActor* Other);
	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_TimerPop(class ATgDeviceVolumeInfo* T);
	void STATIC_OnToggle(class USeqAct_Toggle* inAction);
	void Reset();
	void PostBeginPlay();
	bool SetupDevice();
};


// Class TgGame.TgDeviceVolume_Pulse
// 0x001D (0x02D9 - 0x02BC)
class ATgDeviceVolume_Pulse : public AVolume
{
public:
	class AController*                                 DamageInstigator;                                         // 0x02BC(0x0008)
	int                                                m_nMapObjectId;                                           // 0x02C4(0x0004) (Edit, EditConst)
	int                                                s_nDeviceId;                                              // 0x02C8(0x0004) (Edit)
	class UTgDeviceFire*                               m_FireMode;                                               // 0x02CC(0x0008)
	int                                                s_nTeamNumber;                                            // 0x02D4(0x0004)
	unsigned char                                      s_nTaskForce;                                             // 0x02D8(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceVolume_Pulse");
		return ptr;
	}


	struct FImpactInfo CalcDeviceFire(const struct FVector& StartTrace, const struct FVector& EndTrace, TArray<struct FImpactInfo>* ImpactList);
	void STATIC_FindTouchingActorsFromScript();
	void Fire();
	void STATIC_TurnOff();
	void STATIC_TurnOn();
	void STATIC_OnToggle(class USeqAct_Toggle* inAction);
	void STATIC_OnSetDamageInstigator(class USeqAct_SetDamageInstigator* Action);
	void PostBeginPlay();
	bool SetupDevice();
};


// Class TgGame.TgEndOfWorldVolume
// 0x0000 (0x02C0 - 0x02C0)
class ATgEndOfWorldVolume : public ABlockingVolume
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEndOfWorldVolume");
		return ptr;
	}

};


// Class TgGame.TgHeightFog
// 0x0008 (0x0288 - 0x0280)
class ATgHeightFog : public AInfo
{
public:
	class UHeightFogComponent*                         FogComponent;                                             // 0x0280(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgHeightFog");
		return ptr;
	}

};


// Class TgGame.TgHelpAlertVolume
// 0x0014 (0x02D0 - 0x02BC)
class ATgHelpAlertVolume : public AVolume
{
public:
	int                                                TaskForceNumber;                                          // 0x02BC(0x0004) (Edit)
	TArray<int>                                        GameTipIdList;                                            // 0x02C0(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgHelpAlertVolume");
		return ptr;
	}


	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void RemoveGameTips(class ATgPlayerController* aPC);
	void AddGameTips(class ATgPlayerController* aPC);
};


// Class TgGame.TgIndoorVolume
// 0x0000 (0x02BC - 0x02BC)
class ATgIndoorVolume : public AVolume
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgIndoorVolume");
		return ptr;
	}


	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgItemShopVolume
// 0x0004 (0x02C0 - 0x02BC)
class ATgItemShopVolume : public AVolume
{
public:
	int                                                TaskforceIndex;                                           // 0x02BC(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgItemShopVolume");
		return ptr;
	}


	void SetPurchaseFlag(class AActor* Other, bool bCanPurchase);
	int GetSupportedTaskforce();
	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgMapBoundsVolume
// 0x0008 (0x02C4 - 0x02BC)
class ATgMapBoundsVolume : public AVolume
{
public:
	class UTexture2D*                                  MinimapImage;                                             // 0x02BC(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMapBoundsVolume");
		return ptr;
	}


	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgMapCalloutVolume
// 0x0010 (0x02CC - 0x02BC)
class ATgMapCalloutVolume : public AVolume
{
public:
	struct FString                                     m_sMsg;                                                   // 0x02BC(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMapCalloutVolume");
		return ptr;
	}


	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgMissionListVolume
// 0x0014 (0x02D0 - 0x02BC)
class ATgMissionListVolume : public AVolume
{
public:
	int                                                m_nMapObjectId;                                           // 0x02BC(0x0004) (Edit, EditConst)
	int                                                s_nQueueTableId;                                          // 0x02C0(0x0004) (Edit)
	int                                                s_nQueueTableMsgId;                                       // 0x02C4(0x0004) (Edit)
	class ATeleporter*                                 m_Teleporter;                                             // 0x02C8(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMissionListVolume");
		return ptr;
	}

};


// Class TgGame.TgModifyPawnPropertiesVolume
// 0x0020 (0x02DC - 0x02BC)
class ATgModifyPawnPropertiesVolume : public AVolume
{
public:
	int                                                m_nMapObjectId;                                           // 0x02BC(0x0004) (Edit, EditConst)
	unsigned long                                      m_bDisableJump : 1;                                       // 0x02C0(0x0004) (Edit)
	unsigned long                                      m_bDisableBlockActors : 1;                                // 0x02C0(0x0004) (Edit)
	unsigned long                                      m_bDisableHanging : 1;                                    // 0x02C0(0x0004) (Edit)
	unsigned long                                      m_bDisableAllDevices : 1;                                 // 0x02C0(0x0004) (Edit)
	unsigned long                                      m_bTriggerUseEvent : 1;                                   // 0x02C0(0x0004) (Edit)
	unsigned long                                      m_bOneWayMovement : 1;                                    // 0x02C0(0x0004) (Edit)
	struct FRotator                                    m_vOnewWay;                                               // 0x02C4(0x000C)
	class UArrowComponent*                             m_DirArrow;                                               // 0x02D0(0x0008) (ExportObject, Component, EditInline)
	int                                                s_nLootTableId;                                           // 0x02D8(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgModifyPawnPropertiesVolume");
		return ptr;
	}


	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void PostBeginPlay();
	void STATIC_Used(class AActor* Other);
	void STATIC_LoadObjectConfig();
};


// Class TgGame.TgObjectiveVolume
// 0x0000 (0x02BC - 0x02BC)
class ATgObjectiveVolume : public AVolume
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgObjectiveVolume");
		return ptr;
	}


	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void ClearCurrentObjective();
	void SetCurrentObjective(class AActor* Other);
	bool STATIC_IsObjective(class AActor* Other);
};


// Class TgGame.TgPlayerBlockingVolume
// 0x0000 (0x02C0 - 0x02C0)
class ATgPlayerBlockingVolume : public ABlockingVolume
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPlayerBlockingVolume");
		return ptr;
	}

};


// Class TgGame.TgPlayerCountVolume
// 0x0020 (0x02DC - 0x02BC)
class ATgPlayerCountVolume : public AVolume
{
public:
	int                                                PlayerCountTarget;                                        // 0x02BC(0x0004) (Edit)
	int                                                TaskForceNumber;                                          // 0x02C0(0x0004) (Edit)
	int                                                MessageId;                                                // 0x02C4(0x0004) (Edit)
	TArray<class APawn*>                               Players;                                                  // 0x02C8(0x0010) (NeedCtorLink)
	unsigned long                                      Enabled : 1;                                              // 0x02D8(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPlayerCountVolume");
		return ptr;
	}


	int GetCount();
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void Update(class ATgPawn* Other);
};


// Class TgGame.TgPortal
// 0x001C (0x0300 - 0x02E4)
class ATgPortal : public APortal
{
public:
	unsigned long                                      bUpdateRotation : 1;                                      // 0x02E4(0x0004) (Edit)
	unsigned long                                      bCheckOverlap : 1;                                        // 0x02E4(0x0004) (Edit)
	unsigned long                                      bResetVelocity : 1;                                       // 0x02E4(0x0004) (Edit)
	unsigned long                                      bCheckTaskForce : 1;                                      // 0x02E4(0x0004) (Edit)
	int                                                nTaskForce;                                               // 0x02E8(0x0004) (Edit)
	class USoundCue*                                   TeleportSoundCue;                                         // 0x02EC(0x0008) (Edit)
	float                                              FadeInTime;                                               // 0x02F4(0x0004) (Edit)
	float                                              VolumeMultiplier;                                         // 0x02F8(0x0004) (Edit)
	float                                              PitchMultiplier;                                          // 0x02FC(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPortal");
		return ptr;
	}


	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgPostProcessVolume
// 0x0024 (0x0470 - 0x044C)
class ATgPostProcessVolume : public APostProcessVolume
{
public:
	class UMaterialInterface*                          m_Material;                                               // 0x044C(0x0008) (Edit)
	TEnumAsByte<ESceneDepthPriorityGroup>              m_SceneDPG;                                               // 0x0454(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0455(0x0003) MISSED OFFSET
	class UMaterialInstanceConstant*                   m_MaterialMIC;                                            // 0x0458(0x0008)
	float                                              m_FadeInTime;                                             // 0x0460(0x0004) (Edit)
	float                                              m_FadeOutTime;                                            // 0x0464(0x0004) (Edit)
	struct FName                                       m_FadeScalarParameterName;                                // 0x0468(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPostProcessVolume");
		return ptr;
	}


	void PostBeginPlay();
};


// Class TgGame.TgSpawnGate
// 0x001C (0x02E0 - 0x02C4)
class ATgSpawnGate : public ADynamicBlockingVolume
{
public:
	TEnumAsByte<ESpawnGateType>                        m_eSpawnGateType;                                         // 0x02C4(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x02C5(0x0003) MISSED OFFSET
	class AEmitter*                                    m_StandardEmitter;                                        // 0x02C8(0x0008) (Edit)
	class ATgEmitter_TeamColor*                        m_TeamColoredEmitter;                                     // 0x02D0(0x0008) (Edit)
	unsigned long                                      m_bStartActive : 1;                                       // 0x02D8(0x0004) (Edit)
	unsigned long                                      m_bGateOpen : 1;                                          // 0x02D8(0x0004)
	unsigned long                                      m_bCollisionActive : 1;                                   // 0x02D8(0x0004)
	int                                                m_nCurrentTaskforce;                                      // 0x02DC(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSpawnGate");
		return ptr;
	}


	void ToggleTeamColors();
	void Deactivate();
	void STATIC_Activate();
	void PostBeginPlay();
	int STATIC_GetCurrentTaskforce();
};


// Class TgGame.TgSpawnTeleporterEntrance
// 0x0004 (0x02C0 - 0x02BC)
class ATgSpawnTeleporterEntrance : public AVolume
{
public:
	unsigned long                                      bEnabled : 1;                                             // 0x02BC(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSpawnTeleporterEntrance");
		return ptr;
	}


	void STATIC_OnToggle(class USeqAct_Toggle* Action);
	void Touch(class AActor* WantsTeleport, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void TeleportToExit(class ATgPawn* TgP, class ATgSpawnTeleporterEntrance* From, const struct FExitInfo& To);
	struct FExitInfo STATIC_FindExit(class ATgPawn* TgP, TArray<class ATgSpawnTeleporterExit*>* Exits);
	bool CanTeleport(class AActor* Other);
	int CompareExitInfo(const struct FExitInfo& EI1, const struct FExitInfo& EI2);
};


// Class TgGame.TgTeleportPlayerVolume
// 0x000C (0x02C8 - 0x02BC)
class ATgTeleportPlayerVolume : public AVolume
{
public:
	TEnumAsByte<ETgTeleportVolumeType>                 TeleportLocation;                                         // 0x02BC(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x02BD(0x0003) MISSED OFFSET
	int                                                nMessageId;                                               // 0x02C0(0x0004) (Edit)
	unsigned long                                      bTeleportBots : 1;                                        // 0x02C4(0x0004) (Edit)
	unsigned long                                      bTeleportPlayers : 1;                                     // 0x02C4(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgTeleportPlayerVolume");
		return ptr;
	}


	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgVisibilityVolume
// 0x0010 (0x02CC - 0x02BC)
class ATgVisibilityVolume : public AVolume
{
public:
	class UParticleSystem*                             m_PlayerCameraParticleSystem;                             // 0x02BC(0x0008) (Edit)
	class UParticleSystem*                             m_PlayerCameraInvisibleParticleSystem;                    // 0x02C4(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgVisibilityVolume");
		return ptr;
	}


	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgAudioConversations
// 0x0020 (0x0080 - 0x0060)
class UTgAudioConversations : public UObject
{
public:
	TArray<struct FVoxConversation>                    m_Conversations;                                          // 0x0060(0x0010) (Config, NeedCtorLink)
	unsigned long                                      m_bInitialized : 1;                                       // 0x0070(0x0004)
	unsigned long                                      m_bTF1Conversed : 1;                                      // 0x0070(0x0004)
	unsigned long                                      m_bTF2Conversed : 1;                                      // 0x0070(0x0004)
	class ATgRepInfo_Game*                             m_GRI;                                                    // 0x0074(0x0008)
	int                                                m_nConversationAttemptsRemaining;                         // 0x007C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAudioConversations");
		return ptr;
	}

};


// Class TgGame.TgCapturePoint
// 0x0090 (0x0310 - 0x0280)
class ATgCapturePoint : public AActor
{
public:
	class ATgCollisionProxy_Cylinder*                  s_CollisionProxy;                                         // 0x0280(0x0008)
	class ATgRepInfo_CapturePoint*                     r_RepInfo;                                                // 0x0288(0x0008) (Net)
	float                                              m_fCollisionProxyRadius;                                  // 0x0290(0x0004) (Edit, Const)
	float                                              m_fCollisionProxyHeight;                                  // 0x0294(0x0004) (Edit, Const)
	float                                              m_fBaseTransitionSpeed;                                   // 0x0298(0x0004) (Const)
	float                                              m_fTransitionSpeedBuff;                                   // 0x029C(0x0004) (Const)
	float                                              m_fCurrentTransitionSpeed;                                // 0x02A0(0x0004) (Transient)
	class UTgSeqEvent_ControlPointOwnershipChange*     c_OwnershipChangedKismetNode;                             // 0x02A4(0x0008) (Transient)
	class ATgBotFactory_PointCapture*                  s_BotSpawners[0x2];                                       // 0x02AC(0x0008) (Edit)
	class ATgBotFactory_PointCapture*                  m_CurrentBotSpawners[0x2];                                // 0x02BC(0x0008) (Transient)
	class ATgBotFactory_PointCapture*                  s_NeutralBotSpawner;                                      // 0x02CC(0x0008) (Edit)
	int                                                m_CapturePointIndex;                                      // 0x02D4(0x0004) (Edit, Const)
	float                                              s_fReplenishBotTime;                                      // 0x02D8(0x0004) (Edit, Const)
	float                                              s_fRemainingReplenishBotTime;                             // 0x02DC(0x0004) (Transient)
	float                                              s_fFriendlyReplenishBuffPct;                              // 0x02E0(0x0004)
	float                                              m_fRegenUpdateTimer;                                      // 0x02E4(0x0004)
	float                                              m_fOwnedManaRegen;                                        // 0x02E8(0x0004) (Const)
	float                                              m_fOwnedHealthRegen;                                      // 0x02EC(0x0004) (Const)
	class ATgGame_Mission*                             s_GameInfo;                                               // 0x02F0(0x0008) (Transient)
	int                                                m_nTF1Count;                                              // 0x02F8(0x0004) (Transient)
	int                                                m_nTF2Count;                                              // 0x02FC(0x0004) (Transient)
	float                                              m_fLastEnemyKillVoxTimestamp;                             // 0x0300(0x0004) (Transient)
	int                                                m_nLaneNumber;                                            // 0x0304(0x0004) (Edit)
	class USpriteComponent*                            m_WorldIconSprite;                                        // 0x0308(0x0008) (Edit, ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCapturePoint");
		return ptr;
	}


	void OnGetTaskForceNumber(class UTgSeqAct_GetTaskForceNumber* Action);
	void STATIC_UpdateLockEffects();
	void STATIC_OnToggle(class USeqAct_Toggle* Action);
	void OnNearbyEnemyPlayerDied(class ATgPawn* DeadPawn);
	void Destroyed();
	void OnTaskForceControlChanged(int NewTaskForce);
	int GetCapturePointIndex();
	void SpawnBotsForCurrentTaskForce();
	void OnBotDied(int DeadBotTaskForce);
	void OnPointReclaimed();
	void OnPointCaptureOwnershipChanged(int NewTaskForceOwner, int PreviousTaskForceOwner);
	void NearbyPawnsUpdated();
	void CollisionProxyOnUnTouch(class AActor* Other);
	void CollisionProxyOnTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void PostBeginPlay();
	void PreBeginPlay();
	void SpawnNeutralBot();
	void TakeDamage(int Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void AlertPointChanged();
};


// Class TgGame.TgGame
// 0x0148 (0x0624 - 0x04DC)
class ATgGame : public AFrameworkGame
{
public:
	class UClass*                                      m_ContentPackageReference;                                // 0x04DC(0x0008)
	TEnumAsByte<EGAME_WIN_STATE>                       m_GameWinState;                                           // 0x04E4(0x0001)
	TEnumAsByte<ETG_GAME_TYPE>                         m_GameType;                                               // 0x04E5(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x04E6(0x0002) MISSED OFFSET
	float                                              m_fSpawnProtectionTime;                                   // 0x04E8(0x0004)
	float                                              m_fMaxRepawnTime;                                         // 0x04EC(0x0004)
	float                                              m_fUnpauseCountdownRemaining;                             // 0x04F0(0x0004)
	int                                                s_nBotPlayerCount;                                        // 0x04F4(0x0004)
	unsigned long                                      s_bSpawnOfflinePawns : 1;                                 // 0x04F8(0x0004)
	unsigned long                                      s_bGameInitialized : 1;                                   // 0x04F8(0x0004)
	unsigned long                                      s_bEACMatchStartSent : 1;                                 // 0x04F8(0x0004)
	unsigned long                                      s_bGameEndMissionProcessed : 1;                           // 0x04F8(0x0004)
	unsigned long                                      s_bMissionSealed : 1;                                     // 0x04F8(0x0004)
	unsigned long                                      m_bForceUsePRISpawnPoint : 1;                             // 0x04F8(0x0004) (Const)
	unsigned long                                      m_bRewardCalculated : 1;                                  // 0x04F8(0x0004)
	unsigned long                                      m_bStatsCanTie : 1;                                       // 0x04F8(0x0004)
	unsigned long                                      m_bStatsIsSymmetric : 1;                                  // 0x04F8(0x0004)
	unsigned long                                      m_bIsTutorialGametype : 1;                                // 0x04F8(0x0004)
	unsigned long                                      m_bIsPracticeGametype : 1;                                // 0x04F8(0x0004)
	unsigned long                                      m_bEnableHeadShots : 1;                                   // 0x04F8(0x0004) (Config, GlobalConfig)
	unsigned long                                      m_bPlayOfTheGameLocked : 1;                               // 0x04F8(0x0004)
	unsigned long                                      m_bPlayOfTheGameDisabled : 1;                             // 0x04F8(0x0004)
	unsigned long                                      m_bSpawnDisconnectedPlayersStunned : 1;                   // 0x04F8(0x0004)
	unsigned long                                      m_bPlayersCanOnlyDieOnce : 1;                             // 0x04F8(0x0004)
	unsigned long                                      m_bUseKillEmotes : 1;                                     // 0x04F8(0x0004)
	unsigned long                                      m_bNotifyKillCombos : 1;                                  // 0x04F8(0x0004)
	unsigned long                                      m_bFirstBloodAwarded : 1;                                 // 0x04F8(0x0004)
	int                                                m_nNumTaskForces;                                         // 0x04FC(0x0004)
	int                                                s_nNextActorInstanceId;                                   // 0x0500(0x0004)
	int                                                s_nNextProjectileInstanceId;                              // 0x0504(0x0004)
	TArray<class ATgAIVolume*>                         s_AIVolumes;                                              // 0x0508(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<int>                                        s_Taskforce1AIVolumesIndices;                             // 0x0518(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<int>                                        s_Taskforce2AIVolumesIndices;                             // 0x0528(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<class ATgFortressVolume*>                   s_FortressVolumes;                                        // 0x0538(0x0010) (AlwaysInit, NeedCtorLink)
	unsigned char                                      UnknownData01[0x48];                                      // 0x0548(0x0048) UNKNOWN PROPERTY: MapProperty TgGame.TgGame.s_AIAnnotations
	TArray<class ATgDeviceVolume*>                     s_DeviceVolumes;                                          // 0x0590(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<class ATgActorFactory*>                     s_ActorFactories;                                         // 0x05A0(0x0010) (NeedCtorLink)
	float                                              s_fXPModifier;                                            // 0x05B0(0x0004)
	int                                                m_nTaskforce1Kills;                                       // 0x05B4(0x0004)
	int                                                m_nTaskforce2Kills;                                       // 0x05B8(0x0004)
	float                                              m_fGlobalCooldownTime;                                    // 0x05BC(0x0004) (Const, Config)
	TArray<int>                                        m_ClientLogins;                                           // 0x05C0(0x0010) (AlwaysInit, NeedCtorLink)
	float                                              m_fOcclusionCalcPeriod;                                   // 0x05D0(0x0004) (Config)
	float                                              m_fOcclusionMaxDeviation;                                 // 0x05D4(0x0004) (Config)
	float                                              m_fReadyPercent;                                          // 0x05D8(0x0004) (Config)
	struct FPlayOfTheGameInfo                          m_PlayOfTheGame;                                          // 0x05DC(0x000C)
	float                                              m_fPlayOfTheGameLength;                                   // 0x05E8(0x0004)
	float                                              m_fPlayOfTheGameIntroBufferLength;                        // 0x05EC(0x0004)
	float                                              m_fPlayOfTheGameOuttroBufferLength;                       // 0x05F0(0x0004)
	TArray<struct FPlayOfTheGameEventConfig>           m_PlayOfTheGameEventConfigs;                              // 0x05F4(0x0010) (NeedCtorLink)
	TArray<class ATgSpawnTeleporterExit*>              m_PlayerSpawnExits;                                       // 0x0604(0x0010) (NeedCtorLink)
	TArray<class UPlayer*>                             m_ReadyPlayers;                                           // 0x0614(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame");
		return ptr;
	}


	void OnPawnDied(class ATgPawn* Victim, class AController* Killer, class UClass* dmgType);
	void AddPotGEventToAllPlayers(TEnumAsByte<EPlayOfTheGameEventType> potgEvent);
	int STATIC_GetTaskForceForPlayer(class AController* Player);
	class APlayerStart* STATIC_FindBestPlayerStart(class AController* Player, TArray<class APlayerStart*>* PlayerStartPoints);
	class APlayerStart* STATIC_FindPlayerStartForCapturePoint(class ATgChaosCapturePoint* CapPoint, class AController* Player, bool bUseAttackingForwardSpawn);
	bool STATIC_FindValidSpawnPoints(class ATgPawn* TgP, TArray<class ATgSpawnTeleporterExit*>* ValidExits);
	int STATIC_GetCurrentLane();
	int STATIC_GetGameSpawnPhase(class ATgPawn* TgP);
	void SetEnableHeadshots(bool bEnable);
	void KickIdler(class APlayerController* PC);
	void ClearPauseAfterCountdown();
	void ClearPause();
	bool SetPause(class APlayerController* PC, const struct FScriptDelegate& CanUnpauseDelegate);
	bool STATIC_PreventDeath(class APawn* KilledPawn, class AController* Killer, class UClass* DamageType, const struct FVector& HitLocation);
	bool CanSpectate(class APlayerController* Viewer, class APlayerReplicationInfo* ViewTarget);
	void PostCommitMapChange();
	void PostLogin(class APlayerController* NewPlayer);
	bool FindInactivePRI(class APlayerController* PC);
	void STATIC_AddInactivePRI(class APlayerReplicationInfo* PRI, class APlayerController* PC);
	void STATIC_StartMatch();
	void STATIC_NativeEACStartMatch();
	void STATIC_GotoGameRunningState();
	bool STATIC_ShouldSpawnAtStartSpot(class AController* Player);
	bool ChangeTeam(class AController* Other, int Num, bool bNewTeam);
	float STATIC_RatePlayerStart(class APlayerStart* P, unsigned char Team, class AController* Player);
	float RatePlayerStartPoint(class APlayerStart* P, class AController* Player);
	class ANavigationPoint* STATIC_FindPlayerGroupStart(class AController* Player, int groupNumber, unsigned char InTeam, const struct FString& IncomingName);
	class ANavigationPoint* FindPlayerStart(class AController* Player, unsigned char InTeam, const struct FString& IncomingName);
	class ANavigationPoint* GetReviveLocation(class AController* Player, struct FVector* OutLocation, struct FRotator* OutRotation);
	class ANavigationPoint* FindPlayerStartPoint(class AController* Player, const struct FString& SpawnTagName);
	void STATIC_SetPlayerDefaults(class APawn* PlayerPawn);
	void AddDefaultInventory(class APawn* PlayerPawn);
	void STATIC_RestartPlayer(class AController* aPlayer);
	void AllPlayersEndGame(class AActor* EndGameFocus);
	void PlayerEndGame(class AActor* EndGameFocus, class AController* C);
	class APawn* STATIC_SpawnDefaultPawnFor(class AController* NewPlayer, class ANavigationPoint* StartSpot);
	void STATIC_StartBots();
	void InitGame(const struct FString& Options, struct FString* ErrorMessage);
	void Reset();
	int GetNextProjectileInstanceId();
	int GetNextActorInstanceId();
	void InitGameReplicationInfo();
	void PostBeginPlay();
	void PreBeginPlay();
	class ATgPawn* SpawnBotByName(const struct FString& BotName, int Taskforce, int nCount, const struct FVector& vLocation, const struct FRotator& rRotation, int BotDifficulty, const struct FString& BehaviorTreeName, int nSkinId, int nWeaponId);
	bool STATIC_IsFlankKill(struct FScoreKillData* Data);
	bool STATIC_GetScoreKillData(class AController* Killer, class AController* Other, bool bFakeDeath, struct FScoreKillData* Data);
	void ScoreKillAchievements(struct FScoreKillData* Data);
	void ScoreKillGameType(struct FScoreKillData* Data);
	void ScoreKillCommon(struct FScoreKillData* Data);
	void STATIC_ScoreKill(class AController* Killer, class AController* Other, bool bFakeDeath);
	void MarkAsReady(class UPlayer* P);
	void STATIC_InitPlayOfTheGameConfig();
	void STATIC_LockPlayOfTheGame(bool bLocked);
	void ResetPlayOfTheGame();
	void CachePlayOfTheGame();
	float STATIC_GetWeightedPlayOfTheGameEventRating(class ATgRepInfo_Player* PRI, int nIndex);
	bool ConsiderForBestPlayOfTheGame(class ATgRepInfo_Player* PRI);
	bool CanSpoolUlt();
	bool CanSpoolCredits();
	void SendPauseNotification(class APlayerController* PC);
	void STATIC_EndUnpauseCountdown();
	void BeginUnpauseCountdown(float fSeconds);
	bool STATIC_AllowPausing(class APlayerController* PC);
	void ResetStats();
	void NotifyPostCommitMapChange();
	struct FString STATIC_GetGameVersion();
	float GetRespawnTime(int TaskForceNum);
	float STATIC_GetActualRespawnTime(class ATgPawn* pTgPawn, int TaskForceNum);
	void BotDied(class ATgAIController* aic);
	void PlayerDied(class ATgPlayerController* PC);
	bool SpawnDefaultBotPlayers(bool bStartPaused, TArray<struct FTgAIBotPlayersToSpawn>* BotPlayersToSpawn);
	bool SwapToNewAIController(class AController* C, class ATgPawn_Character* TgPawn);
	void STATIC_EnsureDevicePrecache(int nDeviceId, int nDeviceSkinId);
	void STATIC_EnsureBotPrecache(int nBotId, int nSkinId, int nDeviceSkinId);
	class ATgPawn* SpawnTemplatePlayer(class ATgPlayerController* pTgPC, int nProfileId, int nSkinId, int nWeaponSkinId);
	class ATgPawn* SpawnBotPawn(class ATgAIController* pTgAI, const struct FVector& vLocation, const struct FRotator& rRotation, bool bIgnoreCollision, class ATgPawn* pOwnerPawn, float fDeploySecs);
	class ATgPawn* SpawnBotById(int nBotId, int nSkinId, int nWeaponSkinId, const struct FVector& vLocation, const struct FRotator& rRotation, class ATgBotFactory* pFactory, bool bIgnoreCollision, class ATgPawn* pOwnerPawn, class UTgDeviceFire* deviceFire, float fDeployAnimLength, const struct FName& ControllerClassName, const struct FName& BehaviorTreeName);
	bool STATIC_FinishEndMission();
	bool BeginEndMission(bool bClearNextMapGame, class AActor* EndMissionFocus, float fDelayOverride);
	int STATIC_GetTaskForceCount();
	int STATIC_GetWinningTaskforce();
	void STATIC_ApplyCharacterBasedGameProperties(class ATgPawn* Pawn, class ATgInventoryManager* tgInvManager, int nTaskForce);
	class ATgPawn* SpawnPlayerCharacter(class AController* C, const struct FVector& vLocation);
	void STATIC_InitGameRepInfo();
	void STATIC_LoadGameConfig();
};


// Class TgGame.TgCharacterPerformance
// 0x00A4 (0x06C8 - 0x0624)
class ATgCharacterPerformance : public ATgGame
{
public:
	class UPComPerformanceCaptureBase*                 BasePerformanceCapture;                                   // 0x0624(0x0008) (Transient)
	TEnumAsByte<EPComPerformanceCaptureState>          CurrentCaptureState;                                      // 0x062C(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x062D(0x0003) MISSED OFFSET
	struct FString                                     CharacterInput;                                           // 0x0630(0x0010) (NeedCtorLink)
	struct FString                                     SetInput;                                                 // 0x0640(0x0010) (NeedCtorLink)
	int                                                CurrentCharacterIndex;                                    // 0x0650(0x0004)
	int                                                CurrentSkinIndex;                                         // 0x0654(0x0004)
	TArray<class ATgSkeletalMeshActor_Loader*>         CharacterPlacements;                                      // 0x0658(0x0010) (Transient, NeedCtorLink)
	TArray<struct FString>                             CharactersToTest;                                         // 0x0668(0x0010) (Transient, NeedCtorLink)
	TArray<int>                                        AllSkinIDs;                                               // 0x0678(0x0010) (NeedCtorLink)
	TArray<struct FDeviceToCharacterID>                DeviceToCharacterIDPairs;                                 // 0x0688(0x0010) (NeedCtorLink)
	TArray<struct FPComPerformanceCaptureStatsPerSkin> StatsPerSkin;                                             // 0x0698(0x0010) (NeedCtorLink)
	TArray<class ATgPawn*>                             CharacterPawns;                                           // 0x06A8(0x0010) (NeedCtorLink)
	class UTgManifestGroup*                            ManifestGroup;                                            // 0x06B8(0x0008) (ExportObject, NeedCtorLink, EditInline)
	struct FPointer                                    CharacterPerformanceUtility;                              // 0x06C0(0x0008) (Native)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCharacterPerformance");
		return ptr;
	}


	void STATIC_EnsureDevicePrecache(int nDeviceId, int nDeviceSkinId);
	void STATIC_EnsureBotPrecache(int nBotId, int nSkinId, int nDeviceSkinId);
	void PrintAllSkins();
	void DoNextAction();
	class ATgPawn* SpawnBotByIdForPerformance(int nBotId, int nSkinId, int nWeaponSkinId, const struct FVector& vLocation, const struct FRotator& rRotation);
	void SpawnCharacters();
	void MoveCameraToNode();
	void CollectCharacterPlacementsAndSkins();
	void PostBeginPlay();
};


// Class TgGame.TgGame_Mission
// 0x0120 (0x0744 - 0x0624)
class ATgGame_Mission : public ATgGame
{
public:
	unsigned long                                      m_bSpawnInTaskForceArea : 1;                              // 0x0624(0x0004)
	unsigned long                                      s_bPreGuardianPhasePulsed : 1;                            // 0x0624(0x0004)
	unsigned long                                      s_bGuardianPhasePulsed : 1;                               // 0x0624(0x0004)
	unsigned long                                      s_bWasSurrendered : 1;                                    // 0x0624(0x0004)
	unsigned long                                      m_bSurrenderAvailable : 1;                                // 0x0624(0x0004)
	unsigned long                                      m_bAllowAutoUpgrades : 1;                                 // 0x0624(0x0004)
	unsigned long                                      m_bUsePlayerCharacterIntros : 1;                          // 0x0624(0x0004)
	TEnumAsByte<EGameTimerState>                       m_eTimerState;                                            // 0x0628(0x0001)
	TEnumAsByte<EGameTimerState>                       m_eTimerStatePaused;                                      // 0x0629(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x062A(0x0002) MISSED OFFSET
	float                                              m_fMissionTime;                                           // 0x062C(0x0004)
	float                                              m_fSecondaryMissionTime;                                  // 0x0630(0x0004)
	float                                              m_fWaitingForPlayersTime;                                 // 0x0634(0x0004) (Const)
	float                                              m_fSetupTime;                                             // 0x0638(0x0004) (Config)
	float                                              m_fPausedAtTime;                                          // 0x063C(0x0004)
	float                                              m_fGameMissionTime;                                       // 0x0640(0x0004)
	float                                              s_MissionTimeAccumulator;                                 // 0x0644(0x0004)
	TArray<class UPlayer*>                             s_ReadyPlayers;                                           // 0x0648(0x0010) (NeedCtorLink)
	int                                                s_nReadyMercs;                                            // 0x0658(0x0004)
	float                                              m_fTickCreditsFreq;                                       // 0x065C(0x0004) (Config)
	float                                              m_fCreditsToGivePerTick;                                  // 0x0660(0x0004) (Config)
	int                                                m_nStartingCurrency;                                      // 0x0664(0x0004)
	int                                                m_nStartingLevel;                                         // 0x0668(0x0004)
	int                                                m_nWinBonusXp;                                            // 0x066C(0x0004)
	int                                                m_nWinPlayerXp;                                           // 0x0670(0x0004)
	int                                                m_nLosePlayerXp;                                          // 0x0674(0x0004)
	float                                              m_fGodXpCoefficient;                                      // 0x0678(0x0004)
	float                                              m_fGodXpCoefficientLoss;                                  // 0x067C(0x0004)
	float                                              m_fGodXpWinBonus;                                         // 0x0680(0x0004)
	float                                              m_fFreeVIPWinPoints;                                      // 0x0684(0x0004) (Config)
	float                                              m_fFreeVIPLossPoints;                                     // 0x0688(0x0004) (Config)
	float                                              m_fFreeVIPPerMinute;                                      // 0x068C(0x0004) (Config)
	float                                              m_fPaidVIPWinPoints;                                      // 0x0690(0x0004) (Config)
	float                                              m_fPaidVIPLossPoints;                                     // 0x0694(0x0004) (Config)
	float                                              m_fPaidVIPPerMinute;                                      // 0x0698(0x0004) (Config)
	float                                              m_fBattlePassWinBonus;                                    // 0x069C(0x0004) (Config)
	float                                              m_fBaseTokens;                                            // 0x06A0(0x0004)
	int                                                m_nKillTokens;                                            // 0x06A4(0x0004)
	int                                                m_nWinBonusTokens;                                        // 0x06A8(0x0004)
	class UClass*                                      m_MinimapManagerClass;                                    // 0x06AC(0x0008)
	struct FSurrenderData                              s_SurrenderData[0x2];                                     // 0x06B4(0x0024) (NeedCtorLink)
	float                                              m_fSurrenderTime;                                         // 0x06FC(0x0004)
	int                                                m_XPRadius;                                               // 0x0700(0x0004)
	float                                              m_MinionKillerBonus;                                      // 0x0704(0x0004)
	float                                              m_BasePlayerGoldReward;                                   // 0x0708(0x0004)
	float                                              m_fFirstBloodGoldReward;                                  // 0x070C(0x0004)
	float                                              m_fBasePlayerAssistGoldRewardMultipler;                   // 0x0710(0x0004)
	float                                              m_fBasePlayerAssistXpRewardMultipler;                     // 0x0714(0x0004)
	float                                              m_fBaseNPCAssistGoldRewardMultipler;                      // 0x0718(0x0004)
	float                                              m_fBaseNPCAssistXpRewardMultipler;                        // 0x071C(0x0004)
	TArray<class ATgMinionGoal*>                       m_MinionGoals;                                            // 0x0720(0x0010) (Transient, NeedCtorLink)
	int                                                m_nLastTimeDilationWindowId;                              // 0x0730(0x0004)
	TArray<struct FTimeDilationWindow>                 m_ActiveTimeDilationWindows;                              // 0x0734(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Mission");
		return ptr;
	}


	TEnumAsByte<EGameTimerState> GetMissionTimerStatus();
	float STATIC_GetPlayerWaitTime();
	float STATIC_GetSetupTime();
	void SendSecondaryMissionTimerNotify(TEnumAsByte<EMissionTimerState> eState, float fRemainingSecs);
	void SendMissionTimerNotify(TEnumAsByte<EMissionTimerState> eState, float fRemainingSecs);
	void MissionTimeIncrement(float fInc);
	void MissionTimerModify(bool bPause, int nNewTime);
	float ElapsedTime();
	bool MissionTimerActive();
	void ChangeTimerState(TEnumAsByte<EGameTimerState> eTimerState);
	void AllPlayersReady();
	void MissionTimer();
	void MissionTimerPause();
	void MissionTimerStop();
	void MissionTimerStart();
	void SetSecondaryMissionTime(float fTime);
	void SetMissionTime(float fTime);
	void STATIC_KeepClientsInSync();
	bool StartGameTimer();
	void TgTimer(struct FString* sTimerCommand);
	void QuickEndGame(int nWinnerTF);
	bool CheckScore(class APlayerReplicationInfo* Scorer);
	void STATIC_UpdateLockedPointStatus();
	void OnPointCaptureOwnershipChanged(class ATgCapturePoint* Point, int NewTaskForceOwner, int PreviousTaskForceOwner);
	void STATIC_AddObjectiveScore(class APlayerReplicationInfo* Scorer, int Score);
	void STATIC_StartMatch();
	void PostLogin(class APlayerController* NewPlayer);
	void CreateMinimapManagers(class UClass* managerClass);
	void PostBeginPlay();
	void NativeUpdateTimerState();
	void STATIC_HandleDisconnectedPawn(class ATgPawn_Character* PC);
	bool STATIC_RemoveTimeDilationWindow(int nWindowId);
	int STATIC_RequestTimeDilation(float fTimeDilation, float fDuration, float fRampUp, float fRampDown);
	float STATIC_GetMinIntroWait();
	void CapturePointReclaimed(class ATgPawn_Character* PC);
	void CapturedPoint(class ATgPawn_Character* PC);
	void STATIC_EndGameBySurrender(int SurrenderingTaskForce);
	void SurrenderComplete(int nTaskForce);
	void SurrenderCompleteTimer2();
	void SurrenderCompleteTimer1();
	void PlayerSurrender(int nPlayerId, bool bSurrender);
	void AllPlayersRecall();
	void AllPlayersFullVitals();
	void AllPlayersRevive();
	void MarkAsReady(class UPlayer* P);
	float MissionTimeElapsed();
	float MissionTimeRemaining();
	void STATIC_UpdateMissionTimerEventWinVar();
	void SendMissionTimerEvent(int nEventId);
	class ATgPawn* SpawnPlayerCharacter(class AController* C, const struct FVector& vLocation);
	void SpoolCredits();
	void STATIC_LoadGameConfig();
	bool BeginEndMission(bool bClearNextMapGame, class AActor* EndMissionFocus, float fDelayOverride);
};


// Class TgGame.TgGame_Battle
// 0x0028 (0x076C - 0x0744)
class ATgGame_Battle : public ATgGame_Mission
{
public:
	float                                              m_MultiLaneXpBonus;                                       // 0x0744(0x0004)
	unsigned long                                      m_bRespawnInhibitors : 1;                                 // 0x0748(0x0004)
	unsigned long                                      m_bEnableCrowdEvents : 1;                                 // 0x0748(0x0004)
	unsigned long                                      m_bRestrictStoreInteractions : 1;                         // 0x0748(0x0004)
	unsigned long                                      m_bWinGameOnNexusDestroyed : 1;                           // 0x0748(0x0004)
	int                                                m_nBumbasMaskId;                                          // 0x074C(0x0004)
	int                                                m_nSupportStarterId;                                      // 0x0750(0x0004)
	TArray<struct FTgAIBotPlayersToSpawn>              m_MercsToSpawn;                                           // 0x0754(0x0010) (NeedCtorLink)
	int                                                m_nPIESpawnTable;                                         // 0x0764(0x0004)
	int                                                m_nTargetPlayerCountForMercs;                             // 0x0768(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Battle");
		return ptr;
	}


	void SendLanePusherUpdateAlert(bool isAlive, int tf);
	void SpawnBots();
	int GetPlayerCount();
	void CreateMinimapManagers(class UClass* managerClass);
	void ChangeTimerState(TEnumAsByte<EGameTimerState> eTimerState);
	bool StartGameTimer();
	void TriggerBonusMinions(class ATgRepInfo_TaskForce* tf, int nLane);
	void OnBossMonsterKilled(class ATgPawn* BossMonster, class ATgPawn* KillerPawn);
	void NexusWasDestroyed(class ATgPawn* nexus);
	int CalcWeakestLane(class ATgRepInfo_TaskForce* tf);
	void SendLanePusherSpawnAlert(int Taskforce);
	void ScoreKillGameType(struct FScoreKillData* Data);
	void STATIC_ForceLoadMercenaries(int SpawnTableID);
	void CheckMercenaries();
	bool ShouldSpawnSuperMinions(class ATgBotFactory_Minions* minionFactory);
	void SetInhibitorRespawn(bool bRespawn);
	void CheckTeamAce(class AController* Killer, class AController* Killed);
	int STATIC_GetNextVulnerableTowerId(int nBotId);
	void ApplyTowerImmunity();
	float GetRespawnTime(int TaskForceNum);
	void BotDied(class ATgAIController* aic);
	void PlayerDied(class ATgPlayerController* PC);
	void StructureDied(class ATgPawn_Structure* theStructure);
	void SendGameStartAlert();
	void SendBonusMinionAlerts(class ATgRepInfo_TaskForce* tf, int nLane);
	void STATIC_UpdateGameWinState(class ATgPawn* nexus);
};


// Class TgGame.TgGame_Arena
// 0x002C (0x0798 - 0x076C)
class ATgGame_Arena : public ATgGame_Battle
{
public:
	float                                              s_fLastDespawnTime[0x2];                                  // 0x076C(0x0004)
	float                                              s_fDespawnNotificationDelay;                              // 0x0774(0x0004)
	int                                                m_nKillValueHero;                                         // 0x0778(0x0004)
	int                                                m_nKillValueMinion;                                       // 0x077C(0x0004)
	int                                                m_nKillValueTower;                                        // 0x0780(0x0004)
	int                                                m_MinScoreToTrackMinionKills;                             // 0x0784(0x0004)
	int                                                m_nSpawnWaveTime;                                         // 0x0788(0x0004)
	int                                                m_nSpawnWaveDominatingTime;                               // 0x078C(0x0004)
	int                                                m_nMaxDominatingPoints;                                   // 0x0790(0x0004)
	unsigned long                                      m_bIsCrowdOnFeet : 1;                                     // 0x0794(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Arena");
		return ptr;
	}


	float STATIC_GetTaskForceDominatingFactor(int TaskForceNum);
	void SpawnWaveTeam2Timer();
	void SpawnWaveTeam1Timer();
	class AActor* GetEndFocusActor();
	void CheckGameState();
	void OnMinionDespawn(int Taskforce);
	bool StartGameTimer();
	float STATIC_GetSetupTime();
	void SendDespawnAlert(class ATgRepInfo_TaskForce* tfri);
	void ApplyTowerImmunity();
	bool BeginEndMission(bool bClearNextMapGame, class AActor* EndMissionFocus, float fDelayOverride);
	void STATIC_EndGameBySurrender(int SurrenderingTaskForce);
	float GetRespawnTime(int TaskForceNum);
	void MarkAsReady(class UPlayer* P);
	void ScoreKillGameType(struct FScoreKillData* Data);
};


// Class TgGame.TgGame_Arena_Capture
// 0x0018 (0x07B0 - 0x0798)
class ATgGame_Arena_Capture : public ATgGame_Arena
{
public:
	int                                                s_nCaptureHostilePointXP;                                 // 0x0798(0x0004)
	int                                                s_nCaptureHostilePointGold;                               // 0x079C(0x0004)
	int                                                s_nReclaimPointXP;                                        // 0x07A0(0x0004)
	int                                                s_nReclaimPointGold;                                      // 0x07A4(0x0004)
	int                                                m_nCurrentActiveCapturePointIndex;                        // 0x07A8(0x0004)
	float                                              m_fNewPointTime;                                          // 0x07AC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Arena_Capture");
		return ptr;
	}


	void STATIC_UpdateLockedPointStatus();
	void OnPointCaptureOwnershipChanged(class ATgCapturePoint* Point, int NewTaskForceOwner, int PreviousTaskForceOwner);
	void SpawnNeutralBots();
	void CapturePointReclaimed(class ATgPawn_Character* PC);
	void CapturedPoint(class ATgPawn_Character* PC);
	void ChangeTimerState(TEnumAsByte<EGameTimerState> eTimerState);
	void PostBeginPlay();
};


// Class TgGame.TgGame_Arena_Escort
// 0x0028 (0x07C0 - 0x0798)
class ATgGame_Arena_Escort : public ATgGame_Arena
{
public:
	int                                                m_nSpawnEscortTime;                                       // 0x0798(0x0004)
	int                                                m_nEscortSuccessValue;                                    // 0x079C(0x0004)
	class UTgSeqEvent_SpawnWise*                       s_pEvt[0x2];                                              // 0x07A0(0x0008)
	class UTgSeqEvent_Escort_Despawn_Success*          s_pDespawnEvt[0x2];                                       // 0x07B0(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Arena_Escort");
		return ptr;
	}


	void OnEscortDespawn(int Taskforce);
	void SendEscortSpawnAlert(class ATgRepInfo_TaskForce* tfri);
};


// Class TgGame.TgGame_Arena_Escort_Practice
// 0x0000 (0x07C0 - 0x07C0)
class ATgGame_Arena_Escort_Practice : public ATgGame_Arena_Escort
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Arena_Escort_Practice");
		return ptr;
	}


	void SpawnBots();
	void ChangeTimerState(TEnumAsByte<EGameTimerState> eTimerState);
};


// Class TgGame.TgGame_Arena_Practice
// 0x0000 (0x0798 - 0x0798)
class ATgGame_Arena_Practice : public ATgGame_Arena
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Arena_Practice");
		return ptr;
	}


	void SpawnBots();
	void ChangeTimerState(TEnumAsByte<EGameTimerState> eTimerState);
};


// Class TgGame.TgGame_Battle_Casual
// 0x0000 (0x076C - 0x076C)
class ATgGame_Battle_Casual : public ATgGame_Battle
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Battle_Casual");
		return ptr;
	}


	void StructureDied(class ATgPawn_Structure* theStructure);
	bool ShouldSpawnSuperMinions(class ATgBotFactory_Minions* minionFactory);
	float GetRespawnTime(int TaskForceNum);
};


// Class TgGame.TgGame_Battle_Conquest
// 0x0000 (0x076C - 0x076C)
class ATgGame_Battle_Conquest : public ATgGame_Battle
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Battle_Conquest");
		return ptr;
	}

};


// Class TgGame.TgGame_Battle_Aram
// 0x0000 (0x076C - 0x076C)
class ATgGame_Battle_Aram : public ATgGame_Battle_Conquest
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Battle_Aram");
		return ptr;
	}


	float GetRespawnTime(int TaskForceNum);
};


// Class TgGame.TgGame_Battle_Aram_Practice
// 0x0000 (0x076C - 0x076C)
class ATgGame_Battle_Aram_Practice : public ATgGame_Battle_Aram
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Battle_Aram_Practice");
		return ptr;
	}


	void ChangeTimerState(TEnumAsByte<EGameTimerState> eTimerState);
};


// Class TgGame.TgGame_Battle_Conquest_Erez
// 0x0004 (0x0770 - 0x076C)
class ATgGame_Battle_Conquest_Erez : public ATgGame_Battle_Conquest
{
public:
	int                                                m_nSpawnSiegeWeaponThreshold;                             // 0x076C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Battle_Conquest_Erez");
		return ptr;
	}


	void TriggerLanePusher(class ATgRepInfo_TaskForce* tf, int nLane);
	void PostBeginPlay();
	float GetRespawnTime(int TaskForceNum);
	void ScoreKillGameType(struct FScoreKillData* Data);
	int STATIC_GetNextVulnerableTowerId(int nBotId);
};


// Class TgGame.TgGame_Battle_Conquest_Practice
// 0x0000 (0x076C - 0x076C)
class ATgGame_Battle_Conquest_Practice : public ATgGame_Battle_Conquest
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Battle_Conquest_Practice");
		return ptr;
	}


	void ChangeTimerState(TEnumAsByte<EGameTimerState> eTimerState);
};


// Class TgGame.TgGame_Battle_Conquest_Tc
// 0x0000 (0x076C - 0x076C)
class ATgGame_Battle_Conquest_Tc : public ATgGame_Battle_Conquest
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Battle_Conquest_Tc");
		return ptr;
	}


	float GetRespawnTime(int TaskForceNum);
};


// Class TgGame.TgGame_Battle_Expert
// 0x0000 (0x076C - 0x076C)
class ATgGame_Battle_Expert : public ATgGame_Battle
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Battle_Expert");
		return ptr;
	}


	void TriggerBonusMinions(class ATgRepInfo_TaskForce* tf, int nLane);
};


// Class TgGame.TgGame_Battle_Joust
// 0x0000 (0x076C - 0x076C)
class ATgGame_Battle_Joust : public ATgGame_Battle
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Battle_Joust");
		return ptr;
	}


	float STATIC_GetSetupTime();
	void AutoForfeit();
	void CheckTeamAce(class AController* Killer, class AController* Killed);
	void MarkAsReady(class UPlayer* P);
	float GetRespawnTime(int TaskForceNum);
	int STATIC_GetNextVulnerableTowerId(int nBotId);
};


// Class TgGame.TgGame_Battle_Joust_3v3
// 0x0000 (0x076C - 0x076C)
class ATgGame_Battle_Joust_3v3 : public ATgGame_Battle
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Battle_Joust_3v3");
		return ptr;
	}


	int STATIC_GetNextVulnerableTowerId(int nBotId);
};


// Class TgGame.TgGame_Battle_Practice
// 0x0000 (0x076C - 0x076C)
class ATgGame_Battle_Practice : public ATgGame_Battle
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Battle_Practice");
		return ptr;
	}


	void ChangeTimerState(TEnumAsByte<EGameTimerState> eTimerState);
	float STATIC_GetSetupTime();
	void CheckTeamAce(class AController* Killer, class AController* Killed);
	void MarkAsReady(class UPlayer* P);
	float GetRespawnTime(int TaskForceNum);
	int STATIC_GetNextVulnerableTowerId(int nBotId);
};


// Class TgGame.TgGame_Battle_Training
// 0x0034 (0x07A0 - 0x076C)
class ATgGame_Battle_Training : public ATgGame_Battle_Practice
{
public:
	unsigned long                                      m_bNewTutorial : 1;                                       // 0x076C(0x0004)
	TArray<int>                                        m_StartingItems;                                          // 0x0770(0x0010) (NeedCtorLink)
	int                                                m_StartingSkills[0x4];                                    // 0x0780(0x0004)
	TArray<int>                                        m_RecommendedItems;                                       // 0x0790(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Battle_Training");
		return ptr;
	}


	void SpawnBots();
	float STATIC_GetSetupTime();
	class ATgPawn* SpawnPlayerCharacter(class AController* C, const struct FVector& vLocation);
	float GetRespawnTime(int TaskForceNum);
};


// Class TgGame.TgGame_Paladins
// 0x0100 (0x086C - 0x076C)
class ATgGame_Paladins : public ATgGame_Battle
{
public:
	class UTgGamePhase*                                m_masterPhase;                                            // 0x076C(0x0008)
	class UTgGamePhase*                                m_CurrentPhase;                                           // 0x0774(0x0008)
	class UTgGamePhase*                                m_lastCreatedPhase;                                       // 0x077C(0x0008)
	class UTgGamePhase*                                m_lastDecoratedPhase;                                     // 0x0784(0x0008)
	unsigned long                                      m_bDeferEndingGame : 1;                                   // 0x078C(0x0004)
	unsigned long                                      m_bDisableMusicEvents : 1;                                // 0x078C(0x0004)
	unsigned long                                      m_bScoringEnabled : 1;                                    // 0x078C(0x0004)
	unsigned long                                      m_bSuppressItemMenu : 1;                                  // 0x078C(0x0004)
	unsigned long                                      m_bUsesItemStoreV2 : 1;                                   // 0x078C(0x0004)
	unsigned long                                      m_bCanPurchaseMasterRiding : 1;                           // 0x078C(0x0004)
	unsigned long                                      m_bCanPurchaseItemsAnywhere : 1;                          // 0x078C(0x0004) (Config)
	unsigned long                                      m_bCanPurchaseItemsWhileDead : 1;                         // 0x078C(0x0004) (Config)
	unsigned long                                      m_bLimitBurnCardsToOnePerCategory : 1;                    // 0x078C(0x0004) (Config)
	unsigned long                                      m_bCanSpoolCredits : 1;                                   // 0x078C(0x0004)
	unsigned long                                      m_bAutoMountOnRespawn : 1;                                // 0x078C(0x0004)
	unsigned long                                      m_bDropHealthNuggetOnDeath : 1;                           // 0x078C(0x0004) (Config)
	unsigned long                                      m_bRespawnBots : 1;                                       // 0x078C(0x0004)
	unsigned long                                      m_bDisableKillcam : 1;                                    // 0x078C(0x0004) (Config)
	unsigned long                                      m_bCanApplyCardEquipStats : 1;                            // 0x078C(0x0004) (Config)
	unsigned long                                      m_bLoadoutSelectionEnabled : 1;                           // 0x078C(0x0004) (Config)
	unsigned long                                      m_bTalentsEnabled : 1;                                    // 0x078C(0x0004) (Config)
	unsigned long                                      m_bAutoMountAtRoundBegin : 1;                             // 0x078C(0x0004)
	unsigned long                                      m_bResetPlayersNotInSpawnRoom : 1;                        // 0x078C(0x0004) (Config)
	unsigned long                                      m_bDeckSwappingAlwaysEnabled : 1;                         // 0x078C(0x0004) (Config)
	unsigned long                                      m_bDiminishingReturnsOnCCEnabled : 1;                     // 0x078C(0x0004)
	unsigned long                                      m_bSpawnAbyssalEchoes : 1;                                // 0x078C(0x0004)
	unsigned long                                      m_bHasCompositionData : 1;                                // 0x078C(0x0004)
	unsigned long                                      m_bAllPlayersConnected : 1;                               // 0x078C(0x0004)
	float                                              m_fGameDuration;                                          // 0x0790(0x0004) (Config)
	class ATgChaosCapturePoint*                        m_currentCapturePointForPhases;                           // 0x0794(0x0008)
	int                                                m_nGoalScore;                                             // 0x079C(0x0004) (Config)
	int                                                m_nTF1Score;                                              // 0x07A0(0x0004) (Transient)
	int                                                m_nTF2Score;                                              // 0x07A4(0x0004) (Transient)
	int                                                m_nWinningScore;                                          // 0x07A8(0x0004) (Transient, Config)
	int                                                m_nForceLoadoutCardLevels;                                // 0x07AC(0x0004)
	TEnumAsByte<EHUDType>                              m_eHUDType;                                               // 0x07B0(0x0001)
	TEnumAsByte<ENotifySound>                          m_eMusicEvent;                                            // 0x07B1(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x07B2(0x0002) MISSED OFFSET
	int                                                m_nCreditSpoolActive;                                     // 0x07B4(0x0004)
	int                                                m_nCanSpoolUlt;                                           // 0x07B8(0x0004)
	int                                                m_nAIDisabled;                                            // 0x07BC(0x0004)
	int                                                m_nAimAssistDisabled;                                     // 0x07C0(0x0004)
	float                                              m_fPlayerWaitTime;                                        // 0x07C4(0x0004) (Const)
	int                                                m_nHealthNuggetDeployableId;                              // 0x07C8(0x0004)
	int                                                m_nHealthNuggetTeamOnlyDeployableId;                      // 0x07CC(0x0004)
	int                                                m_fHealthNuggetPersistTime;                               // 0x07D0(0x0004)
	float                                              m_fPlayerViewDistance;                                    // 0x07D4(0x0004) (Config)
	float                                              m_fVisibilityVolumeViewDistance;                          // 0x07D8(0x0004) (Config)
	float                                              m_fCardCooldownIncrease;                                  // 0x07DC(0x0004)
	float                                              m_fCardCooldownMultiplier;                                // 0x07E0(0x0004) (Config)
	float                                              m_fGameTypeReminderTime;                                  // 0x07E4(0x0004) (Config)
	float                                              m_fRespawnBeaconLifeSpan;                                 // 0x07E8(0x0004) (Config)
	float                                              m_fBaseRespawnTime;                                       // 0x07EC(0x0004) (Config)
	float                                              m_fMapLaneChangeDelay;                                    // 0x07F0(0x0004) (Const)
	int                                                m_nStartingCredits;                                       // 0x07F4(0x0004) (Config)
	int                                                m_nMaxCredits;                                            // 0x07F8(0x0004) (Config)
	struct FString                                     m_GameplayEventsWriterClassName;                          // 0x07FC(0x0010) (Config, NeedCtorLink)
	class UGameplayEventsWriter*                       GameplayEventsWriter;                                     // 0x080C(0x0008)
	struct FTeamDifficultyData                         DifficultyData[0x2];                                      // 0x0814(0x0008)
	class ATgAIDirector*                               AIDirector;                                               // 0x0824(0x0008)
	int                                                m_nEventTalentVendorId;                                   // 0x082C(0x0004)
	int                                                m_nEventDeckVendorId;                                     // 0x0830(0x0004)
	float                                              m_fFlankerSoloKillRewardDistance;                         // 0x0834(0x0004) (Config)
	float                                              m_fDamageRoleMultiplier;                                  // 0x0838(0x0004) (Config)
	float                                              m_fFlankRoleMultiplier;                                   // 0x083C(0x0004) (Config)
	float                                              m_fFrontLineRoleMultiplier;                               // 0x0840(0x0004) (Config)
	float                                              m_fSupportRoleMultiplier;                                 // 0x0844(0x0004) (Config)
	int                                                m_nNextUniquePlayerID;                                    // 0x0848(0x0004)
	class UTgAudioConversations*                       m_SpawnChatter;                                           // 0x084C(0x0008)
	class UTgAbyssalEchoes*                            m_AbyssalEchoes;                                          // 0x0854(0x0008)
	TArray<struct Fdword>                              m_dwConnectedPlayers;                                     // 0x085C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Paladins");
		return ptr;
	}


	bool STATIC_HasCaptureObjectives();
	void STATIC_UpdateOccupationStatus(class ATgChaosCapturePoint* CapturePoint, int nNumTF1, int nNumTF2);
	void PlayLanePusherHelpText();
	void AutoMountAllPlayers();
	void AutoMountPlayersOnTaskForce(int nTaskForceNum, bool bInvertTaskForce);
	void STATIC_EndTheGame();
	void NotifyClientsOfTF2ScoreChange(int nScore);
	void NotifyClientsOfTF1ScoreChange(int nScore);
	void TaskforceWin(int nTaskForce, TEnumAsByte<EVictoryType> VictoryType, bool bForce);
	void STATIC_GiveVictoryToTaskforceWithMostPoints(bool bForceVictory);
	void STATIC_GiveVictoryToTaskforceWithMostTickets(bool bForceVictory);
	void STATIC_EnterSuddenDeath();
	void STATIC_GainPoints(int nTaskForce, int numPoints, TEnumAsByte<EVictoryType> VictoryType);
	bool SetTaskforceScore(class ATgRepInfo_TaskForce* Taskforce, int nScore, int* nStoredScore);
	void SetScore(int nTaskForce, int nScore);
	int STATIC_GetScore(int nTaskForce);
	void CheckGameState();
	float STATIC_GetPlayerWaitTime();
	void STATIC_UpdateAllPawnsMetaGameState(TEnumAsByte<EMetaGameState> NewState);
	void STATIC_UpdateTgPawnMetaGameState(class ATgPawn* CurPawn, TEnumAsByte<EMetaGameState> NewState);
	void OnKillConfirmed(class ATgRepInfo_Player* PRI, class ATgRepInfo_TaskForce* Taskforce, int bonusScore);
	void OnPlayerDamaged(class ATgPawn* TargetPawn, class ATgPawn* InstigatorPawn);
	void STATIC_OnPawnRespawned(class ATgPawn* RespawningPawn);
	void OnPawnDied(class ATgPawn* Victim, class AController* Killer, class UClass* dmgType);
	void Killed(class AController* Killer, class AController* KilledPlayer, class APawn* KilledPawn, class UClass* DamageType);
	void SendClientsRequestHelpText(int GameTipId);
	void ShowGameTypeHelpTip();
	int STATIC_GetGameTypeHelpTipIndex(class ATgPlayerController* TgPC);
	void ResetPermanentEffectsForAllPlayers();
	void ResetUltForAllPlayers();
	void ResetKillstreaksForAllPlayers();
	void ResetCreditsForAllPlayers();
	void TakeCredits(const TScriptInterface<class UTgPaladinsController>& TgPC, int nCreditsAmount);
	void GiveCredits(const TScriptInterface<class UTgPaladinsController>& TgPC, int nCreditsAmount);
	void SetCredits(const TScriptInterface<class UTgPaladinsController>& TgPC, int nCreditsAmount);
	void STATIC_InitializeCreditsFor(const TScriptInterface<class UTgPaladinsController>& TgPC);
	void STATIC_RestartPlayer(class AController* aPlayer);
	void LanePusherReachedBaseObjective(class ATgPawn_LanePusher* Lanepusher);
	void LanePusherReachedInnerWall(class ATgPawn_LanePusher* Lanepusher);
	void LanePusherReachedOuterWall(class ATgPawn_LanePusher* Lanepusher);
	void STATIC_KillAllProjectiles();
	void RespawnAllPlayers(bool bResetLivingPlayers, bool bResetDeadPlayers, bool bResetHealth, bool bResetDevices);
	struct FVector STATIC_GetCenterOfPlayerGravity(bool bIncludeDeadPlayers);
	float ModifyRespawnTime(float fRespawnTime);
	void STATIC_GlobalRespawnTimeUpdateHelper(class AController* C, class ATgPawn* TgP, float fRespawnTime, bool bEnsureRespawnTimeDoesntIncrease);
	void STATIC_GlobalRespawnTimeUpdate(float fRespawnTime, bool bEnsureRespawnTimeDoesntIncrease);
	void STATIC_EnableAI();
	void STATIC_DisableAI();
	void STATIC_EnableAimAssist();
	void STATIC_DisableAimAssist();
	void STATIC_EnableUltSpooling();
	void STATIC_DisableUltSpooling();
	void CloseSpawnGates();
	void OpenSpawnGates();
	void PlayPerTaskforceSound(TEnumAsByte<ENotifySound> eTF1SoundID, TEnumAsByte<ENotifySound> eTF2SoundID);
	void PlaySoundForAllPlayers(TEnumAsByte<ENotifySound> eSoundID);
	void PlayMusicForAllPlayers(TEnumAsByte<ENotifySound> eMusicID);
	int STATIC_GetNextUniquePlayerID();
	void ResetGame();
	void AllPlayersReady();
	void ChangeTimerState(TEnumAsByte<EGameTimerState> eTimerState);
	void STATIC_SetupStartMissionTime();
	void PostBeginPlay();
	struct FString GetPhaseValueText();
	void TickPhases(float DeltaSeconds);
	void STATIC_EndAllPhases();
	void STATIC_GoToNextPhase();
	void StartPhase(class UTgGamePhase* NextPhase);
	void StartFirstPhase();
	void STATIC_PushDecoratedPhase(TEnumAsByte<EGamePhase> phaseType, float fDuration, const struct FString& phaseName);
	void PopPhase();
	void PushPhase(TEnumAsByte<EGamePhase> phaseType, float fDuration, const struct FString& phaseName);
	void DecoratePhase(TEnumAsByte<EGamePhase> phaseType, float fDuration, const struct FString& phaseName);
	void AddPhase(TEnumAsByte<EGamePhase> phaseType, float fDuration, const struct FString& phaseName);
	class UTgGamePhase* ConstructGamePhase(TEnumAsByte<EGamePhase> phaseType, float fDuration, const struct FString& phaseName);
	void STATIC_InitMasterPhase();
	void PostPhaseSetup();
	void SetupPhases();
	void SetHUD(TEnumAsByte<EHUDType> eNewHUD);
	void PreBeginPlay();
	void FadeAllClients();
	void STATIC_ApplyGameProperties();
	void STATIC_EndGameStatsLogging();
	void BeginGameStatsLogging();
	bool STATIC_IsFlankKill(struct FScoreKillData* Data);
	float STATIC_GetRewardScale(class AActor* Rewardee, TEnumAsByte<ERewardValueType> RewardType, bool bFlankKill);
	void TriggerMapLaneChange();
	bool BeginEndMission(bool bClearNextMapGame, class AActor* EndMissionFocus, float fDelayOverride);
	void OnBeaconReset(int nTaskForce, class AController* Killer);
	void STATIC_HandleEchoAchievements(int nEchoId, bool bTF1DamagedEcho, bool bTF2DamagedEcho);
	void ScoreKillCommon(struct FScoreKillData* Data);
	bool STATIC_GetScoreKillData(class AController* Killer, class AController* Other, bool bFakeDeath, struct FScoreKillData* Data);
	void ScoreKillGameType(struct FScoreKillData* Data);
	float GetRespawnTime(int TaskForceNum);
	bool CanSpoolUlt();
	bool CanSpoolCredits();
};


// Class TgGame.TgGame_Paladins_Conquest
// 0x0020 (0x088C - 0x086C)
class ATgGame_Paladins_Conquest : public ATgGame_Paladins
{
public:
	float                                              m_fSetupDuration;                                         // 0x086C(0x0004) (Const, Config)
	float                                              m_fGatherDuration;                                        // 0x0870(0x0004) (Const, Config)
	float                                              m_fPushDuration;                                          // 0x0874(0x0004) (Const, Config)
	float                                              m_fCreditCacheGainDuration;                               // 0x0878(0x0004) (Const, Config)
	int                                                m_nLowCreditValue;                                        // 0x087C(0x0004) (Const, Config)
	int                                                m_nMediumCreditValue;                                     // 0x0880(0x0004) (Const, Config)
	int                                                m_nHighCreditValue;                                       // 0x0884(0x0004) (Const, Config)
	int                                                m_nRoundNumber;                                           // 0x0888(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Paladins_Conquest");
		return ptr;
	}


	void PreBeginPlay();
	void SetupPhases();
};


// Class TgGame.TgGame_Paladins_Flagball
// 0x0024 (0x0890 - 0x086C)
class ATgGame_Paladins_Flagball : public ATgGame_Paladins
{
public:
	float                                              m_fSetupDuration;                                         // 0x086C(0x0004) (Const, Config)
	float                                              m_fRoundResetDuration;                                    // 0x0870(0x0004) (Const, Config)
	class ATgFlagballSpawnPoint*                       m_SpawnPoint;                                             // 0x0874(0x0008)
	unsigned long                                      m_bFlagballActive : 1;                                    // 0x087C(0x0004)
	unsigned long                                      m_bPlayOfTheGameOnFinalScore : 1;                         // 0x087C(0x0004)
	unsigned long                                      m_bPlayedOneMinuteLeftSwitch : 1;                         // 0x087C(0x0004)
	unsigned long                                      m_bAnnouncerPlayBallPlayed : 1;                           // 0x087C(0x0004)
	unsigned long                                      m_bAnnouncerPlayedMatchPointTF1 : 1;                      // 0x087C(0x0004)
	unsigned long                                      m_bAnnouncerPlayedMatchPointTF2 : 1;                      // 0x087C(0x0004)
	int                                                m_nFlagballDeviceID;                                      // 0x0880(0x0004)
	TEnumAsByte<ETG_EQUIP_POINT>                       m_eFlagballEquipSlot;                                     // 0x0884(0x0001)
	TEnumAsByte<EFlagballLeadState>                    m_currentLeadState;                                       // 0x0885(0x0001)
	TEnumAsByte<EFlagballPossessionState>              m_currentPossessionState;                                 // 0x0886(0x0001)
	unsigned char                                      UnknownData00[0x1];                                       // 0x0887(0x0001) MISSED OFFSET
	float                                              m_fCleanUpFailSafeTimer;                                  // 0x0888(0x0004)
	float                                              m_fCleanUpFailSafeRate;                                   // 0x088C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Paladins_Flagball");
		return ptr;
	}


	void ScoreGoal(class ATgPawn_Character* CharacterInstigator);
	void AnnounceLeadChange();
	void OnMatchGoal();
	void DropBall();
	bool BallExistsInWorld();
	void OnPawnDied(class ATgPawn* Victim, class AController* Killer, class UClass* dmgType);
	void ConsiderRespawningFlagball();
	void OnFlagballExploded();
	void RemoveFlagballCarrierEffects(class ATgPawn_Character* Character);
	void OnPlayerDropFlagball(class ATgPawn_Character* Character);
	void OnPlayerFireFlagball(class ATgPawn_Character* Character);
	void ApplyFlagballCarrierEffects(class ATgPawn_Character* Character);
	void STATIC_EquipFlagball(class ATgPawn_Character* Character);
	class ATgPawn_Character* STATIC_GetBallCarrier();
	void SetBallExists(bool bExists);
	void OnPlayerPickupBall(class ATgPawn_Character* CharacterInstigator);
	void ClearHUDOverlay(class ATgRepInfo_Player* pPRI);
	void SetHUDOverlay(class ATgRepInfo_Player* pPRI);
	void SpawnFlagballAtCharacter(class ATgPawn_Character* CharacterInstigator);
	void ClearBallCarrier();
	void PlayAnnouncerMatchPoint();
	void PlayAnnouncerPlayBall();
	void SpawnFlagball();
	void DespawnFlagball();
	void SetFlagballActive(bool bActive);
	bool STATIC_IsFlagballActive();
	void ResetFlagballTimer();
	void StartResetFlagballTimer();
	void Tick(float DeltaSeconds);
	void SetupPhases();
	void PostBeginPlay();
	void STATIC_HandleDisconnectedPawn(class ATgPawn_Character* PC);
};


// Class TgGame.TgGame_Paladins_HeavenAndHell
// 0x0000 (0x086C - 0x086C)
class ATgGame_Paladins_HeavenAndHell : public ATgGame_Paladins
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Paladins_HeavenAndHell");
		return ptr;
	}


	void SetupPhases();
	void PostBeginPlay();
};


// Class TgGame.TgGame_Paladins_ShootingRange
// 0x0000 (0x086C - 0x086C)
class ATgGame_Paladins_ShootingRange : public ATgGame_Paladins
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Paladins_ShootingRange");
		return ptr;
	}


	void PostBeginPlay();
	void SetupPhases();
};


// Class TgGame.TgGame_Paladins_SiegeRedux
// 0x000C (0x0878 - 0x086C)
class ATgGame_Paladins_SiegeRedux : public ATgGame_Paladins
{
public:
	float                                              m_fInitialSetupDuration;                                  // 0x086C(0x0004) (Const, Config)
	float                                              m_fSetupDuration;                                         // 0x0870(0x0004) (Const, Config)
	float                                              m_fPushDuration;                                          // 0x0874(0x0004) (Const, Config)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Paladins_SiegeRedux");
		return ptr;
	}


	void SetupPhases();
};


// Class TgGame.TgGame_Paladins_TeamDeathMatch
// 0x0011 (0x087D - 0x086C)
class ATgGame_Paladins_TeamDeathMatch : public ATgGame_Paladins
{
public:
	class ATgGameInfo_TeamDeathMatch*                  m_GITDM;                                                  // 0x086C(0x0008)
	unsigned long                                      m_bSpawnInputLock : 1;                                    // 0x0874(0x0004)
	float                                              m_fSetupDuration;                                         // 0x0878(0x0004) (Config)
	TEnumAsByte<ETDMProgressState>                     m_eProgressState;                                         // 0x087C(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Paladins_TeamDeathMatch");
		return ptr;
	}


	void SetProgressState(TEnumAsByte<ETDMProgressState> eNewProgressState);
	void STATIC_GainPoints(int nTaskForce, int numPoints, TEnumAsByte<EVictoryType> VictoryType);
	void SetupPhases();
	void PostBeginPlay();
	void PreBeginPlay();
};


// Class TgGame.TgGame_PaladinsExtended
// 0x01B4 (0x0A20 - 0x086C)
class ATgGame_PaladinsExtended : public ATgGame_Paladins
{
public:
	float                                              m_fWinningTickets;                                        // 0x086C(0x0004) (Config)
	unsigned long                                      m_bTicketsPersist : 1;                                    // 0x0870(0x0004) (Config)
	unsigned long                                      m_bKillLanePusherOnWallDestroyed : 1;                     // 0x0870(0x0004) (Const, Config)
	unsigned long                                      m_bKeepThisPointForNextRound : 1;                         // 0x0870(0x0004)
	unsigned long                                      m_bConvergeCompletely : 1;                                // 0x0870(0x0004)
	unsigned long                                      m_bCanCaptureDuringSurvival : 1;                          // 0x0870(0x0004)
	unsigned long                                      m_bCanAutoPushForward : 1;                                // 0x0870(0x0004) (Const, Config)
	unsigned long                                      m_bConvergeCompletelyAfterDelay : 1;                      // 0x0870(0x0004)
	unsigned long                                      m_bOverrideSpawnTableID : 1;                              // 0x0870(0x0004)
	unsigned long                                      m_bActivateSpawnGatesAtStart : 1;                         // 0x0870(0x0004) (Config)
	unsigned long                                      m_bRevivePlayersWhenSiegeEngineDies : 1;                  // 0x0870(0x0004) (Config)
	unsigned long                                      m_bStasisTimerOn : 1;                                     // 0x0870(0x0004)
	unsigned long                                      m_bActivateAllCapturePoints : 1;                          // 0x0870(0x0004) (Config)
	unsigned long                                      m_bPointContested : 1;                                    // 0x0870(0x0004)
	unsigned long                                      m_bPointCaptureOvertimeTF1 : 1;                           // 0x0870(0x0004)
	unsigned long                                      m_bPointCaptureOvertimeTF2 : 1;                           // 0x0870(0x0004)
	unsigned long                                      m_bSimpleOvertime : 1;                                    // 0x0870(0x0004)
	unsigned long                                      m_bSimpleOvertimeEnabled : 1;                             // 0x0870(0x0004)
	unsigned long                                      m_bCapturePointContestDurationEnabled : 1;                // 0x0870(0x0004)
	unsigned long                                      m_bTF1Backsliding : 1;                                    // 0x0870(0x0004)
	unsigned long                                      m_bTF2Backsliding : 1;                                    // 0x0870(0x0004)
	unsigned long                                      m_bEndRoundWhenPointCaptured : 1;                         // 0x0870(0x0004)
	unsigned long                                      m_bSpawnLanePusherWhenPointCaptured : 1;                  // 0x0870(0x0004)
	unsigned long                                      m_bCaptureSpawnAlerts : 1;                                // 0x0870(0x0004)
	unsigned long                                      m_bResetPlayersNotInSpawnRoomDisabled : 1;                // 0x0870(0x0004)
	float                                              m_fTicketsForKill;                                        // 0x0874(0x0004) (Config)
	float                                              m_fTicketsPerCaptureTick;                                 // 0x0878(0x0004) (Config)
	float                                              m_fTicketsBonusPerMultiCapture;                           // 0x087C(0x0004) (Config)
	float                                              m_fTicketsPerPointCapture;                                // 0x0880(0x0004) (Config)
	float                                              m_fTF1Tickets;                                            // 0x0884(0x0004)
	float                                              m_fTF2Tickets;                                            // 0x0888(0x0004)
	float                                              m_fTicketsPerTicketDisparity;                             // 0x088C(0x0004) (Config)
	float                                              m_fSecondsPerTicketDisparity;                             // 0x0890(0x0004) (Config)
	float                                              m_fMaximumDisparitySeconds;                               // 0x0894(0x0004) (Config)
	float                                              m_fObjectiveRepickTickets;                                // 0x0898(0x0004) (Config)
	float                                              m_fLastObjectiveRepickTickets;                            // 0x089C(0x0004)
	float                                              m_fRoundLimitDuration;                                    // 0x08A0(0x0004) (Config)
	float                                              s_fRoundLimitElapsed;                                     // 0x08A4(0x0004)
	int                                                m_nPointsForReachingTicketMax;                            // 0x08A8(0x0004) (Config)
	int                                                m_nPointsForReachingRoundTimeLimit;                       // 0x08AC(0x0004) (Config)
	float                                              m_fSecondaryGoalScore;                                    // 0x08B0(0x0004) (Config)
	float                                              m_fSecondaryScoreAmount;                                  // 0x08B4(0x0004) (Const, Config)
	float                                              m_fObjectivePickTime;                                     // 0x08B8(0x0004) (Const, Config)
	float                                              m_fSetupObjectivePickTime;                                // 0x08BC(0x0004) (Const, Config)
	float                                              m_fSpawnGateOpenTime;                                     // 0x08C0(0x0004) (Const, Config)
	float                                              m_fAttackersSpawnGateOpenTime;                            // 0x08C4(0x0004) (Const, Config)
	float                                              m_fDefendersSpawnGateOpenTime;                            // 0x08C8(0x0004) (Const, Config)
	float                                              m_fSetupSpawnGateOpenTime;                                // 0x08CC(0x0004) (Const, Config)
	float                                              m_fObjectiveActivationTime;                               // 0x08D0(0x0004) (Const)
	int                                                m_SpawnTableIndex;                                        // 0x08D4(0x0004)
	class ATgChaosCapturePoint*                        m_CapturedPoint;                                          // 0x08D8(0x0008)
	class ATgChaosCapturePoint*                        m_LastActiveCapturePoint;                                 // 0x08E0(0x0008)
	TArray<class ATgChaosCapturePoint*>                m_CapturePointQueue;                                      // 0x08E8(0x0010) (NeedCtorLink)
	int                                                s_nCurrentCapturePointQueueIndex;                         // 0x08F8(0x0004)
	TArray<struct FCardInfo>                           m_CardVendor;                                             // 0x08FC(0x0010) (NeedCtorLink)
	int                                                m_nRegLanePusherHPScaling;                                // 0x090C(0x0004) (Const, Config)
	int                                                m_nRegLanePusherPowerScaling;                             // 0x0910(0x0004) (Const, Config)
	int                                                m_nGuardianHPScaling;                                     // 0x0914(0x0004) (Const, Config)
	int                                                m_nGuardianPowerScaling;                                  // 0x0918(0x0004) (Const, Config)
	int                                                m_nOuterGateHPScaling;                                    // 0x091C(0x0004) (Const, Config)
	int                                                m_nInnerGateHPScaling;                                    // 0x0920(0x0004) (Const, Config)
	int                                                m_nBaseObjectiveHPScaling;                                // 0x0924(0x0004) (Const, Config)
	class ATgPawn_SiegeWall*                           m_TF1InnerWall;                                           // 0x0928(0x0008)
	class ATgPawn_SiegeWall*                           m_TF1OuterWall;                                           // 0x0930(0x0008)
	class ATgPawn_SiegeWall*                           m_TF1BaseObjective;                                       // 0x0938(0x0008)
	class ATgPawn_SiegeWall*                           m_TF2InnerWall;                                           // 0x0940(0x0008)
	class ATgPawn_SiegeWall*                           m_TF2OuterWall;                                           // 0x0948(0x0008)
	class ATgPawn_SiegeWall*                           m_TF2BaseObjective;                                       // 0x0950(0x0008)
	int                                                m_nForcedObjectiveIndex;                                  // 0x0958(0x0004)
	int                                                m_nCountdown;                                             // 0x095C(0x0004)
	float                                              m_fSpeedScale;                                            // 0x0960(0x0004)
	float                                              m_fRespawnOffset;                                         // 0x0964(0x0004)
	float                                              m_fRespawnIncreaseOverTime;                               // 0x0968(0x0004)
	float                                              m_fTimeDeltaRespawnIncrease;                              // 0x096C(0x0004)
	float                                              m_fDefenseRespawnIncrease;                                // 0x0970(0x0004) (Config)
	float                                              m_fAttackRespawnIncrease;                                 // 0x0974(0x0004) (Config)
	float                                              m_fRespawnTimeCap;                                        // 0x0978(0x0004) (Config)
	float                                              m_fNoSiegeEngineRespawnModification;                      // 0x097C(0x0004) (Config)
	struct FName                                       m_AttackDefendState;                                      // 0x0980(0x0008) (Const)
	TEnumAsByte<EGameMode>                             m_DefaultGameMode;                                        // 0x0988(0x0001) (Const)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0989(0x0003) MISSED OFFSET
	float                                              m_fConvergeStartDistance;                                 // 0x098C(0x0004) (Edit, Config)
	float                                              m_fConvergeRate;                                          // 0x0990(0x0004) (Edit, Config)
	float                                              m_fStartConvergeTime;                                     // 0x0994(0x0004) (Edit, Config)
	float                                              m_fConvergeSafeDistance;                                  // 0x0998(0x0004) (Edit, Config)
	class ATgDevice*                                   ConvergeDevice;                                           // 0x099C(0x0008)
	float                                              m_fAutoPushForwardDelay;                                  // 0x09A4(0x0004) (Const, Config)
	float                                              m_fAutoPushForwardSpeedScale;                             // 0x09A8(0x0004) (Const, Config)
	float                                              m_fStopAutoPushDelay;                                     // 0x09AC(0x0004) (Const, Config)
	int                                                m_nCreditsForHoldingObjective;                            // 0x09B0(0x0004) (Config)
	int                                                m_nCreditsBonusPerContested;                              // 0x09B4(0x0004) (Config)
	int                                                m_nCreditsForHoldingPayload;                              // 0x09B8(0x0004) (Config)
	float                                              m_fFogCompleteConvergeDelay;                              // 0x09BC(0x0004)
	float                                              m_fCapturePointsPerSecond1;                               // 0x09C0(0x0004) (Config)
	float                                              m_fCapturePointsPerSecond2;                               // 0x09C4(0x0004) (Config)
	float                                              m_fCapturePointsPerSecond3;                               // 0x09C8(0x0004) (Config)
	float                                              m_fCapturePointsPerSecond4;                               // 0x09CC(0x0004) (Config)
	float                                              m_fCapturePointsPerSecond5;                               // 0x09D0(0x0004) (Config)
	float                                              m_fPointContestDuration;                                  // 0x09D4(0x0004) (Config)
	float                                              m_fPointOvertimeDuration;                                 // 0x09D8(0x0004) (Config)
	float                                              m_fPointOvertimeDrainPercPerSec;                          // 0x09DC(0x0004) (Config)
	float                                              m_fPointClaimDuration;                                    // 0x09E0(0x0004) (Config)
	float                                              m_fOvertimeActiveTime;                                    // 0x09E4(0x0004)
	float                                              m_fOvertimeActiveTimeMemory[0x3];                         // 0x09E8(0x0004)
	int                                                m_nOvertimeActiveTimeEntry;                               // 0x09F4(0x0004)
	float                                              m_fOvertimeLeft;                                          // 0x09F8(0x0004)
	float                                              m_fBackslidePercent;                                      // 0x09FC(0x0004) (Config)
	float                                              m_fBackslideDelay;                                        // 0x0A00(0x0004) (Config)
	float                                              m_fBackslideRate;                                         // 0x0A04(0x0004) (Config)
	int                                                s_nCurrentActivePointIndex;                               // 0x0A08(0x0004)
	int                                                m_nAttackingTaskforce;                                    // 0x0A0C(0x0004)
	struct FVector                                     m_SnappedWaypointIndicatorOffset;                         // 0x0A10(0x000C)
	float                                              m_fGamePauseDelay;                                        // 0x0A1C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_PaladinsExtended");
		return ptr;
	}


	void NotifyPauseDelay(class APlayerController* PC);
	void STATIC_PauseDelay();
	bool STATIC_AllowPausing(class APlayerController* PC);
	void STATIC_UpdateOccupationStatus(class ATgChaosCapturePoint* CapturePoint, int nNumTF1, int nNumTF2);
	void OnPawnDied(class ATgPawn* Victim, class AController* Killer, class UClass* dmgType);
	void ReachTicketLimit(int nTaskForce, TEnumAsByte<EVictoryType> VictoryType);
	bool STATIC_GainTickets(int nTaskForce, float fNumTickets, TEnumAsByte<EVictoryType> VictoryType);
	void SetTickets(int nTaskForce, float fNumTickets);
	void SetLanePusherSpeedScale(float fNewSpeedScale);
	void InitGameReplicationInfo();
	float STATIC_GetTotalSplineDist(class ASplineActor* Spline);
	void ConvergeFog();
	void ResumeConvergeCompletely();
	void StartFogConverging();
	bool STATIC_KillLanePusherWhenGateIsDestroyed();
	void STATIC_UpdateObjectiveTimer();
	void ResetGameMode();
	void CleanupTicketsForRound();
	void OnRoundEnded();
	class ATgRepInfo_TaskForce* STATIC_GetDefendingTaskForce();
	class ATgRepInfo_TaskForce* STATIC_GetAttackingTaskForce();
	bool IsInGrimReaperMode();
	void StartGameMode();
	void SetResetEscapedPlayersTimers(bool bFirstRound);
	void SetAutoMountTimers(bool bFirstRound);
	void SetSpawnGateTimers(bool bFirstRound);
	void StartNewObjectiveRound(bool bFirstRound);
	void AutoMountDefenders();
	void AutoMountAttackers();
	void AutoMountAllPlayers();
	void SendClientRoundEnded();
	void SendClientRoundObjectivesCompleted();
	void ChangeTimerState(TEnumAsByte<EGameTimerState> eTimerState);
	void STATIC_GotoGameRunningState();
	void ResetScores();
	void STATIC_UpdateAttackingTaskforceForRoundTransition();
	void TransitionToNextRound();
	void RevivePlayers(class ATgRepInfo_TaskForce* ReviveTF);
	void RemoveAllBurnCards();
	void STATIC_KillAllProjectiles();
	void ResetPlayersNotInSpawnRoom(bool bResetAttackers, bool bResetDefenders);
	void ResetDefendersNotInSpawnRoom();
	void ResetAttackersNotInSpawnRoom();
	void ResetAllPlayersNotInSpawnRoom();
	void OpenAllAliveGates(bool bOpen);
	void OpenOuterGates(unsigned char TaskForceNum, bool bOpen);
	void OpenInnerGates(unsigned char TaskForceNum, bool bOpen);
	void ConsoleEvent(const struct FName& EventName);
	void STATIC_KillSiegeWallTowers(int nTaskForce);
	void OnBotDied(class ATgAIController* TgAIC);
	void STATIC_EndStasisTimer();
	void StartStasisTimer();
	float STATIC_GetSpawnGateOpenTime();
	float STATIC_GetPickNextObjectiveTime();
	void BroadcastTimer();
	void STATIC_EndBroadcastTimer();
	void StartBroadcastTimer();
	void STATIC_EndPreRoundSetup();
	void PayloadCheckpointReached(class ATgSplineActor_Payload* Checkpoint);
	void CloseSpawnGates();
	void OpenSpawnGates();
	void PointCaptured(int nTaskForce, bool bSuppressPointsForCapture);
	void PreFillCapturePointQueue();
	void PickNextObjective();
	int STATIC_GetNextSpawnTableId();
	void SetCapturePointActive(class ATgObjective* Objective);
	bool ShouldNextRoundBeASurvivalRound();
	void STATIC_EnableCreditSpoolingWhenObjectiveStateUpdated();
	void STATIC_EnableUltWhenObjectiveStateUpdated();
	void STATIC_UpdateObjectiveStates();
	bool CanGoToObjectiveInactiveState();
	bool CanGoToObjectiveActiveState();
	void GoalReached();
	bool ShouldGoIntoOvertimeOnPointCapture(int TaskForceNum);
	bool CapturePointContestDurationEnabled();
	void CheckAwardObjectiveScore(unsigned char TaskForceNum, class ATgChaosCapturePoint* CapturePoint, int NumOnPoint, int NumContested);
	void ManageCapturePointScore();
	void BackslideDelayTF2();
	void BackslideDelayTF1();
	bool ShouldHandlePointCaptureBacksliding();
	void PointOvertimeEnd();
	void RestartPointOvertime(int TaskForceNum);
	void BeginPointOvertime(int TaskForceNum);
	void EndSimpleOvertime();
	void BeginSimpleOvertime();
	void STATIC_EndCapturePointOvertime();
	void SetCapturePointOvertimeEnabled(bool bEnabled);
	void PointContestEnd();
	void ContestPoint();
	void AllPlayersReady();
	class APawn* STATIC_SpawnDefaultPawnFor(class AController* NewPlayer, class ANavigationPoint* StartSpot);
	bool STATIC_IsSurivivalMode();
	TEnumAsByte<ETeamStatus> GetTeamStatus(unsigned char TaskForceNum, float* CaptureRateModifier);
	float STATIC_GetPointCaptureScoreMultiplier(int nTaskForce);
	void NotifyPlayersOfPointCapture();
	void RewardPointCapture(int nTaskForce);
	void CheckCorePower(class ATgChaosCapturePoint* CapturePoint);
	void STATIC_EndPlayConverge();
	void BeginPlayConverge();
	int ResolveTie();
	void RoundTimeLimitReached();
	void SendRoundLimitTimerNotify(TEnumAsByte<EMissionTimerState> eState, float fElapsedSecs);
	bool OverrideRoundTimeLimit();
	void PostBeginPlay();
	void SendStartRoundOnePointFromWinningAlert(int nTaskForceNum);
	int STATIC_GetTaskForceObjectiveTime(int TaskForceNum);
	void TickOvertime(float DeltaSeconds);
	void CacheConvergeDevice();
	void SiegeEngineAdjustDamage(struct FAdjustDamageParams* Params, float* fDamage);
	void SiegeEnginePreDamageMitigation(class ATgPawn* attacker, class UTgEffectGroup* eg, int nPropertyId, float* fDamage);
	void CaptureSpawnAlert(float TimeRemaining);
	void STATIC_LoadCardVendor();
	void BotDied(class ATgAIController* aic);
	void ScorePayloadHold(class ATgPawn* ScorePawn, int NumContested);
	void ScoreObjectiveHold(class ATgPawn* ScorePawn, int NumContested);
	float GetRespawnTime(int TaskForceNum);
	void NativeTransitionToNextRound();
	bool STATIC_IsContesting(int nTaskForceNum);
	bool STATIC_IsUnderdogContesting();
	int STATIC_GetUnderdogTF();
	class ATgChaosCapturePoint* STATIC_GetCurrentCapturePoint();
	void ResetOvertime();
	float STATIC_GetOvertimeDuration();
	float STATIC_GetWinningTickets();
};


// Class TgGame.TgGame_Paladins_Siege
// 0x0070 (0x0A90 - 0x0A20)
class ATgGame_Paladins_Siege : public ATgGame_PaladinsExtended
{
public:
	int                                                m_nPointsForCapturing;                                    // 0x0A20(0x0004) (Transient, Config)
	int                                                m_nPointsForPayload;                                      // 0x0A24(0x0004) (Transient, Config)
	int                                                m_nPointsForDefending;                                    // 0x0A28(0x0004) (Transient, Config)
	int                                                m_nPointsForPayloadCheckpoint;                            // 0x0A2C(0x0004) (Transient, Config)
	int                                                m_nCreditsForWinningARound;                               // 0x0A30(0x0004) (Config)
	int                                                m_nCreditsForCapturingPoint;                              // 0x0A34(0x0004) (Config)
	int                                                m_nCreditsForSuccessfulDefend;                            // 0x0A38(0x0004) (Config)
	int                                                m_nCreditsForSuccessfulPush;                              // 0x0A3C(0x0004) (Config)
	unsigned long                                      m_bRespawnDeadPlayersAfterRound : 1;                      // 0x0A40(0x0004) (Config)
	unsigned long                                      m_bRespawnLivePlayersAfterRound : 1;                      // 0x0A40(0x0004) (Config)
	unsigned long                                      m_bRoundTreatment : 1;                                    // 0x0A40(0x0004) (Config)
	unsigned long                                      m_bCanWinOnDefense : 1;                                   // 0x0A40(0x0004) (Config)
	unsigned long                                      m_bInCapturePointOvertime : 1;                            // 0x0A40(0x0004)
	unsigned long                                      m_bInPayloadOvertime : 1;                                 // 0x0A40(0x0004)
	unsigned long                                      m_bDestroyPayloadCartAfterPayloadPhase : 1;               // 0x0A40(0x0004)
	unsigned long                                      m_bDoNotSwitchPoints : 1;                                 // 0x0A40(0x0004) (Config)
	unsigned long                                      m_bHasHitCheckpoint : 1;                                  // 0x0A40(0x0004) (Transient)
	unsigned long                                      m_bFadeOutAtRoundEnd : 1;                                 // 0x0A40(0x0004) (Config)
	float                                              m_fLosingCaptureRateModifier;                             // 0x0A44(0x0004) (Config)
	float                                              m_fDurationUntilCaptureOvertime;                          // 0x0A48(0x0004) (Config)
	float                                              m_fCaptureOvertimeWarningDuration;                        // 0x0A4C(0x0004) (Config)
	float                                              m_fPayloadDuration;                                       // 0x0A50(0x0004) (Const, Config)
	float                                              m_fPayloadOvertimeDuration;                               // 0x0A54(0x0004) (Const, Config)
	float                                              m_fPayloadDurationCheckpoint;                             // 0x0A58(0x0004) (Const, Config)
	float                                              m_fRoundEndRespawnDelay;                                  // 0x0A5C(0x0004) (Const, Config)
	float                                              m_fPayloadIncreaseLOSTimeTrigger;                         // 0x0A60(0x0004) (Const)
	int                                                s_nCurrentRound;                                          // 0x0A64(0x0004)
	TArray<class ATgObjectiveCrystal*>                 m_CartRepairCrystals;                                     // 0x0A68(0x0010) (NeedCtorLink)
	TArray<class ATgObjectiveCrystal*>                 m_ActiveCartRepairCrystals;                               // 0x0A78(0x0010) (NeedCtorLink)
	int                                                r_nNumActiveCrystals;                                     // 0x0A88(0x0004) (Net)
	float                                              r_fExtraCrystalRepairTime;                                // 0x0A8C(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Paladins_Siege");
		return ptr;
	}


	bool STATIC_HasCaptureObjectives();
	int STATIC_GetCurrentLane();
	int STATIC_GetGameSpawnPhase(class ATgPawn* TgP);
	void STATIC_FogOvertimeEnd();
	void STATIC_FogOvertime();
	void STATIC_FogOvertimeWarning();
	void TriggerPayloadVictory(int nTaskForce);
	void TriggerCapturePointVictory();
	void TriggerSuccessfulPush(int nTaskForce);
	void TriggerSuccessfulDefense(int nTaskForce);
	class ANavigationPoint* FindPlayerStart(class AController* Player, unsigned char InTeam, const struct FString& IncomingName);
	void PayloadPhaseCleanup();
	void PointCapturePhaseCleanup();
	void BroadcastTimer();
	void ConsiderSpawningEchoForSiege();
	void OpenSpawnGates();
	void CaptureAndPayloadRoundEnded();
	bool ShouldSelectNextCapturePointForLoading();
	void STATIC_SendVictoryMessage(class AActor* Winner, unsigned char Type);
	void AwardTPOnRoundEnded();
	void OnRoundEnded();
	void STATIC_UpdatePayloadLOSCheckRate(bool bFaster);
	void STATIC_TriggerFasterLOSCheckTimer(bool bUpdateLOSRate);
	void ScorePayload();
	void SetPayloadTimer(float fDuration, bool overtime);
	void LanePusherReachedOuterWall(class ATgPawn_LanePusher* Lanepusher);
	void LanePusherReachedInnerWall(class ATgPawn_LanePusher* Lanepusher);
	class ATgPawn_SiegeEngine_Payload* STATIC_GetSiegeEnginePush();
	void STATIC_EnableCreditSpoolingWhenObjectiveStateUpdated();
	void STATIC_EnableUltWhenObjectiveStateUpdated();
	void PickNextObjective();
	void RewardPointCapture(int nTaskForce);
	float STATIC_GetPointCaptureScoreMultiplier(int nTaskForce);
	void SetOvertime(float fOvertime, float fOvertimeWarning);
	void TaskforceWin(int nTaskForce, TEnumAsByte<EVictoryType> VictoryType, bool bForce);
	void PostBeginPlay();
	void StartNewObjectiveRound(bool bFirstRound);
	TArray<class ATgObjectiveCrystal*> GetRepairCrystals();
	TArray<class ATgObjectiveCrystal*> GetAllRepairCrystals();
	TArray<class ATgObjectiveCrystal*> GetCurrentActiveRepairCrystals();
	bool STATIC_IsContesting(int nTaskForceNum);
	void TickOvertime(float DeltaSeconds);
	void TrackMapLane(int laneID);
	void TrackPushSuccess(class ATgRepInfo_TaskForce* Taskforce);
	void TrackPushAttempt(class ATgRepInfo_TaskForce* Taskforce);
	class ATgChaosCapturePoint* STATIC_GetCurrentCapturePoint();
};


// Class TgGame.TgGame_Paladins_Assault
// 0x001C (0x0AAC - 0x0A90)
class ATgGame_Paladins_Assault : public ATgGame_Paladins_Siege
{
public:
	float                                              m_fAttackDuration;                                        // 0x0A90(0x0004) (Config)
	float                                              m_fAttackPhaseOvertimeDuration;                           // 0x0A94(0x0004) (Const, Config)
	float                                              m_fAttackCaptureRateMultiplier;                           // 0x0A98(0x0004) (Config)
	class ATgChaosCapturePoint*                        m_AttackPoint;                                            // 0x0A9C(0x0008)
	unsigned long                                      m_bInAttackPhaseOvertime : 1;                             // 0x0AA4(0x0004)
	float                                              m_fTakeoverSecondPhaseInstructionDelay;                   // 0x0AA8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Paladins_Assault");
		return ptr;
	}


	bool AttackersOnPoint();
	void CaptureAndPayloadRoundEnded();
	bool ShouldHandlePointCaptureBacksliding();
	void STATIC_InstructClientsOnTakeoverSecondPhase();
	void NotifyPlayersOfPointCapture();
	float STATIC_GetPointCaptureScoreMultiplier(int nTaskForce);
	void ActivateTaskforceSpecificCapturePoint(int TaskForceId);
	class ATgChaosCapturePoint* STATIC_GetCurrentCapturePoint();
	void SendAssaultPointCapturedAlert(int Taskforce);
};


// Class TgGame.TgGame_Paladins_Onslaught
// 0x0000 (0x0A90 - 0x0A90)
class ATgGame_Paladins_Onslaught : public ATgGame_Paladins_Siege
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Paladins_Onslaught");
		return ptr;
	}


	bool STATIC_HasCaptureObjectives();
	bool OverrideRoundTimeLimit();
	void ConsiderSpawningEchoForSiege();
	bool STATIC_GainTickets(int nTaskForce, float fNumTickets, TEnumAsByte<EVictoryType> VictoryType);
	int STATIC_GetGameTypeHelpTipIndex(class ATgPlayerController* TgPC);
	void SendStartRoundOnePointFromWinningAlert(int nTaskForceNum);
};


// Class TgGame.TgGame_Paladins_Payload
// 0x0050 (0x0AE0 - 0x0A90)
class ATgGame_Paladins_Payload : public ATgGame_Paladins_Siege
{
public:
	float                                              s_fCurrentTF1FarthestPushDistance;                        // 0x0A90(0x0004)
	float                                              s_fCurrentTF2FarthestPushDistance;                        // 0x0A94(0x0004)
	float                                              s_fCurrentPushTimer;                                      // 0x0A98(0x0004)
	float                                              s_fCurrentTF1FarthestPushDistanceTimestamp;               // 0x0A9C(0x0004)
	float                                              s_fCurrentTF2FarthestPushDistanceTimestamp;               // 0x0AA0(0x0004)
	float                                              s_fTimeTF1HadToPush;                                      // 0x0AA4(0x0004)
	int                                                m_nPayloadOnlyCurrentAttackingTeam;                       // 0x0AA8(0x0004)
	int                                                s_nCurrentTurn;                                           // 0x0AAC(0x0004)
	struct FVector                                     s_vPayloadGhostLocation;                                  // 0x0AB0(0x000C)
	struct FVector                                     s_vPayloadGhostOffset;                                    // 0x0ABC(0x000C) (Edit)
	struct FRotator                                    s_PayloadGhostRotation;                                   // 0x0AC8(0x000C)
	int                                                m_nPayloadGhostID;                                        // 0x0AD4(0x0004)
	class ATgDeployable*                               m_PayloadGhost;                                           // 0x0AD8(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Paladins_Payload");
		return ptr;
	}


	void CaptureAndPayloadRoundEnded();
	void ToggleAttackingTaskforce();
	void ClearCheckpointsReached();
	void SetCheckpoint2Reached();
	void SetCheckpoint1Reached();
	void PayloadCheckpointReached(class ATgSplineActor_Payload* Checkpoint);
	float STATIC_GetPayloadTimer();
	void PayloadExpired();
	void OvertimeExpired();
	void OnRoundEnded();
	void ManageComparativeScoring();
	void TF2TakesLongerThanTF1();
	void TF2ReachesTF1Faster();
	void TF2PushesPastTF1();
	float STATIC_GetDistanceToEndOfSpline();
	void UpdatePayloadProgress();
	void STATIC_UpdateAttackingTaskforceForRoundTransition();
	void BroadcastTimer();
	void LanePusherReachedOuterWall(class ATgPawn_LanePusher* Lanepusher);
	void SetResetEscapedPlayersTimers(bool bFirstRound);
	void SetAutoMountTimers(bool bFirstRound);
	float STATIC_GetDefendersSpawnGateOpenTime();
	float STATIC_GetAttackersSpawnGateOpenTime();
	void OpenDefendersSpawnGates();
	void OpenAttackersSpawnGates();
	void SetSpawnGateTimers(bool bFirstRound);
	void StartGameMode();
	void SendStartRoundOnePointFromWinningAlert(int nTaskForceNum);
	void SpawnPayloadGhost();
};


// Class TgGame.TgGame_Paladins_Survival
// 0x0008 (0x0A98 - 0x0A90)
class ATgGame_Paladins_Survival : public ATgGame_Paladins_Siege
{
public:
	int                                                m_nWinningTaskforceThisRound;                             // 0x0A90(0x0004)
	float                                              m_fRoundStartTime;                                        // 0x0A94(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Paladins_Survival");
		return ptr;
	}


	void SetCapturePointActive(class ATgObjective* Objective);
	void StartNewObjectiveRound(bool bFirstRound);
	void TaskforceWin(int nTaskForce, TEnumAsByte<EVictoryType> VictoryType, bool bForce);
	bool ShouldSelectNextCapturePointForLoading();
	void SurvivalModeRoundEnded();
	void SurvivalModeRoundWon(class ATgRepInfo_TaskForce* RoundWinningTF);
	void OnPawnDied(class ATgPawn* Victim, class AController* Killer, class UClass* dmgType);
	float STATIC_GetPickNextObjectiveTime();
	float STATIC_GetSpawnGateOpenTime();
	bool ShouldNextRoundBeASurvivalRound();
	void CheckAwardObjectiveScore(unsigned char TaskForceNum, class ATgChaosCapturePoint* CapturePoint, int NumOnPoint, int NumContested);
	void PostBeginPlay();
	void SendStartRoundOnePointFromWinningAlert(int nTaskForceNum);
	float GetRespawnTime(int TaskForceNum);
};


// Class TgGame.TgGame_Paladins_Tutorial
// 0x0034 (0x0AC4 - 0x0A90)
class ATgGame_Paladins_Tutorial : public ATgGame_Paladins_Siege
{
public:
	TEnumAsByte<ETutorialState>                        m_eCurrentState;                                          // 0x0A90(0x0001) (Transient)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0A91(0x0003) MISSED OFFSET
	class ATgTutorialInfo*                             TutorialInfo;                                             // 0x0A94(0x0008) (Transient)
	float                                              m_fSetupPauseTime;                                        // 0x0A9C(0x0004)
	unsigned long                                      m_bSetupTimerPaused : 1;                                  // 0x0AA0(0x0004)
	unsigned long                                      m_bReceivedMovementAbility : 1;                           // 0x0AA0(0x0004) (Transient)
	unsigned long                                      m_bReachedJumpLowerArea : 1;                              // 0x0AA0(0x0004) (Transient)
	unsigned long                                      m_bReachedJumpUpperArea : 1;                              // 0x0AA0(0x0004) (Transient)
	unsigned long                                      m_bDamagedWithAlt : 1;                                    // 0x0AA0(0x0004) (Transient)
	unsigned long                                      m_bDamagedWithBattle : 1;                                 // 0x0AA0(0x0004) (Transient)
	unsigned long                                      m_bDamagedWithUlt : 1;                                    // 0x0AA0(0x0004) (Transient)
	unsigned long                                      m_bPointCaptured : 1;                                     // 0x0AA0(0x0004) (Transient)
	unsigned long                                      m_bWaitingForUIReady : 1;                                 // 0x0AA0(0x0004) (Transient)
	float                                              m_fReceivedMoveForwardSeconds;                            // 0x0AA4(0x0004) (Transient)
	float                                              m_fReceivedMoveBackwardSeconds;                           // 0x0AA8(0x0004) (Transient)
	float                                              m_fReceivedMoveLeftSeconds;                               // 0x0AAC(0x0004) (Transient)
	float                                              m_fReceivedMoveRightSeconds;                              // 0x0AB0(0x0004) (Transient)
	float                                              m_fVolumeStandTime;                                       // 0x0AB4(0x0004) (Transient)
	float                                              m_fLastFrameDeltaTime;                                    // 0x0AB8(0x0004) (Transient)
	class UAkEvent*                                    m_EndAnnouncerAudioEvent;                                 // 0x0ABC(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Paladins_Tutorial");
		return ptr;
	}


	void CheckGameState();
	void STATIC_GainPoints(int nTaskForce, int numPoints, TEnumAsByte<EVictoryType> VictoryType);
	void PlayAnnouncer(TEnumAsByte<ETutorialAnnouncerLine> eAnnouncerLine, float fLength, const struct FName& NextFunction);
	void PlayAK(class UAkBaseSoundObject* AKObj, float fLength, const struct FName& NextFunction);
	class ATgTutorialInfo* STATIC_GetTutorialInfo();
	class ATgDevice* STATIC_GetLocalPlayerDevice(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	class ATgPawn* STATIC_GetLocalPlayerPawn();
	class ATgPlayerController* STATIC_GetLocalTgPlayerController();
	void TryClearTimer(const struct FName& TimerName);
	void TrySetTimer(float fLength, bool bLoop, const struct FName& FunctionToCall);
	void STATIC_UnpauseSetupTimer();
	void PauseSetupTimer();
	void PauseSetupTimerAt(float TimeRemaining);
	float STATIC_GetPointCaptureScoreMultiplier(int nTaskForce);
	void Tick(float DeltaSeconds);
	TEnumAsByte<ETutorialState> STATIC_GetTutorialState();
	void STATIC_KillHelper();
	class ATgBotFactory* STATIC_GetCurrentBotFactory();
	bool CurrentBotsDead();
	void SpawnCurrentBots();
	void STATIC_DisableUI();
	void RepeatInstructions();
	void StopRepeatInstructions();
	void StartRepeatInstructions();
	float STATIC_GetRepeatInstructionTime();
	void STATIC_HaltAllAudio();
	bool STATIC_IsAllAudioFinished();
	void PointCaptured(int nTaskForce, bool bSuppressPointsForCapture);
	void LocalPlayerDeviceOnDamaged(struct FOnDamagedParams* Params);
	void LocalPlayerInputReceived(TEnumAsByte<EPlayerInputType> InputType);
	void StartGameMode();
	void STATIC_StartMatch();
	int STATIC_GetAnnouncerSTM(TEnumAsByte<ETutorialAnnouncerLine> eLine);
	int STATIC_GetGamepadObjectiveMsg();
	int STATIC_GetObjectiveMsg();
	bool STATIC_IsUIReady();
	void STATIC_HideWorldOverlays();
	int STATIC_GetWinningTaskforce();
	void AwardAchievement();
	void STATIC_EnableTutorialUI(TEnumAsByte<ETutorialUI> TutUIElement, bool bEnable, float fFadeTime);
};


// Class TgGame.TgGame_PointCapture
// 0x0030 (0x079C - 0x076C)
class ATgGame_PointCapture : public ATgGame_Battle
{
public:
	float                                              s_TicketCheckInterval;                                    // 0x076C(0x0004)
	int                                                s_nCaptureHostilePointXP;                                 // 0x0770(0x0004)
	int                                                s_nCaptureHostilePointGold;                               // 0x0774(0x0004)
	int                                                s_nReclaimPointXP;                                        // 0x0778(0x0004)
	int                                                s_nReclaimPointGold;                                      // 0x077C(0x0004)
	int                                                s_nCurrentPhase;                                          // 0x0780(0x0004) (Transient)
	int                                                s_nPhase2Threshold;                                       // 0x0784(0x0004)
	int                                                s_nPhase3Threshold;                                       // 0x0788(0x0004)
	int                                                m_nSpawnWaveTime;                                         // 0x078C(0x0004)
	int                                                m_nSpawnWaveDominatingTime;                               // 0x0790(0x0004)
	int                                                m_nMaxDominatingPoints;                                   // 0x0794(0x0004)
	int                                                s_nAboutToLoseThreshold;                                  // 0x0798(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_PointCapture");
		return ptr;
	}


	void OnPointCaptureOwnershipChanged(class ATgCapturePoint* Point, int NewTaskForceOwner, int PreviousTaskForceOwner);
	void STATIC_UpdateLockedPointStatus();
	float STATIC_GetTaskForceDominatingFactor(int TaskForceNum);
	void SpawnWaveTeam2Timer();
	void SpawnWaveTeam1Timer();
	void CheckWinState();
	void CheckWinCondition();
	void CheckTickets();
	void ChangeTimerState(TEnumAsByte<EGameTimerState> eTimerState);
	void SpawnNeutralBots();
	bool StartGameTimer();
	float STATIC_GetSetupTime();
	class AActor* GetEndFocusActor();
	bool ShouldSpawnSuperMinions(class ATgBotFactory_Minions* minionFactory);
	int STATIC_GetNextVulnerableTowerId(int nBotId);
	void ApplyTowerImmunity();
	void StructureDied(class ATgPawn_Structure* theStructure);
	void SendBonusMinionAlerts(class ATgRepInfo_TaskForce* tf, int nLane);
	void STATIC_UpdateGameWinState(class ATgPawn* nexus);
	void AlertAboutToLose(int nTaskForce);
	void CapturePointReclaimed(class ATgPawn_Character* PC);
	void CapturedPoint(class ATgPawn_Character* PC);
	void ScoreKillGameType(struct FScoreKillData* Data);
	bool BeginEndMission(bool bClearNextMapGame, class AActor* EndMissionFocus, float fDelayOverride);
	void STATIC_EndGameBySurrender(int SurrenderingTaskForce);
	void MarkAsReady(class UPlayer* P);
	float GetRespawnTime(int TaskForceNum);
};


// Class TgGame.TgGame_Domination
// 0x0004 (0x07A0 - 0x079C)
class ATgGame_Domination : public ATgGame_PointCapture
{
public:
	float                                              m_fRespawnTime;                                           // 0x079C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Domination");
		return ptr;
	}


	void CheckPointLocked(class ATgCapturePoint* Point);
	void STATIC_UpdateLockedPointStatus();
	float GetRespawnTime(int TaskForceNum);
};


// Class TgGame.TgGame_SinglePointCaptureAndHold
// 0x0014 (0x07B0 - 0x079C)
class ATgGame_SinglePointCaptureAndHold : public ATgGame_PointCapture
{
public:
	int                                                m_nCurrentActiveCapturePointIndex;                        // 0x079C(0x0004)
	int                                                m_nNumTicketsForCapturingPoint;                           // 0x07A0(0x0004)
	int                                                m_nNumTicketsForHoldingPoint;                             // 0x07A4(0x0004)
	float                                              m_fNewPointTime;                                          // 0x07A8(0x0004)
	float                                              m_fDefendingTeamRespawnTime;                              // 0x07AC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_SinglePointCaptureAndHold");
		return ptr;
	}


	void STATIC_UpdateLockedPointStatus();
	void CheckTickets();
	void OnPointCaptureOwnershipChanged(class ATgCapturePoint* Point, int NewTaskForceOwner, int PreviousTaskForceOwner);
	void SpawnNeutralBots();
	float GetRespawnTime(int TaskForceNum);
};


// Class TgGame.TgGame_Siege
// 0x0000 (0x076C - 0x076C)
class ATgGame_Siege : public ATgGame_Battle
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Siege");
		return ptr;
	}


	void STATIC_WinGame(int WinningTaskForce);
	void DestroyTower(int Taskforce, int Index);
	void ReachedCheckpoint(int Taskforce, int Tier);
	bool StartGameTimer();
	float STATIC_GetSetupTime();
};


// Class TgGame.TgGame_CTF
// 0x0028 (0x076C - 0x0744)
class ATgGame_CTF : public ATgGame_Mission
{
public:
	class ATgCTFFlagBase*                              m_FlagBases[0x2];                                         // 0x0744(0x0008) (Transient)
	float                                              m_fRoundTime;                                             // 0x0754(0x0004)
	float                                              m_fRoundSetupTime;                                        // 0x0758(0x0004)
	float                                              m_fEndOfRoundTime;                                        // 0x075C(0x0004)
	int                                                m_nCurrentRound;                                          // 0x0760(0x0004) (Transient)
	int                                                m_nNumRounds;                                             // 0x0764(0x0004)
	int                                                m_nSpawnWaveTime;                                         // 0x0768(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_CTF");
		return ptr;
	}


	void SpawnWaveTimer();
	void ScoreFlag(class ATgPawn_Character* FlagCarrier);
	void RegisterFlagBase(class ATgCTFFlagBase* FlagBase);
	void MissionTimer();
	void ChangeTimerState(TEnumAsByte<EGameTimerState> eTimerState);
	bool StartGameTimer();
	float STATIC_GetSetupTime();
	void ScoreKillGameType(struct FScoreKillData* Data);
	float GetRespawnTime(int TaskForceNum);
};


// Class TgGame.TgGameTipManager
// 0x0054 (0x02D4 - 0x0280)
class ATgGameTipManager : public AActor
{
public:
	TArray<struct FTipSavedState>                      m_TipSavedState;                                          // 0x0280(0x0010) (Config, GlobalConfig, NeedCtorLink)
	TArray<struct FGameTipInfo>                        m_GameTipQueue;                                           // 0x0290(0x0010) (NeedCtorLink)
	TArray<struct FGameTipInfo>                        m_GameTipWorldQueue;                                      // 0x02A0(0x0010) (NeedCtorLink)
	TArray<struct FGameTipInfo>                        m_GameTipSpecialQueue;                                    // 0x02B0(0x0010) (NeedCtorLink)
	unsigned long                                      m_bIsActive : 1;                                          // 0x02C0(0x0004)
	class UTgAudioComponent*                           m_AudioComponent;                                         // 0x02C4(0x0008) (ExportObject, Component, EditInline)
	int                                                m_nActiveTip;                                             // 0x02CC(0x0004)
	int                                                m_nPlaySoundTip;                                          // 0x02D0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameTipManager");
		return ptr;
	}


	int STATIC_GameTipQueueSort(const struct FGameTipInfo& A, const struct FGameTipInfo& B);
	void PostBeginPlay();
	void SortGameTipQueue(int nGameTipType);
	void ClearSavedDataForNewRound();
	void STATIC_SetActive();
	void STATIC_UnsuppressAllGameTips();
	void CompleteHelpText(int nGameTipId);
	void SuppressHelpText(int nGameTipId);
	void RemoveHelpText(int nGameTipId, bool bDoNotSuppress);
	void STATIC_DismissHelpText(int nGameTipId, bool bDoNotSuppress);
	bool RequestHelpText(int nGameTipId, bool bIsFriend, bool bWaitForDismiss, const struct FVector& SpawnLocation, class ATgHelpTipActor** OutHelpTipActor);
	bool STATIC_IsSuppressed(int nGameTipId);
};


// Class TgGame.TgHelpTipActor
// 0x0030 (0x02B0 - 0x0280)
class ATgHelpTipActor : public AActor
{
public:
	struct FString                                     m_strTitle;                                               // 0x0280(0x0010) (NeedCtorLink)
	struct FString                                     m_strTip;                                                 // 0x0290(0x0010) (NeedCtorLink)
	int                                                m_nGameTipId;                                             // 0x02A0(0x0004)
	float                                              m_fAlpha;                                                 // 0x02A4(0x0004) (Transient)
	float                                              m_fAlphaNearDistanceSq;                                   // 0x02A8(0x0004)
	float                                              m_fAlphaFarDistanceSq;                                    // 0x02AC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgHelpTipActor");
		return ptr;
	}


	void Remove(bool bSuppress);
};


// Class TgGame.TgMinimapManager
// 0x006C (0x00CC - 0x0060)
class UTgMinimapManager : public UObject
{
public:
	TEnumAsByte<ETgMapTeam>                            m_LocalTeam;                                              // 0x0060(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0061(0x0003) MISSED OFFSET
	unsigned char                                      UnknownData01[0x48];                                      // 0x0061(0x0048) UNKNOWN PROPERTY: MapProperty TgGame.TgMinimapManager.m_EntityMap
	unsigned long                                      m_bShouldDisableVisionRange : 1;                          // 0x00AC(0x0004)
	unsigned long                                      m_bSkipWorldGeometryLOS : 1;                              // 0x00AC(0x0004)
	unsigned long                                      m_bRequiresVisionUpdate : 1;                              // 0x00AC(0x0004)
	float                                              m_fFogOfWarAreaRevealTime;                                // 0x00B0(0x0004)
	float                                              m_fUpdateTimer;                                           // 0x00B4(0x0004)
	float                                              m_fLastEntityUpdateTime;                                  // 0x00B8(0x0004)
	TArray<class AReplicationInfo*>                    m_ReferencedRepInfos;                                     // 0x00BC(0x0010) (AlwaysInit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMinimapManager");
		return ptr;
	}


	void InitForTaskforce(class ATgRepInfo_TaskForce* tf);
	void ForceUpdate(class AReplicationInfo* ri);
	void RemoveAllEntities();
	void STATIC_UpdateThreaded();
	void Update(bool bForce);
};


// Class TgGame.TgObjective
// 0x002C (0x02AC - 0x0280)
class ATgObjective : public AActor
{
public:
	unsigned char                                      r_nDefenderTaskForceIndex;                                // 0x0280(0x0001) (Net)
	unsigned char                                      r_nControllingTaskForceIndex;                             // 0x0281(0x0001) (Net)
	unsigned char                                      r_nContestingTaskForceIndex;                              // 0x0282(0x0001) (Net)
	TEnumAsByte<EObjectiveStatus>                      r_eStatus;                                                // 0x0283(0x0001) (Net)
	int                                                r_nControllingTaskForceCount;                             // 0x0284(0x0004) (Net)
	class UTgSpecialFx*                                m_InWordIndicatorFX;                                      // 0x0288(0x0008)
	class UTgSpecialFx*                                m_ForegroundIndicatorFX;                                  // 0x0290(0x0008)
	int                                                m_nActiveAlertId;                                         // 0x0298(0x0004) (Edit)
	int                                                m_nPendingActiveAlertId;                                  // 0x029C(0x0004) (Edit)
	int                                                m_nInactiveAlertId;                                       // 0x02A0(0x0004) (Edit)
	int                                                m_nWaypointMessageOverride;                               // 0x02A4(0x0004) (Edit)
	unsigned long                                      m_bTriggerEventsOnClientAsWell : 1;                       // 0x02A8(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgObjective");
		return ptr;
	}


	void OnContestedStatusChanged();
	void OnSetStatus();
	void SetStatus(TEnumAsByte<EObjectiveStatus> NewStatus);
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_ActivateTeamFX(bool bEnemyTaskForce);
	void STATIC_ActivateNeutralFX();
};


// Class TgGame.TgObjectiveContestable
// 0x001C (0x02C8 - 0x02AC)
class ATgObjectiveContestable : public ATgObjective
{
public:
	TArray<class ATgPawn_Character*>                   m_TouchingChampions;                                      // 0x02AC(0x0010) (NeedCtorLink)
	struct FVector                                     m_vIndicatorOffset;                                       // 0x02BC(0x000C) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgObjectiveContestable");
		return ptr;
	}


	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool STATIC_IsContested();
	int STATIC_GetNumOnPoint(int nTaskForce);
	bool STATIC_CanAddPawnCaptureList(class ATgPawn_Character* pPawn);
	bool STATIC_CanPawnCapture(class ATgPawn_Character* pPawn);
};


// Class TgGame.TgChaosCapturePoint
// 0x00D8 (0x03A0 - 0x02C8)
class ATgChaosCapturePoint : public ATgObjectiveContestable
{
public:
	int                                                m_nDisplayNameId;                                         // 0x02C8(0x0004) (Edit)
	int                                                r_nUniqueCapturePointId;                                  // 0x02CC(0x0004) (Edit, Net)
	int                                                m_nLaneNumber;                                            // 0x02D0(0x0004) (Edit)
	int                                                m_nTaskForce;                                             // 0x02D4(0x0004) (Edit)
	TArray<class ATgBotFactory_Minions*>               m_Taskforce1Factories;                                    // 0x02D8(0x0010) (Edit, NeedCtorLink)
	TArray<class ATgBotFactory_Minions*>               m_Taskforce2Factories;                                    // 0x02E8(0x0010) (Edit, NeedCtorLink)
	class ATgBotFactory_Minions*                       m_GuardianFactory;                                        // 0x02F8(0x0008) (Edit)
	class ATgSplineActor*                              m_Taskforce1PathStart;                                    // 0x0300(0x0008) (Edit)
	class ATgSplineActor*                              m_Taskforce2PathStart;                                    // 0x0308(0x0008) (Edit)
	TArray<class APlayerStart*>                        m_PlayerBaseSpawnPoints;                                  // 0x0310(0x0010) (Edit, NeedCtorLink)
	TArray<class APlayerStart*>                        m_PlayerRespawnPoints;                                    // 0x0320(0x0010) (Edit, NeedCtorLink)
	class UTgAnimNodeSlot*                             m_CustomAnimNode;                                         // 0x0330(0x0008) (Transient)
	int                                                c_MICStatus;                                              // 0x0338(0x0004)
	unsigned long                                      c_bConfusedRendering : 1;                                 // 0x033C(0x0004)
	unsigned long                                      m_bPrimaryCapturePoint : 1;                               // 0x033C(0x0004) (Edit)
	unsigned long                                      r_bFogActive : 1;                                         // 0x033C(0x0004) (Net)
	unsigned long                                      m_bForceSurvival : 1;                                     // 0x033C(0x0004) (Edit, Const)
	unsigned long                                      m_bAnnouncedDeathFog : 1;                                 // 0x033C(0x0004)
	float                                              m_fLastEnemyCapturingPointMessageTime;                    // 0x0340(0x0004) (Transient)
	float                                              m_fMinEnemyCapturingPointMessageTime;                     // 0x0344(0x0004)
	class ATgHelpTipActor*                             m_HelpTip;                                                // 0x0348(0x0008)
	float                                              r_fCapturedPct;                                           // 0x0350(0x0004) (Net)
	int                                                c_DominationOuterMIC;                                     // 0x0354(0x0004)
	int                                                c_DominationInnerMIC;                                     // 0x0358(0x0004)
	TArray<class ATgStaticMeshActor_CapturePoint*>     CapturePointMeshActors;                                   // 0x035C(0x0010) (Edit, NeedCtorLink)
	TArray<class AVolume*>                             m_Volumes;                                                // 0x036C(0x0010) (Edit, NeedCtorLink)
	int                                                m_nCapturePriority;                                       // 0x037C(0x0004) (Edit)
	class UClass*                                      m_TgSurvivalFogVolumeDensityInfoClass;                    // 0x0380(0x0008) (Edit, Const)
	class ATgSurvivalFogVolumeDensityInfo*             m_ConvergeFog;                                            // 0x0388(0x0008)
	int                                                r_nFogAboutToBeActive;                                    // 0x0390(0x0004) (Net)
	float                                              m_fFogFadeInTotalTime;                                    // 0x0394(0x0004) (Edit)
	float                                              m_fTF1TouchedPointTimer;                                  // 0x0398(0x0004)
	float                                              m_fTF2TouchedPointTimer;                                  // 0x039C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgChaosCapturePoint");
		return ptr;
	}


	void Destroyed();
	void SetFogActive(bool bEnabled);
	int GetControllingPlayerCount();
	void STATIC_UpdateOccupationStatus();
	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void SpawnHelpTip();
	void ShowPathfinder(bool bEnabled);
	void PlayFogHorn();
	void STATIC_UpdateFogStatus();
	void OnSetStatus();
	void Tick(float DeltaTime);
	void PostBeginPlay();
	void PreBeginPlay();
	void ReplicatedEvent(const struct FName& VarName);
	void AnnounceFogOfDeath();
	void PlayEnemyCapturingEmote(class ATgRepInfo_TaskForce* Taskforce);
};


// Class TgGame.TgChaosCapturePoint_ParticleStorm
// 0x0074 (0x0414 - 0x03A0)
class ATgChaosCapturePoint_ParticleStorm : public ATgChaosCapturePoint
{
public:
	class AEmitter*                                    m_FrontEffect;                                            // 0x03A0(0x0008) (Edit)
	class AEmitter*                                    m_SwirlEffect;                                            // 0x03A8(0x0008) (Edit)
	float                                              m_fFogStartDistance;                                      // 0x03B0(0x0004) (Edit)
	float                                              m_fFogConvergeSpeed;                                      // 0x03B4(0x0004) (Edit)
	float                                              m_fSecondsBeforeFogConverge;                              // 0x03B8(0x0004) (Edit)
	float                                              m_fFogMapDistance;                                        // 0x03BC(0x0004) (Edit)
	float                                              m_fFogRadiusRatio;                                        // 0x03C0(0x0004) (Edit)
	float                                              m_fFogAlphaRatio;                                         // 0x03C4(0x0004) (Edit)
	class AAkAmbientSound*                             m_2DSoundActor;                                           // 0x03C8(0x0008) (Edit)
	int                                                m_nNumMobileSoundActors;                                  // 0x03D0(0x0004) (Edit)
	TArray<class ATgMobileAmbientSound*>               m_MobileSoundActors;                                      // 0x03D4(0x0010) (NeedCtorLink)
	class UAkEvent*                                    m_MobileSoundActorAkEvent;                                // 0x03E4(0x0008) (Edit)
	class UAkEvent*                                    m_MobileSoundActorAkEvent_Alt;                            // 0x03EC(0x0008) (Edit)
	TArray<struct FVector>                             m_vPerimeterAnchors;                                      // 0x03F4(0x0010) (NeedCtorLink)
	float                                              m_fTargetStartDistance;                                   // 0x0404(0x0004)
	float                                              m_fPreviousStartDistance;                                 // 0x0408(0x0004)
	float                                              m_fFogUpdateTimestamp;                                    // 0x040C(0x0004)
	float                                              m_fSoundActorConvergeLimit;                               // 0x0410(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgChaosCapturePoint_ParticleStorm");
		return ptr;
	}


	void ResetFog();
	void Tick(float DeltaTime);
	void SetInitialState();
};


// Class TgGame.TgObjectiveCrystal
// 0x003C (0x0304 - 0x02C8)
class ATgObjectiveCrystal : public ATgObjectiveContestable
{
public:
	class ATgPawn_SiegeBeyond_Payload*                 m_pPayload;                                               // 0x02C8(0x0008)
	float                                              r_fContestTime;                                           // 0x02D0(0x0004) (Net)
	float                                              r_fContestTimeRequired;                                   // 0x02D4(0x0004) (Net)
	int                                                m_nTaskForce;                                             // 0x02D8(0x0004) (Edit)
	struct FName                                       m_nmOffensiveTypeName;                                    // 0x02DC(0x0008) (Const)
	struct FName                                       m_nmDefensiveTypeName;                                    // 0x02E4(0x0008) (Const)
	struct FName                                       r_nmCrystalType;                                          // 0x02EC(0x0008) (Edit, Net)
	unsigned long                                      m_bRandomizeCrystalType : 1;                              // 0x02F4(0x0004) (Edit)
	int                                                m_nCrystalPropMeshAsmId;                                  // 0x02F8(0x0004)
	class ATgPropActor*                                m_CrystalProp;                                            // 0x02FC(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgObjectiveCrystal");
		return ptr;
	}


	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void Tick(float DeltaTime);
	bool STATIC_HasCachedPayload();
	void ReplicatedEvent(const struct FName& VarName);
	class ATgPropActor* STATIC_RetrieveCrystalProp();
	void STATIC_RemoveActiveFX();
	void STATIC_ActivateActiveFX();
	void STATIC_ActivateTeamFX(bool bEnemyTaskForce);
	void STATIC_ActivateNeutralFX();
	void STATIC_UpdateFX();
	void SetStatus(TEnumAsByte<EObjectiveStatus> NewStatus);
};


// Class TgGame.TgRepInfo_CapturePoint
// 0x0024 (0x02A4 - 0x0280)
class ATgRepInfo_CapturePoint : public AReplicationInfo
{
public:
	class ATgCapturePoint*                             r_OwningCapturePoint;                                     // 0x0280(0x0008) (Net)
	int                                                r_nUniqueCapturePointId;                                  // 0x0288(0x0004) (Net)
	int                                                r_nControlledByTaskForce;                                 // 0x028C(0x0004) (Net)
	float                                              r_fOwnershipPct;                                          // 0x0290(0x0004) (Net)
	unsigned char                                      r_nTransitionDirection;                                   // 0x0294(0x0001) (Net)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0295(0x0003) MISSED OFFSET
	unsigned long                                      r_bIsLocked : 1;                                          // 0x0298(0x0004) (Net)
	class UTgSeqEvent_ControlPointOwnershipPercent*    c_OwnershipPercentKismetNode;                             // 0x029C(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRepInfo_CapturePoint");
		return ptr;
	}


	int GetCapturePointIndex();
	void OnOwnershipPctChanged();
	void OnTaskForceControlChanged();
	void PostBeginPlay();
	void ReplicatedEvent(const struct FName& VarName);
	struct FVector STATIC_GetCurrentLocation();
};


// Class TgGame.TgRepInfo_Deployable
// 0x0060 (0x02E0 - 0x0280)
class ATgRepInfo_Deployable : public AReplicationInfo
{
public:
	int                                                r_nHealthCurrent;                                         // 0x0280(0x0004) (Net)
	int                                                r_nHealthMaximum;                                         // 0x0284(0x0004) (Net)
	float                                              r_fDeployMaxHealthPCT;                                    // 0x0288(0x0004) (Net)
	int                                                r_nDeployableId;                                          // 0x028C(0x0004) (Net)
	int                                                r_nUniqueDeployableId;                                    // 0x0290(0x0004) (Net)
	float                                              r_fLifespanInitial;                                       // 0x0294(0x0004) (Net)
	float                                              r_fLifespanSync;                                          // 0x0298(0x0004) (Net)
	class ATgDeployable*                               r_DeployableOwner;                                        // 0x029C(0x0008) (Net)
	class ATgRepInfo_Player*                           r_InstigatorInfo;                                         // 0x02A4(0x0008) (Net)
	class ATgRepInfo_TaskForce*                        r_TaskforceInfo;                                          // 0x02AC(0x0008) (Net)
	unsigned long                                      r_bOwnedByTaskforce : 1;                                  // 0x02B4(0x0004) (Net)
	unsigned long                                      c_bReceivedOwner : 1;                                     // 0x02B4(0x0004)
	unsigned long                                      r_bMinimapOnlyOwnerSee : 1;                               // 0x02B4(0x0004) (Net)
	unsigned long                                      r_bInDestroyedState : 1;                                  // 0x02B4(0x0004) (Net)
	unsigned long                                      c_bShowHUDLifespanTimer : 1;                              // 0x02B4(0x0004)
	struct FVector                                     r_ApproxLocation;                                         // 0x02B8(0x000C) (Net)
	struct FTG_HUD_INFO                                c_HudInfo;                                                // 0x02C4(0x0004)
	unsigned char                                      r_bVisibleOnMap[0x3];                                     // 0x02C8(0x0001) (Net)
	TEnumAsByte<EDeployableOverlayIcon>                r_eDeployableOverlayIcon;                                 // 0x02CB(0x0001) (Net)
	TEnumAsByte<EDeployableOverlayState>               r_eDeployableOverlayState;                                // 0x02CC(0x0001) (Net)
	unsigned char                                      UnknownData00[0x3];                                       // 0x02CD(0x0003) MISSED OFFSET
	float                                              r_fVisionRange;                                           // 0x02D0(0x0004) (Net)
	int                                                r_nDeployableOverlayDisplayMask;                          // 0x02D4(0x0004) (Net)
	float                                              r_fDeployableOverlayEnemyViewDist;                        // 0x02D8(0x0004) (Net)
	float                                              c_fBarragePercent;                                        // 0x02DC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRepInfo_Deployable");
		return ptr;
	}


	void SetHUDOverlayEnemyViewDist(float enemyViewDist);
	void SetHUDOverlayState(TEnumAsByte<EDeployableOverlayState> dos);
	void SetHUDOverlayIcon(TEnumAsByte<EDeployableOverlayIcon> doi);
	void SetHUDOverlayDisplayMask(int dodm);
	void STATIC_LifespanTimer();
	void STATIC_UpdateLifespanTimer();
	void SyncLifespanTimer();
	void StartLifespanTimer(float fTime);
	void STATIC_UpdateDeployableLocation();
	void ReceivedDeployableOwner();
	void ReplicatedEvent(const struct FName& VarName);
	void Destroyed();
	void PostBeginPlay();
	void CheckNotifyGroupChanged();
	bool STATIC_IsVisibleToLocalPlayer();
	bool STATIC_IsVisibleToPlayer(class ATgRepInfo_Player* PRI);
	bool STATIC_IsVisibleToMapTeam(TEnumAsByte<ETgMapTeam> MAPTEAM);
	bool STATIC_IsVisibleToAnEnemyTeam();
	void STATIC_UpdateMapVisibility(TEnumAsByte<ETgMapTeam> MAPTEAM, unsigned char bVisible, float fVisionRange, bool bDetected);
	float GetMaxLifespan();
	float STATIC_GetLifespan();
	int STATIC_GetCurrentMaxHealth();
	int STATIC_GetCurrentHealth();
	struct FVector STATIC_GetCurrentLocation();
	void SetTaskForce(class ATgRepInfo_TaskForce* tf);
	class ATgRepInfo_TaskForce* STATIC_GetTaskForce();
};


// Class TgGame.TgRepInfo_Portal
// 0x000C (0x02EC - 0x02E0)
class ATgRepInfo_Portal : public ATgRepInfo_Deployable
{
public:
	class ATgRepInfo_Portal*                           r_TwinDRI;                                                // 0x02E0(0x0008) (Net)
	unsigned long                                      c_bMasterEntity : 1;                                      // 0x02E8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRepInfo_Portal");
		return ptr;
	}

};


// Class TgGame.TgRepInfo_Factory
// 0x0030 (0x02B0 - 0x0280)
class ATgRepInfo_Factory : public AReplicationInfo
{
public:
	TEnumAsByte<EReplicatedFactoryState>               s_FactoryState;                                           // 0x0280(0x0001)
	TEnumAsByte<EReplicatedFactoryState>               r_FactoryState[0x3];                                      // 0x0281(0x0001) (Net)
	unsigned char                                      r_bVisibleOnMap[0x3];                                     // 0x0284(0x0001) (Net)
	unsigned char                                      r_bRespawnVisible[0x3];                                   // 0x0287(0x0001) (Net)
	TEnumAsByte<EMinimapFactoryType>                   r_MinimapType;                                            // 0x028A(0x0001) (Net)
	unsigned char                                      UnknownData00[0x1];                                       // 0x028B(0x0001) MISSED OFFSET
	class ATgActorFactory*                             r_FactoryOwner;                                           // 0x028C(0x0008) (Net)
	class ATgRepInfo_TaskForce*                        r_TaskforceInfo;                                          // 0x0294(0x0008) (Net)
	int                                                r_nFactoryId;                                             // 0x029C(0x0004) (Net)
	class AReplicationInfo*                            r_LastSpawnedRepInfo;                                     // 0x02A0(0x0008) (Net)
	float                                              r_fRespawnDelay;                                          // 0x02A8(0x0004) (Net)
	float                                              r_fRespawnTimer;                                          // 0x02AC(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRepInfo_Factory");
		return ptr;
	}


	void StopRespawnTimer();
	void STATIC_UpdateRespawnTimer();
	void StartRespawnTimer(float fSeconds);
	void STATIC_UpdateInWorldIndicators();
	void Destroyed();
	void ReplicatedEvent(const struct FName& VarName);
	void PostBeginPlay();
	void STATIC_InitFor(class ATgActorFactory* Factory);
	float STATIC_GetRespawnElapsedPercent();
	bool STATIC_IsVisibleToLocalPlayer();
	void STATIC_UpdateMapVisibility(TEnumAsByte<ETgMapTeam> MAPTEAM, unsigned char bVisible, float fVisionRange, bool bDetected);
};


// Class TgGame.TgRepInfo_Game
// 0x031C (0x0604 - 0x02E8)
class ATgRepInfo_Game : public AGameReplicationInfo
{
public:
	TArray<struct FGraphData>                          m_GraphData;                                              // 0x02E8(0x0010) (NeedCtorLink)
	struct FGraphData                                  r_LastDataPoint;                                          // 0x02F8(0x000C)
	float                                              m_GraphUpdateWaitTime;                                    // 0x0304(0x0004)
	TEnumAsByte<ETG_GAME_TYPE>                         r_GameType;                                               // 0x0308(0x0001) (Net)
	TEnumAsByte<EHUDType>                              r_eHUDType;                                               // 0x0309(0x0001) (Net)
	TEnumAsByte<EINITIALIZEABLE_BOOL>                  r_eTalentsEnabled;                                        // 0x030A(0x0001) (Net)
	TEnumAsByte<EMissionTimerState>                    r_nMissionTimerState;                                     // 0x030B(0x0001) (Net)
	TEnumAsByte<EGameTimerState>                       r_eGameTimerState;                                        // 0x030C(0x0001) (Net)
	TEnumAsByte<EMissionTimerState>                    r_nRoundLimitTimerState;                                  // 0x030D(0x0001) (Net)
	TEnumAsByte<EMissionTimerState>                    r_nSecondaryTimerState;                                   // 0x030E(0x0001) (Net)
	unsigned char                                      r_nLastRoundAttacker;                                     // 0x030F(0x0001) (Net)
	unsigned char                                      r_nLastRoundWinner;                                       // 0x0310(0x0001) (Net)
	TEnumAsByte<EFlagState>                            r_FlagState[0x2];                                         // 0x0311(0x0001) (Net)
	TEnumAsByte<EGameEnvironmentRule>                  r_GameEnvironmentRule;                                    // 0x0313(0x0001) (Net)
	TEnumAsByte<EGameRespawnRule>                      r_GameRespawnRule;                                        // 0x0314(0x0001) (Net)
	TEnumAsByte<EGameMode>                             r_GameMode;                                               // 0x0315(0x0001) (Net)
	TEnumAsByte<ENotifySound>                          r_eMusicEvent;                                            // 0x0316(0x0001) (Net)
	TEnumAsByte<EAbyssalEchoActiveSTatus>              r_eAbyssalEchoActive;                                     // 0x0317(0x0001) (Net)
	unsigned long                                      r_bIsMission : 1;                                         // 0x0318(0x0004) (Net)
	unsigned long                                      r_bGameHasSetup : 1;                                      // 0x0318(0x0004) (Net)
	unsigned long                                      r_bGameHasEnded : 1;                                      // 0x0318(0x0004) (Net)
	unsigned long                                      r_bCanPurchaseMasterRiding : 1;                           // 0x0318(0x0004) (Net)
	unsigned long                                      r_bAllowSpawnGuardDuringDeviceFire : 1;                   // 0x0318(0x0004) (Net)
	unsigned long                                      r_bLoadoutSelectionEnabled : 1;                           // 0x0318(0x0004) (Net)
	unsigned long                                      r_bBlockCreditGain : 1;                                   // 0x0318(0x0004) (Net)
	unsigned long                                      r_bBlockEnergyGain : 1;                                   // 0x0318(0x0004) (Net)
	unsigned long                                      r_bDisablePlayerMovement : 1;                             // 0x0318(0x0004) (Net)
	unsigned long                                      r_bOvertime : 1;                                          // 0x0318(0x0004) (Net)
	unsigned long                                      r_bCapturePointOvertime : 1;                              // 0x0318(0x0004) (Net)
	unsigned long                                      r_bLimitBurnCardsToOnePerCategory : 1;                    // 0x0318(0x0004) (Net)
	unsigned long                                      r_bRoundEnding : 1;                                       // 0x0318(0x0004) (Net)
	unsigned long                                      r_bFadeOutAtRoundEnd : 1;                                 // 0x0318(0x0004) (Net)
	unsigned long                                      r_bIntroPlayed : 1;                                       // 0x0318(0x0004) (Net)
	unsigned long                                      r_bUsePointsMode : 1;                                     // 0x0318(0x0004) (Net)
	unsigned long                                      r_bUltimatesLocked : 1;                                   // 0x0318(0x0004) (Net)
	unsigned long                                      r_bCanSpoolUlt : 1;                                       // 0x0318(0x0004) (Net)
	unsigned long                                      r_bAimAssistEnabled : 1;                                  // 0x0318(0x0004) (Net)
	unsigned long                                      r_bSuddenDeath : 1;                                       // 0x0318(0x0004) (Net)
	unsigned long                                      r_bCanPurchaseItemsWhileDead : 1;                         // 0x0318(0x0004) (Net)
	unsigned long                                      r_bSuppressItemMenu : 1;                                  // 0x0318(0x0004) (Net)
	unsigned long                                      r_bUsesItemStoreV2 : 1;                                   // 0x0318(0x0004) (Net)
	unsigned long                                      r_bEnableDistanceFOW : 1;                                 // 0x0318(0x0004) (Net)
	unsigned long                                      r_bSpawnGatesOpen : 1;                                    // 0x0318(0x0004) (Net)
	unsigned long                                      r_bAttackersSpawnGatesOpen : 1;                           // 0x0318(0x0004) (Net)
	unsigned long                                      r_bDefendersSpawnGatesOpen : 1;                           // 0x0318(0x0004) (Net)
	unsigned long                                      r_bForwardProgress : 1;                                   // 0x0318(0x0004) (Net)
	unsigned long                                      r_bServerFlagSprint : 1;                                  // 0x0318(0x0004) (Net)
	unsigned long                                      r_bServerFlagMinimapTeamVisibility : 1;                   // 0x0318(0x0004) (Net)
	unsigned long                                      r_bForce3P : 1;                                           // 0x0318(0x0004) (Net)
	unsigned long                                      r_bForce1P : 1;                                           // 0x0318(0x0004) (Net)
	unsigned long                                      r_bForceOutOfCombatSprint : 1;                            // 0x031C(0x0004) (Net)
	unsigned long                                      r_bAutoMelee : 1;                                         // 0x031C(0x0004) (Net)
	unsigned long                                      r_bShowProjectileProximityDistance : 1;                   // 0x031C(0x0004) (Net)
	unsigned long                                      r_bDisableProjectileProximityDistance : 1;                // 0x031C(0x0004) (Net)
	unsigned long                                      r_bShowHeadMesh : 1;                                      // 0x031C(0x0004) (Net)
	unsigned long                                      r_bUseInstantFireMeshTrace : 1;                           // 0x031C(0x0004) (Net, Config)
	unsigned long                                      r_bAllowWeaponLagPrediction : 1;                          // 0x031C(0x0004) (Net, Config)
	unsigned long                                      r_bSiegeEngineRequiresAlliesToMove : 1;                   // 0x031C(0x0004) (Net)
	unsigned long                                      r_bSiegeEngineMovementPaused : 1;                         // 0x031C(0x0004) (Net)
	unsigned long                                      r_bSiegeEngineMovementPausedAfterDamagingGate : 1;        // 0x031C(0x0004) (Net)
	unsigned long                                      r_bFogConverging : 1;                                     // 0x031C(0x0004) (Net)
	unsigned long                                      r_bFogEnded : 1;                                          // 0x031C(0x0004) (Net)
	unsigned long                                      r_bCheckpoint1Reached : 1;                                // 0x031C(0x0004) (Net)
	unsigned long                                      r_bCheckpoint2Reached : 1;                                // 0x031C(0x0004) (Net)
	unsigned long                                      r_bEnableHeadshots : 1;                                   // 0x031C(0x0004) (Net)
	unsigned long                                      r_bAllowPlayerMountingInSpawnRoom : 1;                    // 0x031C(0x0004) (Net)
	unsigned long                                      r_bAllowPlayerMountingAlways : 1;                         // 0x031C(0x0004) (Net)
	unsigned long                                      r_bKillCamEnabled : 1;                                    // 0x031C(0x0004) (Net)
	unsigned long                                      r_bAttackersKillCamEnabled : 1;                           // 0x031C(0x0004) (Net)
	unsigned long                                      r_bDefendersKillCamEnabled : 1;                           // 0x031C(0x0004) (Net)
	unsigned long                                      r_bBlockKillCam : 1;                                      // 0x031C(0x0004) (Net)
	unsigned long                                      r_bIsFirstRound : 1;                                      // 0x031C(0x0004) (Net)
	unsigned long                                      r_bSpawnGatesOpenedAtLeastOnce : 1;                       // 0x031C(0x0004) (Net)
	unsigned long                                      r_bDisableMusicEvents : 1;                                // 0x031C(0x0004) (Net)
	unsigned long                                      r_bCapturePointAlert : 1;                                 // 0x031C(0x0004) (Net)
	unsigned long                                      r_bCapturePointSpawned : 1;                               // 0x031C(0x0004) (Net)
	unsigned long                                      r_bTF1DamagedEcho : 1;                                    // 0x031C(0x0004) (Net)
	unsigned long                                      r_bTF2DamagedEcho : 1;                                    // 0x031C(0x0004) (Net)
	unsigned long                                      r_bEchoDied : 1;                                          // 0x031C(0x0004)
	unsigned long                                      c_bAbyssalEchoSpawningIn : 1;                             // 0x031C(0x0004)
	int                                                r_nEventTalentVendorId;                                   // 0x0320(0x0004) (Net)
	int                                                r_nEventDeckVendorId;                                     // 0x0324(0x0004) (Net)
	float                                              r_fMissionRemainingTime;                                  // 0x0328(0x0004) (Net)
	int                                                r_nMissionTimerStateChange;                               // 0x032C(0x0004) (Net)
	float                                              r_fMissionTime;                                           // 0x0330(0x0004) (Net)
	float                                              c_fMissionTime;                                           // 0x0334(0x0004)
	float                                              c_fMissionTimeSeconds;                                    // 0x0338(0x0004)
	float                                              c_fAIBotDelaySeconds;                                     // 0x033C(0x0004)
	float                                              r_fRoundLimitElapsed;                                     // 0x0340(0x0004) (Net)
	float                                              r_fRoundLimitDuration;                                    // 0x0344(0x0004) (Net)
	float                                              r_fSecondaryRemainingTime;                                // 0x0348(0x0004) (Net)
	int                                                r_nSecondaryTimerStateChange;                             // 0x034C(0x0004) (Net)
	float                                              r_fSecondaryTime;                                         // 0x0350(0x0004) (Net)
	float                                              c_fSecondaryMissionTime;                                  // 0x0354(0x0004)
	float                                              c_fSecondaryMissionTimeSeconds;                           // 0x0358(0x0004)
	float                                              r_fCapturePointOvertimeStartDuration;                     // 0x035C(0x0004) (Net)
	int                                                r_nCapturePointOvertimeStateChange;                       // 0x0360(0x0004) (Net)
	float                                              r_fPayloadOvertimeStartDuration;                          // 0x0364(0x0004) (Net)
	int                                                r_nPayloadOvertimeStateChange;                            // 0x0368(0x0004) (Net)
	float                                              r_fTF1PayloadPushDistance;                                // 0x036C(0x0004) (Net)
	int                                                r_nPurchaseTime;                                          // 0x0370(0x0004) (Net)
	float                                              m_fPurchaseTimer;                                         // 0x0374(0x0004)
	float                                              r_fBasicAttackDamageMultiplier;                           // 0x0378(0x0004) (Net)
	float                                              r_fGlobalJumpMultiplier;                                  // 0x037C(0x0004) (Net)
	float                                              r_fGlobalMoveSpeedMultiplier;                             // 0x0380(0x0004) (Net)
	float                                              r_fGravityScaleMultiplier;                                // 0x0384(0x0004) (Net)
	float                                              r_fGlobalUltCooldownMultiplier;                           // 0x0388(0x0004) (Net)
	int                                                r_nEnergyChargeDeviceDisabled;                            // 0x038C(0x0004) (Net)
	int                                                r_nAutoHealingDisabled;                                   // 0x0390(0x0004) (Net)
	int                                                r_nGlobalItemPurchaseOverride;                            // 0x0394(0x0004) (Net)
	int                                                r_nGlobalLoadoutChangeOverride;                           // 0x0398(0x0004) (Net)
	float                                              r_fCooldownReduction;                                     // 0x039C(0x0004) (Net)
	float                                              r_fUltChargeRate;                                         // 0x03A0(0x0004) (Net)
	int                                                r_nForceLoadoutCardLevels;                                // 0x03A4(0x0004) (Net)
	class ATgRepInfo_TaskForce*                        r_AttackingTaskForce;                                     // 0x03A8(0x0008) (Net)
	class ATgRepInfo_TaskForce*                        r_CapturingTaskForce;                                     // 0x03B0(0x0008) (Net)
	int                                                r_nChaosRemainingAttackDefendTime;                        // 0x03B8(0x0004) (Net)
	class ATgRepInfo_TaskForce*                        r_Winner;                                                 // 0x03BC(0x0008) (Net)
	float                                              r_fPhysicsThreshold;                                      // 0x03C4(0x0004) (Net)
	struct FString                                     r_sQueueName;                                             // 0x03C8(0x0010) (Net, NeedCtorLink)
	int                                                r_nPlayOfTheGamePawnId;                                   // 0x03D8(0x0004) (Net)
	int                                                r_nPlayOfTheGameMapLane;                                  // 0x03DC(0x0004) (Net)
	int                                                r_nOffenseCrystalCount;                                   // 0x03E0(0x0004) (Net)
	int                                                r_nDefenseCrystalCount;                                   // 0x03E4(0x0004) (Net)
	int                                                r_nMaxOffenseCrystalCount;                                // 0x03E8(0x0004) (Net)
	int                                                r_nMaxDefenseCrystalCount;                                // 0x03EC(0x0004) (Net)
	float                                              r_fPlayOfTheGameTimeStamp;                                // 0x03F0(0x0004) (Net)
	class ATgPlayOfTheGameCamera*                      c_PlayOfTheGameCamera;                                    // 0x03F4(0x0008)
	TArray<class ATgDeployable*>                       m_Deployables;                                            // 0x03FC(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	TArray<class ATgProjectile*>                       m_Projectiles;                                            // 0x040C(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	TArray<class ATgDestructible*>                     m_Destructibles;                                          // 0x041C(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	TArray<class ATgRepInfo_Deployable*>               m_DRIArray;                                               // 0x042C(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	TArray<class ATgRepInfo_CapturePoint*>             m_CPRIArray;                                              // 0x043C(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	TArray<class ATgChaosCapturePoint*>                m_CapturePoints;                                          // 0x044C(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	TArray<class ATgObjectiveCrystal*>                 m_CrystalPoints;                                          // 0x045C(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	class ATgPawn_HHGate*                              r_pHHGate;                                                // 0x046C(0x0008) (Net)
	TArray<class ATgDeployable*>                       m_MovableProjBlockers;                                    // 0x0474(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	int                                                r_nCurrentCheckpoint[0x2];                                // 0x0484(0x0004) (Net, Transient)
	int                                                c_nNextClientOnlyProjectileInstanceId;                    // 0x048C(0x0004) (Transient)
	class ATgPawn_LanePusher*                          r_LanePusher;                                             // 0x0490(0x0008) (Net)
	class ATgPawn_LanePusherBase*                      r_LanePusher1;                                            // 0x0498(0x0008) (Net)
	class ATgPawn_LanePusherBase*                      r_LanePusher2;                                            // 0x04A0(0x0008) (Net)
	class ATgPawn*                                     r_SquadTarget1;                                           // 0x04A8(0x0008)
	class ATgPawn*                                     r_SquadTarget2;                                           // 0x04B0(0x0008)
	float                                              r_fLastSquadTargetUpdate1;                                // 0x04B8(0x0004)
	float                                              r_fLastSquadTargetUpdate2;                                // 0x04BC(0x0004)
	float                                              r_fSpeedScale;                                            // 0x04C0(0x0004) (Net)
	float                                              r_fPayloadProgressPercent;                                // 0x04C4(0x0004) (Net)
	float                                              r_fCheckpoint1Percent;                                    // 0x04C8(0x0004) (Net)
	float                                              r_fCheckpoint2Percent;                                    // 0x04CC(0x0004) (Net)
	float                                              r_fServerFlagDamageMultiplier;                            // 0x04D0(0x0004)
	float                                              r_fServerFlagGroundSpeedModifier;                         // 0x04D4(0x0004)
	float                                              r_fServerFlagAutoHealingMultiplier;                       // 0x04D8(0x0004)
	class ATgPawn_SiegeWall*                           r_pSiegeWallTF1[0x3];                                     // 0x04DC(0x0008) (Net)
	class ATgPawn_SiegeWall*                           r_pSiegeWallTF2[0x3];                                     // 0x04F4(0x0008) (Net)
	float                                              r_fFogDensity;                                            // 0x050C(0x0004) (Net)
	float                                              r_fFogStartDistance;                                      // 0x0510(0x0004) (Net)
	float                                              r_fFogObscureDistance;                                    // 0x0514(0x0004) (Net)
	class AExponentialHeightFog*                       c_Fog;                                                    // 0x0518(0x0008)
	int                                                r_nPersistentTextID;                                      // 0x0520(0x0004) (Net)
	int                                                r_nAlertTextID;                                           // 0x0524(0x0004) (Net)
	int                                                r_nAlertIncrement;                                        // 0x0528(0x0004) (Net)
	int                                                r_nRemainingObjectiveTime;                                // 0x052C(0x0004) (Net)
	int                                                r_nTotalObjectiveTime;                                    // 0x0530(0x0004) (Net)
	float                                              r_fPlayerViewDistance;                                    // 0x0534(0x0004) (Net)
	float                                              r_fVisibilityVolumeViewDistance;                          // 0x0538(0x0004)
	float                                              r_fPushTimer;                                             // 0x053C(0x0004)
	float                                              r_fWeaponMaxLagCompensation;                              // 0x0540(0x0004) (Net)
	float                                              m_fVaultImmuneToSiegeEngineHealth;                        // 0x0544(0x0004)
	float                                              r_fConvergeDistance;                                      // 0x0548(0x0004) (Net)
	float                                              r_fConvergeStartDistance;                                 // 0x054C(0x0004) (Net)
	float                                              r_fFogConvergeInterval;                                   // 0x0550(0x0004) (Net)
	int                                                r_nTaskForcePushSuccessful;                               // 0x0554(0x0004) (Net)
	int                                                r_nTaskForceDefenseSuccessful;                            // 0x0558(0x0004) (Net)
	int                                                r_nMapLane;                                               // 0x055C(0x0004) (Net)
	float                                              r_fGlobalFrictionFalling;                                 // 0x0560(0x0004) (Net)
	float                                              r_fGlobalFrictionFlying;                                  // 0x0564(0x0004) (Net)
	int                                                r_nVideoPathID;                                           // 0x0568(0x0004) (Net)
	int                                                r_nTargetPhaseTicketCount;                                // 0x056C(0x0004) (Net)
	struct FBotDifficultyDebugData                     r_DifficultyDebugData;                                    // 0x0570(0x0064) (Net)
	float                                              r_fWinningTicketsOverride;                                // 0x05D4(0x0004) (Net)
	int                                                r_nAbyssalEchoTimer;                                      // 0x05D8(0x0004) (Net)
	float                                              c_fAbyssalEchoTimer;                                      // 0x05DC(0x0004)
	int                                                r_nAbyssalEchoTimerTotal;                                 // 0x05E0(0x0004) (Net)
	int                                                r_nAbyssalEchoBotId;                                      // 0x05E4(0x0004) (Net)
	class ATgPawn*                                     r_AbyssalEcho;                                            // 0x05E8(0x0008) (Net)
	class UMaterialInstanceConstant*                   c_AbyssalEchoMIC;                                         // 0x05F0(0x0008)
	float                                              c_fAbyssalEchoMICFadeInDuration;                          // 0x05F8(0x0004)
	float                                              c_fAbyssalEchoMICFadeOutDuration;                         // 0x05FC(0x0004)
	float                                              c_fAbyssalEchoMICTimer;                                   // 0x0600(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRepInfo_Game");
		return ptr;
	}


	void PlayMusicEvent(TEnumAsByte<ENotifySound> eMusicEvent);
	void PlayVideo(int nVideoPathID);
	struct FName STATIC_GetVideoPath(int nVideoPathID);
	bool AllowPlayerMounting();
	TArray<class ATgPawn_Character*> GetAllPawnCharacters();
	void AddPotGEventToAllPlayers(TEnumAsByte<EPlayOfTheGameEventType> potgEvent);
	void SetEnableHeadshots(bool bEnable);
	void ProcessMissionTimerEvent(int nEventId, unsigned char nAttackingTaskForce, unsigned char nWinningTaskForce);
	void SendPayloadMissionEvent(int nEventId, class ATgRepInfo_TaskForce* attackingTaskForce, class ATgRepInfo_TaskForce* WinningTaskForce);
	float GetMissionTime();
	void DecrementPoints(int nTaskForce, int nValue);
	void SetUsePointsMode(bool bValue, int nValue);
	void SetCheckpoint(int NewCheckpoint, int Taskforce);
	bool STATIC_FlagIsDown(int TeamIndex);
	void SetFlagDown(int TeamIndex);
	bool STATIC_FlagIsHeldEnemy(int TeamIndex);
	void SetFlagHeldEnemy(int TeamIndex);
	bool STATIC_FlagIsHeldFriendly(int TeamIndex);
	void SetFlagHeldFriendly(int TeamIndex);
	bool STATIC_FlagsAreHome();
	bool STATIC_FlagIsHome(int TeamIndex);
	void SetFlagHome(int TeamIndex);
	int GetNextClientOnlyProjectileInstanceId();
	void RemoveDestructible(class ATgDestructible* Dest);
	void AddDestructible(class ATgDestructible* Dest);
	void RemoveCapturePoint(class ATgChaosCapturePoint* pPoint);
	void STATIC_AddCrystal(class ATgObjectiveCrystal* pCrystal);
	void AddCapturePoint(class ATgChaosCapturePoint* pPoint);
	void RegisterHHGate(class ATgPawn_HHGate* pGate);
	void RemoveCPRI(class ATgRepInfo_CapturePoint* CPRI);
	void AddCPRI(class ATgRepInfo_CapturePoint* CPRI);
	void RemoveDRI(class ATgRepInfo_Deployable* DRI);
	void AddDRI(class ATgRepInfo_Deployable* DRI);
	void MissionTimeUpdateAllClients();
	void STATIC_UpdateMissionTimer(bool bForcePrimary, bool bForceSecondary);
	void STATIC_InitSecondaryMissionTime();
	void STATIC_InitMissionTime();
	void PostBeginPlay();
	void STATIC_UpdateAttackingTaskforce(class ATgRepInfo_TaskForce* NewAttackingTaskForce);
	void STATIC_UpdateFog();
	void SetGameMode(TEnumAsByte<EGameMode> Mode);
	void STATIC_GameEnvironmentRuleUpdated();
	void SetGameRespawnRule(TEnumAsByte<EGameRespawnRule> Rule);
	void SetGameEnvironmentRule(TEnumAsByte<EGameEnvironmentRule> Rule);
	void STATIC_HideHeadMesh();
	void ShowHeadMesh();
	void PrecacheClassByName(const struct FString& godName, const struct FString& SkinName, const struct FString& weaponSkinName);
	void PrecacheClassById(int nBotId, const struct FString& SkinName, const struct FString& weaponSkinName);
	void TestPrecache(int nBotId, int nSkinId, int nWeaponSkinId, bool bAll);
	void STATIC_IntializeMaterialForEcho();
	void STATIC_ClientHandleAlert();
	void STATIC_HandleAlert();
	void ReplicatedEvent(const struct FName& VarName);
	class ATgChaosCapturePoint* STATIC_GetActiveCapturePoint();
	bool AllowHeadShots();
	void RecalcRespawnTimers();
	bool SiegeEngineRequiresAlliesToMove();
	TEnumAsByte<EMAP_LANE> STATIC_GetLane(int nLane, class ATgRepInfo_TaskForce* tfri);
	class ATgProj_Simulated* SpawnSimulatedProjectile(int nProjectileInstanceId, int nFireModeId, class AActor* pOwner, const struct FVector& vLocation, const struct FVector& vRotation, int nProjectileIdOverride, bool bPredictStartLocationBasedOnPing, class UTgDeviceFire* FireMode, unsigned char ExtraInfo);
	class ATgProj_Simulated* STATIC_GetSimulatedProjectile(int nProjectileId);
	class ATgProj_Simulated* STATIC_GetClientSpawnedProjectile(int ClientFireRequestId);
	void STATIC_CapturePointSpawned();
	void STATIC_CaptureAlertAnnounce();
	void DefendersSpawnGatesOpenChanged();
	void AttackersSpawnGatesOpenChanged();
	void SpawnGatesOpenChanged();
	void STATIC_GameTypeSet();
	void STATIC_GameStateChanged();
	void STATIC_UpdateGameTransitionUI();
	void STATIC_UpdateGameScoreUI();
	void STATIC_UpdateGameClockUI();
	void STATIC_ProcessServerGameProperties();
	bool CheckIsEnemy(class AActor* A, class AActor* B);
	class ATgRepInfo_TaskForce* STATIC_GetDefendingTaskForce();
	class ATgRepInfo_TaskForce* STATIC_GetAttackingTaskForce();
	void STATIC_GetAlliedTeamPawns(class ATgPawn* instigatingPawn, TArray<class ATgPawn_Character*>* allyPawns);
	void STATIC_GetOpposingTeamsPawns(class ATgPawn* instigatingPawn, TArray<class ATgPawn_Character*>* enemyPawns);
	void STATIC_GetPawns(TArray<class ATgPawn_Character*>* AllPawns);
	int STATIC_GetNumNearbyPlayers(int nTaskForceNum, const struct FVector& vLocation, float fDist);
	bool TaskForceEnumerate(bool bPlayerOnly, class ATgRepInfo_TaskForce** rpTaskForce, int* rnTaskForceNum);
	class ATgRepInfo_TaskForce* CreateTaskForce(int nTaskForceNum);
	class ATgRepInfo_TaskForce* STATIC_GetTaskForce(int nTaskForceNum, bool bCreate);
	class ATgRepInfo_TaskForce* STATIC_GetTaskForceFor(class AActor* Actor);
	class ATgPawn* STATIC_FindPawnById(int nPawnId);
	class ATgRepInfo_Player* STATIC_GetPRIFromID(int nPRIID);
	class ATgProjectile* STATIC_GetProjectile(int nIndex);
	class ATgDeployable* STATIC_GetDeployable(int nIndex);
	int STATIC_GetDeployableCount();
	float STATIC_GetUltCooldownMultiplier();
	float STATIC_GetCooldownReduction();
};


// Class TgGame.TgRepInfo_Game_TeamDeathMatch
// 0x0008 (0x060C - 0x0604)
class ATgRepInfo_Game_TeamDeathMatch : public ATgRepInfo_Game
{
public:
	int                                                c_nLeadingTeam;                                           // 0x0604(0x0004)
	int                                                c_nLeadingTeamScoreAmount;                                // 0x0608(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRepInfo_Game_TeamDeathMatch");
		return ptr;
	}

};


// Class TgGame.TgRepInfo_Player
// 0x11C4 (0x1644 - 0x0480)
class ATgRepInfo_Player : public APlayerReplicationInfo
{
public:
	int                                                r_nPlayerId;                                              // 0x0480(0x0004) (Net)
	int                                                r_nPawnId;                                                // 0x0484(0x0004) (Net)
	int                                                r_nControlledPawnId;                                      // 0x0488(0x0004) (Net)
	int                                                r_nPlayerGameID;                                          // 0x048C(0x0004) (Net)
	int                                                m_nUIDisplayIndex;                                        // 0x0490(0x0004)
	float                                              c_fLastUpdateTime;                                        // 0x0494(0x0004)
	float                                              r_fCreditCacheDuration;                                   // 0x0498(0x0004) (Net)
	int                                                r_nCreditCacheDurationTick;                               // 0x049C(0x0004) (Net)
	int                                                r_nSupportWins;                                           // 0x04A0(0x0004) (Net)
	int                                                r_nDamageWins;                                            // 0x04A4(0x0004) (Net)
	int                                                r_nFlankWins;                                             // 0x04A8(0x0004) (Net)
	int                                                r_nFrontlineWins;                                         // 0x04AC(0x0004) (Net)
	int                                                r_nEquippedTitleId;                                       // 0x04B0(0x0004) (Net)
	int                                                r_nHealthCurrent;                                         // 0x04B4(0x0004) (Net)
	int                                                r_nHealthMaximum;                                         // 0x04B8(0x0004) (Net)
	int                                                r_nMaxArmor;                                              // 0x04BC(0x0004) (Net)
	int                                                r_nPowerCurrent;                                          // 0x04C0(0x0004) (Net)
	int                                                r_nPowerMaximum;                                          // 0x04C4(0x0004) (Net)
	int                                                r_nPacingType;                                            // 0x04C8(0x0004) (Net)
	int                                                r_nShieldCurrent;                                         // 0x04CC(0x0004) (Net)
	int                                                r_nShieldMaximum;                                         // 0x04D0(0x0004) (Net)
	class ATgRepInfo_Player*                           r_MasterPrep;                                             // 0x04D4(0x0008) (Net)
	class ATgRepInfo_TaskForce*                        r_TaskForce;                                              // 0x04DC(0x0008) (Net)
	class ATgTeamPlayerStart*                          r_SpawnPoint;                                             // 0x04E4(0x0008) (Net)
	float                                              r_fReviveSecs;                                            // 0x04EC(0x0004) (Net)
	float                                              r_fReviveSecsTotal;                                       // 0x04F0(0x0004) (Net)
	unsigned long                                      r_bMapHasLoaded : 1;                                      // 0x04F4(0x0004) (Net)
	unsigned long                                      r_bHasBeenSeenByEnemyTeam : 1;                            // 0x04F4(0x0004) (Net)
	unsigned long                                      r_bHasFlag : 1;                                           // 0x04F4(0x0004) (Net, Transient)
	unsigned long                                      r_bSilhouettesBlocked : 1;                                // 0x04F4(0x0004) (Net)
	unsigned long                                      r_bExtendedSilhouetteRange : 1;                           // 0x04F4(0x0004) (Net)
	unsigned long                                      r_bSpeakingEmote : 1;                                     // 0x04F4(0x0004) (Net)
	unsigned long                                      r_bPlayingAnnouncer : 1;                                  // 0x04F4(0x0004) (Net)
	unsigned long                                      c_bSpeaking : 1;                                          // 0x04F4(0x0004)
	unsigned long                                      r_bNeedsHealing : 1;                                      // 0x04F4(0x0004) (Net)
	unsigned long                                      r_bDropped : 1;                                           // 0x04F4(0x0004) (Net)
	unsigned long                                      r_bForceNotBot : 1;                                       // 0x04F4(0x0004) (Net)
	unsigned long                                      r_bDisconnected : 1;                                      // 0x04F4(0x0004) (Net)
	unsigned long                                      c_bIsDying : 1;                                           // 0x04F4(0x0004)
	unsigned long                                      r_IsRevealed : 1;                                         // 0x04F4(0x0004) (Net)
	unsigned long                                      r_bIsStealthed : 1;                                       // 0x04F4(0x0004) (Net)
	unsigned long                                      r_bIsVolumeStealthed : 1;                                 // 0x04F4(0x0004)
	unsigned long                                      r_bUltimateIsReady : 1;                                   // 0x04F4(0x0004) (Net)
	unsigned long                                      r_bCanUpgradeLegendary : 1;                               // 0x04F4(0x0004) (Net)
	unsigned long                                      s_bAutoSelectCards : 1;                                   // 0x04F4(0x0004)
	unsigned long                                      c_bTrackedProjectileIdsJustChanged : 1;                   // 0x04F4(0x0004)
	unsigned char                                      r_nSurrenderVote;                                         // 0x04F8(0x0001) (Net)
	unsigned char                                      r_bVisibleOnMap[0x3];                                     // 0x04F9(0x0001) (Net)
	unsigned char                                      r_nVisibilityMask;                                        // 0x04FC(0x0001) (Net)
	unsigned char                                      r_nFlashUpdateAmmo;                                       // 0x04FD(0x0001) (Net)
	TEnumAsByte<EDeployableOverlayIcon>                r_eDeployableOverlayIcon;                                 // 0x04FE(0x0001) (Net)
	TEnumAsByte<EDeployableOverlayState>               r_eDeployableOverlayState;                                // 0x04FF(0x0001) (Net)
	TEnumAsByte<EDeployableOverlayIcon>                c_eDeployableOverlayIconOverride;                         // 0x0500(0x0001)
	TEnumAsByte<EDeployableOverlayState>               c_eDeployableOverlayStateOverride;                        // 0x0501(0x0001)
	TEnumAsByte<EGAME_MODE_INSTRUCTION>                r_eCurrentGameModeInstruction;                            // 0x0502(0x0001) (Net)
	unsigned char                                      UnknownData00[0x1];                                       // 0x0503(0x0001) MISSED OFFSET
	TArray<class ATgRepInfo_Player*>                   m_PRIArray;                                               // 0x0504(0x0010) (NeedCtorLink)
	TArray<class ATgRepInfo_Deployable*>               m_DRIArray;                                               // 0x0514(0x0010) (NeedCtorLink)
	class ATgRepInfo_Player*                           c_PriorMasterPrep;                                        // 0x0524(0x0008)
	class ATgRepInfo_TaskForce*                        c_PriorTaskForce;                                         // 0x052C(0x0008)
	int                                                c_fLastHealth;                                            // 0x0534(0x0004)
	float                                              c_fLastDamageTime;                                        // 0x0538(0x0004)
	float                                              r_fVisionRange;                                           // 0x053C(0x0004) (Net)
	class ATgCarriedFlag*                              s_CarriedFlag;                                            // 0x0540(0x0008) (Transient)
	struct FString                                     r_ClanTag;                                                // 0x0548(0x0010) (Net, AlwaysInit, NeedCtorLink)
	struct FString                                     c_PlayerNameWithTag;                                      // 0x0558(0x0010) (AlwaysInit, NeedCtorLink)
	float                                              c_fBarragePercent;                                        // 0x0568(0x0004)
	float                                              m_fSyncAnnouncerFailsafe;                                 // 0x056C(0x0004)
	struct FSimulatedProjectileOverrides               r_SimProjOverrides[0x8];                                  // 0x0570(0x0018) (Net)
	int                                                r_Scores[0x17];                                           // 0x0630(0x0004) (Net)
	struct FDeviceTeamInfo                             r_PlayerDevices[0x31];                                    // 0x068C(0x0028) (Net)
	int                                                r_PlayerDeviceAmmo[0x31];                                 // 0x0E34(0x0004) (Net)
	struct FMarkedTargetInfo                           r_MarkedTargets[0x5];                                     // 0x0EF8(0x0008) (Net)
	float                                              c_fLastSpeakingTime;                                      // 0x0F20(0x0004)
	float                                              s_fNeedHealingDuration;                                   // 0x0F24(0x0004)
	int                                                r_nCredits;                                               // 0x0F28(0x0004) (Net)
	int                                                r_nEarnedCredits;                                         // 0x0F2C(0x0004) (Net)
	int                                                r_nXp;                                                    // 0x0F30(0x0004) (Net)
	int                                                r_nLevel;                                                 // 0x0F34(0x0004) (Net)
	int                                                r_nPlayerScore;                                           // 0x0F38(0x0004) (Net)
	int                                                r_nCardHealth;                                            // 0x0F3C(0x0004) (Net)
	int                                                r_nCardDamage;                                            // 0x0F40(0x0004) (Net)
	int                                                r_nPowerLevel;                                            // 0x0F44(0x0004) (Net)
	int                                                r_nPowerLevelCount;                                       // 0x0F48(0x0004) (Net)
	int                                                r_nProfileId;                                             // 0x0F4C(0x0004) (Net)
	int                                                r_nSkinId;                                                // 0x0F50(0x0004) (Net)
	struct FName                                       r_nmVoicePkg;                                             // 0x0F54(0x0008) (Net)
	struct Fdword                                      r_eVoicePref;                                             // 0x0F5C(0x0004) (Net)
	int                                                r_nKillstreak;                                            // 0x0F60(0x0004) (Net)
	int                                                r_nWeaponSkinId;                                          // 0x0F64(0x0004) (Net)
	int                                                r_nMountSkinId;                                           // 0x0F68(0x0004) (Net)
	int                                                r_nAssistScore;                                           // 0x0F6C(0x0004) (Net)
	class ATgPawn*                                     r_PawnOwner;                                              // 0x0F70(0x0008) (Net)
	int                                                r_nLaneId;                                                // 0x0F78(0x0004) (Net)
	int                                                s_KillOrDeathStreakModifier;                              // 0x0F7C(0x0004)
	struct FsPingInfo                                  r_PingInfo[0x4];                                          // 0x0F80(0x001C) (Net)
	struct FVector                                     c_DeathLocation;                                          // 0x0FF0(0x000C)
	struct FTG_HUD_INFO                                c_HudInfo;                                                // 0x0FFC(0x0004)
	float                                              r_fUltReadyInSecs;                                        // 0x1000(0x0004) (Net)
	int                                                r_nUltimateCharge;                                        // 0x1004(0x0004) (Net)
	int                                                r_nRequiredUltimateCharge;                                // 0x1008(0x0004) (Net)
	int                                                r_nPassiveMode;                                           // 0x100C(0x0004) (Net)
	int                                                r_nPerkCountKit;                                          // 0x1010(0x0004) (Net)
	int                                                r_nPerkCountArmor;                                        // 0x1014(0x0004) (Net)
	int                                                r_nPerkCountWeapon;                                       // 0x1018(0x0004) (Net)
	int                                                r_nPerkCountGeneral;                                      // 0x101C(0x0004) (Net)
	int                                                r_nCardsToDraw;                                           // 0x1020(0x0004) (Net)
	int                                                r_nDrawnCards[0x5];                                       // 0x1024(0x0004) (Net)
	int                                                r_nDrawnPlayer[0x5];                                      // 0x1038(0x0004) (Net)
	float                                              s_fScoreTakenPool;                                        // 0x104C(0x0004)
	float                                              s_fScoreDamagePool;                                       // 0x1050(0x0004)
	float                                              s_fScoreCapturePool;                                      // 0x1054(0x0004)
	float                                              s_fScoreHealingPool;                                      // 0x1058(0x0004)
	float                                              s_fScoreMitigatedPool;                                    // 0x105C(0x0004)
	float                                              s_fScoreTakenThreshold;                                   // 0x1060(0x0004)
	float                                              s_fScoreDamageThreshold;                                  // 0x1064(0x0004)
	float                                              s_fScoreCaptureThreshold;                                 // 0x1068(0x0004)
	float                                              s_fScoreHealingThreshold;                                 // 0x106C(0x0004)
	float                                              s_fScoreMitigatedThreshold;                               // 0x1070(0x0004)
	TArray<struct FDeckCardData>                       s_CardDeckTier1;                                          // 0x1074(0x0010) (NeedCtorLink)
	TArray<struct FDeckCardData>                       s_CardDeckTier2;                                          // 0x1084(0x0010) (NeedCtorLink)
	TArray<struct FDeckCardData>                       s_CardDeckTier3;                                          // 0x1094(0x0010) (NeedCtorLink)
	TArray<struct FDeckCardData>                       s_CardDeckTier4;                                          // 0x10A4(0x0010) (NeedCtorLink)
	TArray<struct FDeckCardData>                       s_CardDeckTier5;                                          // 0x10B4(0x0010) (NeedCtorLink)
	struct FTgAbilityInfo                              r_GeneralAbilityInfo;                                     // 0x10C4(0x0044) (Net)
	struct FTgAbilityInfo                              r_ArmorAbilityInfo;                                       // 0x1108(0x0044) (Net)
	class ATgRepInfo_Player*                           s_LastKillerPRI;                                          // 0x114C(0x0008)
	TArray<struct FPlayOfTheGameEventData>             s_PlayOfTheGameEventList;                                 // 0x1154(0x0010) (NeedCtorLink)
	TArray<struct FPlayOfTheGameEventCounter>          s_PlayOfTheGameEventCounters;                             // 0x1164(0x0010) (NeedCtorLink)
	int                                                r_nDeployableOverlayDisplayMask;                          // 0x1174(0x0004) (Net)
	float                                              r_fDeployableOverlayEnemyViewDist;                        // 0x1178(0x0004) (Net)
	int                                                c_nDeployableOverlayDisplayMaskOverride;                  // 0x117C(0x0004)
	float                                              c_fDeployableOverlayEnemyViewDistOverride;                // 0x1180(0x0004)
	int                                                r_TrackedProjectileIds[0xF];                              // 0x1184(0x0004) (Net)
	struct FTrackedProjectileInitData                  r_TrackedProjectilesInitData[0xF];                        // 0x11C0(0x0030) (Net)
	struct FTrackedProjectileUpdateData                r_TrackedProjectilesUpdateData[0xF];                      // 0x1490(0x001C) (Net)
	struct FVector                                     r_vWaypoint;                                              // 0x1634(0x000C) (Net)
	int                                                s_nVGSGoodLuckHaveFun;                                    // 0x1640(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRepInfo_Player");
		return ptr;
	}


	float STATIC_GetDeployableOverlayEnemyViewDist();
	TEnumAsByte<EDeployableOverlayState> STATIC_GetDeployableOverlayState();
	TEnumAsByte<EDeployableOverlayIcon> STATIC_GetDeployableOverlayIcon();
	int STATIC_GetDeployableOverlayDisplayMask();
	void SetHUDOverlayEnemyViewDist(float enemyViewDist);
	void SetHUDOverlayState(TEnumAsByte<EDeployableOverlayState> dos);
	void SetHUDOverlayIcon(TEnumAsByte<EDeployableOverlayIcon> doi);
	void SetHUDOverlayDisplayMask(int dodm);
	bool STATIC_GetSimProjOverrides(int nFireModeId, float* fRange, float* fRemoteProximity, float* fSpeed, float* fGravityScale, float* fFireAngle);
	void STATIC_ValidateSimProj(int nIndex);
	int STATIC_FindSimProjOverrideIndex(int nFireModeId);
	void SetSimProjFireAngle(int nFireModeId, float fFireAngle);
	void SetSimProjGravityScale(int nFireModeId, float fGravityScale);
	void SetSimProjDist(int nFireModeId, float fDist);
	void SetSimProjRemoteProximity(int nFireModeId, float fRemoteProximity);
	void SetSimProjSpeed(int nFireModeId, float fSpeed);
	void SetSpawnPoint(class ATgTeamPlayerStart* SpawnPoint);
	void SetFlag(class ATgCarriedFlag* NewFlag);
	void OnDeath();
	void TransferMinionOwnershipTo(class ATgRepInfo_Player* NewOwner);
	void CopyProperties(class APlayerReplicationInfo* PRI);
	void STATIC_OverrideWith(class APlayerReplicationInfo* PRI);
	class APlayerReplicationInfo* Duplicate();
	bool STATIC_ShouldBroadCastWelcomeMessage(bool bExiting);
	class ATgPawn* STATIC_FindLocalPlayerPawn();
	class APlayerController* STATIC_FindLocalController();
	void CreditCacheDuration();
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_UpdatedWaypoint();
	void UpdatedTaskForce();
	void STATIC_UpdatedApproxLocation();
	void STATIC_UpdatedHealthCurrent();
	unsigned char STATIC_GetTaskForceNumber();
	void UpdateShield(int nCurrentShield, int nMaxShield);
	void UpdatePower(int nCurrentPower, int nMaxPower);
	void UpdateHealth(int nCurrentHealth, int nMaxHealth, int nMaxArmor);
	void STATIC_UpdatePlayerLocation();
	void UpdateIdAndProfile();
	void Timer();
	void RecalculateTeamColor();
	void ClientInitialize(class AController* C);
	void SetAnnouncerPlaying(bool bPlaying);
	void PopulateGeneralAbilities();
	void PostBeginPlay();
	void ServerRequestRelease();
	void OnRequestRelease();
	void ClientAllPlayersReady();
	void ClientSetAnnouncerPlaying(bool bPlaying);
	int STATIC_GetMarkedTargetCount(int nPawnId);
	void RemoveMarkedTarget(int nPawnId, int nCount);
	void AddMarkedTarget(int nPawnId, int nCount);
	void AddPlayOfTheGameEvent(TEnumAsByte<EPlayOfTheGameEventType> Type, float Amount);
	void STATIC_DrawNewCards(int nPrevPower);
	bool STATIC_LoadCardDeck(bool bDefault);
	void STATIC_UpdatePlayerNameWithTag();
	void STATIC_UpdatePlayerReady();
	void STATIC_UpdateSurrenderVoting();
	void ClientUpdateItemStoreItems();
	bool SetTaskForceNumber(unsigned char nTaskForce, bool bForce);
	void STATIC_UpdateMapVisibility(TEnumAsByte<ETgMapTeam> MAPTEAM, unsigned char bVisible, float fVisionRange, bool bDetected);
	void STATIC_UpdatePingInfo(class ATgRepInfo_Player* pingedPri, const struct FVector& pingedLoc, TEnumAsByte<EPING_TYPE> Type);
	void CheckPingingList();
	bool STATIC_IsVisibleToLocalPlayer();
	bool STATIC_IsVisibleToPlayer(class ATgRepInfo_Player* PRI);
	bool STATIC_IsVisibleToMapTeam(TEnumAsByte<ETgMapTeam> MAPTEAM);
	bool STATIC_IsVisibleToAnEnemyTeam();
	bool STATIC_HasBeenSeenByEnemyTeam();
	void STATIC_UpdateFX();
	void STATIC_UpdatePlayerTaskforceUI();
	void STATIC_UpdateWinsPerRole();
	void STATIC_UpdatePlayerInfoUI();
	void STATIC_UpdateSpectatorUI();
	struct FString STATIC_GetPlayerNameForMsgDisplay(bool bBaseNameOnly);
	void STATIC_UpdateUltimateIsReady(float fCooldownSecs);
	struct FRotator STATIC_GetCurrentRotation();
	struct FVector STATIC_GetCurrentLocation();
	int STATIC_GetCurrentMaxShield();
	int STATIC_GetCurrentShield();
	int STATIC_GetCurrentMaxPower();
	int STATIC_GetCurrentPower();
	int STATIC_GetCurrentMaxArmor();
	int STATIC_GetCurrentMaxHealth();
	int STATIC_GetCurrentHealth();
	void CheckMembership();
	void RemoveMinion(class AReplicationInfo* pRepInfo);
	void AddMinion(class AReplicationInfo* pRepInfo);
	void SetTeam(class ATgRepInfo_TaskForce* pNewTeamRep);
	void STATIC_UpdateBroadcastedItems(class ATgInventoryManager* InvMgr);
	void STATIC_UpdateLevel();
	void STATIC_UpdateScoreboard();
	int STATIC_GetPlayerId();
	bool STATIC_IsMinionOf(class ATgRepInfo_Player* PossibleOwner);
	bool STATIC_IsGodDecoy();
	bool STATIC_IsGod();
	bool IsBot();
	bool STATIC_IsFriendlyWithLocalPlayer();
	void STATIC_SetCurrentlyControlledPawnId(class ATgPawn* pTgPawn);
	int STATIC_GetCurrentlyControlledPawnId();
};


// Class TgGame.TgRepInfo_TaskForce
// 0x00DC (0x037C - 0x02A0)
class ATgRepInfo_TaskForce : public ATeamInfo
{
public:
	struct FString                                     c_fsName;                                                 // 0x02A0(0x0010) (NeedCtorLink)
	int                                                r_nTeamId;                                                // 0x02B0(0x0004) (Net)
	int                                                r_nLeaderPlayerId;                                        // 0x02B4(0x0004) (Net)
	unsigned char                                      r_nTaskForce;                                             // 0x02B8(0x0001) (Net)
	TEnumAsByte<ETgMapTeam>                            r_MapTeam;                                                // 0x02B9(0x0001) (Net)
	unsigned char                                      UnknownData00[0x2];                                       // 0x02BA(0x0002) MISSED OFFSET
	int                                                s_nTaskForceChatId;                                       // 0x02BC(0x0004)
	int                                                s_nStrikeForceId;                                         // 0x02C0(0x0004)
	int                                                s_nTaskTeamNum;                                           // 0x02C4(0x0004)
	struct FColor                                      m_Color;                                                  // 0x02C8(0x0004)
	unsigned long                                      r_bIsSurrendering : 1;                                    // 0x02CC(0x0004) (Net)
	unsigned long                                      r_bSpectator : 1;                                         // 0x02CC(0x0004) (Net)
	unsigned long                                      m_bDestroyOnEmpty : 1;                                    // 0x02CC(0x0004)
	unsigned long                                      r_bIsAttacking : 1;                                       // 0x02CC(0x0004) (Net)
	int                                                s_nPlayerStartCount;                                      // 0x02D0(0x0004)
	TArray<struct FTGTEAM_ENTRY>                       m_TeamPlayers;                                            // 0x02D4(0x0010) (NeedCtorLink)
	TArray<struct FTGTEAM_ENTRY>                       m_TeamBots;                                               // 0x02E4(0x0010) (NeedCtorLink)
	TArray<class ATgRepInfo_Factory*>                  m_Factories;                                              // 0x02F4(0x0010) (NeedCtorLink)
	TArray<class ATgBotFactory_Minions*>               m_MinionFactories;                                        // 0x0304(0x0010) (NeedCtorLink)
	TArray<struct FTEAMTIMEMANAGER_ENTRY>              s_TeamTimerManagers;                                      // 0x0314(0x0010) (NeedCtorLink)
	class UTgMinimapManager*                           s_MinimapManager;                                         // 0x0324(0x0008)
	int                                                r_nScore;                                                 // 0x032C(0x0004) (Net)
	float                                              r_fTickets;                                               // 0x0330(0x0004) (Net)
	int                                                r_nPhaseTickets;                                          // 0x0334(0x0004) (Net)
	float                                              r_fSecondaryScore;                                        // 0x0338(0x0004) (Net)
	int                                                r_nScorePercent;                                          // 0x033C(0x0004) (Net)
	int                                                r_nGoldBuffCount;                                         // 0x0340(0x0004) (Net)
	float                                              r_fUltBuffPerc;                                           // 0x0344(0x0004) (Net)
	int                                                s_nGodVisionMask;                                         // 0x0348(0x0004)
	TArray<struct FGLOBALEFFECT_ENTRY>                 m_GlobalEffectGroups;                                     // 0x034C(0x0010) (NeedCtorLink)
	int                                                m_nTowersKilled;                                          // 0x035C(0x0004)
	int                                                m_nPhoenixCount;                                          // 0x0360(0x0004)
	int                                                r_nGodKillCount;                                          // 0x0364(0x0004)
	int                                                m_nLastGodIndex;                                          // 0x0368(0x0004)
	int                                                m_nLastGodList;                                           // 0x036C(0x0004)
	class ATgRespawnBeaconExit*                        r_RespawnBeaconExit;                                      // 0x0370(0x0008) (Net)
	int                                                c_nScoreOverride;                                         // 0x0378(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRepInfo_TaskForce");
		return ptr;
	}


	void PostTimeLapse(bool bPlayOfTheGame);
	TArray<struct FTGTEAM_ENTRY> STATIC_getTeamPlayers();
	void NotifyScoreChange();
	class ATgPlayerController* STATIC_FindLocalPlayerController();
	void STATIC_UpdateKismetOnScore();
	void ReplicatedEvent(const struct FName& VarName);
	void ReceivedTaskForceNumber();
	void ReceivedScoringChanges();
	bool STATIC_HasActivePlayers();
	void STATIC_RemoveFromTeam(class AController* Other);
	void CreateMinimap(TEnumAsByte<ETgMapTeam> Team, class UClass* managerClass);
	void PostDemoRewind();
	void PostInit();
	void STATIC_GetPlayersByDistance(const struct FVector& fromVector, float dwDist, TArray<class ATgRepInfo_Player*>* List);
	void GetPlayers(TArray<class ATgRepInfo_Player*>* List);
	int STATIC_GetNumAlivePlayers();
	bool STATIC_HasBot(class UClass* PawnClass);
	class ATgPawn* STATIC_GetASiegeWeapon();
	int STATIC_LaneOfSiegeWeapon();
	class ATgRepInfo_Player* STATIC_GetNextGod(bool bIncrement, bool bReset);
	void ResetGodIterator();
	class ATgRepInfo_Player* STATIC_GetGod(int nIndex);
	int STATIC_GetGodCount();
	void RemoveAllGlobalEffectGroups();
	void ReapplyGlobalEffectGroups();
	void RemoveGlobalEffectGroups(class ATgPawn_Character* aPawn);
	void ApplyGlobalEffectGroups(class ATgPawn_Character* aPawn);
	void RemoveGlobalEffectGroup(int nEffectGroupID);
	void AddGlobalEffectGroup(class UTgEffectGroup* eg, class ATgPawn* InstigatorPawn);
	void STATIC_UpdateSurrenderTimer();
	void TeamRemoveFrom(class AController* Other);
	bool STATIC_IsLeader(class ATgRepInfo_Player* pTgPri);
	class ATgBotFactory_Minions* STATIC_GetMinionFactory(int nIndex);
	class ATgRepInfo_Player* STATIC_GetBot(int nIndex);
	class ATgRepInfo_Player* STATIC_GetPlayerByPower(int nIndex);
	class ATgRepInfo_Player* STATIC_GetPlayerById(int nPawnId);
	struct FString STATIC_GetPlayerName(int nIndex);
	class ATgRepInfo_Player* STATIC_GetPlayer(int nIndex);
	int STATIC_GetMinionFactoryCount();
	int STATIC_GetBotCount();
	int STATIC_GetActivePlayerCount();
	int GetPlayerCount();
	bool RepEvent(const struct FName& VarName);
	class ATgRepInfo_Player* CycleFrom(class ATgRepInfo_Player* pFrom, bool bForward);
};


// Class TgGame.TgSurvivalFogVolumeDensityInfo
// 0x0028 (0x02BC - 0x0294)
class ATgSurvivalFogVolumeDensityInfo : public AFogVolumeSphericalDensityInfo
{
public:
	unsigned long                                      m_bFogOn : 1;                                             // 0x0294(0x0004)
	float                                              m_fTargetStartDistance;                                   // 0x0298(0x0004)
	float                                              m_fPreviousStartDistance;                                 // 0x029C(0x0004)
	float                                              m_fFogUpdateTimestamp;                                    // 0x02A0(0x0004)
	float                                              m_fFogUpdateInterval;                                     // 0x02A4(0x0004)
	float                                              m_fConvergenceRate;                                       // 0x02A8(0x0004)
	float                                              m_fFadeInRate;                                            // 0x02AC(0x0004)
	float                                              m_fFadeOutRate;                                           // 0x02B0(0x0004)
	class UFogVolumeSphericalDensityComponent*         SphericalDensityComponent;                                // 0x02B4(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSurvivalFogVolumeDensityInfo");
		return ptr;
	}


	void Tick(float DeltaTime);
	void ConvergeFog(float fNewStartDistance, float interval, bool bForce);
	void ToggleFog(bool bOn);
	void PostBeginPlay();
};


// Class TgGame.TgGamePhase
// 0x0058 (0x00B8 - 0x0060)
class UTgGamePhase : public UObject
{
public:
	float                                              m_fDuration;                                              // 0x0060(0x0004)
	float                                              m_fDurationTimer;                                         // 0x0064(0x0004)
	unsigned long                                      m_bPhaseReadyToEnd : 1;                                   // 0x0068(0x0004)
	unsigned long                                      m_bPhaseEnded : 1;                                        // 0x0068(0x0004)
	unsigned long                                      m_bLoop : 1;                                              // 0x0068(0x0004)
	unsigned long                                      m_bInstantaneous : 1;                                     // 0x0068(0x0004)
	unsigned long                                      m_bBroadcastTime : 1;                                     // 0x0068(0x0004)
	unsigned long                                      m_bSkipDecoratorPhases : 1;                               // 0x0068(0x0004)
	struct FString                                     m_name;                                                   // 0x006C(0x0010) (NeedCtorLink)
	class ATgGame_Paladins*                            m_parentGame;                                             // 0x007C(0x0008)
	class UTgGamePhase*                                m_parentPhase;                                            // 0x0084(0x0008)
	TArray<class UTgGamePhase*>                        m_childPhases;                                            // 0x008C(0x0010) (NeedCtorLink)
	TArray<class UTgGamePhase*>                        m_decoratorPhases;                                        // 0x009C(0x0010) (NeedCtorLink)
	class UTgGamePhase*                                m_CurrentPhase;                                           // 0x00AC(0x0008)
	int                                                m_nPersistentTextID;                                      // 0x00B4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase");
		return ptr;
	}


	class UTgGamePhase* STATIC_GetAncestorOfType(const struct FName& ClassName);
	void ClearTimer(const struct FName& TimerName, class UObject* callingObject);
	void STATIC_SetTimer(float fDuration, bool bLoop, const struct FName& TimerName, class UObject* callingObject);
	void SetPersistentText(int persistentTextID);
	float ModifyRespawnTime(float fRespawnTime);
	void LanePusherReachedBaseObjective(class ATgPawn_LanePusher* Lanepusher);
	void LanePusherReachedInnerWall(class ATgPawn_LanePusher* Lanepusher);
	void LanePusherReachedOuterWall(class ATgPawn_LanePusher* Lanepusher);
	void STATIC_OnCapturePointTick(class ATgChaosCapturePoint* CapturePoint, int nControllingTaskforce);
	void OnScoreChanged(int nTaskForce, int nCurrentScore);
	void STATIC_OnPawnRespawned(class ATgPawn* RespawningPawn);
	void OnPawnDied(class ATgPawn* Victim, class AController* Killer, class UClass* dmgType);
	struct FString GetPhaseValueText();
	void OnDurationEnd();
	void BroadcastTimer();
	void OnTick(float DeltaSeconds);
	void Tick(float DeltaSeconds);
	bool ShouldBroadcastTime();
	void STATIC_FlagPhaseAsOver();
	void STATIC_EndPhase();
	bool Active();
	void BeginPhase();
	bool STATIC_GoToNextPhase();
	bool ShouldYield();
	void StartPhase(class UTgGamePhase* NextPhase);
	void StartFirstPhase();
	int STATIC_GetCurrentPhaseIndex();
	int STATIC_GetPhaseIndex(class UTgGamePhase* Phase);
	bool STATIC_IsAggregatePhase();
	void PostPhaseSetup();
	void Decorate(class UTgGamePhase* Phase);
	void AddPhase(class UTgGamePhase* Phase);
	void STATIC_SetParent(class UTgGamePhase* Phase);
	void SetParentGame(class ATgGame_Paladins* Parent);
};


// Class TgGame.TgGamePhase_ApplyGlobalEffect
// 0x000C (0x00C4 - 0x00B8)
class UTgGamePhase_ApplyGlobalEffect : public UTgGamePhase
{
public:
	int                                                m_nFireModeID;                                            // 0x00B8(0x0004)
	class UTgDeviceFire*                               m_FireMode;                                               // 0x00BC(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_ApplyGlobalEffect");
		return ptr;
	}


	void STATIC_OnPawnRespawned(class ATgPawn* RespawningPawn);
	void STATIC_EndPhase();
	void BeginPhase();
	void SetupFireMode();
};


// Class TgGame.TgGamePhase_Bombardment
// 0x0038 (0x00F0 - 0x00B8)
class UTgGamePhase_Bombardment : public UTgGamePhase
{
public:
	float                                              m_fBombardmentZ;                                          // 0x00B8(0x0004)
	struct FVector                                     m_vBombardmentCenter;                                     // 0x00BC(0x000C)
	float                                              m_fBombardmentRadius;                                     // 0x00C8(0x0004)
	float                                              m_fBombardmentInnerRadius;                                // 0x00CC(0x0004)
	int                                                m_nFireModeID;                                            // 0x00D0(0x0004)
	float                                              m_fBombardmentDelay;                                      // 0x00D4(0x0004)
	float                                              m_fBombardmentRate;                                       // 0x00D8(0x0004)
	class UTgDeviceFire*                               m_FireMode;                                               // 0x00DC(0x0008)
	struct FVector                                     m_vCachedEndpoint;                                        // 0x00E4(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_Bombardment");
		return ptr;
	}


	void STATIC_EndPhase();
	void BombardmentTimer();
	void BombardmentDelay();
	void BeginPhase();
	void STATIC_GetEndpoint(const struct FVector& vStart, const struct FVector& vDirection, float fDist);
	void SetupFireMode();
};


// Class TgGame.TgGamePhase_ManageCapturePoint
// 0x0004 (0x00BC - 0x00B8)
class UTgGamePhase_ManageCapturePoint : public UTgGamePhase
{
public:
	float                                              m_fTickStep;                                              // 0x00B8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_ManageCapturePoint");
		return ptr;
	}


	void ManageCapturePointScore();
	void STATIC_EndPhase();
	void BeginPhase();
	void TrackStats(class ATgChaosCapturePoint* CapturePoint);
};


// Class TgGame.TgGamePhase_RandomlySpawnCreditCaches
// 0x0008 (0x00C0 - 0x00B8)
class UTgGamePhase_RandomlySpawnCreditCaches : public UTgGamePhase
{
public:
	float                                              m_fSpawnPeriod;                                           // 0x00B8(0x0004)
	float                                              m_fSpawnTimer;                                            // 0x00BC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_RandomlySpawnCreditCaches");
		return ptr;
	}


	void STATIC_EndPhase();
	void ActivateRandomCreditCache();
	void OnTick(float DeltaSeconds);
	void BeginPhase();
	void NotifyPlayersOfCreditCacheSpawn();
};


// Class TgGame.TgGamePhase_SendMessageToClients
// 0x0004 (0x00BC - 0x00B8)
class UTgGamePhase_SendMessageToClients : public UTgGamePhase
{
public:
	int                                                m_nMsgId;                                                 // 0x00B8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_SendMessageToClients");
		return ptr;
	}


	void BeginPhase();
	void STATIC_SendMessage();
};


// Class TgGame.TgAchievement
// 0x0034 (0x0094 - 0x0060)
class UTgAchievement : public UObject
{
public:
	class ATgPlayerController*                         Controller;                                               // 0x0060(0x0008)
	unsigned long                                      m_bCustomValue3IsBotId : 1;                               // 0x0068(0x0004) (Const)
	unsigned long                                      m_bAwardsAllowTriggering : 1;                             // 0x0068(0x0004)
	unsigned long                                      m_bIsTickable : 1;                                        // 0x0068(0x0004)
	int                                                m_nBotId;                                                 // 0x006C(0x0004)
	int                                                m_nActivityId;                                            // 0x0070(0x0004)
	int                                                m_nGoalId;                                                // 0x0074(0x0004)
	int                                                m_nCustomValue1;                                          // 0x0078(0x0004)
	int                                                m_nCustomValue2;                                          // 0x007C(0x0004)
	int                                                m_nCustomValue3;                                          // 0x0080(0x0004)
	int                                                m_nCustomValue4;                                          // 0x0084(0x0004)
	int                                                m_nCustomValue5;                                          // 0x0088(0x0004)
	int                                                m_nCurrentProgress;                                       // 0x008C(0x0004)
	int                                                m_nCurrentTarget;                                         // 0x0090(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement");
		return ptr;
	}


	void StopTracking();
	bool STATIC_PassesAsDevice(int nIncomingDeviceID, int nExpectedDeviceID, int nFireMode);
	bool BelongsToBot(int BotId);
	float STATIC_GetCustomValue5();
	float STATIC_GetCustomValue4();
	float STATIC_GetCustomValue3();
	float STATIC_GetCustomValue2();
	float STATIC_GetCustomValue1();
};


// Class TgGame.TgAchievement_AbyssalEchoKill
// 0x0000 (0x0094 - 0x0094)
class UTgAchievement_AbyssalEchoKill : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_AbyssalEchoKill");
		return ptr;
	}

};


// Class TgGame.TgAchievement_AirborneDuration
// 0x0008 (0x009C - 0x0094)
class UTgAchievement_AirborneDuration : public UTgAchievement
{
public:
	unsigned long                                      m_bAirborne : 1;                                          // 0x0094(0x0004)
	float                                              m_fAirborneStartTime;                                     // 0x0098(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_AirborneDuration");
		return ptr;
	}

};


// Class TgGame.TgAchievement_BetweenTheEyes
// 0x0000 (0x0094 - 0x0094)
class UTgAchievement_BetweenTheEyes : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_BetweenTheEyes");
		return ptr;
	}

};


// Class TgGame.TgAchievement_BigSpender
// 0x0000 (0x0094 - 0x0094)
class UTgAchievement_BigSpender : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_BigSpender");
		return ptr;
	}

};


// Class TgGame.TgAchievement_BulletSponge
// 0x0004 (0x0098 - 0x0094)
class UTgAchievement_BulletSponge : public UTgAchievement
{
public:
	int                                                m_nDamageShielded;                                        // 0x0094(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_BulletSponge");
		return ptr;
	}

};


// Class TgGame.TgAchievement_CaptureSiegeObjective
// 0x0000 (0x0094 - 0x0094)
class UTgAchievement_CaptureSiegeObjective : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_CaptureSiegeObjective");
		return ptr;
	}

};


// Class TgGame.TgAchievement_ChampionKill
// 0x0000 (0x0094 - 0x0094)
class UTgAchievement_ChampionKill : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_ChampionKill");
		return ptr;
	}

};


// Class TgGame.TgAchievement_ChampionPOTG
// 0x0000 (0x0094 - 0x0094)
class UTgAchievement_ChampionPOTG : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_ChampionPOTG");
		return ptr;
	}

};


// Class TgGame.TgAchievement_CounterAirDefense
// 0x0000 (0x0094 - 0x0094)
class UTgAchievement_CounterAirDefense : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_CounterAirDefense");
		return ptr;
	}

};


// Class TgGame.TgAchievement_Damage
// 0x0004 (0x0098 - 0x0094)
class UTgAchievement_Damage : public UTgAchievement
{
public:
	float                                              m_fDamageDealt;                                           // 0x0094(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Damage");
		return ptr;
	}

};


// Class TgGame.TgAchievement_DeviceDamage
// 0x0004 (0x0098 - 0x0094)
class UTgAchievement_DeviceDamage : public UTgAchievement
{
public:
	float                                              m_fDamageDealt;                                           // 0x0094(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_DeviceDamage");
		return ptr;
	}

};


// Class TgGame.TgAchievement_DeviceFire
// 0x0000 (0x0094 - 0x0094)
class UTgAchievement_DeviceFire : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_DeviceFire");
		return ptr;
	}

};


// Class TgGame.TgAchievement_DeviceFireGlobalSeconds
// 0x0008 (0x009C - 0x0094)
class UTgAchievement_DeviceFireGlobalSeconds : public UTgAchievement
{
public:
	float                                              m_fStartTime;                                             // 0x0094(0x0004)
	float                                              m_fAccumulatedDuration;                                   // 0x0098(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_DeviceFireGlobalSeconds");
		return ptr;
	}

};


// Class TgGame.TgAchievement_DeviceFireSecondsOneMatch
// 0x0008 (0x009C - 0x0094)
class UTgAchievement_DeviceFireSecondsOneMatch : public UTgAchievement
{
public:
	float                                              m_fStartTime;                                             // 0x0094(0x0004)
	int                                                m_fAccumulatedDuration;                                   // 0x0098(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_DeviceFireSecondsOneMatch");
		return ptr;
	}

};


// Class TgGame.TgAchievement_DeviceHealing
// 0x0004 (0x0098 - 0x0094)
class UTgAchievement_DeviceHealing : public UTgAchievement
{
public:
	int                                                m_nHealingDealt;                                          // 0x0094(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_DeviceHealing");
		return ptr;
	}

};


// Class TgGame.TgAchievement_DeviceHealingNotIncludingSelf
// 0x0000 (0x0098 - 0x0098)
class UTgAchievement_DeviceHealingNotIncludingSelf : public UTgAchievement_DeviceHealing
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_DeviceHealingNotIncludingSelf");
		return ptr;
	}

};


// Class TgGame.TgAchievement_DeviceHitCombo
// 0x0010 (0x00A4 - 0x0094)
class UTgAchievement_DeviceHitCombo : public UTgAchievement
{
public:
	TArray<struct FDeviceHitComboEntry>                m_Entries;                                                // 0x0094(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_DeviceHitCombo");
		return ptr;
	}

};


// Class TgGame.TgAchievement_DoubleKill
// 0x0000 (0x0094 - 0x0094)
class UTgAchievement_DoubleKill : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_DoubleKill");
		return ptr;
	}

};


// Class TgGame.TgAchievement_EmoteAfterKillWithChampion
// 0x0004 (0x0098 - 0x0094)
class UTgAchievement_EmoteAfterKillWithChampion : public UTgAchievement
{
public:
	float                                              m_fKillTime;                                              // 0x0094(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_EmoteAfterKillWithChampion");
		return ptr;
	}

};


// Class TgGame.TgAchievement_EmoteInMatch
// 0x0000 (0x0094 - 0x0094)
class UTgAchievement_EmoteInMatch : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_EmoteInMatch");
		return ptr;
	}

};


// Class TgGame.TgAchievement_EnvironmentalDeath
// 0x0000 (0x0094 - 0x0094)
class UTgAchievement_EnvironmentalDeath : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_EnvironmentalDeath");
		return ptr;
	}

};


// Class TgGame.TgAchievement_ExpendAmmo
// 0x0000 (0x0094 - 0x0094)
class UTgAchievement_ExpendAmmo : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_ExpendAmmo");
		return ptr;
	}

};


// Class TgGame.TgAchievement_FastDamage
// 0x0014 (0x00A8 - 0x0094)
class UTgAchievement_FastDamage : public UTgAchievement
{
public:
	TArray<struct FFastDamageEntry>                    m_DamageEntries;                                          // 0x0094(0x0010) (NeedCtorLink)
	int                                                m_nCurrentDamageTotal;                                    // 0x00A4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_FastDamage");
		return ptr;
	}

};


// Class TgGame.TgAchievement_FastHealDifferentPlayers
// 0x0010 (0x00A4 - 0x0094)
class UTgAchievement_FastHealDifferentPlayers : public UTgAchievement
{
public:
	TArray<struct FFastHealDifferentPlayersEntry>      m_HealEntries;                                            // 0x0094(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_FastHealDifferentPlayers");
		return ptr;
	}

};


// Class TgGame.TgAchievement_FastKillSequence
// 0x0010 (0x00A4 - 0x0094)
class UTgAchievement_FastKillSequence : public UTgAchievement
{
public:
	TArray<float>                                      m_fKillTimes;                                             // 0x0094(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_FastKillSequence");
		return ptr;
	}

};


// Class TgGame.TgAchievement_FirstClass
// 0x0000 (0x0094 - 0x0094)
class UTgAchievement_FirstClass : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_FirstClass");
		return ptr;
	}

};


// Class TgGame.TgAchievement_FromTheGrave
// 0x0004 (0x0098 - 0x0094)
class UTgAchievement_FromTheGrave : public UTgAchievement
{
public:
	int                                                KillerPawnId;                                             // 0x0094(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_FromTheGrave");
		return ptr;
	}

};


// Class TgGame.TgAchievement_GetEliminationsWithChampion
// 0x0000 (0x0094 - 0x0094)
class UTgAchievement_GetEliminationsWithChampion : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_GetEliminationsWithChampion");
		return ptr;
	}

};


// Class TgGame.TgAchievement_GlobalDamage
// 0x0000 (0x0094 - 0x0094)
class UTgAchievement_GlobalDamage : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_GlobalDamage");
		return ptr;
	}

};


// Class TgGame.TgAchievement_GlobalDeviceDamage
// 0x0000 (0x0094 - 0x0094)
class UTgAchievement_GlobalDeviceDamage : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_GlobalDeviceDamage");
		return ptr;
	}

};


// Class TgGame.TgAchievement_GlobalDeviceHealing
// 0x0000 (0x0094 - 0x0094)
class UTgAchievement_GlobalDeviceHealing : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_GlobalDeviceHealing");
		return ptr;
	}

};


// Class TgGame.TgAchievement_GlobalHealing
// 0x0000 (0x0094 - 0x0094)
class UTgAchievement_GlobalHealing : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_GlobalHealing");
		return ptr;
	}

};


// Class TgGame.TgAchievement_GlobalPetTimer
// 0x0008 (0x009C - 0x0094)
class UTgAchievement_GlobalPetTimer : public UTgAchievement
{
public:
	int                                                m_nNumLivePets;                                           // 0x0094(0x0004)
	float                                              m_fStartTime;                                             // 0x0098(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_GlobalPetTimer");
		return ptr;
	}

};


// Class TgGame.TgAchievement_GlobalShielding
// 0x0000 (0x0094 - 0x0094)
class UTgAchievement_GlobalShielding : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_GlobalShielding");
		return ptr;
	}

};


// Class TgGame.TgAchievement_HardCarry
// 0x0004 (0x0098 - 0x0094)
class UTgAchievement_HardCarry : public UTgAchievement
{
public:
	int                                                nKills;                                                   // 0x0094(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_HardCarry");
		return ptr;
	}

};


// Class TgGame.TgAchievement_Headshot
// 0x0004 (0x0098 - 0x0094)
class UTgAchievement_Headshot : public UTgAchievement
{
public:
	int                                                m_nHeadshotsWithoutMissing;                               // 0x0094(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Headshot");
		return ptr;
	}


	int STATIC_IsValidChampion(int nChampionID);
};


// Class TgGame.TgAchievement_HealAtThreshold
// 0x0000 (0x0094 - 0x0094)
class UTgAchievement_HealAtThreshold : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_HealAtThreshold");
		return ptr;
	}

};


// Class TgGame.TgAchievement_HealInOneMatch
// 0x0004 (0x0098 - 0x0094)
class UTgAchievement_HealInOneMatch : public UTgAchievement
{
public:
	int                                                m_nHealingDealt;                                          // 0x0094(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_HealInOneMatch");
		return ptr;
	}

};


// Class TgGame.TgAchievement_HitUniqueWithDeviceInvocation
// 0x0014 (0x00A8 - 0x0094)
class UTgAchievement_HitUniqueWithDeviceInvocation : public UTgAchievement
{
public:
	unsigned long                                      m_bReachedTargetCount : 1;                                // 0x0094(0x0004)
	TArray<class ATgPawn_Character*>                   m_HitTargets;                                             // 0x0098(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_HitUniqueWithDeviceInvocation");
		return ptr;
	}

};


// Class TgGame.TgAchievement_HitOrHitSpecialUniqueWithDeviceInvocation
// 0x0000 (0x00A8 - 0x00A8)
class UTgAchievement_HitOrHitSpecialUniqueWithDeviceInvocation : public UTgAchievement_HitUniqueWithDeviceInvocation
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_HitOrHitSpecialUniqueWithDeviceInvocation");
		return ptr;
	}

};


// Class TgGame.TgAchievement_KillAfterDevice
// 0x0048 (0x00DC - 0x0094)
class UTgAchievement_KillAfterDevice : public UTgAchievement
{
public:
	struct FMap_Mirror                                 m_mlastHits;                                              // 0x0094(0x0048) (Native)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_KillAfterDevice");
		return ptr;
	}

};


// Class TgGame.TgAchievement_KillAfterRoundEnd
// 0x0000 (0x0094 - 0x0094)
class UTgAchievement_KillAfterRoundEnd : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_KillAfterRoundEnd");
		return ptr;
	}

};


// Class TgGame.TgAchievement_KillByRole
// 0x0000 (0x0094 - 0x0094)
class UTgAchievement_KillByRole : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_KillByRole");
		return ptr;
	}

};


// Class TgGame.TgAchievement_KillChampion
// 0x0000 (0x0094 - 0x0094)
class UTgAchievement_KillChampion : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_KillChampion");
		return ptr;
	}

};


// Class TgGame.TgAchievement_KillDuringAbility
// 0x0008 (0x009C - 0x0094)
class UTgAchievement_KillDuringAbility : public UTgAchievement
{
public:
	class ATgDevice*                                   m_CachedDevice;                                           // 0x0094(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_KillDuringAbility");
		return ptr;
	}

};


// Class TgGame.TgAchievement_KillDuringDeviceInvocation
// 0x0010 (0x00A4 - 0x0094)
class UTgAchievement_KillDuringDeviceInvocation : public UTgAchievement
{
public:
	class ATgDevice*                                   m_CachedDevice;                                           // 0x0094(0x0008)
	unsigned long                                      m_bFiring : 1;                                            // 0x009C(0x0004)
	unsigned long                                      m_bKillThresholdReachedThisInvocation : 1;                // 0x009C(0x0004)
	int                                                m_nKillsOccurredThisInvocation;                           // 0x00A0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_KillDuringDeviceInvocation");
		return ptr;
	}

};


// Class TgGame.TgAchievement_KillEndStreak
// 0x0000 (0x0094 - 0x0094)
class UTgAchievement_KillEndStreak : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_KillEndStreak");
		return ptr;
	}

};


// Class TgGame.TgAchievement_KillFromLowHealth
// 0x0000 (0x0094 - 0x0094)
class UTgAchievement_KillFromLowHealth : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_KillFromLowHealth");
		return ptr;
	}

};


// Class TgGame.TgAchievement_KillWithAbility
// 0x0000 (0x0094 - 0x0094)
class UTgAchievement_KillWithAbility : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_KillWithAbility");
		return ptr;
	}

};


// Class TgGame.TgAchievement_KillWithChampionInhand
// 0x0000 (0x0094 - 0x0094)
class UTgAchievement_KillWithChampionInhand : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_KillWithChampionInhand");
		return ptr;
	}

};


// Class TgGame.TgAchievement_KillWithCombo
// 0x0010 (0x00A4 - 0x0094)
class UTgAchievement_KillWithCombo : public UTgAchievement
{
public:
	TArray<struct FKillWithComboEntry>                 m_Entries;                                                // 0x0094(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_KillWithCombo");
		return ptr;
	}

};


// Class TgGame.TgAchievement_KillWithComboAny
// 0x0014 (0x00A8 - 0x0094)
class UTgAchievement_KillWithComboAny : public UTgAchievement
{
public:
	float                                              fTime;                                                    // 0x0094(0x0004)
	TArray<float>                                      m_Entries;                                                // 0x0098(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_KillWithComboAny");
		return ptr;
	}

};


// Class TgGame.TgAchievement_LastOneStanding
// 0x0000 (0x0094 - 0x0094)
class UTgAchievement_LastOneStanding : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_LastOneStanding");
		return ptr;
	}

};


// Class TgGame.TgAchievement_MaldambaSpecificChallenge
// 0x0018 (0x00AC - 0x0094)
class UTgAchievement_MaldambaSpecificChallenge : public UTgAchievement
{
public:
	int                                                m_nDreadSerpentID;                                        // 0x0094(0x0004)
	int                                                m_nSlitherID;                                             // 0x0098(0x0004)
	TArray<struct FMaldambaSpecificChallengeEntry>     m_Entries;                                                // 0x009C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_MaldambaSpecificChallenge");
		return ptr;
	}

};


// Class TgGame.TgAchievement_MitigateDuringAbility
// 0x0008 (0x009C - 0x0094)
class UTgAchievement_MitigateDuringAbility : public UTgAchievement
{
public:
	class ATgDevice*                                   m_CachedDevice;                                           // 0x0094(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_MitigateDuringAbility");
		return ptr;
	}

};


// Class TgGame.TgAchievement_MultiKill
// 0x0000 (0x0094 - 0x0094)
class UTgAchievement_MultiKill : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_MultiKill");
		return ptr;
	}

};


// Class TgGame.TgAchievement_MultiKillAsChampion
// 0x0000 (0x0094 - 0x0094)
class UTgAchievement_MultiKillAsChampion : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_MultiKillAsChampion");
		return ptr;
	}

};


// Class TgGame.TgAchievement_PlayWithTalent
// 0x0000 (0x0094 - 0x0094)
class UTgAchievement_PlayWithTalent : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_PlayWithTalent");
		return ptr;
	}

};


// Class TgGame.TgAchievement_QuestionsLater
// 0x0014 (0x00A8 - 0x0094)
class UTgAchievement_QuestionsLater : public UTgAchievement
{
public:
	unsigned long                                      bTakenDamageYet : 1;                                      // 0x0094(0x0004)
	unsigned long                                      bHasHitAllEnemies : 1;                                    // 0x0094(0x0004)
	TArray<int>                                        EnemyPawnsHit;                                            // 0x0098(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_QuestionsLater");
		return ptr;
	}

};


// Class TgGame.TgAchievement_ShieldForDuration
// 0x0004 (0x0098 - 0x0094)
class UTgAchievement_ShieldForDuration : public UTgAchievement
{
public:
	float                                              m_fStartFireTime;                                         // 0x0094(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_ShieldForDuration");
		return ptr;
	}

};


// Class TgGame.TgAchievement_ShieldInOneMatch
// 0x0004 (0x0098 - 0x0094)
class UTgAchievement_ShieldInOneMatch : public UTgAchievement
{
public:
	int                                                m_nDamageShielded;                                        // 0x0094(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_ShieldInOneMatch");
		return ptr;
	}

};


// Class TgGame.TgAchievement_Showoff
// 0x0000 (0x0094 - 0x0094)
class UTgAchievement_Showoff : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Showoff");
		return ptr;
	}

};


// Class TgGame.TgAchievement_Sniper
// 0x0000 (0x0094 - 0x0094)
class UTgAchievement_Sniper : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Sniper");
		return ptr;
	}

};


// Class TgGame.TgAchievement_SpeakYourMind
// 0x0000 (0x0094 - 0x0094)
class UTgAchievement_SpeakYourMind : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_SpeakYourMind");
		return ptr;
	}

};


// Class TgGame.TgAchievement_SprayAfterKilling
// 0x0004 (0x0098 - 0x0094)
class UTgAchievement_SprayAfterKilling : public UTgAchievement
{
public:
	float                                              m_fKillTime;                                              // 0x0094(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_SprayAfterKilling");
		return ptr;
	}

};


// Class TgGame.TgAchievement_SprayInMatch
// 0x0000 (0x0094 - 0x0094)
class UTgAchievement_SprayInMatch : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_SprayInMatch");
		return ptr;
	}

};


// Class TgGame.TgAchievement_StunEnemies
// 0x0014 (0x00A8 - 0x0094)
class UTgAchievement_StunEnemies : public UTgAchievement
{
public:
	unsigned long                                      m_bReachedTargetCount : 1;                                // 0x0094(0x0004)
	TArray<class ATgPawn*>                             m_HitTargets;                                             // 0x0098(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_StunEnemies");
		return ptr;
	}

};


// Class TgGame.TgAchievement_SurgeonGeneral
// 0x0004 (0x0098 - 0x0094)
class UTgAchievement_SurgeonGeneral : public UTgAchievement
{
public:
	int                                                m_nHealing;                                               // 0x0094(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_SurgeonGeneral");
		return ptr;
	}

};


// Class TgGame.TgAchievement_Survivor
// 0x0000 (0x0094 - 0x0094)
class UTgAchievement_Survivor : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Survivor");
		return ptr;
	}

};


// Class TgGame.TgAchievement_TravelDistanceChampion
// 0x0020 (0x00B4 - 0x0094)
class UTgAchievement_TravelDistanceChampion : public UTgAchievement
{
public:
	float                                              m_fThrowAwayDistance;                                     // 0x0094(0x0004)
	float                                              m_fAccumulationDuration;                                  // 0x0098(0x0004)
	struct FVector                                     m_vLastPosition;                                          // 0x009C(0x000C)
	unsigned long                                      m_bStarted : 1;                                           // 0x00A8(0x0004)
	float                                              m_fAccumulatedTravelDistance;                             // 0x00AC(0x0004)
	float                                              m_fAccumulationTimer;                                     // 0x00B0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_TravelDistanceChampion");
		return ptr;
	}

};


// Class TgGame.TgAchievement_Unstoppable
// 0x0004 (0x0098 - 0x0094)
class UTgAchievement_Unstoppable : public UTgAchievement
{
public:
	unsigned long                                      m_bReachedKillstreak : 1;                                 // 0x0094(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Unstoppable");
		return ptr;
	}

};


// Class TgGame.TgAchievement_UseDeviceWithSkin
// 0x0000 (0x0094 - 0x0094)
class UTgAchievement_UseDeviceWithSkin : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_UseDeviceWithSkin");
		return ptr;
	}

};


// Class TgGame.TgAchievement_Wanderer
// 0x0014 (0x00A8 - 0x0094)
class UTgAchievement_Wanderer : public UTgAchievement
{
public:
	struct FVector                                     m_vLastPlayerLocation;                                    // 0x0094(0x000C)
	unsigned long                                      m_bLastLocationValid : 1;                                 // 0x00A0(0x0004)
	float                                              m_fResidualDistance;                                      // 0x00A4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Wanderer");
		return ptr;
	}

};


// Class TgGame.TgDeploy_Reversal
// 0x0030 (0x04A0 - 0x0470)
class ATgDeploy_Reversal : public ATgDeploy_Shield
{
public:
	int                                                m_nLargeMeshID;                                           // 0x0470(0x0004)
	class UMeshComponent*                              m_SmallMesh;                                              // 0x0474(0x0008) (ExportObject, Component, EditInline)
	class UMeshComponent*                              m_LargeMesh;                                              // 0x047C(0x0008) (ExportObject, Component, EditInline)
	float                                              r_fVengeanceDamage;                                       // 0x0484(0x0004) (Net)
	float                                              r_fAccumulatedDamage;                                     // 0x0488(0x0004) (Net)
	float                                              r_fMinimumDamage;                                         // 0x048C(0x0004) (Net)
	class ATgPawn*                                     m_CachedPawnOwner;                                        // 0x0490(0x0008)
	class UTgDeviceForm_Reversal*                      m_ReversalForm;                                           // 0x0498(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Reversal");
		return ptr;
	}


	void TakeDamage(int Damage, class AController* EventInstigator, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void DestroyIt(bool bSkipFx);
	void ReplicatedEvent(const struct FName& VarName);
	bool BenefitsFromPctShieldIncrease();
	void ToggleLargeMesh();
	void SendDamageToDevice();
	void ScaleFXByDamage();
	void MitigateHealthDamage(class ATgPawn* pInstigator, class UTgEffectDamage* Effect, const struct FImpactInfo& Impact, bool bIsHeadshot, float* NewValue, float* fPercReduction, unsigned char* bWasCapped);
};


// Class TgGame.TgDevice_AccursedArmGun
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_AccursedArmGun : public ATgDevice
{
public:
	class ATgDevice_AccursedArm*                       m_AccursedArm;                                            // 0x0A0C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_AccursedArmGun");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
	void STATIC_FireAmmunition();
	bool CanFireIfLeftMouseDown();
	bool ShouldTreatAmmoAsCharges();
	bool RequiresAmmoToFire();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgDevice_AndroLeg2
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_AndroLeg2 : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_AndroLeg2");
		return ptr;
	}

};


// Class TgGame.TgDevice_AndroxusInhand
// 0x000C (0x0A18 - 0x0A0C)
class ATgDevice_AndroxusInhand : public ATgDevice
{
public:
	int                                                m_nAndroLeg2StackCount;                                   // 0x0A0C(0x0004)
	float                                              m_fQueueFireTime;                                         // 0x0A10(0x0004)
	float                                              m_fQueueFireTimeThreshold;                                // 0x0A14(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_AndroxusInhand");
		return ptr;
	}


	bool STATIC_InterceptLeftMousePressed(class ATgPlayerController* TgController);
	bool CanFireIfLeftMouseDown();
	class UTgGameplayCurvesSet* STATIC_GetShotSpreadTendencyCurvesSet();
};


// Class TgGame.TgDevice_NetherStep
// 0x0008 (0x0A90 - 0x0A88)
class ATgDevice_NetherStep : public ATgDevice_DoubleCharge
{
public:
	float                                              m_fLowGravTime;                                           // 0x0A88(0x0004)
	float                                              m_fLowGravMult;                                           // 0x0A8C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_NetherStep");
		return ptr;
	}


	bool CanFiringBeCanceledByReactivation();
	bool CanFiringBeCanceledByRightMouse();
	bool CanFiringBeCanceledByLeftMouse();
	int STATIC_GetTotalNumberOfShots();
	void SetFireMode(int nFireModeNum, bool ForceSet);
	bool ShouldInterruptStealth();
};


// Class TgGame.TgDevice_Defiance
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_Defiance : public ATgDevice
{
public:
	class ATgDevice_AndroxusInhand*                    m_CachedAndroxusInhand;                                   // 0x0A0C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Defiance");
		return ptr;
	}


	void StartCooldown(int nMode, float fCooldownTimeOverride);
	void DeviceAdjustDamage(int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
	bool STATIC_HasCachedAndroxusInhand();
};


// Class TgGame.TgDevice_AccursedArm
// 0x0000 (0x0A14 - 0x0A14)
class ATgDevice_AccursedArm : public ATgDevice_HitPulse
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_AccursedArm");
		return ptr;
	}


	void ServerForcePersistTimer();
	void ClientOnGunEmptied();
	void OnGunEmptied();
	bool ShouldConsumePowerPoolAfterFire();
	bool ShouldConsumePowerPoolOnStartFire();
	void PersistTimer();
	bool CanBeCanceled();
	bool ShouldInterruptStealth();
};


// Class TgGame.TgDevice_Reversal
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_Reversal : public ATgDevice
{
public:
	float                                              m_fAccumulatedDamage;                                     // 0x0A0C(0x0004)
	float                                              m_fVengeanceDamage;                                       // 0x0A10(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Reversal");
		return ptr;
	}


	void STATIC_InterruptFiringOnServerInternal(bool bSendClientInterrupt, bool bServerFireFailed);
	bool CanBeInterrupted();
	class AProjectile* ProjectileFire(int ProjectileIndex);
	float GetCurrentDamageAmount();
	class UTgDeviceFire* STATIC_GetFireModeForFiringProjectile();
	TEnumAsByte<EDeviceTargetMode> STATIC_GetTargetingMode();
	void STATIC_GetCachedAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_SleightOfHand
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_SleightOfHand : public ATgDevice
{
public:
	class ATgDevice*                                   m_InhandWeapon;                                           // 0x0A0C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_SleightOfHand");
		return ptr;
	}


	bool ShouldCooldownAfterFire();
	bool CanDeviceStartFiringNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDebugRelevant, bool bIgnoreCachedValue, TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgDeviceForm_AccursedArm
// 0x0024 (0x02B0 - 0x028C)
class UTgDeviceForm_AccursedArm : public UTgDeviceForm
{
public:
	unsigned long                                      m_bShouldBeActive : 1;                                    // 0x028C(0x0004)
	float                                              m_fActivationTime;                                        // 0x0290(0x0004)
	float                                              m_fCurrentActivationPercent;                              // 0x0294(0x0004)
	class UMaterialInterface*                          m_cachedWeaponMaterial;                                   // 0x0298(0x0008)
	class UMaterialInstanceConstant*                   m_accursedArmMaterial;                                    // 0x02A0(0x0008)
	struct FName                                       m_nmUltimateActive;                                       // 0x02A8(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_AccursedArm");
		return ptr;
	}


	void StopFire(int nFireModeNum);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	void CacheAccursedArmMaterial();
};


// Class TgGame.TgDeviceForm_Reversal
// 0x0034 (0x02C0 - 0x028C)
class UTgDeviceForm_Reversal : public UTgDeviceForm
{
public:
	float                                              m_fAccumulatedDamage;                                     // 0x028C(0x0004)
	float                                              m_fMaxChargeDamage;                                       // 0x0290(0x0004)
	class ATgEmitter_CameraEffect*                     c_CameraEffect;                                           // 0x0294(0x0008)
	TArray<class UTgAnimNodeBlendList*>                m_1pNodes;                                                // 0x029C(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeBlendList*>                m_3pNodes;                                                // 0x02AC(0x0010) (NeedCtorLink)
	unsigned long                                      m_bIsAbsorbingShots : 1;                                  // 0x02BC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Reversal");
		return ptr;
	}


	void DoInterrupt();
	void StopFire(int nFireModeNum);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	void UpdateAccumulatedDamage(float newDamage);
	void SetActiveChildren(TEnumAsByte<EBlendReversal> ChildIndex);
	void CacheAnimNode(class UAnimNode* Node, bool bIs3p);
	void ClearAnimNodes(bool bIs3p);
};


// Class TgGame.TgInvListener_AndroLeg2
// 0x0000 (0x00C4 - 0x00C4)
class UTgInvListener_AndroLeg2 : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_AndroLeg2");
		return ptr;
	}

};


// Class TgGame.TgInvListener_CursedCylinder
// 0x0000 (0x00C4 - 0x00C4)
class UTgInvListener_CursedCylinder : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_CursedCylinder");
		return ptr;
	}

};


// Class TgGame.TgPawn_Androxus
// 0x004C (0x3324 - 0x32D8)
class ATgPawn_Androxus : public ATgPawn_Character
{
public:
	unsigned long                                      m_bIsInSlowFall : 1;                                      // 0x32D8(0x0004)
	unsigned long                                      r_bIsInSlowFallSimulated : 1;                             // 0x32D8(0x0004) (Net)
	unsigned long                                      m_bForceAccursedArmDevice : 1;                            // 0x32D8(0x0004)
	unsigned long                                      r_bAccursedArmFiring : 1;                                 // 0x32D8(0x0004) (Net)
	unsigned long                                      m_bUltimateReadyDisplayGroupOn : 1;                       // 0x32D8(0x0004)
	float                                              m_fAccursedArmSpeedModifier;                              // 0x32DC(0x0004)
	class ATgDevice*                                   m_AccursedArmInHand;                                      // 0x32E0(0x0008)
	float                                              m_fDefianceAirControl;                                    // 0x32E8(0x0004)
	float                                              m_fAirHangGravityModifier;                                // 0x32EC(0x0004)
	float                                              m_fJumpHoldMaxFallSpeed;                                  // 0x32F0(0x0004)
	class ATgDevice_NetherStep*                        m_NetherStepDevice;                                       // 0x32F4(0x0008)
	float                                              r_fFeatherweightDamageReduction;                          // 0x32FC(0x0004) (Net)
	float                                              r_fLiftOffDrift;                                          // 0x3300(0x0004) (Net)
	int                                                m_nAccursedArmActiveFX;                                   // 0x3304(0x0004)
	TArray<class UTgAnimNodeBlendBySlowFall*>          m_SlowFallAnimNodes;                                      // 0x3308(0x0010) (NeedCtorLink)
	int                                                r_nDesiredSlowFallAnimChild;                              // 0x3318(0x0004) (Net)
	class UTgSpecialFx*                                m_SlowFallFX;                                             // 0x331C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Androxus");
		return ptr;
	}


	void Stun(bool bStunController, TEnumAsByte<EStunType> eType);
	void OnRespawn();
	bool Died(class AController* Killer, class UClass* dmgType, const struct FVector& HitLocation);
	void StopSlowFallFx();
	void PlaySlowFallFx();
	void SetTargetingDevice(class ATgDevice* Dev, const struct FWeaponMeshSwapStrategy& SwapStrategy);
	void PlayAccursedArmEffects(bool bEnabled);
	void ToggleAccursedArm(bool bEnabled, float SpeedModifier);
	void ApplyLiftOff();
	void SetSlowFallAnimationIndex(int nIndex);
	void CacheMultiMeshAnimNodeReferences(class UTgSkeletalMeshComponent* smcomp);
	bool PostPawnSetup();
	void ReplicatedEvent(const struct FName& VarName);
	void OnPawnDied();
	void STATIC_GetAdditionalDamageTakenMultipliers(class ATgDevice* damagingDevice, struct FDiminishedEffectInfo* DiminishingInfo, struct FImpactInfo* Impact);
	bool ShouldForceHideOverlaysWeapon();
	float GetGravityZ();
	float GetAirControl();
	bool STATIC_InitializeSlowFallFX();
};


// Class TgGame.TgDevice_AstralCycle
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_AstralCycle : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_AstralCycle");
		return ptr;
	}

};


// Class TgGame.TgDevice_AstroInhand
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_AstroInhand : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_AstroInhand");
		return ptr;
	}


	bool StartReload(bool bIgnoreCurrentAmmo);
};


// Class TgGame.TgDevice_AstroQ
// 0x0004 (0x0A10 - 0x0A0C)
class ATgDevice_AstroQ : public ATgDevice
{
public:
	unsigned long                                      m_bApplyCooldown : 1;                                     // 0x0A0C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_AstroQ");
		return ptr;
	}


	void OnInstantShotRejected(const struct FImpactToValidate& RejectedPrimaryImpact);
	bool ShouldCooldownAfterFire();
	void DeliverQueuedPendingHits();
	void InterruptFiring(bool bServerFireFailed);
	void STATIC_InterruptOtherDevices(class ATgPawn* TgP);
	void DeliverHit(const struct FImpactInfo& Impact);
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgDevice_CosmicGrace
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_CosmicGrace : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CosmicGrace");
		return ptr;
	}


	bool CanBeInterrupted();
};


// Class TgGame.TgDevice_DeadSpace
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_DeadSpace : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DeadSpace");
		return ptr;
	}

};


// Class TgGame.TgDevice_Lightspeed
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_Lightspeed : public ATgDevice
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_MoveSpeedMultiplier;           // 0x0A0C(0x0008) (Const, Native, NoExport)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Lightspeed");
		return ptr;
	}


	void CancelSafetyTimer();
	bool ShouldInterruptReloadOnFire();
	bool STATIC_InterceptSlotReleased(class ATgPlayerController* TgController);
	bool CanFiringBeCanceledByReactivation();
	bool CanBeInterrupted();
	bool CanBeCanceled();
	bool ShouldBlockReload(class ATgDevice* Dev, bool bIsAutoReload);
	bool ShouldInterruptLift();
	bool STATIC_ShouldUseGradualMovement();
	float STATIC_GetMoveSpeedMultiplier();
};


// Class TgGame.TgDevice_AstralMark
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_AstralMark : public ATgDevice_Mark
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_AstralMark");
		return ptr;
	}


	bool ShouldCooldownAfterFire();
	void DeliverHit(const struct FImpactInfo& Impact);
	void DeliverQueuedPendingHits();
	void STATIC_InterruptOtherDevices(class ATgPawn* TgP);
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgDevice_SpaceJam
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_SpaceJam : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_SpaceJam");
		return ptr;
	}

};


// Class TgGame.TgDevice_SpaceTime
// 0x0018 (0x0A24 - 0x0A0C)
class ATgDevice_SpaceTime : public ATgDevice
{
public:
	class ATgCollisionProxy_Mesh*                      m_BeamCollisionProxy;                                     // 0x0A0C(0x0008)
	TArray<class ATgPawn*>                             m_ActorsInRange;                                          // 0x0A14(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_SpaceTime");
		return ptr;
	}


	void DestroyCollisionProxy();
	void SpawnCollisionProxy();
	void ClearTouchedActors();
	void OnProxyUnTouch(class AActor* Other);
	void OnProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_FireAmmunition();
	void STATIC_InterruptOtherDevices(class ATgPawn* TgP);
	void STATIC_HandleDeviceFormStartFire(int nDeviceModeNum, float fRefireTime, struct FAimData* Aim);
	void DeliverHit(const struct FImpactInfo& Impact);
	bool ShouldStopActionOnOffhandSlotReleased();
	bool IsFunctionallyToggleDevice();
	bool CanBeCanceled();
};


// Class TgGame.TgDevice_StarSeeker
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_StarSeeker : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_StarSeeker");
		return ptr;
	}

};


// Class TgGame.TgDevice_Zodiac
// 0x0018 (0x0A24 - 0x0A0C)
class ATgDevice_Zodiac : public ATgDevice
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_MoveSpeedMultiplier;           // 0x0A0C(0x0008) (Const, Native, NoExport)
	TArray<float>                                      m_EffectRemainingTime;                                    // 0x0A14(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Zodiac");
		return ptr;
	}


	bool STATIC_ShouldUseGradualMovement();
	float STATIC_GetMoveSpeedMultiplier();
	bool CanBeInterrupted();
	void RemoveBuff();
	void ApplyBuff();
};


// Class TgGame.TgDeviceFire_AstralMark
// 0x000C (0x0274 - 0x0268)
class UTgDeviceFire_AstralMark : public UTgDeviceFire
{
public:
	float                                              m_InitialLifetime;                                        // 0x0268(0x0004)
	float                                              m_OverflowTime;                                           // 0x026C(0x0004)
	float                                              m_BaseLifetime;                                           // 0x0270(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_AstralMark");
		return ptr;
	}


	bool ApplyHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
	bool STATIC_IgnoreTargetForBlocking(class AActor* Target);
};


// Class TgGame.TgDeviceFire_SpaceTime
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_SpaceTime : public UTgDeviceFire_WorldLOSOnly
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_SpaceTime");
		return ptr;
	}


	struct FWeaponFireResults CalcActorEncroachmentTargetingFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, float RewindTime, TArray<struct FImpactInfo>* ImpactList, TArray<struct FImpactToValidate>* ImpactsToValidate);
};


// Class TgGame.TgDeviceForm_GravityLift
// 0x0000 (0x028C - 0x028C)
class UTgDeviceForm_GravityLift : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_GravityLift");
		return ptr;
	}


	void SetLockedForBlendNodes(bool bLocked);
};


// Class TgGame.TgInvListener_ExtendAstralMarks
// 0x0000 (0x00CC - 0x00CC)
class UTgInvListener_ExtendAstralMarks : public UTgInventoryObject_Listen_AbilityProcBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_ExtendAstralMarks");
		return ptr;
	}

};


// Class TgGame.TgInvListener_BinaryStar
// 0x0000 (0x00C4 - 0x00C4)
class UTgInvListener_BinaryStar : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_BinaryStar");
		return ptr;
	}

};


// Class TgGame.TgPawn_Astro
// 0x0074 (0x334C - 0x32D8)
class ATgPawn_Astro : public ATgPawn_Character
{
public:
	class ATgDevice_Lightspeed*                        m_LightSpeedDevice;                                       // 0x32D8(0x0008)
	class ATgDevice_AstroQ*                            m_GravityLiftDevice;                                      // 0x32E0(0x0008)
	class ATgDevice_AstralMark*                        m_AstralMarkDevice;                                       // 0x32E8(0x0008)
	class ATgDevice_AstralCycle*                       m_AstralCycleCard;                                        // 0x32F0(0x0008)
	class ATgDevice_StarSeeker*                        m_StarSeekerCard;                                         // 0x32F8(0x0008)
	class ATgPawn_Character*                           m_AstralTarget;                                           // 0x3300(0x0008)
	class ATgPawn_Character*                           m_GravityLiftTarget;                                      // 0x3308(0x0008)
	class ATgPawn_Character*                           m_HitGravityLiftTarget;                                   // 0x3310(0x0008)
	class ATgRepInfo_Player*                           r_HitAstralTarget;                                        // 0x3318(0x0008) (Net)
	class ATgRepInfo_Player*                           r_RemoveAstralTarget;                                     // 0x3320(0x0008) (Net)
	TArray<class ATgRepInfo_Player*>                   m_AstralMarkTargets;                                      // 0x3328(0x0010) (NeedCtorLink)
	float                                              m_fDeadSpaceTimer;                                        // 0x3338(0x0004)
	unsigned long                                      m_bDeadSpaceTimerActive : 1;                              // 0x333C(0x0004)
	struct FRotator                                    r_mUltimateAimRotation;                                   // 0x3340(0x000C) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Astro");
		return ptr;
	}


	void STATIC_GetCameraZoomOverride(float* fZoom, float* fZoomDuration);
	float STATIC_GetJumpSpeedMultiplier();
	void RemoveAstralMarkTarget();
	void AddAstralMarkTarget();
	float GetAirControl();
	float GetGravityZ();
	void STATIC_EffectGroupOnSetActive(bool bActive, bool bRemoving, class UTgEffectGroup* effectGroup);
	void STATIC_GlobalOnPlayerDied(class ATgPawn_Character* Player);
	bool CanKnockbackAffectAC();
	bool AllowBoostedJump();
	bool STATIC_HasDeviceCached(int DeviceID);
	void ReplicatedEvent(const struct FName& VarName);
};


// Class TgGame.TgPawnMod_FxAudio_EDMJenos
// 0x0004 (0x00B0 - 0x00AC)
class UTgPawnMod_FxAudio_EDMJenos : public UTgPawnMod_FxAudio
{
public:
	float                                              m_fGlowMultBass;                                          // 0x00AC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawnMod_FxAudio_EDMJenos");
		return ptr;
	}

};


// Class TgGame.TgDeploy_TurretEffectField
// 0x0018 (0x04B8 - 0x04A0)
class ATgDeploy_TurretEffectField : public ATgDeploy_EffectField
{
public:
	TArray<class AActor*>                              m_DeployTimePendingTargets;                               // 0x04A0(0x0010) (NeedCtorLink)
	class ATgPawn_Turret*                              m_ParentTurret;                                           // 0x04B0(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_TurretEffectField");
		return ptr;
	}


	void Tick(float DeltaSeconds);
	void OnProxyUnTouch(class AActor* Other);
	void OnProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void TouchAllPendingTargets();
};


// Class TgGame.TgDeploy_Epicenter
// 0x0000 (0x04B8 - 0x04B8)
class ATgDeploy_Epicenter : public ATgDeploy_TurretEffectField
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Epicenter");
		return ptr;
	}


	void OnProxyUnTouch(class AActor* Other);
};


// Class TgGame.TgDeploy_Expose
// 0x0000 (0x04B8 - 0x04B8)
class ATgDeploy_Expose : public ATgDeploy_TurretEffectField
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Expose");
		return ptr;
	}


	void STATIC_FireAmmunitionDeployable();
};


// Class TgGame.TgDeploy_Exhaust
// 0x0000 (0x0804 - 0x0804)
class ATgDeploy_Exhaust : public ATgDeploy_EffectTrail
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Exhaust");
		return ptr;
	}

};


// Class TgGame.TgDeploy_TurretLinked
// 0x0008 (0x0474 - 0x046C)
class ATgDeploy_TurretLinked : public ATgDeploy_MatchParentFireMode
{
public:
	class ATgPawn_Turret*                              m_ParentTurret;                                           // 0x046C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_TurretLinked");
		return ptr;
	}


	void Tick(float DeltaSeconds);
};


// Class TgGame.TgDeploy_ShieldBarik
// 0x001C (0x048C - 0x0470)
class ATgDeploy_ShieldBarik : public ATgDeploy_Shield
{
public:
	unsigned long                                      r_bHasCapsule : 1;                                        // 0x0470(0x0004) (Net)
	unsigned long                                      r_bHasAcceleratorField : 1;                               // 0x0470(0x0004) (Net)
	unsigned long                                      r_bHasImpede : 1;                                         // 0x0470(0x0004) (Net)
	unsigned long                                      r_bHasBunker : 1;                                         // 0x0470(0x0004) (Net)
	unsigned long                                      r_bHasFortify : 1;                                        // 0x0470(0x0004) (Net)
	TArray<class AActor*>                              m_AcceleratedActors;                                      // 0x0474(0x0010) (NeedCtorLink)
	class ATgPawn*                                     m_CachedPawnOwner;                                        // 0x0484(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_ShieldBarik");
		return ptr;
	}


	void OnHealthUpdated();
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool BenefitsFromPctShieldIncrease();
	void ReplicatedEvent(const struct FName& VarName);
	void ToggleLockdownMode(bool bSetActive);
	void ToggleFX();
};


// Class TgGame.TgDeploy_ShieldBarikDome
// 0x0004 (0x0474 - 0x0470)
class ATgDeploy_ShieldBarikDome : public ATgDeploy_Shield
{
public:
	float                                              m_fTurretSetupTime;                                       // 0x0470(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_ShieldBarikDome");
		return ptr;
	}


	void DestroyIt(bool bSkipFx);
	bool BenefitsFromPctShieldIncrease();
};


// Class TgGame.TgDevice_BarricadeDome
// 0x0010 (0x0A1C - 0x0A0C)
class ATgDevice_BarricadeDome : public ATgDevice
{
public:
	struct FVector                                     m_TurretSpawnLocation;                                    // 0x0A0C(0x000C)
	int                                                m_FlameTurretID;                                          // 0x0A18(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_BarricadeDome");
		return ptr;
	}


	void STATIC_InterruptOtherDevices(class ATgPawn* TgP);
	void STATIC_InitMaxHealth();
	int STATIC_GetPetIDOverride(int PetIndex);
	void STATIC_GetCachedAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_Fortify
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_Fortify : public ATgDevice_BarricadeMod
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Fortify");
		return ptr;
	}

};


// Class TgGame.TgDevice_RocketBoots
// 0x0000 (0x0A80 - 0x0A80)
class ATgDevice_RocketBoots : public ATgDevice_Charge
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_RocketBoots");
		return ptr;
	}


	bool CanBeCanceled();
	float GetChargeRange();
	float STATIC_GetChargeSpeed();
};


// Class TgGame.TgDevice_Failsafe
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_Failsafe : public ATgDevice
{
public:
	class ATgDevice*                                   m_RocketBootsDevice;                                      // 0x0A0C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Failsafe");
		return ptr;
	}


	bool ShouldCooldownAfterFire();
	bool StartFire();
};


// Class TgGame.TgDevice_Turret
// 0x001C (0x0A28 - 0x0A0C)
class ATgDevice_Turret : public ATgDevice_Pet
{
public:
	int                                                m_FlameTurretID;                                          // 0x0A0C(0x0004)
	int                                                m_MegaTurretID;                                           // 0x0A10(0x0004)
	int                                                m_LockdownTurretID;                                       // 0x0A14(0x0004)
	struct FVector                                     m_SpawnLocationOverride;                                  // 0x0A18(0x000C)
	unsigned long                                      m_bLockdownIsOn : 1;                                      // 0x0A24(0x0004)
	unsigned long                                      m_bHasFlamethrowerTurret : 1;                             // 0x0A24(0x0004)
	unsigned long                                      m_bHasMegaTurret : 1;                                     // 0x0A24(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Turret");
		return ptr;
	}


	void RevertFiremode();
	void ArmLockdownMode(bool bEnable);
	void ArmMegaTurretMode(bool bEnable);
	void ArmFlamethrowerMode(bool bEnable);
	void STATIC_InterruptOtherDevices(class ATgPawn* TgP);
	int STATIC_GetPetIDOverride(int PetIndex);
	void STATIC_GetCachedAim(struct FAimData* Aim);
	void ToggleLockdownMode();
	void STATIC_UpgradeActiveTurrets();
};


// Class TgGame.TgDeviceFire_BarricadeDome
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_BarricadeDome : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_BarricadeDome");
		return ptr;
	}


	class ATgPawn* SpawnPet(bool bPet);
};


// Class TgGame.TgDeviceFire_Lockdown
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_Lockdown : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Lockdown");
		return ptr;
	}


	class ATgPawn* SpawnPet(bool bPet);
};


// Class TgGame.TgDeviceFire_Turret
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_Turret : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Turret");
		return ptr;
	}


	class ATgPawn* SpawnPet(bool bPet);
};


// Class TgGame.TgDeviceFire_TurretShot
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_TurretShot : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_TurretShot");
		return ptr;
	}


	bool STATIC_IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth, bool bInvertTeam);
};


// Class TgGame.TgPawn_Barik
// 0x0008 (0x32E0 - 0x32D8)
class ATgPawn_Barik : public ATgPawn_Character
{
public:
	class ATgDevice*                                   m_CachedBurninate;                                        // 0x32D8(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Barik");
		return ptr;
	}


	bool STATIC_HasCachedBurninate();
	bool STATIC_CanSpawnScalableShields();
	void RequestEmote(TEnumAsByte<EEmote> Emote, int ExtraInfo, int nPriority, float fRelevance, float fPause);
	void ModifyAccuracyForReticleBloom(float* fAccuracy);
};


// Class TgGame.TgDeploy_GeometryBarrierTank
// 0x0040 (0x04D4 - 0x0494)
class ATgDeploy_GeometryBarrierTank : public ATgDeploy_Geometry
{
public:
	class ATgPawn_BarrierTank*                         m_CachedInaraPawn;                                        // 0x0494(0x0008)
	class UMeshComponent*                              m_CenterMesh;                                             // 0x049C(0x0008) (ExportObject, Component, EditInline)
	class UMeshComponent*                              m_LeftMeshes[0x2];                                        // 0x04A4(0x0008) (ExportObject, Component, EditInline)
	class UMeshComponent*                              m_RightMeshes[0x2];                                       // 0x04B4(0x0008) (ExportObject, Component, EditInline)
	int                                                m_WallMeshIDCenter;                                       // 0x04C4(0x0004)
	int                                                m_WallMeshIDEndCap;                                       // 0x04C8(0x0004)
	unsigned long                                      r_bGrowthModeActivationSignal : 1;                        // 0x04CC(0x0004) (Net)
	unsigned long                                      m_bInGrowthMode : 1;                                      // 0x04CC(0x0004)
	unsigned long                                      m_bDidInitialHit : 1;                                     // 0x04CC(0x0004)
	unsigned long                                      r_bEarthenGuardActive : 1;                                // 0x04CC(0x0004) (Net)
	unsigned long                                      r_bHasAlpine : 1;                                         // 0x04CC(0x0004) (Net)
	float                                              m_fGrowStartTime;                                         // 0x04D0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_GeometryBarrierTank");
		return ptr;
	}


	void DestroyIt(bool bSkipFx);
	void DeployComplete();
	void RemoveBasedPawn(class ATgPawn* basedPawn);
	void AddBasedPawn(class ATgPawn* basedPawn);
	void ReplicatedEvent(const struct FName& VarName);
	void ActivateDisplayGroups(const struct FName& DisplayGroup, bool bActivateIndependent, bool bTurnOn);
	bool STATIC_HasCachedInaraPawn();
	struct FVector STATIC_GetSegmentWorldLocation(const struct FVector& vLocalLocation);
	void PushOverlappingActors(float DeltaSeconds);
	void STATIC_DoInitialHit();
	void PushBasedActors();
	void ToggleGrowthMode(bool bTurnOn);
	void SignalGrowthModeStart();
	void STATIC_InitializeMeshSegment(class UMeshComponent* Mesh, float fOffset);
	void SpawnMeshSegments();
};


// Class TgGame.TgDeploy_WardersField
// 0x000C (0x04AC - 0x04A0)
class ATgDeploy_WardersField : public ATgDeploy_EffectField
{
public:
	float                                              r_fRadiusForFX;                                           // 0x04A0(0x0004) (Net)
	float                                              r_fRadiusScaleForDecal;                                   // 0x04A4(0x0004) (Net)
	unsigned long                                      r_bEarthenGuardActive : 1;                                // 0x04A8(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_WardersField");
		return ptr;
	}


	void ScaleAbilityFX();
	void ReplicatedEvent(const struct FName& VarName);
};


// Class TgGame.TgDevice_BarrierTankInhand
// 0x0038 (0x0A44 - 0x0A0C)
class ATgDevice_BarrierTankInhand : public ATgDevice
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_MoveSpeedMultiplier;           // 0x0A0C(0x0008) (Const, Native, NoExport)
	class ATgPawn_BarrierTank*                         m_CachedBarrierTankPawn;                                  // 0x0A14(0x0008)
	struct FVector                                     m_vProjectileSpawnOffset2;                                // 0x0A1C(0x000C)
	struct FVector                                     m_vProjectileSpawnOffset3;                                // 0x0A28(0x000C)
	struct FScriptDelegate                             __InterruptFiringDelegate__Delegate;                      // 0x0A34(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData00[0x4];                                       // 0x0A34(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_BarrierTankInhand");
		return ptr;
	}


	void SelfSlowTimer();
	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
	void InterruptFiringDelegate();
	void STATIC_InterruptLockoutTime();
	bool STATIC_HasCachedBarrierTankPawn();
	void SetAmmo(int AmmoCount, int ClipSize, bool bShouldValidate, int ValidationIDOverride);
	int STATIC_GetProjectileIDOverride(int ProjectileIndex);
	struct FVector GetProjectileSpawnOffset();
	bool STATIC_ShouldUseGradualMovement();
	float STATIC_GetMoveSpeedMultiplier();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgDevice_EarthenGuard
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_EarthenGuard : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_EarthenGuard");
		return ptr;
	}

};


// Class TgGame.TgDevice_GeometryBarrierTank
// 0x000C (0x0A18 - 0x0A0C)
class ATgDevice_GeometryBarrierTank : public ATgDevice
{
public:
	unsigned long                                      r_bHasTremorsEquipped : 1;                                // 0x0A0C(0x0004) (Net)
	float                                              r_fTremorsCooldownReduction;                              // 0x0A10(0x0004) (Net)
	float                                              m_fCachedWallHealthPercent;                               // 0x0A14(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_GeometryBarrierTank");
		return ptr;
	}


	bool CanBeCanceled();
	void OnDeployableDestroyed(class ATgDeployable* deployable);
	void OnDeployableSpawned(class ATgDeployable* deployable);
	bool CanFireWithoutAimResult();
	void ServerEndCustomTargeting();
	void EndCustomTargeting();
	bool STATIC_InterceptLeftMousePressed(class ATgPlayerController* TgController);
	bool STATIC_InterceptSlotReleased(class ATgPlayerController* TgController);
	bool STATIC_InterceptSlotPressed(class ATgPlayerController* TgController);
	void STATIC_UpdateTargetingModeStatus(struct FAimData* Aim);
	bool ShouldAltFireOnTick();
	void STATIC_GetGroundTargetAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_ImpasseMod
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_ImpasseMod : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ImpasseMod");
		return ptr;
	}

};


// Class TgGame.TgDevice_Alpine
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_Alpine : public ATgDevice_ImpasseMod
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Alpine");
		return ptr;
	}

};


// Class TgGame.TgDevice_WardersField
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_WardersField : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_WardersField");
		return ptr;
	}


	void OnDeployableDestroyed(class ATgDeployable* deployable);
	bool CanBeCanceled();
	bool STATIC_InterceptSlotPressed(class ATgPlayerController* TgController);
};


// Class TgGame.TgDeviceForm_GeometryBarrierTank
// 0x0000 (0x028C - 0x028C)
class UTgDeviceForm_GeometryBarrierTank : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_GeometryBarrierTank");
		return ptr;
	}


	void STATIC_UpdateTargetingModeStatusForFX(class UTgSpecialFx* Fx, TEnumAsByte<ETargetingModeStatus> Status, struct FAimData* Aim);
	void STATIC_UpdateTargetingModeLocation(const struct FVector& NewLocation, const struct FRotator& NewRotation, float DistanceScale);
};


// Class TgGame.TgInvListener_Tremors
// 0x0000 (0x00C8 - 0x00C8)
class UTgInvListener_Tremors : public UTgInventoryObject_Listen_ActiveWhileOffCooldown
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_Tremors");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_EarthenGuard
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_EarthenGuard : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_EarthenGuard");
		return ptr;
	}


	bool STATIC_IsValidDeployable(class ATgDeployable* deployable);
};


// Class TgGame.TgInvListener_ImpasseEffect
// 0x0000 (0x00C4 - 0x00C4)
class UTgInvListener_ImpasseEffect : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_ImpasseEffect");
		return ptr;
	}

};


// Class TgGame.TgPawn_BarrierTank
// 0x0080 (0x3358 - 0x32D8)
class ATgPawn_BarrierTank : public ATgPawn_Character
{
public:
	struct FWallPlacementInfo                          m_WallPlacementInfos[0x5];                                // 0x32D8(0x0010)
	struct FVector                                     m_vSegmentExtent;                                         // 0x3328(0x000C) (Const)
	struct FVector                                     m_vOpenSpotExtent;                                        // 0x3334(0x000C) (Const)
	float                                              m_fWallTraceDownDistance;                                 // 0x3340(0x0004) (Const)
	float                                              m_fWallOpenSpotTolerance;                                 // 0x3344(0x0004) (Const)
	float                                              m_fInitialWallScaleZ;                                     // 0x3348(0x0004) (Const)
	unsigned long                                      r_bInGaeBolg : 1;                                         // 0x334C(0x0004) (Net)
	unsigned long                                      m_bUseGaeBolgRetrieve : 1;                                // 0x334C(0x0004)
	float                                              m_fGaeBolgJumpZModifier;                                  // 0x3350(0x0004)
	int                                                r_nInhandAmmoRemaining;                                   // 0x3354(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_BarrierTank");
		return ptr;
	}


	void SetTargetingDevice(class ATgDevice* Dev, const struct FWeaponMeshSwapStrategy& SwapStrategy);
	void OnStartTimelapseNewDeviceState();
	bool DoJump(bool bUpdating, float JumpZSpeed);
	float STATIC_GetJumpSpeedMultiplier();
	void STATIC_EndGaeBolg();
	void StartGaeBolg(float fJumpZMultiplier);
	void STATIC_UpdateWallPlacementInfos(const struct FVector& OriginLocation, const struct FRotator& originRotation);
};


// Class TgGame.TgAnimNodeChannelFire_Pounce
// 0x0004 (0x0184 - 0x0180)
class UTgAnimNodeChannelFire_Pounce : public UTgAnimNodeChannelFire
{
public:
	unsigned long                                      m_bPounceHitSuccessful : 1;                               // 0x0180(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeChannelFire_Pounce");
		return ptr;
	}


	void STATIC_ReplayAnim();
	void STATIC_EndChannel();
};


// Class TgGame.TgDeploy_Midnight
// 0x0028 (0x0494 - 0x046C)
class ATgDeploy_Midnight : public ATgDeployable
{
public:
	float                                              r_fPersistTime;                                           // 0x046C(0x0004) (Net)
	class ATgPawn*                                     r_TargetPawn;                                             // 0x0470(0x0008) (Net)
	class UMaterialInstanceConstant*                   m_pMIC;                                                   // 0x0478(0x0008)
	class UClass*                                      m_FogInfoClass;                                           // 0x0480(0x0008) (Const)
	class ATgMidnightFogVolumeDensityInfo*             m_FogInfo;                                                // 0x0488(0x0008)
	unsigned long                                      m_bCleanedUp : 1;                                         // 0x0490(0x0004)
	unsigned long                                      m_b3PFxActive : 1;                                        // 0x0490(0x0004)
	unsigned long                                      m_b1PSoundActive : 1;                                     // 0x0490(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Midnight");
		return ptr;
	}


	void SetFogOrigin(const struct FVector& vOrigin);
	void SetFogAlpha(float fAlpha);
	void SetFogDistance(float fDistance);
	void SetFogEnabled(bool bEnabled);
	void SpawnFog();
	class UMaterialInstanceConstant* CreateMIC(class UMaterialInterface* pMaterialInterface);
	void Cleanup();
	void DestroyIt(bool bSkipFx);
	void Destroyed();
	void MidnightDeployablePersistTimer();
	void ApplyCameraEffectParams();
	void SetPersistTimer();
	void ReplicatedEvent(const struct FName& VarName);
};


// Class TgGame.TgDevice_BladesInhand
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_BladesInhand : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_BladesInhand");
		return ptr;
	}


	int STATIC_GetProjectileIDOverride(int ProjectileIndex);
};


// Class TgGame.TgDevice_BladesInhandAltFire
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_BladesInhandAltFire : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_BladesInhandAltFire");
		return ptr;
	}

};


// Class TgGame.TgDevice_Pounce
// 0x000C (0x0A8C - 0x0A80)
class ATgDevice_Pounce : public ATgDevice_Charge
{
public:
	class ATgPawn_Blades*                              m_CachedBlades;                                           // 0x0A80(0x0008)
	unsigned long                                      m_bHasBounced : 1;                                        // 0x0A88(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Pounce");
		return ptr;
	}


	void BounceOff();
	void ClientBounceOff();
	void ServerBounceOff(class AActor* Other);
	void PostHitLockOut();
	bool STATIC_HasCachedBlades();
	void STATIC_GetTargetingAim(struct FAimData* Aim);
	bool STATIC_IsPostHitLockOutActive();
};


// Class TgGame.TgDevice_Midnight
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_Midnight : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Midnight");
		return ptr;
	}


	void MidnightTimer();
	void CustomFire();
	void OnDeployableSpawned(class ATgDeployable* deployable);
};


// Class TgGame.TgDevice_NineLives
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_NineLives : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_NineLives");
		return ptr;
	}

};


// Class TgGame.TgDevice_Prowl
// 0x0018 (0x0A24 - 0x0A0C)
class ATgDevice_Prowl : public ATgDevice_Stim
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_MoveSpeedMultiplier;           // 0x0A0C(0x0008) (Const, Native, NoExport)
	struct FScriptDelegate                             __InterruptFiringDelegate__Delegate;                      // 0x0A14(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData00[0x4];                                       // 0x0A14(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Prowl");
		return ptr;
	}


	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
	void InterruptFiringDelegate();
	bool STATIC_ShouldUseGradualMovement();
	float STATIC_GetMoveSpeedMultiplier();
	bool CanFiringBeCanceledByReactivation();
	bool CanBeCanceled();
	bool CanBeInterrupted();
	bool ShouldInterruptLift();
};


// Class TgGame.TgDeviceFire_Midnight
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_Midnight : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Midnight");
		return ptr;
	}


	void CustomFire();
};


// Class TgGame.TgDeviceFire_MidnightSub
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_MidnightSub : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_MidnightSub");
		return ptr;
	}


	float STATIC_GetFadeInPerc();
	float STATIC_GetDamageRadius();
};


// Class TgGame.TgDeviceForm_Pounce
// 0x002C (0x02B8 - 0x028C)
class UTgDeviceForm_Pounce : public UTgDeviceForm
{
public:
	TArray<class UTgAnimNodeChannelFire_Pounce*>       m_PounceNodes3p;                                          // 0x028C(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeChannelFire_Pounce*>       m_PounceNodes1p;                                          // 0x029C(0x0010) (NeedCtorLink)
	unsigned long                                      bFOVZoomActive : 1;                                       // 0x02AC(0x0004)
	float                                              m_fCameraFOVInterpolationTime;                            // 0x02B0(0x0004)
	float                                              m_fFOVModifier;                                           // 0x02B4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Pounce");
		return ptr;
	}


	void TriggerFOVZoom(bool bActive);
	void StopFire(int nFireModeNum);
	void Generic2(unsigned char byExtraData);
	void Generic1(unsigned char byExtraData);
	void SetPounceNodeHitSuccessful(bool bSuccessfulHit);
	void Hit(int nFireMode, class AActor* Target, float fDamageAmount, const struct FVector& HitLocation, const struct FVector& HitNormal, struct FExtraDamageInfo* ExtraInfo);
	void Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	void CacheAnimNode(class UAnimNode* Node, bool bIs3p);
	void ClearAnimNodes(bool bIs3p);
};


// Class TgGame.TgDeviceForm_StreetJustice
// 0x0014 (0x02A0 - 0x028C)
class UTgDeviceForm_StreetJustice : public UTgDeviceForm
{
public:
	TArray<class UTgSpecialFx*>                        m_AppliedFx;                                              // 0x028C(0x0010) (NeedCtorLink)
	float                                              m_fExecuteThreshold;                                      // 0x029C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_StreetJustice");
		return ptr;
	}

};


// Class TgGame.TgEffectForm_Maeve_Midnight
// 0x0018 (0x0114 - 0x00FC)
class UTgEffectForm_Maeve_Midnight : public UTgEffectForm
{
public:
	int                                                m_nEndFXId;                                               // 0x00FC(0x0004)
	class UTgSpecialFx*                                m_pEndFX;                                                 // 0x0100(0x0008)
	class ATgEmitter_CameraEffect*                     m_pCameraEffect;                                          // 0x0108(0x0008)
	float                                              m_fEndFXKillTime;                                         // 0x0110(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_Maeve_Midnight");
		return ptr;
	}


	void STATIC_KillEndFX();
	void STATIC_HideEffectForm();
};


// Class TgGame.TgInventoryObject_Listen_Featherlite
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_Featherlite : public UTgInventoryObject_Listen_ActiveWhileOffCooldown
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Featherlite");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_CatBurglar
// 0x0000 (0x00D8 - 0x00D8)
class UTgInventoryObject_Listen_CatBurglar : public UTgInventoryObject_Listen_FirstShotDuringOrAfterMovementAbility
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_CatBurglar");
		return ptr;
	}

};


// Class TgGame.TgPawn_Blades
// 0x0114 (0x33EC - 0x32D8)
class ATgPawn_Blades : public ATgPawn_Character
{
public:
	float                                              m_fGravityFalloffDuration;                                // 0x32D8(0x0004)
	float                                              m_fGravityFalloffTimer;                                   // 0x32DC(0x0004)
	float                                              m_fAirControlReductionDuration;                           // 0x32E0(0x0004)
	float                                              m_fAirControlReductionTimer;                              // 0x32E4(0x0004)
	float                                              m_fAirControlReductionPercent;                            // 0x32E8(0x0004)
	unsigned long                                      r_bProwlActive : 1;                                       // 0x32EC(0x0004) (Net)
	unsigned long                                      c_bHasDjSkin : 1;                                         // 0x32EC(0x0004)
	unsigned long                                      c_bHasDjWeapon : 1;                                       // 0x32EC(0x0004)
	float                                              r_fProwlAccelMultiplier;                                  // 0x32F0(0x0004) (Net)
	float                                              r_fProwlGroundSpeedMultiplier;                            // 0x32F4(0x0004) (Net)
	float                                              r_fProwlJumpHeightMultiplier;                             // 0x32F8(0x0004) (Net)
	float                                              r_fProwlAirControlMultiplier;                             // 0x32FC(0x0004) (Net)
	float                                              r_fProwlFadeOutDuration;                                  // 0x3300(0x0004) (Net)
	float                                              m_fProwlFadeOutTimer;                                     // 0x3304(0x0004)
	float                                              r_fFeatherliteGravityMultiplier;                          // 0x3308(0x0004) (Net)
	TEnumAsByte<EGemEmissiveAnim>                      r_eGemEmissiveAnim;                                       // 0x330C(0x0001) (Net)
	TEnumAsByte<EGemEmissiveAnim>                      r_eGemEmissiveEndAnim;                                    // 0x330D(0x0001) (Net)
	TEnumAsByte<EDjBladesFace>                         c_eCurrentDjBladesFace;                                   // 0x330E(0x0001)
	TEnumAsByte<EDjBladesFace>                         c_eDjBladesFace[0x3];                                     // 0x330F(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x3312(0x0002) MISSED OFFSET
	class UMaterialInstanceConstant*                   c_pGemEmissiveMIC;                                        // 0x3314(0x0008)
	struct FName                                       m_nmGemEmissiveParamName;                                 // 0x331C(0x0008)
	float                                              m_fGemEmissiveBaseValue;                                  // 0x3324(0x0004)
	float                                              m_fGemEmissiveBaseAnimSpeed;                              // 0x3328(0x0004)
	float                                              c_fGemEmissiveCurrentValue;                               // 0x332C(0x0004)
	TArray<TEnumAsByte<EGemEmissiveAnim>>              c_eGemEmissiveAnimType;                                   // 0x3330(0x0010) (NeedCtorLink)
	TArray<float>                                      c_fGemEmissiveTargetValue;                                // 0x3340(0x0010) (NeedCtorLink)
	TArray<float>                                      c_fGemEmissiveAnimSpeed;                                  // 0x3350(0x0010) (NeedCtorLink)
	TArray<float>                                      c_fGemEmissiveHoldTimer;                                  // 0x3360(0x0010) (NeedCtorLink)
	float                                              m_fGemEmissive1PBaseValue;                                // 0x3370(0x0004)
	float                                              m_fGemEmissive1PAnimSpeedMult;                            // 0x3374(0x0004)
	float                                              m_fGemEmissive1PValueMult;                                // 0x3378(0x0004)
	float                                              m_fGemEmissiveGlobalScalar;                               // 0x337C(0x0004)
	float                                              c_fDjBladesFaceTimeout[0x3];                              // 0x3380(0x0004)
	struct FDjBladesFaceConfig                         c_DjBladesFaceConfig[0x8];                                // 0x338C(0x0008)
	TArray<struct FDjBladesVGSFace>                    c_DjBladesVGSFaces;                                       // 0x33CC(0x0010) (NeedCtorLink)
	struct FName                                       c_nmDjBladesFaceXParamName;                               // 0x33DC(0x0008)
	struct FName                                       c_nmDjBladesFaceYParamName;                               // 0x33E4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Blades");
		return ptr;
	}


	void ApplyDjBladesFace(TEnumAsByte<EDjBladesFace> eFace);
	void STATIC_UpdateDjBladesFace();
	void SetDjBladesFace(TEnumAsByte<EDjBladesFace> eFace, TEnumAsByte<EDjBladesFacePriority> ePriority, float fTimeout);
	void OnEmoteSoundFinished();
	void OnEmoteSoundPlayed(TEnumAsByte<EEmote> Emote);
	void OnVGSSoundFinished();
	void OnVGSSoundPlayed(int nVgsId);
	float GetEmoteChance(TEnumAsByte<EEmote> Emote);
	float GetAbilityEmoteChance(TEnumAsByte<EEmote> Emote);
	bool RespectsEmoteGlobalCooldown(TEnumAsByte<EEmote> Emote);
	int GetNumAirJumps();
	float STATIC_GetJumpHeightMultiplier();
	bool DoJump(bool bUpdating, float JumpZSpeed);
	bool CannotJumpNow();
	void ReplicatedEvent(const struct FName& VarName);
	float Get1PGemEmissiveMultiplier(TEnumAsByte<EGemEmissiveAnim> eAnim);
	void ApplyGemEmissveAnim(TEnumAsByte<EGemEmissiveAnim> eAnim);
	void ClearGemEmissiveEndAnim();
	void SetGemEmissiveEndAnim(TEnumAsByte<EGemEmissiveAnim> eEndAnim);
	void ClearGemEmissiveAnim();
	void SetGemEmissiveAnim(TEnumAsByte<EGemEmissiveAnim> eAnim);
	void AnimateGemEmissiveParam(TEnumAsByte<EGemEmissiveAnim> eAnim, float fTargetValue, float fAnimSpeed, float fHoldTime);
	void ClearGemEmissiveParam(TEnumAsByte<EGemEmissiveAnim> eAnim);
	void ResetGemEmissiveParam();
	float STATIC_GetProwlAirControlMultiplier();
	float STATIC_GetProwlJumpHeightMultiplier();
	float STATIC_GetProwlGroundSpeedMultiplier();
	float STATIC_GetProwlAccelMultiplier();
	void DeviceAdjustDamage(struct FAdjustDamageParams* Params, float* fDamage);
	void QueueBounceCustom(float fDuration, float fPctAirControlReduction, struct FVector* vBounceVelocity);
	void AirControlReduction(float fDuration, float fPercentReduction);
	void STATIC_GravityFallOff(float fDuration);
	float GetGravityZ();
};


// Class TgGame.TgPawnMod_FxAudio_DjMaeve
// 0x0008 (0x00B4 - 0x00AC)
class UTgPawnMod_FxAudio_DjMaeve : public UTgPawnMod_FxAudio
{
public:
	float                                              m_fGlowMultBass;                                          // 0x00AC(0x0004)
	float                                              m_fGlowMult;                                              // 0x00B0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawnMod_FxAudio_DjMaeve");
		return ptr;
	}

};


// Class TgGame.TgDeploy_BombKingStickyBomb
// 0x0088 (0x04F4 - 0x046C)
class ATgDeploy_BombKingStickyBomb : public ATgDeployable
{
public:
	unsigned long                                      r_bDetonated : 1;                                         // 0x046C(0x0004) (Net)
	unsigned long                                      c_bSuppressExplosion : 1;                                 // 0x046C(0x0004)
	unsigned long                                      r_bShouldDetach : 1;                                      // 0x046C(0x0004) (Net)
	class ATgPawn_Character*                           r_StuckPlayer;                                            // 0x0470(0x0008) (Net)
	struct FName                                       m_StuckSocket;                                            // 0x0478(0x0008)
	class ATgPawn_Character*                           m_CachedPlayer;                                           // 0x0480(0x0008)
	float                                              m_fBounceVelocityMultiplier;                              // 0x0488(0x0004)
	struct FVector                                     r_HitNormal;                                              // 0x048C(0x000C) (Net)
	class UTgSpecialFx*                                m_GetStuckFx;                                             // 0x0498(0x0008)
	class UTgSpecialFx*                                m_StickOtherFx;                                           // 0x04A0(0x0008)
	class ATgPawn_LanePusherBase*                      r_StuckCart;                                              // 0x04A8(0x0008) (Net)
	struct FRotator                                    r_StuckRotation;                                          // 0x04B0(0x000C) (Net)
	struct FVector                                     r_CartOffset;                                             // 0x04BC(0x000C) (Net)
	class ATgDeployable*                               r_StuckGeometry;                                          // 0x04C8(0x0008) (Net)
	int                                                r_nOriginalProjectileID;                                  // 0x04D0(0x0004) (Net)
	float                                              r_fFXDamageRadius;                                        // 0x04D4(0x0004) (Net)
	float                                              r_fFXEffectiveRadius;                                     // 0x04D8(0x0004) (Net)
	class ATgCollisionProxy*                           m_CollisionProxy;                                         // 0x04DC(0x0008)
	TArray<class ATgPawn_Character*>                   m_PendingCollisions;                                      // 0x04E4(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_BombKingStickyBomb");
		return ptr;
	}


	void ProcessPendingCollisions();
	bool ProcessCollision(class ATgPawn_Character* TargetChar);
	void ProxyUnTouch(class AActor* Other);
	void ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void CheckHideHUDOverlay();
	void STATIC_InstantFireDeployable();
	void ExplodeOnShield();
	void Landed(const struct FVector& HitNormal, class AActor* FloorActor);
	void Tick(float DeltaSeconds);
	void StickToPlayerSocket();
	void Check1PHide();
	void DetachFromPlayer();
	void ForceBombFall();
	void DetachTimer();
	void TakeDamage(int Damage, class AController* EventInstigator, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void DestroyIt(bool bSkipFx);
	void HideSpawningProjectile();
	void ReplicatedEvent(const struct FName& VarName);
};


// Class TgGame.TgDeploy_PoppyBomb
// 0x0038 (0x04A4 - 0x046C)
class ATgDeploy_PoppyBomb : public ATgDeployable
{
public:
	unsigned long                                      r_bDetonated : 1;                                         // 0x046C(0x0004) (Net)
	class ATgPawn_Character*                           m_CachedPlayer;                                           // 0x0470(0x0008)
	struct FVector                                     r_HitNormal;                                              // 0x0478(0x000C) (Net)
	class ATgPawn_LanePusherBase*                      r_StuckCart;                                              // 0x0484(0x0008) (Net)
	struct FRotator                                    r_StuckRotation;                                          // 0x048C(0x000C) (Net)
	struct FVector                                     r_CartOffset;                                             // 0x0498(0x000C) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_PoppyBomb");
		return ptr;
	}


	void ExplodeOnShield();
	void Landed(const struct FVector& HitNormal, class AActor* FloorActor);
	void DestroyIt(bool bSkipFx);
	void ReplicatedEvent(const struct FName& VarName);
};


// Class TgGame.TgDevice_BombKingDetonator
// 0x000C (0x0A18 - 0x0A0C)
class ATgDevice_BombKingDetonator : public ATgDevice
{
public:
	unsigned long                                      m_bDetonatePoppyBombs : 1;                                // 0x0A0C(0x0004)
	unsigned long                                      m_bInFalseFireRetryPeriod : 1;                            // 0x0A0C(0x0004)
	float                                              m_fFalseFireRetryStart;                                   // 0x0A10(0x0004)
	float                                              m_fFalseFireRetryTime;                                    // 0x0A14(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_BombKingDetonator");
		return ptr;
	}


	void HandleFalseFireRecory();
	bool ShouldInterruptMount();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	class UTgDeviceFire* STATIC_GetCurrentFire();
};


// Class TgGame.TgDevice_KingBomb
// 0x0004 (0x0A84 - 0x0A80)
class ATgDevice_KingBomb : public ATgDevice_Charge
{
public:
	float                                              m_fEndFireZoomDurationOverride;                           // 0x0A80(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_KingBomb");
		return ptr;
	}


	struct FImpactInfo CalcWeaponFire(const struct FAimData& Aim, TArray<struct FImpactInfo>* ImpactList);
	void ApplyPostExplodeKnockback();
	void OutroLockoutTime();
	void STATIC_FireAmmunition();
	bool CanBeCanceled();
	float GetChargeRange();
	float STATIC_GetChargeSpeed();
	bool ShouldInstigatorCollideWith(class AActor* Other);
};


// Class TgGame.TgDevice_BombKingInhand
// 0x0048 (0x0A64 - 0x0A1C)
class ATgDevice_BombKingInhand : public ATgDevice_DualWield
{
public:
	unsigned long                                      r_bHasActiveProjectile : 1;                               // 0x0A1C(0x0004) (Net)
	unsigned long                                      m_bInDetonationMode : 1;                                  // 0x0A1C(0x0004)
	TArray<struct FStickyBombPendingDetonate>          m_PendingDetonations;                                     // 0x0A20(0x0010) (NeedCtorLink)
	TArray<class ATgProjectile*>                       m_PendingProjectileConversions;                           // 0x0A30(0x0010) (NeedCtorLink)
	TArray<int>                                        c_nLiveExplosiveIds;                                      // 0x0A40(0x0010) (NeedCtorLink)
	float                                              m_fValidationTolerance;                                   // 0x0A50(0x0004) (Const)
	struct FScriptDelegate                             __DetonatorFiringDelegate__Delegate;                      // 0x0A54(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData00[0x4];                                       // 0x0A54(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_BombKingInhand");
		return ptr;
	}


	void PostReloadTimer();
	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
	void DetonatorFiringDelegate();
	void STATIC_UpdateActiveProjectiles(class ATgProjectile* Proj);
	void AddProjectileWaitingForDeployable(class ATgProj_BombKingStickyBomb* stickyBomb);
	void ServerRestoreBombs();
	void ClientRestoreBombs();
	void SpecialInstantFire(const struct FVector& explodeLocation);
	void ServerExplodeAtLocation(int projID, int deployID, const struct FVector& explodeLocation, const struct FVector& vVelocity);
	void ServerTriggerBombDetonation();
	void ClientTriggerBombDetonation();
	void ClientProcessBombDetonation(class ATgProj_BombKingStickyBomb* stickyBomb);
	void RemovePendingConversion(class ATgProjectile* Proj, int deployID);
	bool STATIC_ValidateStickyBombExplosion(class ATgProj_BombKingStickyBomb* Proj, class ATgDeploy_BombKingStickyBomb* dep, const struct FVector& vExplodeLocation, const struct FVector& vVelocity);
};


// Class TgGame.TgDevice_GrumpyBomb
// 0x0004 (0x0A10 - 0x0A0C)
class ATgDevice_GrumpyBomb : public ATgDevice
{
public:
	float                                              m_fPostTargetingLockInDuration;                           // 0x0A0C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_GrumpyBomb");
		return ptr;
	}


	void PostTargetingLockIn();
	bool CanToggleTargetingOff();
	bool CanBeInterrupted();
	bool ShouldInterruptReloadOnBeginTargeting();
	void PutAway();
	bool STATIC_InterceptRightMousePressed(class ATgPlayerController* TgController);
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	bool STATIC_IsTargetingModeReady(TEnumAsByte<EDeviceFailType>* failType);
	void EnterTargetingMode();
	bool STATIC_UsesTargetingMode();
};


// Class TgGame.TgDevice_PoppyBomb
// 0x0004 (0x0A10 - 0x0A0C)
class ATgDevice_PoppyBomb : public ATgDevice
{
public:
	unsigned long                                      r_bHasActiveProjectile : 1;                               // 0x0A0C(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_PoppyBomb");
		return ptr;
	}


	bool Use();
	void PlayPoppyDetonateAnim();
	void STATIC_HandleDeviceFormStartFire(int nDeviceModeNum, float fRefireTime, struct FAimData* Aim);
	void ServerDetonatePoppyBomb();
	void DetonatePoppyBomb();
	bool HasActivePoppyBomb();
	bool ShouldCooldownAfterFire();
	void STATIC_UpdateActiveProjectiles(class ATgProjectile* Proj);
	bool STATIC_IsDeviceFiringForUI();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgInvListener_Demolition
// 0x0000 (0x00D8 - 0x00D8)
class UTgInvListener_Demolition : public UTgInventoryObject_Listen_HitWithDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_Demolition");
		return ptr;
	}

};


// Class TgGame.TgPawn_BombKing
// 0x0050 (0x3328 - 0x32D8)
class ATgPawn_BombKing : public ATgPawn_Character
{
public:
	float                                              m_fBounceDampingVertMin;                                  // 0x32D8(0x0004) (Edit)
	float                                              m_fBounceDampingVertMax;                                  // 0x32DC(0x0004) (Edit)
	float                                              m_fBounceDampingHorizMin;                                 // 0x32E0(0x0004) (Edit)
	float                                              m_fBounceDampingHorizMax;                                 // 0x32E4(0x0004) (Edit)
	unsigned long                                      c_bRenderKingBombMesh : 1;                                // 0x32E8(0x0004)
	unsigned long                                      m_bForced3PDuringKingBomb : 1;                            // 0x32E8(0x0004)
	int                                                c_nKingBombMeshID;                                        // 0x32EC(0x0004)
	struct FVector                                     m_fKingBombCameraOffset;                                  // 0x32F0(0x000C) (Edit)
	TEnumAsByte<EWeaponMeshState>                      r_weaponMeshState;                                        // 0x32FC(0x0001) (Net)
	unsigned char                                      UnknownData00[0x3];                                       // 0x32FD(0x0003) MISSED OFFSET
	int                                                m_nInhandID;                                              // 0x3300(0x0004)
	int                                                m_nGrumpyBombID;                                          // 0x3304(0x0004)
	int                                                m_nPoppyBombID;                                           // 0x3308(0x0004)
	float                                              r_fJoltKnockback;                                         // 0x330C(0x0004) (Net)
	class UClass*                                      m_InhandClass;                                            // 0x3310(0x0008)
	class UClass*                                      m_GrumpyBombClass;                                        // 0x3318(0x0008)
	class UClass*                                      m_PoppyBombClass;                                         // 0x3320(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_BombKing");
		return ptr;
	}


	void SpecialHideStickyBomb(int projID, int deployID);
	void PostTimeLapse(bool bPlayOfTheGame);
	void PreTimeLapse(bool bPlayOfTheGame);
	void PlayDyingEffects();
	struct FVector STATIC_GetCameraOffsetOverride(const struct FVector& originalOffset, TEnumAsByte<ECameraPerspectiveType> ePerspectiveType);
	void SetTargetingDevice(class ATgDevice* Dev, const struct FWeaponMeshSwapStrategy& SwapStrategy);
	void SwitchToPoppyBomb();
	void SwitchToGrumpyBomb();
	void SwitchToStickyBomb();
	void SwapFromKingBombMesh();
	void SwapToKingBombMesh();
	void ReplicatedEvent(const struct FName& VarName);
	void OnRespawn();
	void OnPawnDied();
	void DeviceAdjustDamage(struct FAdjustDamageParams* Params, float* fDamage);
	bool ShouldBeFirstPersonThisTick(TEnumAsByte<ECameraPerspectiveType>* ePersectiveType);
	void STATIC_GetMeshAssemblyToUse(int* nBodyAsmId, int* nCoreAsmId);
};


// Class TgGame.TgProj_BombKingStickyBomb
// 0x0024 (0x05A4 - 0x0580)
class ATgProj_BombKingStickyBomb : public ATgProj_FreeGrenade
{
public:
	unsigned long                                      m_bExplodedOnShield : 1;                                  // 0x0580(0x0004)
	unsigned long                                      m_bExplodedOnDeployGeomtry : 1;                           // 0x0580(0x0004)
	unsigned long                                      c_bReadyToHide : 1;                                       // 0x0580(0x0004)
	class AActor*                                      m_CachedHitTarget;                                        // 0x0584(0x0008)
	struct FVector                                     m_vCachedHitLocation;                                     // 0x058C(0x000C)
	struct FVector                                     m_vCachedHitNormal;                                       // 0x0598(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_BombKingStickyBomb");
		return ptr;
	}


	void SetNonThreatening();
	void ShutDown();
	void Destroyed();
	void STATIC_HideForNonOwnerClient();
	void ClientExplodeSpecial(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool PredictStickToPlayerSocket(struct FVector* outSocketLocation, struct FRotator* outSocketRotation);
	void STATIC_HideProjectile();
	void SpecialHideProjectile();
	bool ApplyTheHit(class UTgDeviceFire* FireMode, const struct FImpactInfo& Impact, class AActor* DamageInstigator);
	void AltFireDetonate();
	void ExplodeOnTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	class AActor* CalculateHitActor(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, struct FTraceHitInfo* HitInfo);
	class ATgDeployable* SpawnDeployable(const struct FVector& vLocation, class AActor* TargetActor, const struct FVector& vNormal);
};


// Class TgGame.TgProj_GrumpyBomb
// 0x0010 (0x0590 - 0x0580)
class ATgProj_GrumpyBomb : public ATgProj_FreeGrenade
{
public:
	class UTgSilhouetteComponent*                      m_Silhouette;                                             // 0x0580(0x0008) (ExportObject, Component, EditInline)
	unsigned long                                      m_bSilhouetteInitialized : 1;                             // 0x0588(0x0004)
	unsigned long                                      m_bSilhouetteAllowed : 1;                                 // 0x0588(0x0004)
	float                                              m_fPostLandDurationAccelerant;                            // 0x058C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_GrumpyBomb");
		return ptr;
	}


	void ProxyUnTouch(class AActor* Other);
	void ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool CheckTeamPassThrough(class AActor* Other);
	void StartLandExplodeTimer();
	float STATIC_GetPostLandDuration();
	bool STATIC_IsAccelerantEquipped();
	void CheckShowOutline();
	void ReplicatedEvent(const struct FName& VarName);
	void InitializeSilhouetteComponent();
};


// Class TgGame.TgProj_PoppyBomb
// 0x0000 (0x0580 - 0x0580)
class ATgProj_PoppyBomb : public ATgProj_FreeGrenade
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_PoppyBomb");
		return ptr;
	}


	void SetNonThreatening();
	bool CheckTeamPassThrough(class AActor* Other);
	void PlayHitTargetFX(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, bool bExploded);
	void PlayHitWallExplosionFX(const struct FVector& HitNormal, const struct FVector& HitLocation);
	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
	void AltFireDetonate();
	class ATgDeployable* SpawnDeployable(const struct FVector& vLocation, class AActor* TargetActor, const struct FVector& vNormal);
};


// Class TgGame.TgDevice_BuckInhand
// 0x0020 (0x0A2C - 0x0A0C)
class ATgDevice_BuckInhand : public ATgDevice
{
public:
	float                                              m_fReloadScaleUsed;                                       // 0x0A0C(0x0004)
	float                                              m_fStartReloadTimestamp;                                  // 0x0A10(0x0004)
	float                                              m_fFirstShellReloadTime;                                  // 0x0A14(0x0004)
	float                                              m_fShellReloadTime;                                       // 0x0A18(0x0004)
	float                                              m_fPostReloadTime;                                        // 0x0A1C(0x0004)
	float                                              m_fReloadTimer;                                           // 0x0A20(0x0004)
	int                                                m_nProgressiveReloadTransactionID;                        // 0x0A24(0x0004)
	unsigned long                                      m_bIsReloadingFirstShell : 1;                             // 0x0A28(0x0004)
	unsigned long                                      s_bPendingServerEndReload : 1;                            // 0x0A28(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_BuckInhand");
		return ptr;
	}


	void ClientInterruptReload(bool bAllowAmmoFill);
	void ServerStartReload();
	void PostReloadTimer();
	void PlayReloadAnim(TEnumAsByte<EReloadAnimType> rat, float reloadTime);
	void PreReloadTimer();
	bool StartReload(bool bIgnoreCurrentAmmo);
	void ServerEndReloadForInhandFire();
	bool Use();
};


// Class TgGame.TgDevice_HeroicLeap
// 0x0000 (0x0A14 - 0x0A14)
class ATgDevice_HeroicLeap : public ATgDevice_Leap
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_HeroicLeap");
		return ptr;
	}


	bool ShouldInterruptReloadOnFire();
	bool ShouldMountCancelFiring();
	void SetLeapParams(float* scaleLateral, float* scaleVertical, float* additiveLateral, float* additiveVertical);
};


// Class TgGame.TgDevice_Recovery
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_Recovery : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Recovery");
		return ptr;
	}

};


// Class TgGame.TgDevice_BuckWild
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_BuckWild : public ATgDevice_Stim
{
public:
	class ATgDevice_BuckInhand*                        m_CachedInhandDevice;                                     // 0x0A0C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_BuckWild");
		return ptr;
	}


	void LinkedDeviceEquipped(class ATgDevice* Dev);
	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	bool CanBeInterrupted();
	bool ShouldInterruptReloadOnFire();
	void OnStartFireRequestSent();
};


// Class TgGame.TgDeviceFire_HeroicLeap
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_HeroicLeap : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_HeroicLeap");
		return ptr;
	}


	bool STATIC_IgnoreTargetForBlocking(class AActor* Target);
};


// Class TgGame.TgPawn_Buck
// 0x0000 (0x32D8 - 0x32D8)
class ATgPawn_Buck : public ATgPawn_Character
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Buck");
		return ptr;
	}


	void ModifyAccuracyForReticleBloom(float* fAccuracy);
};


// Class TgGame.TgAnimNodeBlendByAbilityReiSpiritLink
// 0x0000 (0x0168 - 0x0168)
class UTgAnimNodeBlendByAbilityReiSpiritLink : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByAbilityReiSpiritLink");
		return ptr;
	}


	void Break();
	void STATIC_Recast();
	void STATIC_Summon();
};


// Class TgGame.TgDevice_BunnyDefense
// 0x0014 (0x0A20 - 0x0A0C)
class ATgDevice_BunnyDefense : public ATgDevice
{
public:
	class ATgPawn_Bunny*                               m_CachedBunny;                                            // 0x0A0C(0x0008)
	float                                              m_fAoEPeriod;                                             // 0x0A14(0x0004)
	float                                              m_fAoEProcTimeRemaining;                                  // 0x0A18(0x0004)
	unsigned long                                      m_bAoEPostFireOnly : 1;                                   // 0x0A1C(0x0004)
	unsigned long                                      m_bEnemyEffectsApplied : 1;                               // 0x0A1C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_BunnyDefense");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	void STATIC_FireAmmunition();
	bool CanBeCanceled();
	void Tick(float DeltaSeconds);
	void STATIC_PerformAoE();
	class UTgDeviceFire* STATIC_GetAoEFireMode();
	bool CanFiringBeCanceledByLeftMouse();
	void STATIC_RemoveAllEnvelopEnemyEffects();
	void STATIC_ApplyAllEnvelopEnemyEffects();
	void STATIC_RemoveEnvelopEnemyEffects(class ATgPawn* pTarget);
	void STATIC_ApplyEnvelopEnemyEffects(class ATgPawn* pTarget);
};


// Class TgGame.TgDevice_BunnyHeal
// 0x0030 (0x0A3C - 0x0A0C)
class ATgDevice_BunnyHeal : public ATgDevice
{
public:
	class ATgPawn_Bunny*                               m_CachedBunny;                                            // 0x0A0C(0x0008)
	class ATgPawn_Character*                           m_CurrentHealTarget;                                      // 0x0A14(0x0008)
	int                                                m_nMaxHealTargets;                                        // 0x0A1C(0x0004)
	float                                              m_fSeekingSearchRadius;                                   // 0x0A20(0x0004)
	unsigned long                                      m_bCanHealPastTargets : 1;                                // 0x0A24(0x0004)
	float                                              m_fHealBounceDelay;                                       // 0x0A28(0x0004)
	TArray<struct FBunnyHealHistoryEntry>              m_BunnyHealHistory;                                       // 0x0A2C(0x0010) (AlwaysInit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_BunnyHeal");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	bool CanDeviceStartFiringNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDebugRelevant, bool bIgnoreCachedValue, TEnumAsByte<EDeviceFailType>* failType);
	void ServerStartFire(float MovementTimeStamp, const struct FVector& MovementInAccel, const struct FVector& MovementClientLoc, unsigned char MovementNewFlags, unsigned char MovementClientRoll, int MovementView, int ClientFireRequestId, unsigned char ClientFireMode, class AActor* HitActor, float StartTraceX, float StartTraceY, float StartTraceZ, float EndTraceX, float EndTraceY, float EndTraceZ, int nCompressedAimVector, bool bFirstBurstShot, float fAttackSpeedPercChange);
	void CallServerStartFire(const struct FAimData& Aim, bool bPendingUpdate);
	void InstantFire();
	void STATIC_ClientEarlyOut();
	void EarlyOut();
	float GetRange();
	class ATgProj_BunnyHeal* SpawnHealProjectile(class ATgPawn* PawnFrom, class ATgPawn* PawnTo);
	void OnHealProjectileImpact(class ATgProj_BunnyHeal* Proj, class ATgPawn* HitPawn);
	void STATIC_OnProjectileShutdownCheckEndSequence(class ATgProj_BunnyHeal* Proj);
	void STATIC_PerformCleanup();
	class UTgDeviceFire* STATIC_GetFireModeForFiringProjectile();
	class UTgDeviceFire* STATIC_NativeGetFireModeForFiringProjectile();
	bool STATIC_CheckHealTargetLoS(const struct FVector& vOrigin, class ATgPawn* pTarget);
	bool STATIC_HealTarget(class ATgPawn* pTarget);
	class ATgPawn* STATIC_GetNextHealTarget(const struct FVector& vOrigin, class ATgPawn* pPawnFrom);
};


// Class TgGame.TgDevice_BunnyInhand
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_BunnyInhand : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_BunnyInhand");
		return ptr;
	}

};


// Class TgGame.TgDevice_BunnyLink
// 0x0028 (0x0A34 - 0x0A0C)
class ATgDevice_BunnyLink : public ATgDevice
{
public:
	class ATgPawn_Bunny*                               m_CachedBunny;                                            // 0x0A0C(0x0008)
	class ATgPawn_Character*                           m_CandidateSpiritLinkTarget;                              // 0x0A14(0x0008)
	class ATgPawn_Character*                           m_CurrentSpiritLinkTarget;                                // 0x0A1C(0x0008)
	float                                              m_fLinkedDamageHealthFloor;                               // 0x0A24(0x0004)
	float                                              m_fSpiritLinkBreakThreshold;                              // 0x0A28(0x0004)
	class UTgDeviceFire_BunnyLink*                     m_LinkDeviceMode;                                         // 0x0A2C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_BunnyLink");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	bool CanDeviceStartFiringNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDebugRelevant, bool bIgnoreCachedValue, TEnumAsByte<EDeviceFailType>* failType);
	void ServerStartFire(float MovementTimeStamp, const struct FVector& MovementInAccel, const struct FVector& MovementClientLoc, unsigned char MovementNewFlags, unsigned char MovementClientRoll, int MovementView, int ClientFireRequestId, unsigned char ClientFireMode, class AActor* HitActor, float StartTraceX, float StartTraceY, float StartTraceZ, float EndTraceX, float EndTraceY, float EndTraceZ, int nCompressedAimVector, bool bFirstBurstShot, float fAttackSpeedPercChange);
	void CallServerStartFire(const struct FAimData& Aim, bool bPendingUpdate);
	void InstantFire();
	bool STATIC_IsSelfDamageEffectGroup(class UTgEffectGroup* pEffectGroup);
	bool STATIC_HasLinkDeviceMode();
	class ATgPawn_Character* STATIC_QueryForTarget();
	int STATIC_GetMaxSpiritLinks();
	void STATIC_ApplySelfDamage(class ATgPawn* attacker, int nDamageAmount);
};


// Class TgGame.TgDevice_BunnyUlt
// 0x0014 (0x0A20 - 0x0A0C)
class ATgDevice_BunnyUlt : public ATgDevice
{
public:
	class ATgPawn_Bunny*                               m_CachedBunny;                                            // 0x0A0C(0x0008)
	class ATgPawn*                                     m_CurrentUltTarget;                                       // 0x0A14(0x0008)
	unsigned long                                      m_bRequireTargetToFire : 1;                               // 0x0A1C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_BunnyUlt");
		return ptr;
	}


	bool CanDeviceStartFiringNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDebugRelevant, bool bIgnoreCachedValue, TEnumAsByte<EDeviceFailType>* failType);
	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	void ServerStartFire(float MovementTimeStamp, const struct FVector& MovementInAccel, const struct FVector& MovementClientLoc, unsigned char MovementNewFlags, unsigned char MovementClientRoll, int MovementView, int ClientFireRequestId, unsigned char ClientFireMode, class AActor* HitActor, float StartTraceX, float StartTraceY, float StartTraceZ, float EndTraceX, float EndTraceY, float EndTraceZ, int nCompressedAimVector, bool bFirstBurstShot, float fAttackSpeedPercChange);
	void InstantFire();
	float GetRange();
	void CallServerStartFire(const struct FAimData& Aim, bool bPendingUpdate);
};


// Class TgGame.TgDeviceFire_BunnyLink
// 0x0014 (0x028C - 0x0278)
class UTgDeviceFire_BunnyLink : public UTgDeviceFire_CustomEffect
{
public:
	class ATgPawn_Bunny*                               m_CachedBunny;                                            // 0x0278(0x0008)
	unsigned long                                      m_bInLinkTargetSelection : 1;                             // 0x0280(0x0004)
	float                                              m_fEnemyTargetPenalty;                                    // 0x0284(0x0004)
	float                                              m_fLinkedTargetPenalty;                                   // 0x0288(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_BunnyLink");
		return ptr;
	}


	bool STATIC_HasCachedBunny();
};


// Class TgGame.TgDeviceForm_BunnySpiritLink
// 0x0040 (0x02CC - 0x028C)
class UTgDeviceForm_BunnySpiritLink : public UTgDeviceForm
{
public:
	TArray<class UTgAnimNodeBlendBySimpleStance*>      m_SimpleStanceReiInspect1p;                               // 0x028C(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeBlendBySimpleStance*>      m_SimpleStanceReiInspect3p;                               // 0x029C(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeBlendByAbilityReiSpiritLink*> m_ReiSpiritLinkNodes3p;                                   // 0x02AC(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeBlendByAbilityReiSpiritLink*> m_ReiSpiritLinkNodes1p;                                   // 0x02BC(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_BunnySpiritLink");
		return ptr;
	}


	void Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	void CacheAnimNode(class UAnimNode* Node, bool bIs3p);
	void ClearAnimNodes(bool bIs3p);
	void SetSpiritLinkFamiliarActive(bool bIsActive);
};


// Class TgGame.TgPawn_Bunny
// 0x00B0 (0x3388 - 0x32D8)
class ATgPawn_Bunny : public ATgPawn_Character
{
public:
	class ATgDevice_BunnyLink*                         m_CachedBunnyLink;                                        // 0x32D8(0x0008)
	class ATgDevice_BunnyHeal*                         m_CachedBunnyHeal;                                        // 0x32E0(0x0008)
	class ATgDevice_BunnyDefense*                      m_CachedBunnyDefense;                                     // 0x32E8(0x0008)
	class ATgDevice_BunnyUlt*                          m_CachedBunnyUlt;                                         // 0x32F0(0x0008)
	class UTgDeviceForm_BunnySpiritLink*               c_CachedBunnyLinkForm;                                    // 0x32F8(0x0008)
	unsigned long                                      m_bWhileEnemyLinkedEffectsApplied : 1;                    // 0x3300(0x0004)
	unsigned long                                      m_bWhileFriendlyLinkedEffectsApplied : 1;                 // 0x3300(0x0004)
	unsigned long                                      m_bSpiritLinkViewConstraint : 1;                          // 0x3300(0x0004) (Const)
	unsigned long                                      m_bLinkedPawnsNetworkUpdate : 1;                          // 0x3300(0x0004)
	unsigned long                                      m_bHasBeefySpiritLinkTalent : 1;                          // 0x3300(0x0004)
	int                                                m_nFriendlyLinkBeamFXId_1P;                               // 0x3304(0x0004)
	int                                                m_nFriendlyLinkBeamFXId_3P;                               // 0x3308(0x0004)
	int                                                m_nEnemyLinkBeamFXId_1P;                                  // 0x330C(0x0004)
	int                                                m_nEnemyLinkBeamFXId_3P;                                  // 0x3310(0x0004)
	int                                                m_nLinkBreakBeamFXId_1P;                                  // 0x3314(0x0004)
	float                                              m_fLinkBreakBeamTTL;                                      // 0x3318(0x0004)
	struct FName                                       m_nmLinkBeamStartSocket;                                  // 0x331C(0x0008)
	float                                              m_fLinkBreakDelay;                                        // 0x3324(0x0004)
	float                                              m_fLinkBeamWeaknessOffset;                                // 0x3328(0x0004)
	float                                              m_fLinkBeamRestrengthenPeriod;                            // 0x332C(0x0004)
	struct FName                                       m_nmFamiliarFxDisplayGroup;                               // 0x3330(0x0008)
	struct FName                                       m_nmBeamWeaknessParameter;                                // 0x3338(0x0008)
	class ATgPawn_Character*                           m_CurrentTarget;                                          // 0x3340(0x0008)
	float                                              m_fMaxSpiritLinkRangeFeet;                                // 0x3348(0x0004) (Const)
	float                                              m_fSpiritLinkLoSFoVClient;                                // 0x334C(0x0004) (Const)
	float                                              m_fSpiritLinkLoSFoVServerGrace;                           // 0x3350(0x0004) (Const)
	TArray<struct FSpiritLink>                         m_SpiritLinks;                                            // 0x3354(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<struct FBreakingSpiritLink>                 m_SpiritLinkBreaks;                                       // 0x3364(0x0010) (AlwaysInit, NeedCtorLink)
	int                                                r_nSpiritLinkedPawnIds[0x3];                              // 0x3374(0x0004) (Net)
	int                                                m_nBeefySpiritLinkTalentId;                               // 0x3380(0x0004)
	float                                              m_fBeefySpiritLinkTalentDuration;                         // 0x3384(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Bunny");
		return ptr;
	}


	float STATIC_GetJumpHeightMultiplier();
	void PostBeginPlay();
	bool PostPawnSetup();
	void ReplicatedEvent(const struct FName& VarName);
	bool STATIC_HasCachedLinkForm();
	void STATIC_ClientUpdateLinkedPawns();
	bool STATIC_IsPawnSpiritLinked(class ATgPawn* QueryTarget);
	void STATIC_RemoveSpiritLink(class ATgPawn* LinkTarget);
	void STATIC_RemoveSpiritLinkByIndex(int nIndex);
	void STATIC_AddSpiritLink(class ATgPawn* LinkTarget);
	void STATIC_RemoveBreakingSpiritLinkAtIndex(int nIndex);
	void STATIC_AddBreakingSpiritLink(class ATgPawn* LinkTarget);
	bool STATIC_RemoveSpiritLinkEffects(class ATgPawn* LinkTarget);
	bool STATIC_ApplySpiritLinkEffects(class ATgPawn* LinkTarget);
	void STATIC_PawnMitigateDamageOther(class ATgPawn* Other, TEnumAsByte<EPawnDamageMitigatorReason> eReason, class ATgPawn* attacker, class UTgEffectGroup* eg, int nPropertyId, float* fDamage);
	float STATIC_GetLinkBreakDelay();
};


// Class TgGame.TgProj_BunnyHeal
// 0x0018 (0x0544 - 0x052C)
class ATgProj_BunnyHeal : public ATgProj_Simulated
{
public:
	float                                              m_fRetargetingTimer;                                      // 0x052C(0x0004)
	float                                              m_fRetargetTime;                                          // 0x0530(0x0004)
	class ATgPawn*                                     m_pBouncedFrom;                                           // 0x0534(0x0008)
	class ATgDevice_BunnyHeal*                         m_CachedBunnyHeal;                                        // 0x053C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_BunnyHeal");
		return ptr;
	}


	void STATIC_UpdateTrackingTargetActor();
	void Tick(float DeltaSeconds);
	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
	bool ApplyTheHit(class UTgDeviceFire* FireMode, const struct FImpactInfo& Impact, class AActor* DamageInstigator);
	void ShutDown();
	void STATIC_UpdateSeekingDirection(float fDeltaTime);
	bool CanHitTarget(class AActor* Other);
	bool STATIC_HasCachedBunnyHeal();
};


// Class TgGame.TgDevice_BlastShot
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_BlastShot : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_BlastShot");
		return ptr;
	}


	void ScaleAbilityRadius();
};


// Class TgGame.TgDevice_Scout
// 0x002C (0x0A38 - 0x0A0C)
class ATgDevice_Scout : public ATgDevice
{
public:
	class ATgPawn*                                     m_CachedPawnOwner;                                        // 0x0A0C(0x0008)
	TArray<class ATgPawn*>                             m_AlliesScouted;                                          // 0x0A14(0x0010) (NeedCtorLink)
	TArray<class ATgPawn*>                             m_EnemiesScouted;                                         // 0x0A24(0x0010) (NeedCtorLink)
	float                                              m_fScoutRefreshTime;                                      // 0x0A34(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Scout");
		return ptr;
	}


	void ClearScoutTargets();
	void TickScout();
};


// Class TgGame.TgDevice_Somersault
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_Somersault : public ATgDevice
{
public:
	class ATgDevice*                                   m_DodgeRollDevice;                                        // 0x0A0C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Somersault");
		return ptr;
	}


	bool ShouldCooldownAfterFire();
	bool StartFire();
};


// Class TgGame.TgInventoryObject_Listen_BigGame
// 0x000C (0x00D0 - 0x00C4)
class UTgInventoryObject_Listen_BigGame : public UTgInvListener
{
public:
	float                                              m_fDisengageHitTime;                                      // 0x00C4(0x0004)
	class AActor*                                      m_DisengageHitTarget;                                     // 0x00C8(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_BigGame");
		return ptr;
	}

};


// Class TgGame.TgPawn_Cassie
// 0x0010 (0x32E8 - 0x32D8)
class ATgPawn_Cassie : public ATgPawn_Character
{
public:
	float                                              r_fRadiusForBlastShotFX;                                  // 0x32D8(0x0004) (Net)
	unsigned long                                      r_bRollBonusActive : 1;                                   // 0x32DC(0x0004) (Net)
	class ATgDevice_Scout*                             m_CachedScoutDevice;                                      // 0x32E0(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Cassie");
		return ptr;
	}


	void UpdateBonusVisualization();
	void ReplicatedEvent(const struct FName& VarName);
};


// Class TgGame.TgProj_BlastShot
// 0x0000 (0x052C - 0x052C)
class ATgProj_BlastShot : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_BlastShot");
		return ptr;
	}


	void STATIC_GetExplosionFXParams(TArray<struct FParticleSysParam>* Params);
};


// Class TgGame.TgDeploy_DistortionField
// 0x0004 (0x04B4 - 0x04B0)
class ATgDeploy_DistortionField : public ATgDeploy_EffectAura
{
public:
	float                                              m_fRadiusVFXScale;                                        // 0x04B0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_DistortionField");
		return ptr;
	}


	void ScaleFX();
	void ActivateOnWhenDeployedFx(bool bOn);
	bool STATIC_DistortionFieldTalentEquipped();
	bool STATIC_IsObscuringOverriden(class ATgPawn* Viewer, class ATgPawn* Target, bool bViewerInside);
	void RemoveEffects(class AActor* Target);
	void ApplyEffects(class AActor* Target);
};


// Class TgGame.TgDeploy_CommanderUlt
// 0x0008 (0x04A8 - 0x04A0)
class ATgDeploy_CommanderUlt : public ATgDeploy_EffectField
{
public:
	class UTgCameraShake*                              m_CameraShake;                                            // 0x04A0(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_CommanderUlt");
		return ptr;
	}


	void STATIC_FlashFireCountUpdated();
	void ProxyTouchHit(class AActor* Other);
};


// Class TgGame.TgDevice_CommanderCreditPassive
// 0x0014 (0x0A20 - 0x0A0C)
class ATgDevice_CommanderCreditPassive : public ATgDevice
{
public:
	struct FPointer                                    VfTable_ITgCallbackInterface;                             // 0x0A0C(0x0008) (Const, Native, NoExport)
	int                                                nKillCount;                                               // 0x0A14(0x0004)
	class UTgCallbackContainer*                        m_CallbackContainer;                                      // 0x0A18(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CommanderCreditPassive");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	void STATIC_RemoveCommanderPassiveTeam();
	void STATIC_ApplyCommanderPassiveTeam();
	void STATIC_GiveCreditsToTeam(int nCredits);
	void STATIC_CheckGiveCreditsOnKill();
};


// Class TgGame.TgDevice_CommanderInhand
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_CommanderInhand : public ATgDevice
{
public:
	float                                              m_fQueueFireTime;                                         // 0x0A0C(0x0004)
	float                                              m_fQueueFireTimeThreshold;                                // 0x0A10(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CommanderInhand");
		return ptr;
	}


	void StopFire();
	bool STATIC_InterceptLeftMousePressed(class ATgPlayerController* TgController);
	bool CanFireIfLeftMouseDown();
};


// Class TgGame.TgDevice_CommanderPassive
// 0x0010 (0x0A1C - 0x0A0C)
class ATgDevice_CommanderPassive : public ATgDevice
{
public:
	struct FPointer                                    VfTable_ITgCallbackInterface;                             // 0x0A0C(0x0008) (Const, Native, NoExport)
	class UTgCallbackContainer*                        m_CallbackContainer;                                      // 0x0A14(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CommanderPassive");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	void OnOwnerLiveRespawn();
	void STATIC_RemoveCommanderPassiveTeam();
	void STATIC_ApplyCommanderPassiveTeam(bool bRegisterCallback);
	void STATIC_RemoveCommanderPassiveTarget(class ATgPawn* pTarget);
	void STATIC_ApplyCommanderPassiveTarget(class ATgPawn* pTarget);
};


// Class TgGame.TgDevice_CommanderUlt
// 0x0028 (0x0A34 - 0x0A0C)
class ATgDevice_CommanderUlt : public ATgDevice
{
public:
	class ATgPawn_Commander*                           m_CachedCommander;                                        // 0x0A0C(0x0008)
	class ATgDevice_CommanderUltFire*                  m_CommanderUltFireDevice;                                 // 0x0A14(0x0008)
	struct FVector                                     m_vLastDeployLocPreOffset;                                // 0x0A1C(0x000C)
	struct FRotator                                    m_rInitialDeployRotation;                                 // 0x0A28(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CommanderUlt");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
	void STATIC_HandleDeviceFormStartFire(int nDeviceModeNum, float fRefireTime, struct FAimData* Aim);
	bool ShouldInterruptReloadOnFire();
	bool STATIC_UsesEnergy();
	bool STATIC_UpdateUltChargePercent();
	bool CanFiringBeLocked();
};


// Class TgGame.TgDevice_CommanderUltFire
// 0x000C (0x0A18 - 0x0A0C)
class ATgDevice_CommanderUltFire : public ATgDevice
{
public:
	class ATgDevice_CommanderUlt*                      m_CommanderUltDevice;                                     // 0x0A0C(0x0008)
	float                                              m_fTraceDownDistance;                                     // 0x0A14(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CommanderUltFire");
		return ptr;
	}


	void LinkedDeviceEquipped(class ATgDevice* Dev);
	bool ShouldInterruptReloadOnFire();
	void STATIC_GetGroundTargetAim(struct FAimData* Aim);
	bool CanFiringBeLocked();
};


// Class TgGame.TgDevice_DistortionField
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_DistortionField : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DistortionField");
		return ptr;
	}


	bool ShouldInterruptStealth();
};


// Class TgGame.TgDevice_CommanderLeap
// 0x0010 (0x0A24 - 0x0A14)
class ATgDevice_CommanderLeap : public ATgDevice_Leap
{
public:
	class ATgPawn_Commander*                           m_Commander;                                              // 0x0A14(0x0008)
	class ATgDevice_CommanderScope*                    m_Scope;                                                  // 0x0A1C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CommanderLeap");
		return ptr;
	}


	bool ShouldInterruptReloadOnFire();
	bool ShouldMountCancelFiring();
	void STATIC_InterruptOtherDevices(class ATgPawn* TgP);
	bool STATIC_HasCachedScope();
	bool STATIC_HasCachedCommander();
};


// Class TgGame.TgDevice_CommanderScope
// 0x0008 (0x0A2C - 0x0A24)
class ATgDevice_CommanderScope : public ATgDevice_ToggleADS
{
public:
	class ATgDevice_CommanderInhand*                   m_CachedInhandDev;                                        // 0x0A24(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CommanderScope");
		return ptr;
	}


	void STATIC_ChangeWeaponZoom(bool bZoomOn);
	void STATIC_CancelFloat();
	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
	void ShowReticle(bool bShow);
	void STATIC_UnlockFromFiring();
	void STATIC_LockFromFiring();
	void STATIC_CancelJumpFloat();
};


// Class TgGame.TgDeviceFire_CommanderUlt
// 0x000C (0x0274 - 0x0268)
class UTgDeviceFire_CommanderUlt : public UTgDeviceFire
{
public:
	float                                              m_fMaxZTrace;                                             // 0x0268(0x0004)
	float                                              m_fZOffSet;                                               // 0x026C(0x0004)
	float                                              m_fXYOffset;                                              // 0x0270(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_CommanderUlt");
		return ptr;
	}


	bool STATIC_GetDeployLocationAndRotation(struct FVector* OutLocation, struct FRotator* OutRotation);
};


// Class TgGame.TgDeviceForm_CommanderInhand
// 0x0000 (0x028C - 0x028C)
class UTgDeviceForm_CommanderInhand : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_CommanderInhand");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_CommanderScope
// 0x002C (0x02CC - 0x02A0)
class UTgDeviceForm_CommanderScope : public UTgDeviceForm_ToggleADS
{
public:
	class ATgPawn_Commander*                           m_CachedOctavia;                                          // 0x02A0(0x0008)
	unsigned long                                      m_bAirScoped : 1;                                         // 0x02A8(0x0004)
	TArray<class UTgAnimNodeBlendBySimpleStance*>      m_SimpleStanceAirScoped1P;                                // 0x02AC(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeBlendBySimpleStance*>      m_SimpleStanceAirScoped3P;                                // 0x02BC(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_CommanderScope");
		return ptr;
	}


	void CacheAnimNode(class UAnimNode* Node, bool bIs3p);
	void ClearAnimNodes(bool bIs3p);
	bool STATIC_HasCachedOctavia();
};


// Class TgGame.TgInventoryObject_Listen_CommanderUltChargePassive
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_CommanderUltChargePassive : public UTgInventoryObject_Listen_ActiveWhileOffCooldown
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_CommanderUltChargePassive");
		return ptr;
	}

};


// Class TgGame.TgPawn_Commander
// 0x002C (0x3304 - 0x32D8)
class ATgPawn_Commander : public ATgPawn_Character
{
public:
	TArray<int>                                        c_ScopeRevealTargets;                                     // 0x32D8(0x0010) (AlwaysInit, NeedCtorLink)
	unsigned long                                      m_bAirScoped : 1;                                         // 0x32E8(0x0004)
	unsigned long                                      m_bAirJumpFloating : 1;                                   // 0x32E8(0x0004)
	unsigned long                                      m_bScopedThisJump : 1;                                    // 0x32E8(0x0004)
	unsigned long                                      m_bJumpFloatedThisJump : 1;                               // 0x32E8(0x0004)
	unsigned long                                      r_bDistortionFieldTalentEquipped : 1;                     // 0x32E8(0x0004) (Net)
	float                                              m_fAirScopeTime;                                          // 0x32EC(0x0004)
	float                                              m_fJumpLockoutTime;                                       // 0x32F0(0x0004) (Const)
	class ATgDevice_CommanderPassive*                  m_CachedCommanderPassive;                                 // 0x32F4(0x0008)
	class ATgDevice_CommanderScope*                    m_CommanderScope;                                         // 0x32FC(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Commander");
		return ptr;
	}


	void STATIC_SafetyScopeReset();
	void Landed(const struct FVector& HitNormal, class AActor* FloorActor);
	bool DoJump(bool bUpdating, float JumpZSpeed);
	void STATIC_JumpFloatLockoutTimer();
	bool STATIC_HasCachedScope();
};


// Class TgGame.TgAnimNodeBlendByAbilityCorvusDagger
// 0x0000 (0x0168 - 0x0168)
class UTgAnimNodeBlendByAbilityCorvusDagger : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByAbilityCorvusDagger");
		return ptr;
	}


	void STATIC_CorvusTeleportAnimActivate();
	void STATIC_CorvusDaggerThrow();
};


// Class TgGame.TgAnimNodeChannelFire_CorvusUlt
// 0x0001 (0x0181 - 0x0180)
class UTgAnimNodeChannelFire_CorvusUlt : public UTgAnimNodeChannelFire
{
public:
	TEnumAsByte<ECorvusUltAnimState>                   m_eAnimState;                                             // 0x0180(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeChannelFire_CorvusUlt");
		return ptr;
	}


	void SetAnimState(TEnumAsByte<ECorvusUltAnimState> animState);
	void STATIC_ReplayAnim();
	void STATIC_EndChannel();
};


// Class TgGame.TgDeploy_CorvusDagger
// 0x0004 (0x0470 - 0x046C)
class ATgDeploy_CorvusDagger : public ATgDeployable
{
public:
	float                                              r_fPersistTime;                                           // 0x046C(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_CorvusDagger");
		return ptr;
	}


	void STATIC_CorvusUltDeployablePersistTimer();
	void SetPersistTimer();
	void OnPersistTimerExpire();
	void DestroyIt(bool bSkipFx);
	void ReplicatedEvent(const struct FName& VarName);
};


// Class TgGame.TgDeploy_CorvusUlt
// 0x0000 (0x04A0 - 0x04A0)
class ATgDeploy_CorvusUlt : public ATgDeploy_EffectField
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_CorvusUlt");
		return ptr;
	}


	void StartFire();
	void OnProxyUnTouch(class AActor* Other);
	void OnProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgDevice_CorvusBeaconLifeSteal
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_CorvusBeaconLifeSteal : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CorvusBeaconLifeSteal");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
};


// Class TgGame.TgDevice_CorvusDagger
// 0x0025 (0x0A31 - 0x0A0C)
class ATgDevice_CorvusDagger : public ATgDevice
{
public:
	unsigned long                                      m_bCancelled : 1;                                         // 0x0A0C(0x0004)
	unsigned long                                      m_bAllowTeleport : 1;                                     // 0x0A0C(0x0004)
	struct FVector                                     m_vTeleportToLocation;                                    // 0x0A10(0x000C)
	struct FVector                                     m_vProjSpawnLocation;                                     // 0x0A1C(0x000C)
	class ATgPawn_Corvus*                              m_CachedCorvus;                                           // 0x0A28(0x0008)
	TEnumAsByte<ECorvusDaggerState>                    m_eLocalDaggerState;                                      // 0x0A30(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CorvusDagger");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	void OnOwnerRespawn();
	void OnOwnerLiveRespawn();
	void DeviceShutDown(bool bDeactiveMode, bool bResetCooldowns);
	void ServerTeleportToDagger(const struct FVector& vDest);
	void DoTeleport();
	void STATIC_TeleportToDagger(const struct FVector& vDest);
	bool CanTeleportNow();
	void STATIC_TeleportLockoutEnd();
	bool CanBeCanceled();
	void InterruptFiring(bool bServerFireFailed);
	bool CanBeInterrupted();
	bool STATIC_InterceptSlotPressed(class ATgPlayerController* TgController);
	bool CanFiringBeCanceledByLeftMouse();
	bool ShouldCooldownAfterFire();
	bool STATIC_IsDeviceFiringLockedForUI();
	bool STATIC_IsDeviceFiringForUI();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	bool STATIC_IsSafeSpot(const struct FVector& vSpot, bool bZTraceOnly);
	bool STATIC_DaggerIsAway();
	void STATIC_DaggerStateTransitionFrom(TEnumAsByte<ECorvusDaggerState> eFrom);
	void STATIC_DaggerStateTransitionIn(TEnumAsByte<ECorvusDaggerState> eInto);
	void STATIC_UpdateDaggerState(TEnumAsByte<ECorvusDaggerState> eInto);
};


// Class TgGame.TgDevice_CorvusDaggerTalent
// 0x0024 (0x0A30 - 0x0A0C)
class ATgDevice_CorvusDaggerTalent : public ATgDevice
{
public:
	class ATgCollisionProxy_Mesh*                      m_BeamCollisionProxy;                                     // 0x0A0C(0x0008)
	TArray<class ATgPawn*>                             m_ActorsInRange;                                          // 0x0A14(0x0010) (NeedCtorLink)
	struct FVector                                     m_vDaggerLocation;                                        // 0x0A24(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CorvusDaggerTalent");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	void DestroyCollisionProxy();
	void SpawnCollisionProxy();
	void ClearTouchedActors();
	void OnProxyUnTouch(class AActor* Other);
	void OnProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_FireAmmunition();
	void DeliverHit(const struct FImpactInfo& Impact);
	bool CanBeCanceled();
};


// Class TgGame.TgDevice_CorvusInhand
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_CorvusInhand : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CorvusInhand");
		return ptr;
	}

};


// Class TgGame.TgDevice_CorvusRMB
// 0x0084 (0x0A90 - 0x0A0C)
class ATgDevice_CorvusRMB : public ATgDevice
{
public:
	class ATgPawn_Corvus*                              m_Corvus;                                                 // 0x0A0C(0x0008)
	struct FImpactInfo                                 m_CachedImpact;                                           // 0x0A14(0x007C) (Component)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CorvusRMB");
		return ptr;
	}


	void STATIC_UpdateHitTargetInfo(class AActor* HitActor, const struct FVector& HitLocation);
	void OnInstantShotRejected(const struct FImpactToValidate& RejectedPrimaryImpact);
	void OnInstantShotVerified(const struct FImpactInfo& VerifiedPrimaryImpact);
	struct FImpactInfo CalcWeaponFire(const struct FAimData& Aim, TArray<struct FImpactInfo>* ImpactList);
	bool ShouldCooldownAfterFire();
	void STATIC_DeliverDelayedBurstHeal();
	void DeliverHit(const struct FImpactInfo& Impact);
	void DeliverQueuedPendingHits();
	bool STATIC_HasCachedCorvus();
	void DeviceAdjustHeal(int nPropertyId, struct FImpactInfo* Impact, float* fHeal);
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgDevice_CorvusUlt
// 0x0018 (0x0A24 - 0x0A0C)
class ATgDevice_CorvusUlt : public ATgDevice
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_MoveSpeedMultiplier;           // 0x0A0C(0x0008) (Const, Native, NoExport)
	class ATgPawn_Corvus*                              m_CachedCorvus;                                           // 0x0A14(0x0008)
	class ATgDevice_CorvusUltFire*                     m_CorvusUltFireDevice;                                    // 0x0A1C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CorvusUlt");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
	void STATIC_UltimateFired();
	void STATIC_LastShotCancelTimer();
	bool CanBeInterrupted();
	void CustomFire();
	bool ShouldSwitchBackToBasicAttackTargeting(TEnumAsByte<ECastMode> CastMode);
	bool CanBeCanceled();
	bool ShouldMountCancelFiring();
	bool CanBeSilenced();
	bool CanFireIfLeftMouseDown();
	bool STATIC_IsToggleDevice();
	bool STATIC_IsTargetingModeReady(TEnumAsByte<EDeviceFailType>* failType);
	void ExitTargetingMode();
	void TickTargetingMode(float DeltaSeconds);
	bool STATIC_UsesTargetingMode();
	bool STATIC_ShouldUseGradualMovement();
	float STATIC_GetMoveSpeedMultiplier();
};


// Class TgGame.TgDevice_CorvusUltFire
// 0x000C (0x0A18 - 0x0A0C)
class ATgDevice_CorvusUltFire : public ATgDevice
{
public:
	class ATgDevice_CorvusUlt*                         m_CorvusUltDevice;                                        // 0x0A0C(0x0008)
	float                                              m_fTraceDownDistance;                                     // 0x0A14(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CorvusUltFire");
		return ptr;
	}


	void LinkedDeviceEquipped(class ATgDevice* Dev);
	bool ShouldConsumePowerPoolAfterFire();
	bool ShouldConsumePowerPoolOnStartFire();
	bool STATIC_InterceptLeftMouseReleased(class ATgPlayerController* TgController);
	bool STATIC_InterceptLeftMousePressed(class ATgPlayerController* TgController);
	void STATIC_GetGroundTargetAim(struct FAimData* Aim);
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgDevice_CorvusUltMod
// 0x0020 (0x0A2C - 0x0A0C)
class ATgDevice_CorvusUltMod : public ATgDevice
{
public:
	TArray<class AActor*>                              m_ImmuneTargets;                                          // 0x0A0C(0x0010) (NeedCtorLink)
	TArray<float>                                      m_ImmuneTimes;                                            // 0x0A1C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CorvusUltMod");
		return ptr;
	}


	void RemoveEffect(class ATgDeploy_CorvusUlt* CorvusUltDeploy, class AActor* Target);
	void ApplyEffect(class ATgDeploy_CorvusUlt* CorvusUltDeploy, class AActor* Target);
	void ApplyOnTouchEffect(class AActor* Target);
};


// Class TgGame.TgDevice_CorvusBeacon
// 0x0004 (0x0A10 - 0x0A0C)
class ATgDevice_CorvusBeacon : public ATgDevice_Mark
{
public:
	unsigned long                                      m_bBeaconCanBounce : 1;                                   // 0x0A0C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CorvusBeacon");
		return ptr;
	}


	void DeliverHit(const struct FImpactInfo& Impact);
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgDevice_TripleBeacon
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_TripleBeacon : public ATgDevice
{
public:
	class ATgDevice_CorvusBeacon*                      m_CachedCorvusBeaconDevice;                               // 0x0A0C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_TripleBeacon");
		return ptr;
	}


	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
};


// Class TgGame.TgDeviceFire_CorvusBeacon
// 0x000C (0x0274 - 0x0268)
class UTgDeviceFire_CorvusBeacon : public UTgDeviceFire
{
public:
	float                                              m_fServerScaleBufferMult;                                 // 0x0268(0x0004)
	float                                              m_fBaseEncroachmentActorRange;                            // 0x026C(0x0004)
	float                                              m_fScaleYZ;                                               // 0x0270(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_CorvusBeacon");
		return ptr;
	}


	bool STATIC_IgnoreTargetForBlocking(class AActor* Target);
};


// Class TgGame.TgDeviceFire_CorvusRMB
// 0x0000 (0x0278 - 0x0278)
class UTgDeviceFire_CorvusRMB : public UTgDeviceFire_EncroachmentFireCone
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_CorvusRMB");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_CorvusDagger
// 0x0040 (0x02CC - 0x028C)
class UTgDeviceForm_CorvusDagger : public UTgDeviceForm
{
public:
	TArray<class UTgAnimNodeBlendByAbilityCorvusDagger*> m_CorvusDaggerNodes3p;                                    // 0x028C(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeBlendByAbilityCorvusDagger*> m_CorvusDaggerNodes1p;                                    // 0x029C(0x0010) (NeedCtorLink)
	TArray<class UTgAnimBlendByPaladinsCharacter*>     m_CorvusNodes3p;                                          // 0x02AC(0x0010) (NeedCtorLink)
	TArray<class UTgAnimBlendByPaladinsCharacter*>     m_CorvusNodes1p;                                          // 0x02BC(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_CorvusDagger");
		return ptr;
	}


	void Generic1(unsigned char byExtraData);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	void CacheAnimNode(class UAnimNode* Node, bool bIs3p);
	void ClearAnimNodes(bool bIs3p);
};


// Class TgGame.TgDeviceForm_CorvusUlt
// 0x0020 (0x02AC - 0x028C)
class UTgDeviceForm_CorvusUlt : public UTgDeviceForm
{
public:
	TArray<class UTgAnimNodeChannelFire_CorvusUlt*>    m_CorvusUltNodes3p;                                       // 0x028C(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeChannelFire_CorvusUlt*>    m_CorvusUltNodes1p;                                       // 0x029C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_CorvusUlt");
		return ptr;
	}


	void Generic2(unsigned char byExtraData);
	void Generic1(unsigned char byExtraData);
	void CacheAnimNode(class UAnimNode* Node, bool bIs3p);
	void ClearAnimNodes(bool bIs3p);
};


// Class TgGame.TgInvListener_CorvusMark
// 0x0000 (0x00C8 - 0x00C8)
class UTgInvListener_CorvusMark : public UTgInvListener_SetChildFiremode
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_CorvusMark");
		return ptr;
	}

};


// Class TgGame.TgPawn_Corvus
// 0x0070 (0x3348 - 0x32D8)
class ATgPawn_Corvus : public ATgPawn_Character
{
public:
	class ATgPawn*                                     r_RMBTarget;                                              // 0x32D8(0x0008) (Net)
	float                                              m_fDelayTargetValid;                                      // 0x32E0(0x0004)
	class ATgPawn_Character*                           m_BeaconTarget;                                           // 0x32E4(0x0008)
	class ATgDevice_CorvusBeacon*                      m_CachedBeaconDevice;                                     // 0x32EC(0x0008)
	class ATgDevice_CorvusDagger*                      m_CachedCorvusDagger;                                     // 0x32F4(0x0008)
	class ATgDevice_CorvusUlt*                         m_CachedCorvusUlt;                                        // 0x32FC(0x0008)
	class ATgDevice_CorvusDaggerTalent*                m_CachedCorvusDaggerTalent;                               // 0x3304(0x0008)
	class ATgProj_CorvusDagger*                        r_DaggerProjectile;                                       // 0x330C(0x0008) (Net)
	class ATgDeploy_CorvusDagger*                      r_DaggerDeployable;                                       // 0x3314(0x0008) (Net)
	TEnumAsByte<ECorvusDaggerState>                    r_eRemoteDaggerState;                                     // 0x331C(0x0001) (Net)
	unsigned char                                      UnknownData00[0x3];                                       // 0x331D(0x0003) MISSED OFFSET
	struct FVector                                     r_vPreTeleportLocation;                                   // 0x3320(0x000C) (Net)
	float                                              m_fPreviousAscentVelocity;                                // 0x332C(0x0004)
	float                                              m_fFlightMaxRiseSpeed;                                    // 0x3330(0x0004)
	TArray<struct FBeaconInfo>                         m_BeaconTargets;                                          // 0x3334(0x0010) (Component, AlwaysInit, NeedCtorLink)
	unsigned long                                      r_bBeaconLifeStealEquipped : 1;                           // 0x3344(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Corvus");
		return ptr;
	}


	struct FVector STATIC_GetTeleportLocation();
	bool OnLiveRespawn();
	void ClientRemoveBeaconTarget(class ATgPawn* RemoveBeacon);
	void ClientAddBeaconTarget(class ATgRepInfo_Player* AddBeacon);
	void ReplicatedEvent(const struct FName& VarName);
	bool STATIC_ShouldAscend();
	void STATIC_EffectGroupOnSetActive(bool bActive, bool bRemoving, class UTgEffectGroup* effectGroup);
	void STATIC_RemoveAllBeaconTargets();
	void STATIC_RemoveBeaconTarget(class ATgPawn* RemoveBeaconTarget);
	void STATIC_AddBeaconTarget(class ATgRepInfo_Player* AddBeaconTarget);
	bool STATIC_HasRMBTarget();
	void STATIC_SetRMBTarget(class ATgPawn* pChar);
};


// Class TgGame.TgProj_CorvusDagger
// 0x0000 (0x052C - 0x052C)
class ATgProj_CorvusDagger : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_CorvusDagger");
		return ptr;
	}


	void SetNonThreatening();
	bool STATIC_GetDeployLocationAndRotation(const struct FVector& vLocation, class AActor* TargetActor, const struct FVector& vNormal, struct FVector* OutLocation, struct FRotator* OutRotation);
};


// Class TgGame.TgAnimNodeChannelFire_CorrupterUlt
// 0x0001 (0x0169 - 0x0168)
class UTgAnimNodeChannelFire_CorrupterUlt : public UTgAnimNodeBlendList
{
public:
	TEnumAsByte<ECorrupterUltAnimState>                CurrentState;                                             // 0x0168(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeChannelFire_CorrupterUlt");
		return ptr;
	}


	void STATIC_InterruptAbility();
	bool STATIC_IsUnderGround();
	void STATIC_SetVoraUltExitState(TEnumAsByte<ECorrupterUltAnimState> eState);
	void STATIC_RefireAnim();
};


// Class TgGame.TgDevice_CorrupterInhand
// 0x0014 (0x0A30 - 0x0A1C)
class ATgDevice_CorrupterInhand : public ATgDevice_ChainSequence
{
public:
	class ATgPawn_Corrupter*                           m_Corrupter;                                              // 0x0A1C(0x0008)
	class UTgDeviceForm_CorrupterInhand*               m_DeviceForm;                                             // 0x0A24(0x0008)
	int                                                m_nChainMax;                                              // 0x0A2C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CorrupterInhand");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	int GetChainMax();
	void STATIC_UpdateDesiredFireMode();
	void DeliverHit(const struct FImpactInfo& Impact);
};


// Class TgGame.TgDevice_CorrupterPassive
// 0x000C (0x0A18 - 0x0A0C)
class ATgDevice_CorrupterPassive : public ATgDevice
{
public:
	class ATgPawn_Corrupter*                           m_Corrupter;                                              // 0x0A0C(0x0008)
	int                                                nChainMax;                                                // 0x0A14(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CorrupterPassive");
		return ptr;
	}


	int GetChainMax();
	void DeliverHit(const struct FImpactInfo& Impact);
};


// Class TgGame.TgDevice_CorrupterSiphon
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_CorrupterSiphon : public ATgDevice
{
public:
	class ATgPawn_Corrupter*                           m_Corrupter;                                              // 0x0A0C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CorrupterSiphon");
		return ptr;
	}


	bool STATIC_HasCachedCorrupter();
};


// Class TgGame.TgDevice_CorrupterUlt
// 0x0020 (0x0A2C - 0x0A0C)
class ATgDevice_CorrupterUlt : public ATgDevice
{
public:
	unsigned long                                      hasFired : 1;                                             // 0x0A0C(0x0004) (Net)
	class ATgPawn_Corrupter*                           m_Corrupter;                                              // 0x0A10(0x0008)
	class ATgPawn*                                     r_Target;                                                 // 0x0A18(0x0008) (Net)
	float                                              m_fNextTargetUpdateIn;                                    // 0x0A20(0x0004)
	float                                              m_fUpdateTargetPeriod;                                    // 0x0A24(0x0004)
	float                                              m_fDeliverDamageDelay;                                    // 0x0A28(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CorrupterUlt");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	bool ShouldInterruptReloadOnFire();
	bool ShouldMountCancelFiring();
	bool CanBeCanceled();
	bool STATIC_InterceptLeftMousePressed(class ATgPlayerController* TgController);
	void ServerDoUltFire(class ATgPawn* Target);
	void PlayClientFireFx(const struct FVector& HitLocation, int nSocketIndex, bool bSuccessfulHit, float fRefireTime, int nShotsFired);
	void DoUltFire(class ATgPawn* Target);
	void STATIC_DeliverDamage();
	bool CanEnterCombat();
	bool CanPerformUlt();
	bool STATIC_HasCachedCorrupter();
};


// Class TgGame.TgDevice_CorrupterLatch
// 0x0008 (0x0A5C - 0x0A54)
class ATgDevice_CorrupterLatch : public ATgDevice_Latch
{
public:
	class ATgPawn_Corrupter*                           m_CachedCorrupter;                                        // 0x0A54(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CorrupterLatch");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
};


// Class TgGame.TgDevice_CorrupterSpin
// 0x0010 (0x0A24 - 0x0A14)
class ATgDevice_CorrupterSpin : public ATgDevice_Leap
{
public:
	float                                              fAoeDistance;                                             // 0x0A14(0x0004)
	class ATgPawn_Corrupter*                           m_Corrupter;                                              // 0x0A18(0x0008)
	float                                              fDeactivateTime;                                          // 0x0A20(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CorrupterSpin");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	void OnCeaseActive();
	void DeliverHit(const struct FImpactInfo& Impact);
	bool ShouldInterruptReloadOnFire();
	bool ShouldMountCancelFiring();
	void STATIC_VoraSlam3pExtension();
	void STATIC_DeactivateSpin();
	bool STATIC_HasCachedCorrupter();
	bool ShouldForce3P(class UTgDeviceForm* DeviceForm, bool bOnlyCheckDeviceForm);
};


// Class TgGame.TgDeviceForm_CorrupterInhand
// 0x0020 (0x02AC - 0x028C)
class UTgDeviceForm_CorrupterInhand : public UTgDeviceForm
{
public:
	class ATgPawn_Corrupter*                           m_Corrupter;                                              // 0x028C(0x0008)
	float                                              m_fPreviousAppliedAmmoPerc;                               // 0x0294(0x0004)
	float                                              m_fCurrentAppliedAmmoPerc;                                // 0x0298(0x0004)
	float                                              m_fAnimatedReloadStartNormalizedTime;                     // 0x029C(0x0004) (Const)
	float                                              m_fAnimatedReloadEndNormalizedTime;                       // 0x02A0(0x0004) (Const)
	float                                              m_fReloadDuration;                                        // 0x02A4(0x0004)
	float                                              m_fReloadTimer;                                           // 0x02A8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_CorrupterInhand");
		return ptr;
	}


	void Generic1(unsigned char Data);
	void STATIC_SetScytheFlaming(bool isFlaming);
	bool STATIC_HasCachedCorrupter();
};


// Class TgGame.TgDeviceForm_CorrupterUlt
// 0x001C (0x02A8 - 0x028C)
class UTgDeviceForm_CorrupterUlt : public UTgDeviceForm
{
public:
	class ATgPawn_Corrupter*                           m_CachedCorrupter;                                        // 0x028C(0x0008)
	unsigned long                                      m_bPoolActive : 1;                                        // 0x0294(0x0004)
	TArray<class UTgAnimNodeChannelFire_CorrupterUlt*> m_VoraAnimNodes;                                          // 0x0298(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_CorrupterUlt");
		return ptr;
	}


	void STATIC_DoIntroLooping();
	void STATIC_DoNoTarget();
	void STATIC_TriggerAnimation(bool bExecute);
	void STATIC_CleanUpPool();
	void STATIC_SetVoraUltExitState(TEnumAsByte<ECorrupterUltAnimState> eState);
	void STATIC_RefireAnim();
	void DoInterrupt();
	void StopFire(int nFireModeNum);
	void Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	void BuildUp(int nFireMode, int nEquipSlot, int nSocketIndex, float fBuildupTime);
	bool STATIC_IsFinishedIntro();
	void RecoverDeviceState(TEnumAsByte<ETG_REP_DEVICE_STATE> DesiredState);
	void CacheAnimNode(class UAnimNode* Node, bool bIs3p);
	void ClearAnimNodes(bool bIs3p);
	bool STATIC_HasCachedCorrupter();
};


// Class TgGame.TgPawn_Corrupter
// 0x0048 (0x3320 - 0x32D8)
class ATgPawn_Corrupter : public ATgPawn_Character
{
public:
	class ATgDevice_CorrupterSpin*                     m_SpinDevice;                                             // 0x32D8(0x0008)
	class ATgDevice_CorrupterInhand*                   m_InHandDevice;                                           // 0x32E0(0x0008)
	class ATgDevice_CorrupterLatch*                    m_CachedLatch;                                            // 0x32E8(0x0008)
	class ATgDevice_CorrupterPassive*                  m_CorruptionPassive;                                      // 0x32F0(0x0008)
	class ATgDevice_CorrupterUlt*                      m_UltDevice;                                              // 0x32F8(0x0008)
	int                                                r_nCorruptionStacks;                                      // 0x3300(0x0004) (Net)
	int                                                nMaxCorruption;                                           // 0x3304(0x0004)
	int                                                nAmountToHealPerStack;                                    // 0x3308(0x0004)
	int                                                c_nPoolMeshID;                                            // 0x330C(0x0004)
	int                                                c_nNormalMeshID;                                          // 0x3310(0x0004)
	float                                              m_PreviousZHeight;                                        // 0x3314(0x0004)
	float                                              m_GravityMultiplier;                                      // 0x3318(0x0004)
	unsigned long                                      m_bRenderPool : 1;                                        // 0x331C(0x0004)
	unsigned long                                      m_bForced3PDuringPool : 1;                                // 0x331C(0x0004)
	unsigned long                                      m_bForcingMeshTransition : 1;                             // 0x331C(0x0004)
	unsigned long                                      r_bAbility1CanEmote : 1;                                  // 0x331C(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Corrupter");
		return ptr;
	}


	void STATIC_DoUltRefund(float TimeRemaining, float fEnergyRefund);
	void STATIC_ConsumeUltCharge(float fEnergyCost);
	void STATIC_SwapToOrFromPool(bool ToPool);
	void OnRespawn();
	void STATIC_IncrementCorruption();
	bool STATIC_IsMax(bool ShouldReset);
	void STATIC_ClearCorruption();
	bool STATIC_HasCachedUltDevice();
	bool STATIC_HasCachedSpinningDevice();
	float GetGravityZ();
	void MaxOutGravity();
	void StartZTracking();
	void ResetGravTimers();
	int STATIC_GetCorruption();
	int STATIC_GetMaxCorruption();
};


// Class TgGame.TgProj_Latch
// 0x0000 (0x052C - 0x052C)
class ATgProj_Latch : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Latch");
		return ptr;
	}

};


// Class TgGame.TgProj_CorrupterBaseProjectile
// 0x0010 (0x056C - 0x055C)
class ATgProj_CorrupterBaseProjectile : public ATgProj_ExtraColliders
{
public:
	class ATgPawn_Corrupter*                           m_Corrupter;                                              // 0x055C(0x0008)
	class UTgDeviceFire*                               m_FireSpecial;                                            // 0x0564(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_CorrupterBaseProjectile");
		return ptr;
	}


	bool ApplyTheHit(class UTgDeviceFire* FireMode, const struct FImpactInfo& Impact, class AActor* DamageInstigator);
};


// Class TgGame.TgProj_CorrupterChain1
// 0x0000 (0x056C - 0x056C)
class ATgProj_CorrupterChain1 : public ATgProj_CorrupterBaseProjectile
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_CorrupterChain1");
		return ptr;
	}

};


// Class TgGame.TgProj_CorrupterChain2
// 0x0000 (0x056C - 0x056C)
class ATgProj_CorrupterChain2 : public ATgProj_CorrupterBaseProjectile
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_CorrupterChain2");
		return ptr;
	}

};


// Class TgGame.TgProj_CorrupterChain3
// 0x0000 (0x056C - 0x056C)
class ATgProj_CorrupterChain3 : public ATgProj_CorrupterBaseProjectile
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_CorrupterChain3");
		return ptr;
	}

};


// Class TgGame.TgProj_CorrupterChain4
// 0x0000 (0x056C - 0x056C)
class ATgProj_CorrupterChain4 : public ATgProj_CorrupterBaseProjectile
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_CorrupterChain4");
		return ptr;
	}

};


// Class TgGame.TgProj_CorrupterSiphon
// 0x0000 (0x055C - 0x055C)
class ATgProj_CorrupterSiphon : public ATgProj_ExtraColliders
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_CorrupterSiphon");
		return ptr;
	}


	bool ApplyTheHit(class UTgDeviceFire* FireMode, const struct FImpactInfo& Impact, class AActor* DamageInstigator);
	void RangeReached();
	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
};


// Class TgGame.TgAnimBlendByPaladinsCharacter_Darklord
// 0x0018 (0x055C - 0x0544)
class UTgAnimBlendByPaladinsCharacter_Darklord : public UTgAnimBlendByPaladinsCharacter
{
public:
	class ATgPawn_Darklord*                            m_CachedDarklordPawn;                                     // 0x0544(0x0008)
	unsigned long                                      m_bTriggerUltKilledTargetRetrieve : 1;                    // 0x054C(0x0004)
	float                                              m_fCounterAnimDelay;                                      // 0x0550(0x0004) (Const)
	float                                              m_fCounterAnimTimeStamp;                                  // 0x0554(0x0004)
	int                                                m_nCounterAnimIndex;                                      // 0x0558(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByPaladinsCharacter_Darklord");
		return ptr;
	}


	void OnRetrieve();
	void PlayCounterAttackAnim(bool bPlayCounterToIdleAnim);
};


// Class TgGame.TgAnimNodeChannelFire_Spite
// 0x0001 (0x0181 - 0x0180)
class UTgAnimNodeChannelFire_Spite : public UTgAnimNodeChannelFire
{
public:
	TEnumAsByte<ESpiteAnimState>                       m_eAnimState;                                             // 0x0180(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeChannelFire_Spite");
		return ptr;
	}


	void SetAnimState(TEnumAsByte<ESpiteAnimState> animState);
	void STATIC_ReplayAnim();
	void STATIC_EndChannel();
};


// Class TgGame.TgDevice_Billow
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_Billow : public ATgDevice
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_MoveSpeedMultiplier;           // 0x0A0C(0x0008) (Const, Native, NoExport)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Billow");
		return ptr;
	}


	void STATIC_UpdateOutroLockoutTime();
	bool ShouldMountCancelFiring();
	bool CanBeInterrupted();
	bool CanBeCanceled();
	bool STATIC_ShouldUseGradualMovement();
	float STATIC_GetMoveSpeedMultiplier();
};


// Class TgGame.TgDevice_DarklordInhand
// 0x0000 (0x0A1C - 0x0A1C)
class ATgDevice_DarklordInhand : public ATgDevice_ChainSequence
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DarklordInhand");
		return ptr;
	}


	int STATIC_GetChainFireModeIndex();
	int GetChainMax();
};


// Class TgGame.TgDevice_Spite
// 0x0034 (0x0AB4 - 0x0A80)
class ATgDevice_Spite : public ATgDevice_Charge
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_MoveSpeedMultiplier;           // 0x0A80(0x0008) (Const, Native, NoExport)
	class ATgPawn_Darklord*                            m_CachedDarklord;                                         // 0x0A88(0x0008)
	unsigned long                                      m_bWaitingForServerHit : 1;                               // 0x0A90(0x0004)
	unsigned long                                      m_bHasStartedChainAttacks : 1;                            // 0x0A90(0x0004)
	unsigned long                                      m_bHasBounced : 1;                                        // 0x0A90(0x0004)
	unsigned long                                      m_bHasRefundedEnergy : 1;                                 // 0x0A90(0x0004)
	unsigned long                                      r_bApplyPercentDamage : 1;                                // 0x0A90(0x0004) (Net)
	int                                                m_nNumHits;                                               // 0x0A94(0x0004)
	class ATgPawn_Character*                           m_HitCharacter;                                           // 0x0A98(0x0008)
	TEnumAsByte<EPolymorphType>                        m_HitCharacterStartPolymorphType;                         // 0x0AA0(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0AA1(0x0003) MISSED OFFSET
	float                                              m_fJoinViewLerpTime;                                      // 0x0AA4(0x0004) (Const)
	float                                              m_fJoinSeparationDistance;                                // 0x0AA8(0x0004) (Const)
	float                                              m_fJoinMoveTweenTime;                                     // 0x0AAC(0x0004) (Const)
	float                                              m_fJoinMinGroundOffset;                                   // 0x0AB0(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Spite");
		return ptr;
	}


	void RefundEnergy();
	void ApplyFinalHit();
	void STATIC_FinishChainAttacks(bool bBounceOff, bool bApplyFinalHit);
	void ClientFinishChainAttacks(bool bBounceOff, bool bApplyFinalHit);
	void ClientAbortWaitingForServerHit();
	void ApplyChainHit();
	void RemoveStunHit();
	void ApplyStunHit();
	void StartChainAttacks(class AActor* Other);
	void ClientStartChainAttacks(class AActor* Other);
	void BounceOff();
	void CheckForRefund();
	void AbortChainAttacks();
	void OnInterruptEvent();
	void ServerStartChainAttacks(class AActor* Other);
	bool ShouldAbortChainAttacks();
	bool STATIC_IsTargetImmune(class ATgPawn_Character* pOther);
	bool STATIC_HasCachedDarklord();
	float STATIC_GetCachedFiringPostHitDelay();
	bool ShouldLiftInterrupt();
	bool STATIC_ShouldUseGradualMovement();
	float STATIC_GetMoveSpeedMultiplier();
	bool ShouldForce3P(class UTgDeviceForm* DeviceForm, bool bOnlyCheckDeviceForm);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_Counter
// 0x0004 (0x0A10 - 0x0A0C)
class ATgDevice_Counter : public ATgDevice
{
public:
	unsigned long                                      r_bInterruptAfterCounterAttack : 1;                       // 0x0A0C(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Counter");
		return ptr;
	}


	void STATIC_UpdateOutroLockoutTime();
	void CounterDelay();
	bool CanTriggerCounterAttack();
};


// Class TgGame.TgDevice_CounterAttack
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_CounterAttack : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CounterAttack");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_Counter
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_Counter : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Counter");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_CounterAttack
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_CounterAttack : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_CounterAttack");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Counter
// 0x0000 (0x028C - 0x028C)
class UTgDeviceForm_Counter : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Counter");
		return ptr;
	}


	void Generic1(unsigned char byExtraData);
};


// Class TgGame.TgDeviceForm_CounterAttack
// 0x0020 (0x02AC - 0x028C)
class UTgDeviceForm_CounterAttack : public UTgDeviceForm
{
public:
	TArray<class UTgAnimBlendByPaladinsCharacter*>     m_DarklordNodes3p;                                        // 0x028C(0x0010) (NeedCtorLink)
	TArray<class UTgAnimBlendByPaladinsCharacter*>     m_DarklordNodes1p;                                        // 0x029C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_CounterAttack");
		return ptr;
	}


	void Generic1(unsigned char byExtraData);
	void CacheAnimNode(class UAnimNode* Node, bool bIs3p);
	void ClearAnimNodes(bool bIs3p);
};


// Class TgGame.TgDeviceForm_DarklordInhand
// 0x0038 (0x02D4 - 0x029C)
class UTgDeviceForm_DarklordInhand : public UTgDeviceForm_Inhand
{
public:
	class ATgPawn_Darklord*                            m_CachedDarklord;                                         // 0x029C(0x0008)
	float                                              m_fFadeParamMin;                                          // 0x02A4(0x0004) (Const)
	float                                              m_fFadeParamMax;                                          // 0x02A8(0x0004) (Const)
	float                                              m_fAmmoParamMin;                                          // 0x02AC(0x0004) (Const)
	float                                              m_fAmmoParamMax;                                          // 0x02B0(0x0004) (Const)
	float                                              m_fMaskParamMin;                                          // 0x02B4(0x0004) (Const)
	float                                              m_fMaskParamMax;                                          // 0x02B8(0x0004) (Const)
	float                                              m_fPreviousAppliedAmmoPerc;                               // 0x02BC(0x0004)
	float                                              m_fCurrentAppliedAmmoPerc;                                // 0x02C0(0x0004)
	float                                              m_fAnimatedReloadStartNormalizedTime;                     // 0x02C4(0x0004) (Const)
	float                                              m_fAnimatedReloadEndNormalizedTime;                       // 0x02C8(0x0004) (Const)
	float                                              m_fReloadDuration;                                        // 0x02CC(0x0004)
	float                                              m_fReloadTimer;                                           // 0x02D0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_DarklordInhand");
		return ptr;
	}


	void STATIC_UpdateMeshMaterials(class UTgSkeletalMeshComponent_Weapon* Mesh, float fPerc);
	void STATIC_UpdateSpecialFxMaterials(class UTgSpecialFx* Fx, float fPerc);
	void STATIC_UpdateAmmoCountFx(float fPreviousPerc, float fCurrentPerc);
	void ForceUpdateAmmoCountFx(float fPreviousPerc, float fCurrentPerc);
	void OnReload(float fReloadTime);
	bool STATIC_HasCachedDarklord();
};


// Class TgGame.TgDeviceForm_Spite
// 0x003C (0x02C8 - 0x028C)
class UTgDeviceForm_Spite : public UTgDeviceForm
{
public:
	TArray<class UTgAnimNodeChannelFire_Spite*>        m_SpiteNodes3p;                                           // 0x028C(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeChannelFire_Spite*>        m_SpiteNodes1p;                                           // 0x029C(0x0010) (NeedCtorLink)
	TArray<class UTgAnimBlendByPaladinsCharacter_Darklord*> m_DarklordNodes1p;                                        // 0x02AC(0x0010) (NeedCtorLink)
	unsigned long                                      bFOVZoomActive : 1;                                       // 0x02BC(0x0004)
	float                                              m_fCameraFOVInterpolationTime;                            // 0x02C0(0x0004)
	float                                              m_fFOVModifier;                                           // 0x02C4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Spite");
		return ptr;
	}


	void RecoverDeviceState(TEnumAsByte<ETG_REP_DEVICE_STATE> DesiredState);
	void TriggerFOVZoom(bool bActive);
	void StopFire(int nFireModeNum);
	void Generic5(unsigned char byExtraData);
	void Generic4(unsigned char byExtraData);
	void Generic3(unsigned char byExtraData);
	void Generic2(unsigned char byExtraData);
	void Generic1(unsigned char byExtraData);
	void CacheAnimNode(class UAnimNode* Node, bool bIs3p);
	void ClearAnimNodes(bool bIs3p);
};


// Class TgGame.TgInvListener_Counter
// 0x0004 (0x00CC - 0x00C8)
class UTgInvListener_Counter : public UTgInventoryObject_Listen_ActiveWhileOffCooldown
{
public:
	float                                              m_fLastCounterTime;                                       // 0x00C8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_Counter");
		return ptr;
	}

};


// Class TgGame.TgInvListener_CounterLegendary
// 0x0000 (0x00C8 - 0x00C8)
class UTgInvListener_CounterLegendary : public UTgInventoryObject_Listen_ActiveWhileOffCooldown
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_CounterLegendary");
		return ptr;
	}

};


// Class TgGame.TgInvListener_SpiteLegendary
// 0x0000 (0x00C8 - 0x00C8)
class UTgInvListener_SpiteLegendary : public UTgInventoryObject_Listen_ActiveWhileOffCooldown
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_SpiteLegendary");
		return ptr;
	}

};


// Class TgGame.TgPawn_Darklord
// 0x0004 (0x32DC - 0x32D8)
class ATgPawn_Darklord : public ATgPawn_Character
{
public:
	unsigned long                                      m_bUseWhirlZoom : 1;                                      // 0x32D8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Darklord");
		return ptr;
	}


	void STATIC_GetCameraZoomOverride(float* fZoom, float* fZoomDuration);
	void OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode, int nAmmoRemaining);
	TEnumAsByte<EEmote> STATIC_GetDeviceEmoteType(class ATgDevice* Dev);
	void RemoveJoinForcedView(class ATgPawn_Character* Source, class ATgPawn_Character* Target);
	void AddJoinForcedView(class ATgPawn_Character* Source, class ATgPawn_Character* Target);
	void DeviceAdjustDamage(struct FAdjustDamageParams* Params, float* fDamage);
};


// Class TgGame.TgProj_DarklordChain1
// 0x0000 (0x055C - 0x055C)
class ATgProj_DarklordChain1 : public ATgProj_ExtraColliders
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_DarklordChain1");
		return ptr;
	}

};


// Class TgGame.TgProj_DarklordChain2
// 0x0000 (0x055C - 0x055C)
class ATgProj_DarklordChain2 : public ATgProj_ExtraColliders
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_DarklordChain2");
		return ptr;
	}

};


// Class TgGame.TgProj_DarklordChain3
// 0x0000 (0x055C - 0x055C)
class ATgProj_DarklordChain3 : public ATgProj_ExtraColliders
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_DarklordChain3");
		return ptr;
	}


	struct FVector GetCollisionOffsetDir();
	float STATIC_GetDecalRotationOffset();
};


// Class TgGame.TgProj_DarklordChain3Legendary
// 0x0000 (0x055C - 0x055C)
class ATgProj_DarklordChain3Legendary : public ATgProj_DarklordChain3
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_DarklordChain3Legendary");
		return ptr;
	}

};


// Class TgGame.TgProj_DarklordCounter
// 0x0000 (0x055C - 0x055C)
class ATgProj_DarklordCounter : public ATgProj_ExtraColliders
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_DarklordCounter");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeChannelFire_Telepunch
// 0x0001 (0x0181 - 0x0180)
class UTgAnimNodeChannelFire_Telepunch : public UTgAnimNodeChannelFire
{
public:
	TEnumAsByte<ETelepunchAnimState>                   m_eAnimState;                                             // 0x0180(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeChannelFire_Telepunch");
		return ptr;
	}


	void SetAnimState(TEnumAsByte<ETelepunchAnimState> animState);
	void STATIC_ReplayAnim();
	void STATIC_EndChannel();
};


// Class TgGame.TgDeploy_DemonTeleport
// 0x0000 (0x046C - 0x046C)
class ATgDeploy_DemonTeleport : public ATgDeployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_DemonTeleport");
		return ptr;
	}

};


// Class TgGame.TgDevice_DemonInhand
// 0x0004 (0x0A10 - 0x0A0C)
class ATgDevice_DemonInhand : public ATgDevice
{
public:
	unsigned long                                      m_bUltIsActive : 1;                                       // 0x0A0C(0x0004)
	unsigned long                                      m_bDemonStimIsActive : 1;                                 // 0x0A0C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DemonInhand");
		return ptr;
	}


	class UTgGameplayCurvesSet_RecoilSimple* STATIC_GetRecoilCurve();
	void SetAmmo(int AmmoCount, int ClipSize, bool bShouldValidate, int ValidationIDOverride);
	bool ShouldShowAmmoCount();
	bool RequiresAmmoToFire();
	bool CheckAutoReload();
};


// Class TgGame.TgDevice_DemonTeleport
// 0x001C (0x0A28 - 0x0A0C)
class ATgDevice_DemonTeleport : public ATgDevice
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_MoveSpeedMultiplier;           // 0x0A0C(0x0008) (Const, Native, NoExport)
	unsigned long                                      m_bCancelled : 1;                                         // 0x0A14(0x0004)
	unsigned long                                      m_bPhaseApplied : 1;                                      // 0x0A14(0x0004)
	unsigned long                                      m_bAllowTeleport : 1;                                     // 0x0A14(0x0004)
	float                                              m_fTeleportDelayTimer;                                    // 0x0A18(0x0004)
	struct FVector                                     m_vTeleportToLocation;                                    // 0x0A1C(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DemonTeleport");
		return ptr;
	}


	void OnDeployableDestroyed(class ATgDeployable* deployable);
	void TeleportAlmostFinished();
	void OnDeployableSpawned(class ATgDeployable* deployable);
	void ClientConfirmTelportToLocation(const struct FVector& vTeleportToLocation);
	void DeviceShutDown(bool bDeactiveMode, bool bResetCooldowns);
	float GetCustomTimerBarMaxTime();
	float GetCustomTimerBarCurrentTime();
	void FinishPhaseIn();
	void StartPhaseIn();
	void TeleportToDeployable(const struct FVector& vDest);
	void ServerTeleportToDeployable(const struct FVector& vDest);
	void DoTeleport();
	void STATIC_InterruptEmote(class ATgPawn* TgP);
	bool CanTeleportNow();
	bool CanBeCanceled();
	void InterruptFiring(bool bServerFireFailed);
	bool CanBeInterrupted();
	bool STATIC_InterceptSlotPressed(class ATgPlayerController* TgController);
	bool CanFiringBeCanceledByLeftMouse();
	bool ShouldCooldownAfterFire();
	bool ShouldTeleportOnTimeout();
	bool STATIC_IsDeviceFiringLockedForUI();
	bool STATIC_IsDeviceFiringForUI();
	bool ShouldForce3P(class UTgDeviceForm* DeviceForm, bool bOnlyCheckDeviceForm);
	bool STATIC_ShouldUseGradualMovement();
	float STATIC_GetMoveSpeedMultiplier();
};


// Class TgGame.TgDevice_DemonStim
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_DemonStim : public ATgDevice_Stim
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DemonStim");
		return ptr;
	}


	bool ShouldInterruptReloadOnFire();
};


// Class TgGame.TgDevice_DemonUlt
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_DemonUlt : public ATgDevice_Stim
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DemonUlt");
		return ptr;
	}


	void TransitionOut();
	bool CanBeCanceled();
};


// Class TgGame.TgDevice_Telepunch
// 0x003C (0x0A48 - 0x0A0C)
class ATgDevice_Telepunch : public ATgDevice
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_MoveSpeedMultiplier;           // 0x0A0C(0x0008) (Const, Native, NoExport)
	class ATgPawn_Demon*                               m_CachedDemon;                                            // 0x0A14(0x0008)
	class ATgPawn_Character*                           m_HitCharacter;                                           // 0x0A1C(0x0008)
	unsigned long                                      m_bLiftApplied : 1;                                       // 0x0A24(0x0004)
	unsigned long                                      m_bStealthApplied : 1;                                    // 0x0A24(0x0004)
	float                                              m_fLerpTime;                                              // 0x0A28(0x0004)
	struct FVector                                     m_vHitCharacterInitialLocation;                           // 0x0A2C(0x000C)
	float                                              m_fHorizontalHitMaxDist;                                  // 0x0A38(0x0004)
	float                                              m_fVerticalHitMaxDist;                                    // 0x0A3C(0x0004)
	float                                              m_fTeleportPreferedDistance;                              // 0x0A40(0x0004)
	float                                              m_fTargetLockTime;                                        // 0x0A44(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Telepunch");
		return ptr;
	}


	bool ShouldRemoveLift();
	bool STATIC_IsTargetInRangeToHit();
	void AbortTelepunch();
	void OnInterruptEvent();
	void ConfirmTelepunchTarget();
	void ApplySlam(class ATgPawn_Character* Target);
	void DelayedSlam();
	void RemoveTravelStealth(class ATgPawn_Character* Target);
	void ApplyTravelStealth(class ATgPawn_Character* Target);
	void RemoveLift(class ATgPawn_Character* Target);
	void ApplyLift(class ATgPawn_Character* Target);
	void PostTeleportLockOut();
	void PostTeleportPreHit();
	void ResetPostHitDelay();
	void ClientLerpToTarget(class ATgPawn_Character* Target, const struct FVector& vTargetLocation, float fLerpTime);
	void AltFirePostHitDelay();
	void STATIC_FadeOutUltFx();
	void STATIC_LerpToTarget(class ATgPawn_Character* Target, const struct FVector& vTargetLocation, float fLerpTime);
	float STATIC_GetLerpToTargetTime(const struct FVector& vTargetLocation);
	void DeliverHit(const struct FImpactInfo& Impact);
	struct FImpactInfo CalcWeaponFire(const struct FAimData& Aim, TArray<struct FImpactInfo>* ImpactList);
	bool STATIC_HasCachedDemon();
	bool ShouldConsumePowerPoolOnStartFire();
	bool STATIC_ShouldUseGradualMovement();
	float STATIC_GetMoveSpeedMultiplier();
	bool ShouldForce3P(class UTgDeviceForm* DeviceForm, bool bOnlyCheckDeviceForm);
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgDeviceFire_DemonTeleport
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_DemonTeleport : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_DemonTeleport");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_Telepunch
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_Telepunch : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Telepunch");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_Uppercut
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_Uppercut : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Uppercut");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_DemonInhand
// 0x0014 (0x02A0 - 0x028C)
class UTgDeviceForm_DemonInhand : public UTgDeviceForm
{
public:
	unsigned long                                      m_bFiredFromLeft : 1;                                     // 0x028C(0x0004)
	struct FName                                       c_nmSocketLeft;                                           // 0x0290(0x0008)
	struct FName                                       c_nmSocketRight;                                          // 0x0298(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_DemonInhand");
		return ptr;
	}


	struct FVector GetTracerSocketLocation();
	void Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
};


// Class TgGame.TgDeviceForm_DemonTeleport
// 0x0020 (0x02AC - 0x028C)
class UTgDeviceForm_DemonTeleport : public UTgDeviceForm
{
public:
	TArray<class UTgAnimBlendByPaladinsCharacter*>     m_DemonNodes3p;                                           // 0x028C(0x0010) (NeedCtorLink)
	TArray<class UTgAnimBlendByPaladinsCharacter*>     m_DemonNodes1p;                                           // 0x029C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_DemonTeleport");
		return ptr;
	}


	void Generic1(unsigned char byExtraData);
	void CacheAnimNode(class UAnimNode* Node, bool bIs3p);
	void ClearAnimNodes(bool bIs3p);
};


// Class TgGame.TgDeviceForm_Telepunch
// 0x0024 (0x02B0 - 0x028C)
class UTgDeviceForm_Telepunch : public UTgDeviceForm
{
public:
	TArray<class UTgAnimNodeChannelFire_Telepunch*>    m_TelepunchNodes3p;                                       // 0x028C(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeChannelFire_Telepunch*>    m_TelepunchNodes1p;                                       // 0x029C(0x0010) (NeedCtorLink)
	unsigned long                                      m_bUltFxActive : 1;                                       // 0x02AC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Telepunch");
		return ptr;
	}


	void RecoverDeviceState(TEnumAsByte<ETG_REP_DEVICE_STATE> DesiredState);
	void STATIC_EnableUltFx(bool bActive);
	void DoInterrupt();
	void StopFire(int nFireModeNum);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	void Generic3(unsigned char byExtraData);
	void Generic2(unsigned char byExtraData);
	void CacheAnimNode(class UAnimNode* Node, bool bIs3p);
	void ClearAnimNodes(bool bIs3p);
};


// Class TgGame.TgDeviceForm_Uppercut
// 0x0000 (0x028C - 0x028C)
class UTgDeviceForm_Uppercut : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Uppercut");
		return ptr;
	}

};


// Class TgGame.TgInvListener_BloodSense
// 0x0000 (0x00C8 - 0x00C8)
class UTgInvListener_BloodSense : public UTgInventoryObject_Listen_ActiveWhileOffCooldown
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_BloodSense");
		return ptr;
	}

};


// Class TgGame.TgPawn_Demon
// 0x0020 (0x32F8 - 0x32D8)
class ATgPawn_Demon : public ATgPawn_Character
{
public:
	unsigned long                                      r_bIsUltActive : 1;                                       // 0x32D8(0x0004) (Net)
	unsigned long                                      r_bIsUltTargeting : 1;                                    // 0x32D8(0x0004) (Net)
	unsigned long                                      r_bIsUltTraveling : 1;                                    // 0x32D8(0x0004) (Net)
	unsigned long                                      c_bUltRevealApplied : 1;                                  // 0x32D8(0x0004)
	unsigned long                                      c_bStimActive : 1;                                        // 0x32D8(0x0004)
	unsigned long                                      r_bTeleportActive : 1;                                    // 0x32D8(0x0004) (Net)
	unsigned long                                      r_bTeleportAlmostFinished : 1;                            // 0x32D8(0x0004) (Net)
	unsigned long                                      r_bBloodSenseActive : 1;                                  // 0x32D8(0x0004) (Net)
	unsigned long                                      c_bBloodSenseRevealApplied : 1;                           // 0x32D8(0x0004)
	unsigned long                                      m_bUseTeleportZoom : 1;                                   // 0x32D8(0x0004)
	unsigned long                                      m_bUseTelepunchZoom : 1;                                  // 0x32D8(0x0004)
	unsigned long                                      m_bTelepunchTargetLocked : 1;                             // 0x32D8(0x0004)
	float                                              r_fBloodSenseThreshold;                                   // 0x32DC(0x0004) (Net)
	float                                              c_fBloodSenseUpdateTimer;                                 // 0x32E0(0x0004)
	float                                              c_fBloodSenseUpdateRate;                                  // 0x32E4(0x0004)
	float                                              s_fPostUltKillVoiceTimer;                                 // 0x32E8(0x0004)
	int                                                s_LastTelepunchTargetPawnId;                              // 0x32EC(0x0004)
	class ATgPawn_Character*                           m_TelepunchTarget;                                        // 0x32F0(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Demon");
		return ptr;
	}


	void STATIC_UpdateTeleportSoundSwitch();
	void ApplyUltTravelingFx(bool bVisible);
	void PauseDeviceTimers(bool bPaused);
	void ClientOnUltFinished();
	void OnUltFinished();
	void ClientOnUltStarted();
	void OnUltStarted();
	void ServerNotifyTelepunchTarget(class ATgPawn_Character* pTarget);
	void STATIC_GetCameraZoomOverride(float* fZoom, float* fZoomDuration);
	void CancelHUD();
	void SetTargetRevealed(class ATgRepInfo_Player* pPRI, bool bRevealed, bool bFullScale, bool bHideWhenInLOS);
	bool STATIC_IsValidUltTarget(class ATgPawn* pPawn);
	void ClearUltTargeting();
	void ReplicatedEvent(const struct FName& VarName);
};


// Class TgGame.TgProj_DemonTeleport
// 0x0004 (0x0530 - 0x052C)
class ATgProj_DemonTeleport : public ATgProj_Simulated
{
public:
	unsigned long                                      m_bStopped : 1;                                           // 0x052C(0x0004)
	unsigned long                                      m_bTriggerExplosion : 1;                                  // 0x052C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_DemonTeleport");
		return ptr;
	}


	void StopMoving(const struct FVector& NewLocation);
	void RangeReached();
	void ExplodeOnTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void HitWall(const struct FVector& HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp);
	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
};


// Class TgGame.TgProj_Telepunch
// 0x0000 (0x052C - 0x052C)
class ATgProj_Telepunch : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Telepunch");
		return ptr;
	}


	void ExplodeOnTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgDevice_Booster
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_Booster : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Booster");
		return ptr;
	}


	bool CanBeInterrupted();
	bool CanBeCanceled();
	bool STATIC_IsToggleDevice();
	bool CanBeCrippled();
};


// Class TgGame.TgDevice_Thrust
// 0x0000 (0x0A80 - 0x0A80)
class ATgDevice_Thrust : public ATgDevice_Charge
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Thrust");
		return ptr;
	}


	bool ShouldInterruptReloadOnFire();
	float GetChargeRange();
	void STATIC_GetTargetingAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_DragonSlam
// 0x001C (0x0A28 - 0x0A0C)
class ATgDevice_DragonSlam : public ATgDevice
{
public:
	unsigned long                                      m_bHasHitTarget : 1;                                      // 0x0A0C(0x0004)
	class ATgPawn_Drogoz*                              m_CachedDrogozOwner;                                      // 0x0A10(0x0008)
	class ATgCollisionProxy_Cylinder*                  m_CollisionProxy;                                         // 0x0A18(0x0008)
	class ATgDevice*                                   m_DrogozLeg1;                                             // 0x0A20(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DragonSlam");
		return ptr;
	}


	bool ShouldMountCancelFiring();
	bool CanBeCanceled();
	void STATIC_FireAmmunition();
	void SpawnCollisionProxy();
	void Destroyed();
	void RefundEnergy();
	void ServerImpactTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void ClientImpactTarget();
	void OnProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void CustomFire();
	bool STATIC_InterceptRightMousePressed(class ATgPlayerController* TgController);
	bool STATIC_HasDrogozLeg1();
};


// Class TgGame.TgDevice_DrogozInhand
// 0x002C (0x0A38 - 0x0A0C)
class ATgDevice_DrogozInhand : public ATgDevice
{
public:
	class ATgPawn_Drogoz*                              m_CachedDrogozPawn;                                       // 0x0A0C(0x0008)
	class ATgDevice*                                   m_DrogozLeg2;                                             // 0x0A14(0x0008)
	struct FVector                                     m_vSalvoProjectileSpawnOffset;                            // 0x0A1C(0x000C)
	unsigned long                                      m_bStartedSalvo : 1;                                      // 0x0A28(0x0004)
	class ATgDevice*                                   m_SalvoDevice;                                            // 0x0A2C(0x0008)
	int                                                m_nSalvoRockets;                                          // 0x0A34(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DrogozInhand");
		return ptr;
	}


	class AProjectile* ProjectileFire(int ProjectileIndex);
	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
	void ServerStartSalvoReload();
	void SalvoPostFireTimer();
	void STATIC_EndSalvo();
	void PrimeSalvo();
	struct FVector GetProjectileSpawnOffset();
	void GiveAmmoWithClientSync(int Amount);
	void SetAmmo(int AmmoCount, int ClipSize, bool bShouldValidate, int ValidationIDOverride);
	bool STATIC_HasCachedDrogozPawn();
	void STATIC_FireAmmunition();
	bool HasDrogozLeg2();
	bool CanFiringBeLocked();
	bool ShouldAutoFire();
	bool CanReload(bool bIsAutoReload);
};


// Class TgGame.TgDevice_FireSpit
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_FireSpit : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_FireSpit");
		return ptr;
	}

};


// Class TgGame.TgDevice_Salvo
// 0x0010 (0x0A1C - 0x0A0C)
class ATgDevice_Salvo : public ATgDevice
{
public:
	class ATgDevice_DrogozInhand*                      m_CachedInhand;                                           // 0x0A0C(0x0008)
	class ATgDevice*                                   m_DrogozLeg2;                                             // 0x0A14(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Salvo");
		return ptr;
	}


	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
	void STATIC_EndSalvo();
	void STATIC_HandleDeviceFormStartFire(int nDeviceModeNum, float fRefireTime, struct FAimData* Aim);
	bool ShouldMountCancelFiring();
	bool CanBeInterrupted();
	bool HasDrogozLeg2();
	void OnStartFireRequestSent();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	bool ShouldInterruptStealth();
};


// Class TgGame.TgDevice_Survival
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_Survival : public ATgDevice
{
public:
	class ATgDevice*                                   m_ThrustDevice;                                           // 0x0A0C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Survival");
		return ptr;
	}


	bool ShouldCooldownAfterFire();
	bool StartFire();
};


// Class TgGame.TgDevice_WYRMJets
// 0x0010 (0x0A1C - 0x0A0C)
class ATgDevice_WYRMJets : public ATgDevice
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_MoveSpeedMultiplier;           // 0x0A0C(0x0008) (Const, Native, NoExport)
	class ATgDevice*                                   m_CachedBoosterDevice;                                    // 0x0A14(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_WYRMJets");
		return ptr;
	}


	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
	bool STATIC_ShouldUseGradualMovement();
	float STATIC_GetMoveSpeedMultiplier();
};


// Class TgGame.TgDeviceFire_DrogozInhand
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_DrogozInhand : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_DrogozInhand");
		return ptr;
	}


	bool CheckValidTarget(class AActor* Target, bool bPredicting);
};


// Class TgGame.TgDeviceFire_DrogozInhand_Salvo
// 0x0008 (0x0270 - 0x0268)
class UTgDeviceFire_DrogozInhand_Salvo : public UTgDeviceFire_DrogozInhand
{
public:
	class ATgDevice_DrogozInhand*                      m_CachedDrogozInhand;                                     // 0x0268(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_DrogozInhand_Salvo");
		return ptr;
	}


	float STATIC_GetPostHitDelay();
	float STATIC_GetBonusShieldDamagePerc();
	bool STATIC_HasCachedDrogozInhand();
};


// Class TgGame.TgDeviceFire_Salvo
// 0x0008 (0x0270 - 0x0268)
class UTgDeviceFire_Salvo : public UTgDeviceFire
{
public:
	class ATgDevice_DrogozInhand*                      m_CachedDrogozInhand;                                     // 0x0268(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Salvo");
		return ptr;
	}


	float STATIC_GetPreHitDelay();
	bool STATIC_HasCachedDrogozInhand();
};


// Class TgGame.TgDeviceForm_Salvo
// 0x002C (0x02B8 - 0x028C)
class UTgDeviceForm_Salvo : public UTgDeviceForm
{
public:
	TArray<class UTgAnimNodeBlendList*>                m_SalvoBlendList1P;                                       // 0x028C(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeBlendList*>                m_SalvoBlendList3P;                                       // 0x029C(0x0010) (NeedCtorLink)
	unsigned long                                      m_bSalvoLightShouldBlink : 1;                             // 0x02AC(0x0004)
	unsigned long                                      m_bSalvoLightIsOn : 1;                                    // 0x02AC(0x0004)
	float                                              m_fLastLightChangeTime;                                   // 0x02B0(0x0004)
	float                                              m_fMinLightChangeTime;                                    // 0x02B4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Salvo");
		return ptr;
	}


	void StopFire(int nFireModeNum);
	void Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	void CacheAnimNode(class UAnimNode* Node, bool bIs3p);
	void ClearAnimNodes(bool bIs3p);
};


// Class TgGame.TgInvListener_Combustible
// 0x0000 (0x00C8 - 0x00C8)
class UTgInvListener_Combustible : public UTgInventoryObject_Listen_ActiveWhileOffCooldown
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_Combustible");
		return ptr;
	}

};


// Class TgGame.TgInvListener_Dragonskin
// 0x0000 (0x00C8 - 0x00C8)
class UTgInvListener_Dragonskin : public UTgInventoryObject_Listen_ActiveWhileOffCooldown
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_Dragonskin");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_BarrierReef
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_BarrierReef : public UTgInventoryObject_Listen_ShellShieldEffect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_BarrierReef");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Spitfire
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_Spitfire : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Spitfire");
		return ptr;
	}

};


// Class TgGame.TgPawn_Drogoz
// 0x0034 (0x330C - 0x32D8)
class ATgPawn_Drogoz : public ATgPawn_Character
{
public:
	unsigned long                                      m_bIsInBooster : 1;                                       // 0x32D8(0x0004)
	unsigned long                                      m_bDragonSlamIsBlocking : 1;                              // 0x32D8(0x0004)
	unsigned long                                      m_bDragonSlamHasHit : 1;                                  // 0x32D8(0x0004)
	unsigned long                                      m_bUseDragonSlamRetrieve : 1;                             // 0x32D8(0x0004)
	unsigned long                                      m_bInBoosterLockout : 1;                                  // 0x32D8(0x0004)
	unsigned long                                      r_bSalvoActiveFlag : 1;                                   // 0x32D8(0x0004) (Net)
	unsigned long                                      r_bCombustibleActive : 1;                                 // 0x32D8(0x0004) (Net)
	unsigned long                                      m_bBoosterUseConstantSpeedReduction : 1;                  // 0x32D8(0x0004) (Edit)
	float                                              m_fCurrentBoosterSpeed;                                   // 0x32DC(0x0004)
	float                                              m_fBoosterEndTime;                                        // 0x32E0(0x0004)
	class ATgDevice*                                   m_CachedBoosterDevice;                                    // 0x32E4(0x0008)
	float                                              m_fBoosterLockoutTime;                                    // 0x32EC(0x0004)
	float                                              m_fBoosterKnockbackLockoutTime;                           // 0x32F0(0x0004)
	float                                              m_fBoosterKnockbackLockoutTimestamp;                      // 0x32F4(0x0004)
	int                                                r_nInhandAmmoRemaining;                                   // 0x32F8(0x0004) (Net)
	float                                              m_fBoosterSpeedReductionRate;                             // 0x32FC(0x0004) (Edit)
	float                                              m_fBoosterInactiveSpeedReductionRate;                     // 0x3300(0x0004) (Edit)
	float                                              m_fBoosterInactiveSpeedReductionDelay;                    // 0x3304(0x0004) (Edit)
	float                                              m_fBoosterInactiveSpeedReductionTimer;                    // 0x3308(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Drogoz");
		return ptr;
	}


	void OnStartTimelapseNewDeviceState();
	bool CanFlyWithoutHover();
	bool RespectsEmoteGlobalCooldown(TEnumAsByte<EEmote> Emote);
	void StartKnockbackLockout();
	void Knock(bool bKnocked, float fKnockbackFrictionOverride, const struct FVector& vKnockbackVelocityOverride);
	void ReplicatedEvent(const struct FName& VarName);
	bool ShouldBeFirstPersonThisTick(TEnumAsByte<ECameraPerspectiveType>* ePersectiveType);
	void DeviceOnStartBuildup(class ATgDevice* Dev);
};


// Class TgGame.TgProj_DrogozRocket
// 0x0004 (0x0530 - 0x052C)
class ATgProj_DrogozRocket : public ATgProj_Simulated
{
public:
	unsigned long                                      m_bWasFromSalvo : 1;                                      // 0x052C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_DrogozRocket");
		return ptr;
	}


	bool ApplyTheHit(class UTgDeviceFire* FireMode, const struct FImpactInfo& Impact, class AActor* DamageInstigator);
};


// Class TgGame.TgProj_Loogie
// 0x0004 (0x0530 - 0x052C)
class ATgProj_Loogie : public ATgProj_Simulated
{
public:
	unsigned long                                      m_bWasExplodedByRocket : 1;                               // 0x052C(0x0004)
	unsigned long                                      m_bIgnoreRocketOwner : 1;                                 // 0x052C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Loogie");
		return ptr;
	}


	bool ApplyTheHit(class UTgDeviceFire* FireMode, const struct FImpactInfo& Impact, class AActor* DamageInstigator);
	bool UseAOE();
	void ClientExplodeSpecial(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void DetonateFromRocket(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void ExplodeOnTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void ScaleAbilityFX();
	void PlayAdditionalHitFX(class AActor* HitActor, const struct FVector& FXLocation, const struct FVector& HitNormal, const struct FVector& ProjDir, TArray<struct FParticleSysParam>* ExplosionParams);
	void STATIC_HideProjectile();
};


// Class TgGame.TgDevice_Blink
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_Blink : public ATgDevice
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_MoveSpeedMultiplier;           // 0x0A0C(0x0008) (Const, Native, NoExport)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Blink");
		return ptr;
	}


	bool CanFireIfLeftMouseDown();
	void OnOwnerLiveRespawn();
	void STATIC_InterruptOtherDevices(class ATgPawn* TgP);
	bool CanFireWithoutAimResult();
	float STATIC_GetFiringPreHitDelay(int nMode);
	bool STATIC_IsTargetingModeReady(TEnumAsByte<EDeviceFailType>* failType);
	bool STATIC_ShouldUseGradualMovement();
	float STATIC_GetMoveSpeedMultiplier();
	bool CanBeCrippled();
};


// Class TgGame.TgDevice_Soar
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_Soar : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Soar");
		return ptr;
	}


	bool ShouldMountCancelFiring();
	bool CanBeInterrupted();
	bool CanBeCanceled();
};


// Class TgGame.TgDevice_Wormhole
// 0x0020 (0x0A2C - 0x0A0C)
class ATgDevice_Wormhole : public ATgDevice
{
public:
	struct FVector                                     m_vPreviousLocation;                                      // 0x0A0C(0x000C)
	class ATgDevice_Blink*                             m_CachedBlink;                                            // 0x0A18(0x0008)
	class UTgDeviceMod_TargetingAimForwarder*          m_WormholeAimForwarderMod;                                // 0x0A20(0x0008) (ExportObject, NeedCtorLink, EditInline)
	unsigned long                                      m_bWormholeEnabled : 1;                                   // 0x0A28(0x0004)
	unsigned long                                      m_bWormholeEndedDuringBlink : 1;                          // 0x0A28(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Wormhole");
		return ptr;
	}


	float GetCustomTimerBarMaxTime();
	float GetCustomTimerBarCurrentTime();
	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
	void ResetWormhole();
	void RefireLockout();
	void ClientRefireLockout();
	void STATIC_DisableWormhole();
	void ClientDisableWormhole();
	void ClientEnableWormhole(const struct FVector& vPrevLocation);
	void ProcWormhole();
	void SavePosition();
	void RequireHardReset();
	void DeviceRestart(bool bPostRevive);
	void OnOwnerRespawn();
	void OnOwnerLiveRespawn();
	void STATIC_GetTargetingAim(struct FAimData* Aim);
};


// Class TgGame.TgDeviceForm_Stasis
// 0x000C (0x0298 - 0x028C)
class UTgDeviceForm_Stasis : public UTgDeviceForm
{
public:
	unsigned long                                      m_bNeedsLoopActivation : 1;                               // 0x028C(0x0004)
	float                                              m_fFireStartTime;                                         // 0x0290(0x0004)
	float                                              m_fLoopDelay;                                             // 0x0294(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Stasis");
		return ptr;
	}


	void StopFire(int nFireModeNum);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
};


// Class TgGame.TgPawn_Evie
// 0x0000 (0x32D8 - 0x32D8)
class ATgPawn_Evie : public ATgPawn_Character
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Evie");
		return ptr;
	}

};


// Class TgGame.TgDeploy_DeadZone
// 0x0000 (0x04A0 - 0x04A0)
class ATgDeploy_DeadZone : public ATgDeploy_EffectField
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_DeadZone");
		return ptr;
	}

};


// Class TgGame.TgDevice_Flutter
// 0x0000 (0x0A80 - 0x0A80)
class ATgDevice_Flutter : public ATgDevice_Charge
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Flutter");
		return ptr;
	}


	void STATIC_GetTargetingAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_FaeFlight
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_FaeFlight : public ATgDevice
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_MoveSpeedMultiplier;           // 0x0A0C(0x0008) (Const, Native, NoExport)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_FaeFlight");
		return ptr;
	}


	bool CanBeCanceled();
	bool ShouldMountCancelFiring();
	bool STATIC_ShouldUseGradualMovement();
	float STATIC_GetMoveSpeedMultiplier();
};


// Class TgGame.TgDevice_FairyInhand
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_FairyInhand : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_FairyInhand");
		return ptr;
	}


	void DeviceAdjustDamage(int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
};


// Class TgGame.TgDevice_Seedling
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_Seedling : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Seedling");
		return ptr;
	}

};


// Class TgGame.TgPawn_Fairy
// 0x002C (0x3304 - 0x32D8)
class ATgPawn_Fairy : public ATgPawn_Character
{
public:
	float                                              m_fFairyFlySpeedModifier;                                 // 0x32D8(0x0004)
	float                                              m_fFlightAccelerationPerSecond;                           // 0x32DC(0x0004) (Edit)
	float                                              m_fFlightDecelerationPerSecond;                           // 0x32E0(0x0004) (Edit)
	float                                              m_fFlightMaxRiseSpeed;                                    // 0x32E4(0x0004) (Edit)
	float                                              m_fAscentDecelerationPerSecond;                           // 0x32E8(0x0004) (Edit)
	float                                              m_fFaeFlightFriction;                                     // 0x32EC(0x0004) (Edit)
	float                                              m_fPreviousAscentVelocity;                                // 0x32F0(0x0004)
	class ATgDevice_Flutter*                           m_CachedFlutterDevice;                                    // 0x32F4(0x0008)
	class ATgDevice_FaeFlight*                         m_CachedFaeFlightDevice;                                  // 0x32FC(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Fairy");
		return ptr;
	}


	struct FVector STATIC_GetChargeDirection();
	bool STATIC_HasFaeFlightDevice();
	bool STATIC_HasFlutterDevice();
};


// Class TgGame.TgProj_Seedling
// 0x0050 (0x05D0 - 0x0580)
class ATgProj_Seedling : public ATgProj_FreeGrenade
{
public:
	int                                                m_nSecondaryProjToSpawn;                                  // 0x0580(0x0004) (Const)
	int                                                m_nSpawnsRemaining;                                       // 0x0584(0x0004)
	class USkeletalMeshComponent*                      m_CachedSMC;                                              // 0x0588(0x0008) (ExportObject, Component, EditInline)
	class UTgSkelControlSingleBone*                    m_GrenadeSkelControl;                                     // 0x0590(0x0008)
	class UTgSkelControlSingleBone*                    m_SpikesSkelControl;                                      // 0x0598(0x0008)
	class UMaterialInstanceConstant*                   m_fCachedMIC;                                             // 0x05A0(0x0008)
	struct FRotator                                    m_rRotationalVelocity;                                    // 0x05A8(0x000C)
	class UTgSilhouetteComponent*                      m_Silhouette;                                             // 0x05B4(0x0008) (ExportObject, Component, EditInline)
	struct FLinearColor                                m_LocalSilhouetteColor;                                   // 0x05BC(0x0010)
	unsigned long                                      m_bSilhouetteInitialized : 1;                             // 0x05CC(0x0004)
	unsigned long                                      m_bSilhouetteAllowed : 1;                                 // 0x05CC(0x0004)
	unsigned long                                      m_bBuildupSoundPlayed : 1;                                // 0x05CC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Seedling");
		return ptr;
	}


	void StartLandExplodeTimer();
	float STATIC_GetPostLandDuration();
	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
	bool CheckTeamPassThrough(class AActor* Other);
	void PostBeginPlay();
	void InitializeSilhouetteComponent();
	struct FVector STATIC_GetRotatedAim(const struct FVector& initialAim, int Angle);
};


// Class TgGame.TgProj_SeedlingSecondary
// 0x0008 (0x05D8 - 0x05D0)
class ATgProj_SeedlingSecondary : public ATgProj_Seedling
{
public:
	unsigned long                                      m_bInitialized : 1;                                       // 0x05D0(0x0004)
	float                                              m_fGrowthLifetime;                                        // 0x05D4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_SeedlingSecondary");
		return ptr;
	}

};


// Class TgGame.TgDeploy_ShieldFernando
// 0x0028 (0x0498 - 0x0470)
class ATgDeploy_ShieldFernando : public ATgDeploy_Shield
{
public:
	int                                                m_nLargeShieldMeshID;                                     // 0x0470(0x0004)
	class UMeshComponent*                              m_SmallMesh;                                              // 0x0474(0x0008) (ExportObject, Component, EditInline)
	class UMeshComponent*                              m_LargeMesh;                                              // 0x047C(0x0008) (ExportObject, Component, EditInline)
	int                                                r_nToweringBarrierHealth;                                 // 0x0484(0x0004) (Net)
	int                                                r_nAegisBonusHealth;                                      // 0x0488(0x0004) (Net)
	unsigned long                                      m_bHasHeatTransfer : 1;                                   // 0x048C(0x0004)
	unsigned long                                      m_bHasRattle : 1;                                         // 0x048C(0x0004)
	class ATgPawn_Fernando*                            m_CachedFernandoOwner;                                    // 0x0490(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_ShieldFernando");
		return ptr;
	}


	void TakeDamage(int Damage, class AController* EventInstigator, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void ReplicatedEvent(const struct FName& VarName);
	bool BenefitsFromPctShieldIncrease();
	void ToggleLargeMesh();
};


// Class TgGame.TgDevice_Aegis
// 0x0004 (0x0A10 - 0x0A0C)
class ATgDevice_Aegis : public ATgDevice
{
public:
	float                                              m_fPreviousMinCooldown;                                   // 0x0A0C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Aegis");
		return ptr;
	}


	void OnCeaseActive();
	void OnBecomeActive();
};


// Class TgGame.TgDevice_FernandoImmortal
// 0x0000 (0x0A6C - 0x0A6C)
class ATgDevice_FernandoImmortal : public ATgDevice_ActiveAura
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_FernandoImmortal");
		return ptr;
	}


	void STATIC_EndLockOutEarly();
	bool ShouldLockJumping();
	bool CanBeCanceled();
};


// Class TgGame.TgDevice_ChargeFernando
// 0x0004 (0x0A84 - 0x0A80)
class ATgDevice_ChargeFernando : public ATgDevice_Charge
{
public:
	float                                              m_fCooldownReduction;                                     // 0x0A80(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ChargeFernando");
		return ptr;
	}


	bool CanBeCanceled();
};


// Class TgGame.TgDevice_FernandoInhand
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_FernandoInhand : public ATgDevice
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_MoveSpeedMultiplier;           // 0x0A0C(0x0008) (Const, Native, NoExport)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_FernandoInhand");
		return ptr;
	}


	bool CanFireIfLeftMouseDown();
	bool STATIC_ShouldUseGradualMovement();
	float STATIC_GetMoveSpeedMultiplier();
};


// Class TgGame.TgDevice_ReachOut
// 0x0000 (0x0A44 - 0x0A44)
class ATgDevice_ReachOut : public ATgDevice_LongReach
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ReachOut");
		return ptr;
	}


	bool STATIC_IsNuggetValid(class AActor* Target);
};


// Class TgGame.TgDevice_ShieldFernando
// 0x0018 (0x0A24 - 0x0A0C)
class ATgDevice_ShieldFernando : public ATgDevice
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_MoveSpeedMultiplier;           // 0x0A0C(0x0008) (Const, Native, NoExport)
	class ATgPawn_Fernando*                            m_CachedPawn;                                             // 0x0A14(0x0008)
	float                                              m_fManaGrace;                                             // 0x0A1C(0x0004)
	float                                              m_fAegisShieldDestroyedLockOutTime;                       // 0x0A20(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ShieldFernando");
		return ptr;
	}


	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
	void STATIC_AegisShieldDestroyedLockoutTimer();
	void STATIC_ManaRegenLockoutTimer();
	bool CanBeCanceled();
	bool STATIC_HasCachedPawn();
	bool CanBeInterrupted();
	void CancelSafetyPeriodTimer();
	void STATIC_InitMaxHealth();
	bool IsFunctionallyToggleDevice();
	void STATIC_UpdateShieldHealthFromMana(class ATgPawn_Fernando* pFernando);
	bool STATIC_ShouldUseGradualMovement();
	float STATIC_GetMoveSpeedMultiplier();
	bool CanBeSilenced();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgPawn_Fernando
// 0x0010 (0x32E8 - 0x32D8)
class ATgPawn_Fernando : public ATgPawn_Character
{
public:
	int                                                r_ShieldDisplayType;                                      // 0x32D8(0x0004) (Net)
	unsigned long                                      r_bHasAegisTalent : 1;                                    // 0x32DC(0x0004) (Net)
	unsigned long                                      r_bAegisShieldWasDestroyed : 1;                           // 0x32DC(0x0004) (Net)
	unsigned long                                      c_bShowingShield : 1;                                     // 0x32DC(0x0004)
	class ATgDevice_ShieldFernando*                    m_CachedShieldDevice;                                     // 0x32E0(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Fernando");
		return ptr;
	}


	void StopShieldFX();
	void PlayLargeShieldFX();
	void PlayShieldFX();
	void ReplicatedEvent(const struct FName& VarName);
	void HideShield();
	void ShowShield();
	float STATIC_GetManaRegen();
	bool STATIC_HasCachedShieldDevice();
	bool STATIC_CanSpawnScalableShields();
	bool SpecialAOEImmunity(const struct FVector& AOECenter, class UTgDeviceFire* instigatingFiremode);
};


// Class TgGame.TgDevice_HyperBeam
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_HyperBeam : public ATgDevice
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_MoveSpeedMultiplier;           // 0x0A0C(0x0008) (Const, Native, NoExport)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_HyperBeam");
		return ptr;
	}


	bool ShouldConsumePowerPoolAfterFire();
	bool ShouldConsumePowerPoolOnStartFire();
	void STATIC_FiringDuration();
	bool ShouldStopActionOnOffhandSlotReleased();
	bool IsFunctionallyToggleDevice();
	bool CanBeCanceled();
	bool STATIC_ShouldUseGradualMovement();
	float STATIC_GetMoveSpeedMultiplier();
};


// Class TgGame.TgDevice_Protection
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_Protection : public ATgDevice
{
public:
	class ATgPawn_Gauntlet*                            m_Gauntlet;                                               // 0x0A0C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Protection");
		return ptr;
	}


	bool ShouldInterruptReloadOnFire();
	bool ShouldCooldownAfterFire();
	void DeliverQueuedPendingHits();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgDevice_Recharge
// 0x000C (0x0A18 - 0x0A0C)
class ATgDevice_Recharge : public ATgDevice
{
public:
	class ATgPawn_Gauntlet*                            m_CachedGauntletPawn;                                     // 0x0A0C(0x0008)
	unsigned long                                      m_bCanTargetShields : 1;                                  // 0x0A14(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Recharge");
		return ptr;
	}


	bool STATIC_HasCachedGauntlet();
	void STATIC_UpdateHitTargetInfo(class AActor* HitActor, const struct FVector& HitLocation);
	void OnInstantShotVerified(const struct FImpactInfo& VerifiedPrimaryImpact);
	struct FImpactInfo CalcWeaponFire(const struct FAimData& Aim, TArray<struct FImpactInfo>* ImpactList);
	void CooldownTimer();
	void ClientStartCooldownTimer();
	void StartCooldownTimer();
	void CancelSafetyTimer();
	bool CanBeCanceled();
	bool ShouldStopActionOnOffhandSlotReleased();
	bool IsFunctionallyToggleDevice();
};


// Class TgGame.TgDevice_SilenceBeam
// 0x0010 (0x0A1C - 0x0A0C)
class ATgDevice_SilenceBeam : public ATgDevice
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_MoveSpeedMultiplier;           // 0x0A0C(0x0008) (Const, Native, NoExport)
	class ATgPawn_Gauntlet*                            m_CachedGauntletPawn;                                     // 0x0A14(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_SilenceBeam");
		return ptr;
	}


	void RemoveSilence(class ATgPawn* pTarget);
	void ApplySilence(class ATgPawn* pTarget);
	float GetCustomTimerBarMaxTime();
	float GetCustomTimerBarCurrentTime();
	bool STATIC_HasCachedGauntlet();
	void STATIC_UpdateSilenceTargetInfo(class AActor* HitActor, const struct FVector& HitLocation);
	void OnInstantShotVerified(const struct FImpactInfo& VerifiedPrimaryImpact);
	struct FImpactInfo CalcWeaponFire(const struct FAimData& Aim, TArray<struct FImpactInfo>* ImpactList);
	void STATIC_FiringTimer();
	void STATIC_UpdateFiringTimer();
	void ClientStartFiringTimer(float fFiringTimer);
	void StartFiringTimer();
	bool ShouldInterruptReloadOnFire();
	void CancelSafetyTimer();
	bool CanBeCanceled();
	bool ShouldStopActionOnOffhandSlotReleased();
	bool ShouldInterruptInhand();
	bool IsFunctionallyToggleDevice();
	bool CanFiringBeCanceledByLeftMouse();
	bool STATIC_IsToggleDevice();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	bool STATIC_ShouldUseGradualMovement();
	float STATIC_GetMoveSpeedMultiplier();
};


// Class TgGame.TgDevice_ArcaneMissilesInhand
// 0x0000 (0x0A24 - 0x0A24)
class ATgDevice_ArcaneMissilesInhand : public ATgDevice_ToggleInhand
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ArcaneMissilesInhand");
		return ptr;
	}

};


// Class TgGame.TgDevice_GauntletInhand
// 0x0000 (0x0A24 - 0x0A24)
class ATgDevice_GauntletInhand : public ATgDevice_ArcaneMissilesInhand
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_GauntletInhand");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_GauntletInhand
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_GauntletInhand : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_GauntletInhand");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_HyperBeam
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_HyperBeam : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_HyperBeam");
		return ptr;
	}


	bool STATIC_IgnoreTargetForBlocking(class AActor* Target);
	struct FWeaponFireResults CalcActorEncroachmentTargetingFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, float RewindTime, TArray<struct FImpactInfo>* ImpactList, TArray<struct FImpactToValidate>* ImpactsToValidate);
};


// Class TgGame.TgDeviceFire_Protection
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_Protection : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Protection");
		return ptr;
	}


	bool STATIC_IgnoreTargetForBlocking(class AActor* Target);
};


// Class TgGame.TgDeviceFire_Recharge
// 0x0008 (0x0270 - 0x0268)
class UTgDeviceFire_Recharge : public UTgDeviceFire
{
public:
	float                                              s_fLastNoShieldFXPlayTimestamp;                           // 0x0268(0x0004)
	float                                              s_fTimeBetweenNoShieldFX;                                 // 0x026C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Recharge");
		return ptr;
	}


	void SpecialShieldDestroyed();
	bool STATIC_IgnoreTargetForBlocking(class AActor* Target);
	bool STATIC_IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth, bool bInvertTeam);
};


// Class TgGame.TgDeviceFire_SilenceBeam
// 0x0014 (0x027C - 0x0268)
class UTgDeviceFire_SilenceBeam : public UTgDeviceFire
{
public:
	class ATgPawn_Gauntlet*                            m_CachedGauntlet;                                         // 0x0268(0x0008)
	float                                              m_fLockOnScale;                                           // 0x0270(0x0004) (Const)
	float                                              m_fServerRangeBufferMult;                                 // 0x0274(0x0004)
	float                                              m_fBaseEncroachmentActorRange;                            // 0x0278(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_SilenceBeam");
		return ptr;
	}


	bool STATIC_IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth, bool bInvertTeam);
};


// Class TgGame.TgDeviceForm_ArcaneMissilesInhand
// 0x000C (0x02A8 - 0x029C)
class UTgDeviceForm_ArcaneMissilesInhand : public UTgDeviceForm_Inhand
{
public:
	class ATgPawn_Gauntlet*                            m_CachedGauntlet;                                         // 0x029C(0x0008)
	float                                              c_fLastReceivedTransitionInTime;                          // 0x02A4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_ArcaneMissilesInhand");
		return ptr;
	}


	void STATIC_UpdateAmmoCountFx(float fPreviousPerc, float fCurrentPerc);
	void STATIC_UpdateAmmoCountSingleFx(class UTgSpecialFx* Fx, float fAmmoPerc);
	void StopFire(int nFireModeNum);
	void RecoverDeviceState(TEnumAsByte<ETG_REP_DEVICE_STATE> DesiredState);
	void PlayToggleTransitionAnimations(float transitionPercent, float totalTransitionTime, bool transitionToActive);
	void Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	class UTgAnimNodeSlot* STATIC_GetFullBodyAnimNode();
	bool STATIC_HasCachedGauntlet();
};


// Class TgGame.TgPawn_Gauntlet
// 0x0058 (0x3330 - 0x32D8)
class ATgPawn_Gauntlet : public ATgPawn_Character
{
public:
	class AActor*                                      r_SilenceTarget;                                          // 0x32D8(0x0008) (Net)
	struct FVector                                     r_SilenceHitOffset;                                       // 0x32E0(0x000C) (Net)
	struct FVector                                     c_InterpSilenceHitOffset;                                 // 0x32EC(0x000C)
	float                                              c_fSilenceHitOffsetInterpSpeed;                           // 0x32F8(0x0004)
	class AActor*                                      r_RechargeTarget;                                         // 0x32FC(0x0008) (Net)
	struct FVector                                     r_RechargeHitOffset;                                      // 0x3304(0x000C) (Net)
	struct FVector                                     c_InterpRechargeHitOffset;                                // 0x3310(0x000C)
	class ATgPawn_Character*                           c_SilenceTarget;                                          // 0x331C(0x0008)
	class ATgPawn_Character*                           c_ProtectionTarget;                                       // 0x3324(0x0008)
	int                                                m_PrePolymorphRechargeShield;                             // 0x332C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Gauntlet");
		return ptr;
	}


	void RestartAllDevices(bool bPostRevive);
	void STATIC_GotBurnCard(int BurnCardId);
	bool STATIC_HasValidSilenceBeamTarget();
	bool STATIC_CanSpawnScalableShields();
	void SetPolymorph(TEnumAsByte<EPolymorphType> NewPolymorph, class AActor* instigatingActor);
	bool STATIC_Is1PBodyOverlay(TEnumAsByte<EOverlayMICType> Type);
	void Tick(float DeltaSeconds);
};


// Class TgGame.TgDeploy_HealingTotem
// 0x0014 (0x0480 - 0x046C)
class ATgDeploy_HealingTotem : public ATgDeployable
{
public:
	float                                              r_fRadiusScale;                                           // 0x046C(0x0004) (Net)
	unsigned long                                      r_bHasHealingRain : 1;                                    // 0x0470(0x0004) (Net)
	unsigned long                                      r_bHasWindTotem : 1;                                      // 0x0470(0x0004) (Net)
	float                                              r_fMonolithReduction;                                     // 0x0474(0x0004) (Net)
	class ATgPawn*                                     m_CachedPawnOwner;                                        // 0x0478(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_HealingTotem");
		return ptr;
	}


	void STATIC_ScaleFXListRadius(float fDamageRadius, float fDamageRadiusUU, TArray<class UObject*>* FxList);
	void ScaleAbilityFX();
	void ScaleAbilityRadius();
	void ReplicatedEvent(const struct FName& VarName);
	void ToggleWindTotemFX();
	void ToggleHealingRainFX();
	void MitigateHealthDamage(class ATgPawn* pInstigator, class UTgEffectDamage* Effect, const struct FImpactInfo& Impact, bool bIsHeadshot, float* NewValue, float* fPercReduction, unsigned char* bWasCapped);
	void AdjustHeal(int nPropertyId, struct FImpactInfo* Impact, float* fHeal);
};


// Class TgGame.TgDevice_GrohkInhand
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_GrohkInhand : public ATgDevice
{
public:
	class ATgPawn_Grohk*                               m_CachedGrohkPawn;                                        // 0x0A0C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_GrohkInhand");
		return ptr;
	}


	void STATIC_UpdateInhandTargetInfo(class AActor* HitActor, const struct FVector& HitLocation);
	void OnInstantShotVerified(const struct FImpactInfo& VerifiedPrimaryImpact);
	struct FImpactInfo CalcWeaponFire(const struct FAimData& Aim, TArray<struct FImpactInfo>* ImpactList);
	bool STATIC_HasCachedGrohkPawn();
};


// Class TgGame.TgDevice_HealingTotem
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_HealingTotem : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_HealingTotem");
		return ptr;
	}


	bool ShouldInterruptReloadOnFire();
	void STATIC_GetGroundTargetAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_Tempest
// 0x0000 (0x0A14 - 0x0A14)
class ATgDevice_Tempest : public ATgDevice_HitPulse
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Tempest");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	bool ShouldInterruptReloadOnFire();
	void PersistTimer();
	void DeliverQueuedPendingHits();
	bool ShouldConsumePowerPoolAfterFire();
	bool ShouldConsumePowerPoolOnStartFire();
	bool CanBeCanceled();
	bool CanBeInterrupted();
	bool CanFireIfLeftMouseDown();
};


// Class TgGame.TgDevice_ShockPulse
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_ShockPulse : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ShockPulse");
		return ptr;
	}


	bool STATIC_IsReloading();
};


// Class TgGame.TgDeviceFire_GrohkInhand
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_GrohkInhand : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_GrohkInhand");
		return ptr;
	}


	bool STATIC_IsArcingAttack();
};


// Class TgGame.TgDeviceFire_Tempest
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_Tempest : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Tempest");
		return ptr;
	}


	struct FImpactInfo CalcAoeFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, float RewindTime, TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgDeviceForm_ArcingBeam
// 0x0020 (0x02AC - 0x028C)
class UTgDeviceForm_ArcingBeam : public UTgDeviceForm
{
public:
	TArray<struct FArcingFXInfo>                       m_ArcingBeamList;                                         // 0x028C(0x0010) (NeedCtorLink)
	class AActor*                                      m_BeamSourceActor;                                        // 0x029C(0x0008)
	float                                              m_fBeamPersistTime;                                       // 0x02A4(0x0004)
	int                                                m_nBeamEffectID;                                          // 0x02A8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_ArcingBeam");
		return ptr;
	}


	void StopArcingBeamEffects(class AActor* Target);
	void STATIC_UpdateBeamEndLocation(int Idx);
	void SetTargetArcingBeamEffect(class AActor* Target);
	void SetSourceArcingBeamEffect(class AActor* Source);
	void StopFire(int nFireModeNum);
};


// Class TgGame.TgDeviceForm_Tempest
// 0x0020 (0x02AC - 0x028C)
class UTgDeviceForm_Tempest : public UTgDeviceForm
{
public:
	class AActor*                                      m_BeamTarget1;                                            // 0x028C(0x0008)
	class AActor*                                      m_BeamTarget2;                                            // 0x0294(0x0008)
	unsigned long                                      m_bBeamActive1 : 1;                                       // 0x029C(0x0004)
	unsigned long                                      m_bBeamActive2 : 1;                                       // 0x029C(0x0004)
	unsigned long                                      m_bBeamDirty1 : 1;                                        // 0x029C(0x0004)
	unsigned long                                      m_bBeamDirty2 : 1;                                        // 0x029C(0x0004)
	float                                              m_fBeamStartTime1;                                        // 0x02A0(0x0004)
	float                                              m_fBeamStartTime2;                                        // 0x02A4(0x0004)
	float                                              m_fBeamOnTime;                                            // 0x02A8(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Tempest");
		return ptr;
	}


	void StopArcingBeamEffects();
	void SetTargetArcingBeamEffect(class AActor* Target);
	void Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	void StopFire(int nFireModeNum);
};


// Class TgGame.TgInvListener_SpiritsDomain
// 0x0000 (0x00DC - 0x00DC)
class UTgInvListener_SpiritsDomain : public UTgInvListener_TargetOverHealed
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_SpiritsDomain");
		return ptr;
	}

};


// Class TgGame.TgPawn_Grohk
// 0x002C (0x3304 - 0x32D8)
class ATgPawn_Grohk : public ATgPawn_Character
{
public:
	class AActor*                                      r_InhandTarget;                                           // 0x32D8(0x0008) (Net)
	struct FVector                                     r_InhandHitOffset;                                        // 0x32E0(0x000C) (Net)
	unsigned long                                      c_bIsInTempest : 1;                                       // 0x32EC(0x0004)
	float                                              c_fTempestOverlayStrength;                                // 0x32F0(0x0004)
	float                                              c_fTempestRampUpRate;                                     // 0x32F4(0x0004) (Const)
	float                                              c_fTempsetRampDownRate;                                   // 0x32F8(0x0004) (Const)
	class ATgDevice_Tempest*                           m_CachedTempest;                                          // 0x32FC(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Grohk");
		return ptr;
	}


	void OnDeviceFormStopFire(int nEquipSlot, int nFireModeNum);
	void OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode, int nAmmoRemaining);
	class UMaterialInstanceConstant* STATIC_GetOverlayMaterial(TEnumAsByte<EOverlayMICType> Type);
};


// Class TgGame.TgDeploy_DeepRoots
// 0x0004 (0x04A4 - 0x04A0)
class ATgDeploy_DeepRoots : public ATgDeploy_EffectField
{
public:
	float                                              r_fRadiusForFX;                                           // 0x04A0(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_DeepRoots");
		return ptr;
	}


	void ScaleAbilityFX();
	void ReplicatedEvent(const struct FName& VarName);
};


// Class TgGame.TgDevice_Whirlwind2
// 0x0004 (0x0A70 - 0x0A6C)
class ATgDevice_Whirlwind2 : public ATgDevice_ActiveAura
{
public:
	float                                              c_fOverrideUltEnergy;                                     // 0x0A6C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Whirlwind2");
		return ptr;
	}


	void Tick(float DeltaTime);
	void STATIC_ClearUltSimulation();
	bool StartFire();
	bool CanBeCanceled();
};


// Class TgGame.TgDevice_Blossom
// 0x0000 (0x0A6C - 0x0A6C)
class ATgDevice_Blossom : public ATgDevice_PassiveAura
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Blossom");
		return ptr;
	}


	void ScaleFX();
	void ScaleCollisionProxy();
	bool ShouldAuraBeActive();
};


// Class TgGame.TgDevice_CripplingThrow
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_CripplingThrow : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CripplingThrow");
		return ptr;
	}

};


// Class TgGame.TgDevice_GroverInhand
// 0x000C (0x0A18 - 0x0A0C)
class ATgDevice_GroverInhand : public ATgDevice
{
public:
	int                                                m_nProjectilesRemaining;                                  // 0x0A0C(0x0004)
	int                                                m_nProjectileCount;                                       // 0x0A10(0x0004)
	float                                              m_fMultiProjectileDelay;                                  // 0x0A14(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_GroverInhand");
		return ptr;
	}


	void STATIC_FireNext();
};


// Class TgGame.TgDevice_Whirlwind
// 0x0000 (0x0A14 - 0x0A14)
class ATgDevice_Whirlwind : public ATgDevice_HitPulse
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Whirlwind");
		return ptr;
	}


	void PersistTimer();
	bool CancelledByJumping();
	bool ShouldLockJumping();
	bool CanBeCanceled();
	bool CanBeInterrupted();
	bool CanFireIfLeftMouseDown();
};


// Class TgGame.TgDevice_OverGrowth
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_OverGrowth : public ATgDevice
{
public:
	class ATgDevice*                                   m_VineDevice;                                             // 0x0A0C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_OverGrowth");
		return ptr;
	}


	bool ShouldCooldownAfterFire();
	bool StartFire();
};


// Class TgGame.TgDevice_Vine
// 0x0024 (0x0A30 - 0x0A0C)
class ATgDevice_Vine : public ATgDevice
{
public:
	class AActor*                                      m_PullTarget;                                             // 0x0A0C(0x0008)
	struct FVector                                     m_vPullLocation;                                          // 0x0A14(0x000C)
	unsigned long                                      m_bCanBeCanceled : 1;                                     // 0x0A20(0x0004)
	unsigned long                                      m_bMissedPull : 1;                                        // 0x0A20(0x0004)
	unsigned long                                      m_bIsPulling : 1;                                         // 0x0A20(0x0004)
	unsigned long                                      m_bHasPulledOnce : 1;                                     // 0x0A20(0x0004)
	unsigned long                                      m_bTeleportedAfterFiring : 1;                             // 0x0A20(0x0004)
	int                                                m_nRampantBloomingFiremodeIndex;                          // 0x0A24(0x0004) (Const)
	class ATgPawn_Grover*                              m_CachedPawn;                                             // 0x0A28(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Vine");
		return ptr;
	}


	bool STATIC_HasCachedPawn();
	void STATIC_RampantBloomingHeal();
	bool CanBeCanceled();
	void AuthStartCooldown(int nMode, float fCooldownTimeOverride);
	bool ShouldCooldownAfterFire();
	void Tick(float DeltaSeconds);
	void SetIsPullingHitSpecial(bool bIsPulling);
	void ClientEndPull();
	void EndPull();
	void MissPull();
	void PullToTarget(class AActor* Target, const struct FVector& targetPos);
	bool STATIC_IsValidPullTarget(class AActor* pCandidate);
	void STATIC_GetReticleTargetAim(struct FAimData* Aim);
};


// Class TgGame.TgDeviceFire_GroverVine
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_GroverVine : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_GroverVine");
		return ptr;
	}


	struct Fdword STATIC_GetTraceFlags(bool bIgnoreWorld);
};


// Class TgGame.TgDeviceForm_Blossom
// 0x0000 (0x028C - 0x028C)
class UTgDeviceForm_Blossom : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Blossom");
		return ptr;
	}


	void Generic1(unsigned char byExtraData);
};


// Class TgGame.TgDeviceForm_Vine
// 0x0038 (0x02C4 - 0x028C)
class UTgDeviceForm_Vine : public UTgDeviceForm
{
public:
	unsigned long                                      m_bBeamActive : 1;                                        // 0x028C(0x0004)
	unsigned long                                      m_bVineInterrupted : 1;                                   // 0x028C(0x0004)
	class AActor*                                      m_BeamTarget;                                             // 0x0290(0x0008)
	struct FVector                                     m_vBeamTargetLocation;                                    // 0x0298(0x000C)
	TArray<class UTgAnimNodeBlendByAbilityVine*>       m_VineBlendList1P;                                        // 0x02A4(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeBlendByAbilityVine*>       m_VineBlendList3P;                                        // 0x02B4(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Vine");
		return ptr;
	}


	void Generic1(unsigned char byExtraData);
	void StopFire(int nFireModeNum);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	void STATIC_DisconnectBeam();
	void ConnectBeamToTarget(class AActor* Target, const struct FVector& Location);
	void CacheAnimNode(class UAnimNode* Node, bool bIs3p);
	void ClearAnimNodes(bool bIs3p);
	bool STATIC_UsesTargetingMode();
};


// Class TgGame.TgInventoryObject_Listen_DeepRoots
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_DeepRoots : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_DeepRoots");
		return ptr;
	}

};


// Class TgGame.TgInvListener_Efflorescence
// 0x0000 (0x00C4 - 0x00C4)
class UTgInvListener_Efflorescence : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_Efflorescence");
		return ptr;
	}

};


// Class TgGame.TgPawn_Grover
// 0x0018 (0x32F0 - 0x32D8)
class ATgPawn_Grover : public ATgPawn_Character
{
public:
	float                                              r_fRadiusForFXBlossom;                                    // 0x32D8(0x0004) (Net)
	unsigned long                                      r_bHasRampantBlooming : 1;                                // 0x32DC(0x0004) (Net)
	class ATgDevice_Vine*                              m_CachedVine;                                             // 0x32E0(0x0008)
	class ATgDevice_Whirlwind2*                        m_CachedUlt;                                              // 0x32E8(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Grover");
		return ptr;
	}


	bool STATIC_HasCachedUlt();
	bool STATIC_HasCachedVine();
	float STATIC_GetUIUltChargePercent();
};


// Class TgGame.TgProj_Vine
// 0x0008 (0x0534 - 0x052C)
class ATgProj_Vine : public ATgProj_Simulated
{
public:
	class UTgDeviceForm_Vine*                          m_VineForm;                                               // 0x052C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Vine");
		return ptr;
	}


	void SetNonThreatening();
	void StartPull(class AActor* Target, const struct FVector& HitLocation);
	void Fizzle();
	void ExplodeOnTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgChampionTickManager
// 0x0064 (0x00C4 - 0x0060)
class UTgChampionTickManager : public UObject
{
public:
	int                                                m_nCurrentFrame;                                          // 0x0060(0x0004)
	int                                                m_nNextID;                                                // 0x0064(0x0004)
	class ATgPlayerController*                         m_CachedPlayerController;                                 // 0x0068(0x0008)
	unsigned long                                      m_bTickThrottlingEnabled : 1;                             // 0x0070(0x0004) (Config)
	float                                              m_fGuaranteedTickDistance;                                // 0x0074(0x0004) (Config)
	int                                                m_nTickGroupCount;                                        // 0x0078(0x0004) (Config)
	unsigned char                                      UnknownData00[0x48];                                      // 0x007C(0x0048) UNKNOWN PROPERTY: MapProperty TgGame.TgChampionTickManager.c_ChampionEntries

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgChampionTickManager");
		return ptr;
	}


	void PrepTick(float fDeltaTime);
	void Initialize();
};


// Class TgGame.TgDeploy_OppressorMine
// 0x009C (0x0508 - 0x046C)
class ATgDeploy_OppressorMine : public ATgDeployable
{
public:
	class ATgPawn*                                     m_CachedPawnOwner;                                        // 0x046C(0x0008)
	class ATgRepInfo_TaskForce*                        m_CachedEnemyTaskForce;                                   // 0x0474(0x0008)
	class ATgPawn_Character*                           r_CurrentTargets[0x6];                                    // 0x047C(0x0008) (Net)
	int                                                m_nBeamFXID;                                              // 0x04AC(0x0004)
	class UTgSpecialFx*                                m_BeamFXs[0x6];                                           // 0x04B0(0x0008)
	unsigned long                                      m_bNeedsNetDirtyUpdate : 1;                               // 0x04E0(0x0004)
	class ATgPawn_LanePusherBase*                      r_StuckCart;                                              // 0x04E4(0x0008) (Net)
	struct FRotator                                    r_StuckRotation;                                          // 0x04EC(0x000C) (Net)
	struct FVector                                     r_CartOffset;                                             // 0x04F8(0x000C) (Net)
	float                                              m_fAmplitudeRadiusScale;                                  // 0x0504(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_OppressorMine");
		return ptr;
	}


	bool DamageShouldEnterCombat();
	void DestroyIt(bool bSkipFx);
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_UpdateAllBeams();
	void RemoveEffects(class ATgPawn_Character* Target);
	void ApplyEffects(class ATgPawn_Character* Target);
	void STATIC_FilterNewTargets(TArray<class ATgPawn_Character*>* newTargets);
	int STATIC_FilterCurrentTargets(int maxTargets);
	bool STATIC_IsValidTarget(class AActor* Target);
};


// Class TgGame.TgDeploy_Transporter
// 0x0030 (0x049C - 0x046C)
class ATgDeploy_Transporter : public ATgDeployable
{
public:
	struct FVector                                     m_StartLocation;                                          // 0x046C(0x000C)
	struct FVector                                     m_ProjectileEndLocation;                                  // 0x0478(0x000C)
	float                                              m_fProjectileHeight;                                      // 0x0484(0x0004)
	class UTgSpecialFx*                                m_DeploymentFX;                                           // 0x0488(0x0008)
	struct FVector                                     r_TeleportLocation;                                       // 0x0490(0x000C) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Transporter");
		return ptr;
	}


	void Tick(float DeltaSeconds);
	void SpawnDeployFX();
	void ReplicatedEvent(const struct FName& VarName);
};


// Class TgGame.TgDevice_KinessaInhand
// 0x001C (0x0A28 - 0x0A0C)
class ATgDevice_KinessaInhand : public ATgDevice
{
public:
	struct FVector                                     m_vSniperProjectileSpawnOffset;                           // 0x0A0C(0x000C) (Edit)
	class UForceFeedbackWaveform*                      m_ForceFeedbackStartFireScout;                            // 0x0A18(0x0008)
	class UForceFeedbackWaveform*                      m_ForceFeedbackStartFireSniper;                           // 0x0A20(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_KinessaInhand");
		return ptr;
	}


	void STATIC_EndSteadyInhandEffects();
	void StartSteadyInhandEffects();
	bool RequiresAmmoToFire();
	void SetFireMode(int nFireModeNum, bool ForceSet);
};


// Class TgGame.TgDevice_OppressorMine
// 0x0024 (0x0A30 - 0x0A0C)
class ATgDevice_OppressorMine : public ATgDevice
{
public:
	TArray<class AActor*>                              m_NewTargetSFXRecentTargets;                              // 0x0A0C(0x0010) (NeedCtorLink)
	TArray<float>                                      m_NewTargetSFXTargetTime;                                 // 0x0A1C(0x0010) (NeedCtorLink)
	float                                              m_fMinNewTargetSFXDelay;                                  // 0x0A2C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_OppressorMine");
		return ptr;
	}


	void PlayOppressorMineNewTargetSound(class AActor* Target);
	void ClientPlayOppressorMineNewTargetSound(class AActor* Target);
};


// Class TgGame.TgDevice_SniperMode
// 0x0014 (0x0A34 - 0x0A20)
class ATgDevice_SniperMode : public ATgDevice_ToggleModeWithLockout
{
public:
	class ATgPawn_Kinessa*                             m_CachedKinessaOwner;                                     // 0x0A20(0x0008)
	class ATgDevice_KinessaInhand*                     m_CachedKinessaInhandDev;                                 // 0x0A28(0x0008)
	unsigned long                                      m_bIsZoomed : 1;                                          // 0x0A30(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_SniperMode");
		return ptr;
	}


	bool ShouldStopActionOnOffhandSlotReleased();
	bool IsFunctionallyToggleDevice();
	bool STATIC_InterceptSlotReleased(class ATgPlayerController* TgController);
	void CompleteInterrupt();
	bool STATIC_IsPlayerToggleZoomSet();
	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
	void RefreshZoomState(bool bZoomOn);
	bool ShouldInterruptInhand();
	bool CanBeInterrupted();
	bool ShouldInterruptMount();
	float STATIC_GetChargeDelayModifier();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgDevice_Transporter
// 0x0010 (0x0A1C - 0x0A0C)
class ATgDevice_Transporter : public ATgDevice
{
public:
	float                                              m_fDowntraceDistance;                                     // 0x0A0C(0x0004)
	struct FVector                                     c_vCurrentTargeting2Location;                             // 0x0A10(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Transporter");
		return ptr;
	}


	void ClientPlayTransporterDestroyedSound();
	void OnDeployableDestroyed(class ATgDeployable* deployable);
	void TickTargetingMode(float DeltaSeconds);
	void STATIC_GetGroundTargetAim(struct FAimData* Aim);
};


// Class TgGame.TgDeviceFire_OppressorMine
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_OppressorMine : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_OppressorMine");
		return ptr;
	}


	bool STATIC_IgnoreTargetForBlocking(class AActor* Target);
};


// Class TgGame.TgDeviceFire_Transporter
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_Transporter : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Transporter");
		return ptr;
	}


	void TeleportFire();
};


// Class TgGame.TgDeviceForm_Transporter
// 0x0020 (0x02AC - 0x028C)
class UTgDeviceForm_Transporter : public UTgDeviceForm
{
public:
	class ATgSkeletalMeshActor*                        c_TargetingModeMeshIndicator2;                            // 0x028C(0x0008)
	class UTgSpecialFx*                                c_TargetingModeFx2;                                       // 0x0294(0x0008)
	struct FVector                                     c_TargetingModeFx2Location;                               // 0x029C(0x000C)
	int                                                c_nTargetingModeFx2Id;                                    // 0x02A8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Transporter");
		return ptr;
	}


	void ShowReticle(bool bShow);
	void ExitTargetingMode();
	void EnterTargetingMode();
	void STATIC_UpdateTargetingModeStatus(TEnumAsByte<ETargetingModeStatus> Status, struct FAimData* Aim);
	void STATIC_UpdateTargetingMode2Location(const struct FVector& NewLocation, const struct FRotator& NewRotation, float DistanceScale);
	void STATIC_InitializeTargetingModeFX();
};


// Class TgGame.TgInvListener_SteadyAim
// 0x0008 (0x00CC - 0x00C4)
class UTgInvListener_SteadyAim : public UTgInvListener
{
public:
	int                                                m_nSteadyAimStackCount;                                   // 0x00C4(0x0004)
	float                                              m_fFullyChargedHitTime;                                   // 0x00C8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_SteadyAim");
		return ptr;
	}

};


// Class TgGame.TgPawn_Kinessa
// 0x0040 (0x3318 - 0x32D8)
class ATgPawn_Kinessa : public ATgPawn_Character
{
public:
	float                                              m_fPreviousPitchMin;                                      // 0x32D8(0x0004)
	float                                              m_fPreviousPitchMax;                                      // 0x32DC(0x0004)
	struct FVector                                     r_vHyperTargetEndLocation;                                // 0x32E0(0x000C) (Net)
	struct FVector                                     r_vHyperShotEndLocation;                                  // 0x32EC(0x000C) (Net)
	unsigned long                                      m_bPendingMovementPenaltyOnLanded : 1;                    // 0x32F8(0x0004)
	unsigned long                                      r_bIsZoomed : 1;                                          // 0x32F8(0x0004) (Net)
	unsigned long                                      m_bIsInInhandPostFire : 1;                                // 0x32F8(0x0004)
	unsigned long                                      c_bHeadHunterFiring : 1;                                  // 0x32F8(0x0004)
	unsigned long                                      r_bTeleportOverlayActive : 1;                             // 0x32F8(0x0004) (Net)
	float                                              m_fScopedSpeedModifier;                                   // 0x32FC(0x0004)
	float                                              m_fZoomChargeTimestamp;                                   // 0x3300(0x0004)
	float                                              r_fFullChargeDelay;                                       // 0x3304(0x0004) (Net)
	float                                              r_fTeleportOverlayMaxStrength;                            // 0x3308(0x0004) (Net)
	float                                              c_fTeleportOverlayStrength;                               // 0x330C(0x0004)
	float                                              r_fTeleportOverlayUpRate;                                 // 0x3310(0x0004) (Net)
	float                                              r_fTeleportOverlayDownRate;                               // 0x3314(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Kinessa");
		return ptr;
	}


	void SetScopeChargeSound(bool IsActive);
	void OnDeviceFormFire(int nEquipSlot, float fRefireTime, int nFireMode);
	void OnDeviceFormStopFire(int nEquipSlot, int nFireModeNum);
	void STATIC_UpdateWeaponZoomEffects(float fZoomAmt);
	float GetZoomChargePercentage();
	void SetZoomState(bool bIsZoomed, float fSpeedModifier, float fChargeDelay);
	void PlayHyperShotEffects();
	void PlayHyperTargetEffects();
	void ReplicatedEvent(const struct FName& VarName);
	void ClearHyperShotLocations();
	void SetHyperShotLocation(const struct FVector& beamEnd);
	void SetHyperTargetLocation(const struct FVector& beamEnd);
	void PlayTeleportFx(int nTeleportState, const struct FVector& vLoc);
	class UMaterialInstanceConstant* STATIC_GetOverlayMaterial(TEnumAsByte<EOverlayMICType> Type);
};


// Class TgGame.TgProj_OppressorMine
// 0x0000 (0x0580 - 0x0580)
class ATgProj_OppressorMine : public ATgProj_FreeGrenade
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_OppressorMine");
		return ptr;
	}


	bool ShouldHitBounce(class AActor* Target, const struct FVector& HitNormal);
	class AActor* CalculateHitActor(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, struct FTraceHitInfo* HitInfo);
	class ATgDeployable* SpawnDeployable(const struct FVector& vLocation, class AActor* TargetActor, const struct FVector& vNormal);
};


// Class TgGame.TgDevice_NinjaRMB1
// 0x000C (0x0A8C - 0x0A80)
class ATgDevice_NinjaRMB1 : public ATgDevice_Charge
{
public:
	unsigned long                                      c_bAlreadyConsumedStamina : 1;                            // 0x0A80(0x0004)
	class ATgPawn_Koga*                                m_CachedKoga;                                             // 0x0A84(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_NinjaRMB1");
		return ptr;
	}


	bool CanFiringBeCanceledByReactivation();
	void OnLinkDevice(class ATgPawn* TgP);
	void ConsumeAmmoFromFiring(int nAmmoConsumptionOverride, int nFireRequestIDOverride);
	void ConsumeStaminaOnFire();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	bool CanFiringBeCanceledByRightMouse();
	bool CanFiringBeCanceledByLeftMouse();
	bool STATIC_IsDeviceFiringLockedForUI();
	bool STATIC_HasEnoughStaminaToFire();
};


// Class TgGame.TgDevice_NinjaRMB2
// 0x0014 (0x0A94 - 0x0A80)
class ATgDevice_NinjaRMB2 : public ATgDevice_Charge
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_MoveSpeedMultiplier;           // 0x0A80(0x0008) (Const, Native, NoExport)
	float                                              m_fLastStaminaPreConsumption;                             // 0x0A88(0x0004)
	class ATgPawn_Koga*                                m_CachedKoga;                                             // 0x0A8C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_NinjaRMB2");
		return ptr;
	}


	bool CanFiringBeCanceledByReactivation();
	void OnLinkDevice(class ATgPawn* TgP);
	void ConsumeAmmoFromFiring(int nAmmoConsumptionOverride, int nFireRequestIDOverride);
	void ConsumeStaminaOnFire();
	bool CanDeviceStartFiringNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDebugRelevant, bool bIgnoreCachedValue, TEnumAsByte<EDeviceFailType>* failType);
	bool CanFiringBeCanceledByRightMouse();
	bool CanFiringBeCanceledByLeftMouse();
	bool STATIC_ShouldUseGradualMovement();
	float STATIC_GetMoveSpeedMultiplier();
	void DeviceAdjustDamage(int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_DragonFang
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_DragonFang : public ATgDevice
{
public:
	class ATgPawn_Koga*                                m_CachedKoga;                                             // 0x0A0C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DragonFang");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	bool ShouldBlockDragonStance();
	bool TickHealthDrain(float fDeltaTime);
};


// Class TgGame.TgDevice_CycloneStrike
// 0x000C (0x0A20 - 0x0A14)
class ATgDevice_CycloneStrike : public ATgDevice_HitPulse
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_MoveSpeedMultiplier;           // 0x0A14(0x0008) (Const, Native, NoExport)
	unsigned long                                      m_bLockInputOnPostFire : 1;                               // 0x0A1C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CycloneStrike");
		return ptr;
	}


	bool ShouldLockJumping();
	void PersistTimer();
	void STATIC_InterruptOtherDevices(class ATgPawn* TgP);
	bool STATIC_ShouldUseGradualMovement();
	float STATIC_GetMoveSpeedMultiplier();
};


// Class TgGame.TgDevice_MasterOfArms
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_MasterOfArms : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_MasterOfArms");
		return ptr;
	}


	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
};


// Class TgGame.TgDevice_NinjaAltInhand
// 0x000C (0x0A18 - 0x0A0C)
class ATgDevice_NinjaAltInhand : public ATgDevice
{
public:
	unsigned long                                      c_bAlreadyConsumedStamina : 1;                            // 0x0A0C(0x0004)
	class ATgPawn_Koga*                                m_CachedKoga;                                             // 0x0A10(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_NinjaAltInhand");
		return ptr;
	}


	void OnLinkDevice(class ATgPawn* TgP);
	void ConsumeAmmoFromFiring(int nAmmoConsumptionOverride, int nFireRequestIDOverride);
	void ConsumeStaminaOnFire();
	bool CanDeviceStartFiringNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDebugRelevant, bool bIgnoreCachedValue, TEnumAsByte<EDeviceFailType>* failType);
	bool STATIC_IsDeviceFiringLockedForUI();
	bool STATIC_HasEnoughStaminaToFire();
};


// Class TgGame.TgDevice_NinjaF
// 0x0014 (0x0A20 - 0x0A0C)
class ATgDevice_NinjaF : public ATgDevice
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_MoveSpeedMultiplier;           // 0x0A0C(0x0008) (Const, Native, NoExport)
	class ATgPawn_Koga*                                m_CachedKoga;                                             // 0x0A14(0x0008)
	unsigned long                                      m_bSprinting : 1;                                         // 0x0A1C(0x0004)
	unsigned long                                      c_bPendingRestart : 1;                                    // 0x0A1C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_NinjaF");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	bool ShouldInterruptReloadOnFire();
	bool CanFiringBeCanceledByReactivation();
	void ConsumeAmmoFromFiring(int nAmmoConsumptionOverride, int nFireRequestIDOverride);
	void ConsumeStaminaOnFire();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDebugRelevant, TEnumAsByte<EDeviceFailType>* failType);
	void OnServerQueuedRefire();
	bool STATIC_InterceptSlotPressed(class ATgPlayerController* TgController);
	bool STATIC_IsFiringButResetCapable();
	void ClientEndFireAndRestart();
	void DeviceConsumePowerPool(unsigned char FireModeNum);
	bool STATIC_IsDeviceFiringLockedForUI();
	bool STATIC_HasEnoughStaminaToFire();
	float STATIC_GetStaminaCostPerSec();
	bool STATIC_ShouldUseGradualMovement();
	float STATIC_GetMoveSpeedMultiplier();
	bool ShouldBlockReload(class ATgDevice* Dev, bool bIsAutoReload);
};


// Class TgGame.TgDevice_NinjaInhand
// 0x0004 (0x0A10 - 0x0A0C)
class ATgDevice_NinjaInhand : public ATgDevice
{
public:
	float                                              m_fAmmoRefundChance;                                      // 0x0A0C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_NinjaInhand");
		return ptr;
	}


	bool ShouldConsumeAmmo(int nFireRequestId, TArray<struct FImpactToValidate> Impacts);
};


// Class TgGame.TgDevice_NinjaSwap
// 0x0014 (0x0A20 - 0x0A0C)
class ATgDevice_NinjaSwap : public ATgDevice
{
public:
	unsigned long                                      r_bDeferredSwapInterrupt : 1;                             // 0x0A0C(0x0004) (Net)
	class ATgPawn_Koga*                                m_CachedKoga;                                             // 0x0A10(0x0008)
	class ATgDevice_NinjaRMB2*                         m_CachedRMB2;                                             // 0x0A18(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_NinjaSwap");
		return ptr;
	}


	bool CanFiringBeCanceledByReactivation();
	void FiringEndTransition();
	void STATIC_HandleDeviceFormStartFire(int nDeviceModeNum, float fRefireTime, struct FAimData* Aim);
	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
	void OnRMB2Charge();
	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	void NotifyWeaponSwap(float fSwapTime);
	bool IsFunctionallyToggleDevice();
	bool CanBeCanceled();
	bool CanDeviceStartFiringNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDebugRelevant, bool bIgnoreCachedValue, TEnumAsByte<EDeviceFailType>* failType);
	bool STATIC_HasEnoughStaminaToFire();
	bool STATIC_IsDeviceFiringLockedForUI();
	void QueueInterrupt();
	float STATIC_GetStaminaCostPerSec();
};


// Class TgGame.TgDevice_RestoreStamina
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_RestoreStamina : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_RestoreStamina");
		return ptr;
	}


	void IncreaseStaminaBy(int Amount);
};


// Class TgGame.TgDeviceForm_NinjaInhand
// 0x0018 (0x02D0 - 0x02B8)
class UTgDeviceForm_NinjaInhand : public UTgDeviceForm_SpinnerWhileFiring
{
public:
	struct FName                                       c_nmSocketLeft;                                           // 0x02B8(0x0008)
	struct FName                                       c_nmSocketRight;                                          // 0x02C0(0x0008)
	float                                              c_fHeatBuildup;                                           // 0x02C8(0x0004)
	float                                              c_fPerShotHeatBuildup;                                    // 0x02CC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_NinjaInhand");
		return ptr;
	}


	void Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	struct FVector GetTracerSocketLocation(int nIndex);
	float STATIC_GetHeatBuiltUp();
};


// Class TgGame.TgPawn_Koga
// 0x0058 (0x3330 - 0x32D8)
class ATgPawn_Koga : public ATgPawn_Character
{
public:
	unsigned long                                      m_bUseSecondWeapon : 1;                                   // 0x32D8(0x0004)
	unsigned long                                      c_bUseSecondDeathAnim : 1;                                // 0x32D8(0x0004)
	unsigned long                                      c_bWallClimbExpected : 1;                                 // 0x32D8(0x0004)
	int                                                m_nAltInhandSlot;                                         // 0x32DC(0x0004) (Const)
	int                                                m_nAltAltfireSlot;                                        // 0x32E0(0x0004) (Const)
	float                                              m_fStamina;                                               // 0x32E4(0x0004)
	float                                              m_fMaxStamina;                                            // 0x32E8(0x0004)
	float                                              m_fStaminaRegenLockout;                                   // 0x32EC(0x0004)
	float                                              m_fSwapLockoutTime;                                       // 0x32F0(0x0004)
	float                                              m_fStaminaRegenLockoutTime;                               // 0x32F4(0x0004)
	float                                              r_fRemoteStamina;                                         // 0x32F8(0x0004) (Net)
	float                                              c_fOldRemoteStamina;                                      // 0x32FC(0x0004)
	class ATgDevice_NinjaF*                            m_CachedNinjaF;                                           // 0x3300(0x0008)
	class ATgDevice_NinjaSwap*                         m_CachedNinjaSwap;                                        // 0x3308(0x0008)
	class ATgDevice_WallClimb*                         m_CachedWallClimb;                                        // 0x3310(0x0008)
	class ATgDevice_DragonFang*                        m_CachedDragonFangLeg;                                    // 0x3318(0x0008)
	struct FString                                     m_sSkillIconOverride;                                     // 0x3320(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Koga");
		return ptr;
	}


	void Landed(const struct FVector& HitNormal, class AActor* FloorActor);
	void LiveRespawn(bool bResetHealth, bool bResetDevices);
	void OnRespawn();
	bool Died(class AController* Killer, class UClass* dmgType, const struct FVector& HitLocation);
	bool CannotJumpNow();
	bool DoJump(bool bUpdating, float JumpZSpeed);
	bool StartAction(class ATgDevice* Dev, bool bUpdateTimeStamp, TEnumAsByte<EDeviceFailType>* failType);
	void InterruptInhandReload();
	void SetTargetingDevice(class ATgDevice* Dev, const struct FWeaponMeshSwapStrategy& SwapStrategy);
	void STATIC_FinishedWeaponSwap();
	void SwapToSecondWeapon(bool bSecondWeaponActive);
	struct FName GetDeathAnimName();
	void STATIC_PlayDying(class UClass* dmgType, const struct FVector& HitLoc);
	void BecomeViewTarget(class APlayerController* PC);
	void EndViewTarget(class APlayerController* PC);
	void ClientModifyStamina(int fAmtModified, bool bDiscrete);
	float ModifyStamina(float fAmtModified, bool bSendToClient, bool bDiscrete);
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_LinkDragonFang(class ATgDevice_DragonFang* pFang);
	bool AllowBoostedJump();
	bool STATIC_GetTurnRotatorOverride(int* nYawOffset);
	bool STATIC_IsWallClimbing();
	bool STATIC_IsSwappingWeapons();
	int STATIC_GetUISkillEqpSlotOverride(int nEquipSlot, TEnumAsByte<EUI_SKILL_EQUIP_SLOT> eUISlot, bool bBaseSkillOnly, bool bGamepadUI);
	void DeviceOnFire(class ATgDevice* Dev);
	class ATgDevice* STATIC_GetCurrentInhandDevice();
	void STATIC_UpdateKogaSprintFX(float fPrevStamina, float fCurrentStamina);
};


// Class TgGame.TgDevice_CombatSlide
// 0x0008 (0x0A88 - 0x0A80)
class ATgDevice_CombatSlide : public ATgDevice_Charge
{
public:
	int                                                m_nEyeheightAdjustmentWhileSliding;                       // 0x0A80(0x0004) (Edit)
	float                                              m_fEyeHeightSmoothFactor;                                 // 0x0A84(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CombatSlide");
		return ptr;
	}


	bool ShouldLockJumping();
	void STATIC_ExtendJumpLock();
	bool CanBeCanceled();
	bool ShouldBlockReload(class ATgDevice* Dev, bool bIsAutoReload);
	bool ShouldInterruptReloadOnFire();
};


// Class TgGame.TgDevice_InPursuit
// 0x001C (0x0A28 - 0x0A0C)
class ATgDevice_InPursuit : public ATgDevice
{
public:
	unsigned long                                      m_bRecalculateTarget : 1;                                 // 0x0A0C(0x0004)
	class ATgPawn_Character*                           m_CurrentMark;                                            // 0x0A10(0x0008)
	class AActor*                                      m_PursuitTarget;                                          // 0x0A18(0x0008)
	class ATgDevice_LexInhand*                         m_CachedInhand;                                           // 0x0A20(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_InPursuit");
		return ptr;
	}


	void LinkedDeviceEquipped(class ATgDevice* Dev);
	void TruePostFire();
	bool CanBeCanceled();
	bool ShouldBlockReload(class ATgDevice* Dev, bool bIsAutoReload);
};


// Class TgGame.TgDevice_LexInhand
// 0x0024 (0x0A30 - 0x0A0C)
class ATgDevice_LexInhand : public ATgDevice
{
public:
	class ATgPawn_Lex*                                 m_CachedLexPawn;                                          // 0x0A0C(0x0008)
	class ATgDevice_InPursuit*                         m_CachedInPursuitDevice;                                  // 0x0A14(0x0008)
	class ATgDevice_Vengeance_Lex*                     m_CachedVengeanceDevice;                                  // 0x0A1C(0x0008)
	unsigned long                                      m_bShouldAutoFire : 1;                                    // 0x0A24(0x0004)
	unsigned long                                      r_bDeathHastensEquiped : 1;                               // 0x0A24(0x0004) (Net)
	float                                              m_fQueueFireTime;                                         // 0x0A28(0x0004)
	float                                              m_fQueueFireTimeThreshold;                                // 0x0A2C(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_LexInhand");
		return ptr;
	}


	bool STATIC_HasCachedLexPawn();
	void SetAmmo(int AmmoCount, int ClipSize, bool bShouldValidate, int ValidationIDOverride);
	bool STATIC_InterceptLeftMousePressed(class ATgPlayerController* TgController);
	void DeviceAdjustDamage(int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
	bool ShouldAutoFire();
	bool CanFireIfLeftMouseDown();
	struct FAimData STATIC_ValidateReceivedAim(float ClientMovementTimeStamp, const struct FAimData& Aim);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_MarkShot
// 0x000C (0x0A18 - 0x0A0C)
class ATgDevice_MarkShot : public ATgDevice
{
public:
	unsigned long                                      m_bRecalculateMark : 1;                                   // 0x0A0C(0x0004)
	class ATgPawn_Character*                           m_CurrentMark;                                            // 0x0A10(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_MarkShot");
		return ptr;
	}


	bool StartFire();
};


// Class TgGame.TgDevice_Requip
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_Requip : public ATgDevice
{
public:
	class ATgDevice*                                   m_InhandWeapon;                                           // 0x0A0C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Requip");
		return ptr;
	}


	bool ShouldCooldownAfterFire();
	bool CanDeviceStartFiringNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDebugRelevant, bool bIgnoreCachedValue, TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgDevice_Restock
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_Restock : public ATgDevice
{
public:
	class ATgDevice*                                   m_InhandWeapon;                                           // 0x0A0C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Restock");
		return ptr;
	}


	bool ShouldCooldownAfterFire();
};


// Class TgGame.TgDevice_TheLaw
// 0x0010 (0x0A1C - 0x0A0C)
class ATgDevice_TheLaw : public ATgDevice
{
public:
	float                                              m_ExecutePercentage;                                      // 0x0A0C(0x0004)
	struct FRotator                                    AimRotation;                                              // 0x0A10(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_TheLaw");
		return ptr;
	}

};


// Class TgGame.TgDevice_Vengeance_Lex
// 0x0024 (0x0A30 - 0x0A0C)
class ATgDevice_Vengeance_Lex : public ATgDevice
{
public:
	class ATgRepInfo_Player*                           r_MarkedPlayer;                                           // 0x0A0C(0x0008) (Net)
	class ATgRepInfo_Player*                           s_PreviouslyMarkedPlayer;                                 // 0x0A14(0x0008)
	unsigned long                                      s_bRevealApplied : 1;                                     // 0x0A1C(0x0004)
	class ATgDevice*                                   s_DiscoveryDevice;                                        // 0x0A20(0x0008)
	float                                              m_fMarkPlayerRefreshRate;                                 // 0x0A28(0x0004)
	float                                              m_fCheckPlayerRefreshRate;                                // 0x0A2C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Vengeance_Lex");
		return ptr;
	}


	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
	void STATIC_FireAmmunition();
	int CalculateBounty();
	void SetMarkedPlayer(class ATgRepInfo_Player* Target);
	void CheckMarkedPlayer();
	void MarkRandomPlayer(bool bWantsRandom);
};


// Class TgGame.TgDeviceFire_Pursuit
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_Pursuit : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Pursuit");
		return ptr;
	}


	void SetProperty(int nPropertyId, float fNewValue);
};


// Class TgGame.TgDeviceFire_TheLaw
// 0x0008 (0x0270 - 0x0268)
class UTgDeviceFire_TheLaw : public UTgDeviceFire
{
public:
	class ATgWeaponMeshActor_LexInhand*                m_pCachedLexWeaponMeshActor;                              // 0x0268(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_TheLaw");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_LexInhand
// 0x0080 (0x030C - 0x028C)
class UTgDeviceForm_LexInhand : public UTgDeviceForm
{
public:
	struct FName                                       c_nmSocketLeft;                                           // 0x028C(0x0008)
	struct FName                                       c_nmSocketRight;                                          // 0x0294(0x0008)
	TArray<class UTgAnimBlendByPaladinsCharacter_Lex*> m_LexCharacterNodes1P;                                    // 0x029C(0x0010) (NeedCtorLink)
	TArray<class UTgAnimBlendByPaladinsCharacter_Lex*> m_LexCharacterNodes3P;                                    // 0x02AC(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeStanceDualFire*>           m_DualFireStanceNodes1P;                                  // 0x02BC(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeStanceDualFire*>           m_DualFireStanceNodes3P;                                  // 0x02CC(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeFitToDuration*>            m_FireDurationNodes1P;                                    // 0x02DC(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeFitToDuration*>            m_FireDurationNodes3P;                                    // 0x02EC(0x0010) (NeedCtorLink)
	class ATgPawn_Lex*                                 m_CachedLex;                                              // 0x02FC(0x0008)
	int                                                m_nPursuitFireIndex;                                      // 0x0304(0x0004)
	float                                              m_fDeathHastensDuration;                                  // 0x0308(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_LexInhand");
		return ptr;
	}


	struct FVector GetTracerSocketLocation();
	void Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	void SetDualFireParity(bool bLeftFire);
	void OnAmmoChange();
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	void CacheAnimNode(class UAnimNode* Node, bool bIs3p);
	void ClearAnimNodes(bool bIs3p);
	bool STATIC_HasCachedLex();
	void SetFireMode(int nMode);
};


// Class TgGame.TgInvListener_DeathHastens
// 0x0000 (0x00C4 - 0x00C4)
class UTgInvListener_DeathHastens : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_DeathHastens");
		return ptr;
	}

};


// Class TgGame.TgInvListener_KillVengeanceTarget
// 0x0008 (0x00CC - 0x00C4)
class UTgInvListener_KillVengeanceTarget : public UTgInvListener
{
public:
	class ATgDevice_Vengeance_Lex*                     m_CachedVengeance;                                        // 0x00C4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_KillVengeanceTarget");
		return ptr;
	}

};


// Class TgGame.TgInvListener_NearVengeanceTarget
// 0x000C (0x00D0 - 0x00C4)
class UTgInvListener_NearVengeanceTarget : public UTgInvListener
{
public:
	unsigned long                                      m_bIsActive : 1;                                          // 0x00C4(0x0004)
	class ATgDevice_Vengeance_Lex*                     m_CachedVengeance;                                        // 0x00C8(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_NearVengeanceTarget");
		return ptr;
	}

};


// Class TgGame.TgBeamHelper_TheLaw
// 0x0000 (0x00AC - 0x00AC)
class UTgBeamHelper_TheLaw : public UTgBeamHelper
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBeamHelper_TheLaw");
		return ptr;
	}

};


// Class TgGame.TgPawn_Lex
// 0x0068 (0x3340 - 0x32D8)
class ATgPawn_Lex : public ATgPawn_Character
{
public:
	class ATgDevice_Vengeance_Lex*                     m_VengeanceDevice;                                        // 0x32D8(0x0008)
	class ATgDevice_CombatSlide*                       m_CombatSlideDevice;                                      // 0x32E0(0x0008)
	class ATgDevice_InPursuit*                         m_InPursuitDevice;                                        // 0x32E8(0x0008)
	class ATgWeaponMeshActor_LexInhand*                m_WeaponMeshActorLexInhand;                               // 0x32F0(0x0008)
	class ATgPawn*                                     m_Target;                                                 // 0x32F8(0x0008)
	float                                              m_MaxSlideCameraAngle;                                    // 0x3300(0x0004)
	int                                                m_PrevCameraYaw;                                          // 0x3304(0x0004)
	unsigned long                                      c_bUltFiring : 1;                                         // 0x3308(0x0004)
	unsigned long                                      c_bPursuitFiring : 1;                                     // 0x3308(0x0004)
	unsigned long                                      m_bFireLeftWeapon : 1;                                    // 0x3308(0x0004)
	class ATgPawn_Character*                           r_Targets[0x5];                                           // 0x330C(0x0008) (Net)
	TEnumAsByte<ETheLawTargetState>                    r_TargetStates[0x5];                                      // 0x3334(0x0001) (Net)
	unsigned char                                      UnknownData00[0x3];                                       // 0x3339(0x0003) MISSED OFFSET
	int                                                r_nInhandAmmoRemaining;                                   // 0x333C(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Lex");
		return ptr;
	}


	void ManageBeams();
	void SetDualFireParity(bool bLeftFire);
	void OnAmmoChange();
	bool OnLiveRespawn();
	void OnRespawn();
	void PostTimeLapse(bool bPlayOfTheGame);
	bool Died(class AController* Killer, class UClass* dmgType, const struct FVector& HitLocation);
	void ReplicatedEvent(const struct FName& VarName);
	bool STATIC_GetTurnRotatorOverride(int* nYawOffset);
	class AActor* STATIC_GetTargetActor();
	bool STATIC_IsLifeStealTarget(class ATgPawn* Target);
	class ATgDevice_Vengeance_Lex* STATIC_GetCachedVengeanceDevice();
	void STATIC_GlobalOnPlayerDied(class ATgPawn_Character* Player);
	bool STATIC_IsFiringAtMarkShotMark();
};


// Class TgGame.TgWeaponMeshActor_LexInhand
// 0x008D (0x04DD - 0x0450)
class ATgWeaponMeshActor_LexInhand : public ATgWeaponMeshActor
{
public:
	class ATgPawn_Lex*                                 m_CachedLex;                                              // 0x0450(0x0008)
	class UTgBeamHelper*                               c_Beams[0x5];                                             // 0x0458(0x0008)
	class UTgBeamHelper*                               c_ExecutableBeams[0x5];                                   // 0x0480(0x0008)
	TArray<class UTgAnimBlendByPaladinsCharacter_Lex*> m_LexCharacterNodes1P;                                    // 0x04A8(0x0010) (NeedCtorLink)
	TArray<class UTgAnimBlendByPaladinsCharacter_Lex*> m_LexCharacterNodes3P;                                    // 0x04B8(0x0010) (NeedCtorLink)
	struct FName                                       c_LeftInHandSocket;                                       // 0x04C8(0x0008)
	struct FName                                       c_RightInHandSocket;                                      // 0x04D0(0x0008)
	unsigned long                                      c_bJustRenderedBeamsForUlt : 1;                           // 0x04D8(0x0004)
	TEnumAsByte<EBeamState>                            c_eBeamState;                                             // 0x04DC(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgWeaponMeshActor_LexInhand");
		return ptr;
	}


	void OverrideTracerFireLoc(int nIndex, struct FVector* FireLoc);
	void ManageBeams();
	void ManageBeamExecutable(int Index);
	void ManageBeamNonExecutable(int Index);
	void ClearExecutableBeam(int Index);
	void ClearNonExecutableBeam(int Index);
	void ClearBeam(int Index);
	void ClearBeams();
	void STATIC_HideBeams();
	void ShowHitBeams();
	void ShowTargetingBeams();
	bool STATIC_HasCachedLex();
};


// Class TgGame.TgDeploy_IllusionLongbow
// 0x0068 (0x04D4 - 0x046C)
class ATgDeploy_IllusionLongbow : public ATgDeployable
{
public:
	int                                                c_nDefaultBodyMeshId;                                     // 0x046C(0x0004)
	int                                                c_nDefaultHeadMeshId;                                     // 0x0470(0x0004)
	int                                                c_nDefaultWeaponMeshId;                                   // 0x0474(0x0004)
	class UTgSkeletalMeshComponent*                    m_BodyMesh;                                               // 0x0478(0x0008) (ExportObject, Component, EditInline)
	class UTgSkeletalMeshComponent*                    m_HeadMesh;                                               // 0x0480(0x0008) (ExportObject, Component, EditInline)
	class UTgSkeletalMeshComponent_Weapon*             m_WeaponMesh;                                             // 0x0488(0x0008) (ExportObject, Component, EditInline)
	TArray<class UMaterialInstanceConstant*>           m_bodyReplacementMICs;                                    // 0x0490(0x0010) (NeedCtorLink)
	TArray<class UMaterialInstanceConstant*>           m_headReplacementMICs;                                    // 0x04A0(0x0010) (NeedCtorLink)
	TArray<class UMaterialInstanceConstant*>           m_weaponReplacementMICs;                                  // 0x04B0(0x0010) (NeedCtorLink)
	unsigned long                                      m_bFadingAway : 1;                                        // 0x04C0(0x0004)
	float                                              m_fLifeAfterDeathOverride;                                // 0x04C4(0x0004) (Const)
	class ATgCollisionProxy_Cylinder*                  m_FxCollisionProxy;                                       // 0x04C8(0x0008)
	float                                              m_fCollisionRadius;                                       // 0x04D0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_IllusionLongbow");
		return ptr;
	}


	void SpawnCollisionProxy();
	void Destroyed();
	void DestroyIt(bool bSkipFx);
	void OnProxyUnTouch(class AActor* Other);
	void OnProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void ReplaceWithFadeOutMaterial();
	void STATIC_FixupMeshComponent(int nMeshId, class UTgSkeletalMeshComponent* Component);
	void STATIC_UpdateFadeAway();
};


// Class TgGame.TgDevice_Withdraw
// 0x0000 (0x0A80 - 0x0A80)
class ATgDevice_Withdraw : public ATgDevice_ChargeBackward
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Withdraw");
		return ptr;
	}


	void StealthCooldownDelay();
	void ClientStartCooldown(int nMode, float fCooldownTime);
	bool ShouldCooldownAfterFire();
	bool ShouldInterruptInhand();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	bool STATIC_IsDeviceFiringForUI();
};


// Class TgGame.TgDevice_HeatHaze
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_HeatHaze : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_HeatHaze");
		return ptr;
	}


	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
	void STATIC_InhandFired();
};


// Class TgGame.TgDevice_ImpalerArrow
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_ImpalerArrow : public ATgDevice
{
public:
	class ATgPawn_Longbow*                             m_CachedLongbow;                                          // 0x0A0C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ImpalerArrow");
		return ptr;
	}


	void STATIC_FireAmmunition();
	bool HasCachedLongbow();
	bool ShouldInterruptInhand();
	bool ShouldCooldownAfterFire();
	bool STATIC_IsDeviceFiringForUI();
	bool ShouldAltFireOnTick();
};


// Class TgGame.TgDevice_LongbowInhand
// 0x0030 (0x0A3C - 0x0A0C)
class ATgDevice_LongbowInhand : public ATgDevice
{
public:
	class ATgPawn_Longbow*                             m_CachedLongbow;                                          // 0x0A0C(0x0008)
	float                                              s_fLastFireHoldPct;                                       // 0x0A14(0x0004)
	float                                              m_fFireReleasePercent;                                    // 0x0A18(0x0004)
	float                                              m_fImpalerReticleAnimationTimer;                          // 0x0A1C(0x0004)
	float                                              m_fReticleReleaseAnimationDuration;                       // 0x0A20(0x0004) (Edit)
	float                                              m_fImpalerReticleFadeInDuration;                          // 0x0A24(0x0004) (Edit)
	float                                              m_fImpalerReticleFadeOutDuration;                         // 0x0A28(0x0004) (Edit)
	float                                              m_fImpalerReticleGrowth;                                  // 0x0A2C(0x0004) (Edit)
	struct FVector                                     m_vProjectileSpawnOffsetPlanted;                          // 0x0A30(0x000C) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_LongbowInhand");
		return ptr;
	}


	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
	bool CanBeInterrupted();
	bool StartFireHold();
	void ReleaseFireHoldInternal();
	void AdjustSpawnedProjectile(class ATgProjectile* SpawnedProjectile);
	void SetFireHoldAmt(float fFireHoldTime);
	int STATIC_GetProjectileIDOverride(int ProjectileIndex);
	class AProjectile* ProjectileFire(int ProjectileIndex);
	bool CanBeCanceled();
	bool ReleaseHoldOnRightMouseReleased();
	struct FVector GetProjectileSpawnOffset();
	bool HasCachedLongbow();
	bool ShouldAutoFire();
};


// Class TgGame.TgDevice_LongbowPlanted
// 0x0010 (0x0A1C - 0x0A0C)
class ATgDevice_LongbowPlanted : public ATgDevice_Stim
{
public:
	class ATgPawn_Longbow*                             m_CachedLongbow;                                          // 0x0A0C(0x0008)
	class ATgDevice_LongbowInhand*                     m_CachedInhand;                                           // 0x0A14(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_LongbowPlanted");
		return ptr;
	}


	void LinkedDeviceEquipped(class ATgDevice* Dev);
	bool HasCachedLongbow();
	void TransitionOut();
	bool CanBeInterrupted();
	bool CanBeCanceled();
};


// Class TgGame.TgDeviceForm_HeatHaze
// 0x000C (0x0298 - 0x028C)
class UTgDeviceForm_HeatHaze : public UTgDeviceForm
{
public:
	unsigned long                                      m_bShouldBeActive : 1;                                    // 0x028C(0x0004)
	float                                              m_fUltActivationTime;                                     // 0x0290(0x0004)
	float                                              m_fUltActivationPercent;                                  // 0x0294(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_HeatHaze");
		return ptr;
	}


	void Generic1(unsigned char byExtraData);
	void StopFire(int nFireModeNum);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	void STATIC_UpdateMeshMICValue(class UMeshComponent* MeshComp);
	void STATIC_UpdateUltMeshVisibility(float DeltaSeconds);
};


// Class TgGame.TgDeviceForm_LongbowInhand
// 0x004C (0x02D8 - 0x028C)
class UTgDeviceForm_LongbowInhand : public UTgDeviceForm
{
public:
	unsigned long                                      m_bImpalerArrowFXIsActive : 1;                            // 0x028C(0x0004)
	unsigned long                                      m_bBowDrawing : 1;                                        // 0x028C(0x0004)
	float                                              m_fBowDrawPercentage;                                     // 0x0290(0x0004)
	float                                              m_fBowDrawStartPercentage;                                // 0x0294(0x0004)
	float                                              m_fBowDrawTime;                                           // 0x0298(0x0004)
	float                                              m_fBowDrawTotalDuration;                                  // 0x029C(0x0004)
	class ATgPawn_Longbow*                             m_LongbowOwner;                                           // 0x02A0(0x0008)
	TArray<class UTgAnimBlendByPercent*>               m_BlendByPct1P;                                           // 0x02A8(0x0010) (NeedCtorLink)
	TArray<class UTgAnimBlendByPercent*>               m_BlendByPct3P;                                           // 0x02B8(0x0010) (NeedCtorLink)
	class UTgSkelControlSingleBone*                    m_ArrowSkelControl1P;                                     // 0x02C8(0x0008)
	class UTgSkelControlSingleBone*                    m_ImpalerSkelControl1P;                                   // 0x02D0(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_LongbowInhand");
		return ptr;
	}


	void SetToggleState(bool IsActive);
	void PlayToggleTransitionAnimations(float transitionPercent, float totalTransitionTime, bool transitionToActive);
	void DoInterrupt();
	void Generic1(unsigned char byExtraData);
	void Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	void Cache1PAnimNodes(class UTgSkeletalMeshComponent* SkelComp);
	void CacheAnimNode(class UAnimNode* Node, bool bIs3p);
	void ClearAnimNodes(bool bIs3p);
};


// Class TgGame.TgInvListener_DesertSilence
// 0x0000 (0x00C4 - 0x00C4)
class UTgInvListener_DesertSilence : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_DesertSilence");
		return ptr;
	}

};


// Class TgGame.TgPawn_Longbow
// 0x000C (0x32E4 - 0x32D8)
class ATgPawn_Longbow : public ATgPawn_Character
{
public:
	class ATgDevice_LongbowInhand*                     m_CachedInhand;                                           // 0x32D8(0x0008)
	unsigned long                                      r_bImpalerArrowIsActive : 1;                              // 0x32E0(0x0004) (Net)
	unsigned long                                      r_bExplosiveImpalerArrow : 1;                             // 0x32E0(0x0004) (Net)
	unsigned long                                      r_bDesertSilenceArrow : 1;                                // 0x32E0(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Longbow");
		return ptr;
	}


	void ApplyStealthServer(TEnumAsByte<ESTEALTH_TYPE> eStealthed, float fRate, bool bForce);
	void InterruptStealth(class ATgDevice* OriginatingDevice);
	bool CanEmoteDuringTimelapse(TEnumAsByte<EEmote> Emote);
	float GetEmoteInternalCooldown(TEnumAsByte<EEmote> Emote);
	bool RespectsEmoteGlobalCooldown(TEnumAsByte<EEmote> Emote);
	void ClearImpalerArrow();
	bool Died(class AController* Killer, class UClass* dmgType, const struct FVector& HitLocation);
	void KillAllOwnedPets(bool bGameModeSource);
	void ApplyStealthClient();
	void ToggleImpalerArrow(bool bEnabled);
	void ReplicatedEvent(const struct FName& VarName);
	bool STATIC_HasCachedInhandDevice();
	void STATIC_UpdateStealthScarfMaterial();
};


// Class TgGame.TgProj_Greatbow
// 0x0000 (0x052C - 0x052C)
class ATgProj_Greatbow : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Greatbow");
		return ptr;
	}


	void ApplySpawnParams(float fProjectileSpeed, float fGravityScale);
};


// Class TgGame.TgProj_ImpalerArrow
// 0x0000 (0x052C - 0x052C)
class ATgProj_ImpalerArrow : public ATgProj_Greatbow
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_ImpalerArrow");
		return ptr;
	}


	void PlayHitTargetFX(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, bool bExploded);
	bool ApplyTheHit(class UTgDeviceFire* FireMode, const struct FImpactInfo& Impact, class AActor* DamageInstigator);
};


// Class TgGame.TgAnimNodeChannelFire_ImaniFrostBomb
// 0x0000 (0x0180 - 0x0180)
class UTgAnimNodeChannelFire_ImaniFrostBomb : public UTgAnimNodeChannelFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeChannelFire_ImaniFrostBomb");
		return ptr;
	}

};


// Class TgGame.TgDeploy_ManaRift
// 0x0008 (0x0474 - 0x046C)
class ATgDeploy_ManaRift : public ATgDeployable
{
public:
	class ATgPawn*                                     m_CachedPawnOwner;                                        // 0x046C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_ManaRift");
		return ptr;
	}

};


// Class TgGame.TgDevice_SplittingIce
// 0x0004 (0x0A28 - 0x0A24)
class ATgDevice_SplittingIce : public ATgDevice_ArcingBeam
{
public:
	unsigned long                                      m_bShouldRequireRootedTarget : 1;                         // 0x0A24(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_SplittingIce");
		return ptr;
	}


	bool STATIC_IsValidArcTarget(class AActor* TestActor, const struct FArcingInfo& Info, bool bIgnoreHealth);
};


// Class TgGame.TgDevice_DragonFlight
// 0x0028 (0x0A34 - 0x0A0C)
class ATgDevice_DragonFlight : public ATgDevice
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_MoveSpeedMultiplier;           // 0x0A0C(0x0008) (Const, Native, NoExport)
	class ATgPawn_ImaniAvatar*                         m_CachedImaniAvatar;                                      // 0x0A14(0x0008)
	float                                              m_fAccumulatedDeviation;                                  // 0x0A1C(0x0004)
	float                                              m_fDeviationMeanLifetime;                                 // 0x0A20(0x0004)
	TEnumAsByte<EFlightThrottle>                       m_eCurrentThrottle;                                       // 0x0A24(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0A25(0x0003) MISSED OFFSET
	float                                              m_fDragonForcedUpwardAcceleration;                        // 0x0A28(0x0004)
	float                                              m_fDragonPreferredClearance;                              // 0x0A2C(0x0004)
	unsigned long                                      c_bLastInterceptedAscend : 1;                             // 0x0A30(0x0004)
	unsigned long                                      m_bWantsAscend : 1;                                       // 0x0A30(0x0004)
	unsigned long                                      m_bWantsDescend : 1;                                      // 0x0A30(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DragonFlight");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	void SetThrottle(TEnumAsByte<EFlightThrottle> newThrottle);
	bool STATIC_InterceptSlotReleased(class ATgPlayerController* TgController);
	bool STATIC_InterceptSlotPressed(class ATgPlayerController* TgController);
	void STATIC_ServerUpdateAscendDescend(bool bWantsAscend, bool bWantsDescend);
	bool STATIC_WantsDescend();
	bool STATIC_WantsAscend();
	void STATIC_SetInitialBearing(class ATgPawn_ImaniAvatar* pAvatar);
	float STATIC_GetForcedAscentAcceleration();
	float STATIC_GetAscentMultiplier();
	bool STATIC_ShouldUseGradualMovement();
	float STATIC_GetMoveSpeedMultiplier();
	float STATIC_UpdateAccumulatedDeviation(float fDeltaBearing, float fDeltaSeconds);
};


// Class TgGame.TgDevice_DragonsFire
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_DragonsFire : public ATgDevice
{
public:
	class ATgPawn_Imani*                               m_CachedImani;                                            // 0x0A0C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DragonsFire");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
};


// Class TgGame.TgDevice_ImaniDragonE
// 0x000C (0x0A18 - 0x0A0C)
class ATgDevice_ImaniDragonE : public ATgDevice
{
public:
	class ATgPawn_ImaniAvatar*                         m_CachedImaniAvatar;                                      // 0x0A0C(0x0008)
	float                                              m_fUltCancelSafetyPeriod;                                 // 0x0A14(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ImaniDragonE");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgDevice_ImaniDragonInhand
// 0x0010 (0x0A1C - 0x0A0C)
class ATgDevice_ImaniDragonInhand : public ATgDevice
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_MoveSpeedMultiplier;           // 0x0A0C(0x0008) (Const, Native, NoExport)
	class ATgPawn_ImaniAvatar*                         m_CachedImaniAvatar;                                      // 0x0A14(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ImaniDragonInhand");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	bool STATIC_ShouldUseGradualMovement();
	float STATIC_GetMoveSpeedMultiplier();
	void STATIC_GetReticleTargetAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_ImaniF
// 0x0020 (0x0A2C - 0x0A0C)
class ATgDevice_ImaniF : public ATgDevice
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_MoveSpeedMultiplier;           // 0x0A0C(0x0008) (Const, Native, NoExport)
	float                                              m_fLastMultiplierUsed;                                    // 0x0A14(0x0004)
	float                                              m_fInterruptSpeedThresholdSqr;                            // 0x0A18(0x0004)
	class ATgPawn_Imani*                               m_CachedImani;                                            // 0x0A1C(0x0008)
	class ATgDevice_ImaniLMB2*                         m_CachedLMB2;                                             // 0x0A24(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ImaniF");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
	bool IsFunctionallyToggleDevice();
	bool CanBeInterrupted();
	bool CanBeCanceled();
	float STATIC_GetAscentMultiplier();
	bool STATIC_ShouldUseGradualMovement();
	float STATIC_GetMoveSpeedMultiplier();
};


// Class TgGame.TgDevice_ImaniLMB1
// 0x0024 (0x0A30 - 0x0A0C)
class ATgDevice_ImaniLMB1 : public ATgDevice
{
public:
	class ATgPawn_Imani*                               m_CachedImani;                                            // 0x0A0C(0x0008)
	struct FVector                                     m_vProjectileSpawnOffset2;                                // 0x0A14(0x000C)
	unsigned long                                      m_bFireLeftHand : 1;                                      // 0x0A20(0x0004)
	unsigned long                                      m_bClearCasting : 1;                                      // 0x0A20(0x0004)
	float                                              c_fLastFireTimestamp;                                     // 0x0A24(0x0004)
	float                                              c_fTimeToRelaxHands;                                      // 0x0A28(0x0004)
	float                                              m_fClearcastManaConversionLockoutTime;                    // 0x0A2C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ImaniLMB1");
		return ptr;
	}


	void CallServerRestartFireLoop(const struct FAimData& Aim);
	void CallServerStartFire(const struct FAimData& Aim, bool bPendingUpdate);
	void ServerStartFire(float MovementTimeStamp, const struct FVector& MovementInAccel, const struct FVector& MovementClientLoc, unsigned char MovementNewFlags, unsigned char MovementClientRoll, int MovementView, int ClientFireRequestId, unsigned char ClientFireMode, class AActor* HitActor, float StartTraceX, float StartTraceY, float StartTraceZ, float EndTraceX, float EndTraceY, float EndTraceZ, int nCompressedAimVector, bool bFirstBurstShot, float fAttackSpeedPercChange);
	struct FVector GetProjectileSpawnOffset();
	void PlayClientFireFx(const struct FVector& HitLocation, int nSocketIndex, bool bSuccessfulHit, float fRefireTime, int nShotsFired);
	bool ShouldConsumePowerPoolAfterFire();
	bool ShouldConsumePowerPoolOnStartFire();
	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
	bool CanBeInterrupted();
	bool CanBeCanceled();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	float STATIC_GetCachedFiringPostHitDelay();
	float STATIC_GetFiringPreHitDelay(int nMode);
	bool STATIC_HasCachedImani();
};


// Class TgGame.TgDevice_ImaniLMB2
// 0x0034 (0x0A40 - 0x0A0C)
class ATgDevice_ImaniLMB2 : public ATgDevice
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_MoveSpeedMultiplier;           // 0x0A0C(0x0008) (Const, Native, NoExport)
	class ATgPawn_Imani*                               m_CachedImani;                                            // 0x0A14(0x0008)
	struct FVector                                     m_vProjectileSpawnOffset2;                                // 0x0A1C(0x000C)
	unsigned long                                      m_bFireLeftHand : 1;                                      // 0x0A28(0x0004)
	float                                              c_fLastFireTimestamp;                                     // 0x0A2C(0x0004)
	float                                              c_fTimeToRelaxHands;                                      // 0x0A30(0x0004)
	float                                              s_fLastFireHoldPct;                                       // 0x0A34(0x0004)
	float                                              m_fFireReleasePercent;                                    // 0x0A38(0x0004)
	float                                              m_fReticleReleaseAnimationDuration;                       // 0x0A3C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ImaniLMB2");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	void CallServerRestartFireLoop(const struct FAimData& Aim);
	void CallServerStartFire(const struct FAimData& Aim, bool bPendingUpdate);
	void ServerStartFire(float MovementTimeStamp, const struct FVector& MovementInAccel, const struct FVector& MovementClientLoc, unsigned char MovementNewFlags, unsigned char MovementClientRoll, int MovementView, int ClientFireRequestId, unsigned char ClientFireMode, class AActor* HitActor, float StartTraceX, float StartTraceY, float StartTraceZ, float EndTraceX, float EndTraceY, float EndTraceZ, int nCompressedAimVector, bool bFirstBurstShot, float fAttackSpeedPercChange);
	void ServerRestartFireLoop(float MovementTimeStamp, const struct FVector& MovementInAccel, const struct FVector& MovementClientLoc, unsigned char MovementNewFlags, unsigned char MovementClientRoll, int MovementView, int ClientFireRequestId, unsigned char ClientFireMode, class AActor* HitActor, float StartTraceX, float StartTraceY, float StartTraceZ, float EndTraceX, float EndTraceY, float EndTraceZ, int nCompressedAimVector, bool bFirstBurstShot, float fAttackSpeedPercChange);
	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
	bool CanBeInterrupted();
	bool StartFireHold();
	bool ShouldConsumePowerPoolAfterFire();
	bool ShouldConsumePowerPoolOnStartFire();
	void STATIC_FireAmmunition();
	void LockoutClearcast();
	void ReleaseFireHoldInternal();
	void ServerReleaseFireHold(float fClientFireHoldPercent, int nClientFireRequestId);
	void AdjustSpawnedProjectile(class ATgProjectile* SpawnedProjectile);
	struct FVector GetProjectileSpawnOffset();
	void PlayClientFireFx(const struct FVector& HitLocation, int nSocketIndex, bool bSuccessfulHit, float fRefireTime, int nShotsFired);
	void SetFireHoldAmt(float fFireHoldTime);
	bool CanEnterCombat();
	bool CanBeCanceled();
	bool ReleaseHoldOnRightMouseReleased();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	bool STATIC_HasCachedImani();
	bool STATIC_ShouldUseGradualMovement();
	float STATIC_GetMoveSpeedMultiplier();
};


// Class TgGame.TgDevice_ImaniRMB1
// 0x0010 (0x0A1C - 0x0A0C)
class ATgDevice_ImaniRMB1 : public ATgDevice
{
public:
	unsigned long                                      r_bHasActiveProjectile : 1;                               // 0x0A0C(0x0004) (Net)
	float                                              m_fLastDistanceTravelled;                                 // 0x0A10(0x0004)
	class ATgPawn_Imani*                               m_CachedImani;                                            // 0x0A14(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ImaniRMB1");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	bool AttemptDetonation();
	void STATIC_ServerDetonateFrostBomb();
	void STATIC_DetonateFrostBomb();
	bool HasActiveFrostBomb();
	void STATIC_UpdateActiveProjectiles(class ATgProjectile* Proj);
	void STATIC_ProjectileInFlight();
	void STATIC_InterruptOtherDevices(class ATgPawn* TgP);
	bool STATIC_InterceptRightMouseReleased(class ATgPlayerController* TgController);
	bool STATIC_InterceptRightMousePressed(class ATgPlayerController* TgController);
	bool STATIC_InterceptLeftMouseReleased(class ATgPlayerController* TgController);
	bool STATIC_InterceptLeftMousePressed(class ATgPlayerController* TgController);
	bool CanDeviceStartFiringNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDebugRelevant, bool bIgnoreCachedValue, TEnumAsByte<EDeviceFailType>* failType);
	void STATIC_OnActiveProjectile(bool bActive);
	void ReplicatedEvent(const struct FName& VarName);
	bool CanBeSilenced();
	bool STATIC_UsesTargetingMode();
	void DeviceAdjustDamage(int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgDevice_ImaniRMB2
// 0x0020 (0x0A2C - 0x0A0C)
class ATgDevice_ImaniRMB2 : public ATgDevice
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_MoveSpeedMultiplier;           // 0x0A0C(0x0008) (Const, Native, NoExport)
	unsigned long                                      m_bOverrideTargeting : 1;                                 // 0x0A14(0x0004)
	int                                                m_nVFXNumTrailingShots;                                   // 0x0A18(0x0004)
	class ATgPawn_Imani*                               m_CachedImani;                                            // 0x0A1C(0x0008)
	class ATgDevice_ImaniLMB2*                         m_CachedLMB2;                                             // 0x0A24(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ImaniRMB2");
		return ptr;
	}


	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	void PlayClientFireFx(const struct FVector& HitLocation, int nSocketIndex, bool bSuccessfulHit, float fRefireTime, int nShotsFired);
	void StopFire();
	bool SimulateStartFire();
	bool CanBeCanceled();
	bool CanFiringBeCanceledByReactivation();
	bool STATIC_IsInFinalPostFire();
	float STATIC_GetVerticalAirMovementMultiplier();
	bool STATIC_ShouldUseGradualMovement();
	float STATIC_GetMoveSpeedMultiplier();
	float STATIC_GetLateralAirMoveSpeedMultiplier();
	bool CanBeSilenced();
	bool STATIC_UsesTargetingMode();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgDevice_ImaniSwap
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_ImaniSwap : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ImaniSwap");
		return ptr;
	}


	void STATIC_HandleDeviceFormStartFire(int nDeviceModeNum, float fRefireTime, struct FAimData* Aim);
	void STATIC_NotifyStanceSwap(float fSwapTime);
	bool CanBeCanceled();
	bool CanDeviceStartFiringNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDebugRelevant, bool bIgnoreCachedValue, TEnumAsByte<EDeviceFailType>* failType);
	bool STATIC_IsDeviceFiringLockedForUI();
};


// Class TgGame.TgDevice_ManaRift
// 0x0020 (0x0A2C - 0x0A0C)
class ATgDevice_ManaRift : public ATgDevice
{
public:
	class ATgPawn_Imani*                               m_CachedImani;                                            // 0x0A0C(0x0008)
	float                                              m_fDistanceTolerance;                                     // 0x0A14(0x0004)
	struct FVector                                     m_vLastLocation;                                          // 0x0A18(0x000C)
	unsigned long                                      m_bLocationIsLive : 1;                                    // 0x0A24(0x0004)
	float                                              m_fLocationTimestamp;                                     // 0x0A28(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ManaRift");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	bool ShouldInterruptReloadOnFire();
};


// Class TgGame.TgDevice_ImaniUlt
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_ImaniUlt : public ATgDevice_Pet
{
public:
	class ATgPawn_Imani*                               m_CachedImani;                                            // 0x0A0C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ImaniUlt");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	void STATIC_OnSummonEnded();
	void STATIC_FailsafeTeardown();
	float GetSummonDuration();
	class ATgPawn_ImaniAvatar* STATIC_GetAvatarImani();
};


// Class TgGame.TgDeviceFire_ImaniRMB2
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_ImaniRMB2 : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_ImaniRMB2");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_ImaniDragonFlight
// 0x0000 (0x028C - 0x028C)
class UTgDeviceForm_ImaniDragonFlight : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_ImaniDragonFlight");
		return ptr;
	}


	bool ShouldForce3P();
};


// Class TgGame.TgDeviceForm_ImaniF
// 0x0008 (0x0294 - 0x028C)
class UTgDeviceForm_ImaniF : public UTgDeviceForm
{
public:
	class ATgPawn_Imani*                               m_CachedImani;                                            // 0x028C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_ImaniF");
		return ptr;
	}


	void StopFire(int nFireModeNum);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	bool STATIC_HasCachedImani();
};


// Class TgGame.TgDeviceForm_ImaniInhandFire
// 0x0054 (0x02E0 - 0x028C)
class UTgDeviceForm_ImaniInhandFire : public UTgDeviceForm
{
public:
	unsigned long                                      m_bChanneling : 1;                                        // 0x028C(0x0004)
	unsigned long                                      m_bFullyCharged : 1;                                      // 0x028C(0x0004)
	unsigned long                                      m_bUseLeftHand : 1;                                       // 0x028C(0x0004)
	float                                              m_fSpellChannelingPercentage;                             // 0x0290(0x0004)
	float                                              m_fSpellChannelingStartPercentage;                        // 0x0294(0x0004)
	float                                              m_fSpellChannelingTime;                                   // 0x0298(0x0004)
	float                                              m_fSpellChannelingTotalDuration;                          // 0x029C(0x0004)
	TArray<class UTgAnimBlendByPercent*>               m_BlendByPct1P;                                           // 0x02A0(0x0010) (NeedCtorLink)
	TArray<class UTgAnimBlendByPercent*>               m_BlendByPct3P;                                           // 0x02B0(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeStanceDualFire*>           m_DualFireStanceNodes1P;                                  // 0x02C0(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeStanceDualFire*>           m_DualFireStanceNodes3P;                                  // 0x02D0(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_ImaniInhandFire");
		return ptr;
	}


	void SetToggleState(bool IsActive);
	void PlayToggleTransitionAnimations(float transitionPercent, float totalTransitionTime, bool transitionToActive);
	void SetDualFireParity(bool bLeftFire);
	void DoInterrupt();
	void Generic1(unsigned char byExtraData);
	void Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	void CacheAnimNode(class UAnimNode* Node, bool bIs3p);
	void ClearAnimNodes(bool bIs3p);
};


// Class TgGame.TgDeviceForm_ImaniInhandFrost
// 0x0020 (0x02AC - 0x028C)
class UTgDeviceForm_ImaniInhandFrost : public UTgDeviceForm
{
public:
	TArray<class UTgAnimNodeStanceDualFire*>           m_DualFireStanceNodes1P;                                  // 0x028C(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeStanceDualFire*>           m_DualFireStanceNodes3P;                                  // 0x029C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_ImaniInhandFrost");
		return ptr;
	}


	void SetDualFireParity(bool bLeftFire);
	void Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	void CacheAnimNode(class UAnimNode* Node, bool bIs3p);
	void ClearAnimNodes(bool bIs3p);
};


// Class TgGame.TgDeviceForm_ImaniSwap
// 0x000C (0x0298 - 0x028C)
class UTgDeviceForm_ImaniSwap : public UTgDeviceForm
{
public:
	unsigned long                                      m_bSecondaryStance : 1;                                   // 0x028C(0x0004)
	class ATgWeaponMeshActor_ImaniInhand*              m_CachedWMA;                                              // 0x0290(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_ImaniSwap");
		return ptr;
	}


	void RecoverDeviceState(TEnumAsByte<ETG_REP_DEVICE_STATE> DesiredState);
	void DoInterrupt();
	void Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	void StopFire(int nFireModeNum);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	void UpdateStanceFromPawn();
	void STATIC_SetMaterialState(const struct FName& ToStateName, const struct FName& FromStateName, bool useTransitionTime);
	void SetStance(bool bUseSecondary);
	bool STATIC_HasCachedWMA();
	void STATIC_RecalculateMaterial();
};


// Class TgGame.TgPawn_Imani
// 0x0110 (0x33E8 - 0x32D8)
class ATgPawn_Imani : public ATgPawn_Character
{
public:
	float                                              m_fAccumulatedGlideDeviation;                             // 0x32D8(0x0004)
	float                                              r_fGlideDeviationMeanLifetime;                            // 0x32DC(0x0004) (Net)
	unsigned long                                      r_bUseSecondaryStance : 1;                                // 0x32E0(0x0004) (Net)
	unsigned long                                      r_bPreventClearcast : 1;                                  // 0x32E0(0x0004) (Net)
	unsigned long                                      r_bInClearcast : 1;                                       // 0x32E0(0x0004) (Net)
	unsigned long                                      m_bPendingClearcastState : 1;                             // 0x32E0(0x0004)
	unsigned long                                      s_bAvatarNeedsCleanup : 1;                                // 0x32E0(0x0004)
	unsigned long                                      c_bLastBombManuallyDetonated : 1;                         // 0x32E0(0x0004)
	unsigned long                                      m_bHasDragonsFire : 1;                                    // 0x32E0(0x0004)
	unsigned long                                      c_bSimulateAccumulatedGlideDeviation : 1;                 // 0x32E0(0x0004)
	unsigned long                                      c_bAkClearcastActive : 1;                                 // 0x32E0(0x0004)
	unsigned long                                      c_bAkUsingFireStance : 1;                                 // 0x32E0(0x0004)
	unsigned long                                      m_bBlockPossession : 1;                                   // 0x32E0(0x0004)
	unsigned long                                      c_bFXCleanupNeeded : 1;                                   // 0x32E0(0x0004)
	unsigned long                                      m_HideAvatarUIOverlay : 1;                                // 0x32E0(0x0004)
	unsigned long                                      c_bHasDigitizedSkin : 1;                                  // 0x32E0(0x0004)
	TEnumAsByte<ESummonState>                          r_eSummoningState;                                        // 0x32E4(0x0001) (Net)
	TEnumAsByte<ESummonState>                          m_eAcknowledgedSummoningState;                            // 0x32E5(0x0001)
	TEnumAsByte<EAvatarState>                          m_eLastAvatarState;                                       // 0x32E6(0x0001)
	TEnumAsByte<EDigitizedImaniFace>                   c_eCurrentDigitizedImaniFace;                             // 0x32E7(0x0001)
	float                                              m_fIceManaConversionLockout;                              // 0x32E8(0x0004)
	float                                              m_fCachedMana;                                            // 0x32EC(0x0004)
	float                                              r_fLastVerticalMovementSpeedMultiplier;                   // 0x32F0(0x0004) (Net)
	int                                                m_nAltInhandSlot;                                         // 0x32F4(0x0004) (Const)
	int                                                m_nAltAltfireSlot;                                        // 0x32F8(0x0004) (Const)
	float                                              m_fSwapLockoutTime;                                       // 0x32FC(0x0004)
	float                                              r_fMaxMovementDegPerSec;                                  // 0x3300(0x0004) (Net)
	float                                              m_fManaGainedPerPointDamage;                              // 0x3304(0x0004)
	struct FVector                                     r_InhandHitLoc;                                           // 0x3308(0x000C) (Net)
	float                                              m_fLastFlightBearing;                                     // 0x3314(0x0004)
	class ATgDevice_ImaniF*                            m_CachedImaniF;                                           // 0x3318(0x0008)
	class ATgDevice_ImaniUlt*                          m_CachedImaniUlt;                                         // 0x3320(0x0008)
	class ATgDevice_ImaniLMB1*                         m_CachedImaniFrost;                                       // 0x3328(0x0008)
	class ATgDevice_ImaniLMB2*                         m_CachedImaniFire;                                        // 0x3330(0x0008)
	class ATgDevice_ImaniRMB2*                         m_CachedImaniFlameCannon;                                 // 0x3338(0x0008)
	class ATgPawn_ImaniAvatar*                         r_ActiveAvatar;                                           // 0x3340(0x0008) (Net)
	float                                              m_fClearcastDuration;                                     // 0x3348(0x0004)
	float                                              m_fTotalDragonTransition;                                 // 0x334C(0x0004)
	float                                              m_fDragonTransitionTimeLeft;                              // 0x3350(0x0004)
	TArray<int>                                        m_nDevicesDamageToMana;                                   // 0x3354(0x0010) (NeedCtorLink)
	int                                                r_nDragonsFireParity;                                     // 0x3364(0x0004) (Net)
	class AProjectile*                                 m_lastHitProjectile;                                      // 0x3368(0x0008)
	class ATgPlayerController*                         m_pLastPlayerController;                                  // 0x3370(0x0008)
	struct FString                                     m_sSkillIconOverride;                                     // 0x3378(0x0010) (NeedCtorLink)
	float                                              r_fDragonTimePercentRemaining;                            // 0x3388(0x0004) (Net)
	float                                              c_fDigitizedSkinFaceSwapDelayTimer;                       // 0x338C(0x0004)
	float                                              c_fDigitizedSkinFaceSwapDelayMinTime;                     // 0x3390(0x0004) (Edit)
	float                                              c_fDigitizedSkinFaceSwapDelayMaxTime;                     // 0x3394(0x0004) (Edit)
	struct FDigitizedImaniConfig                       c_DigitizedImaniConfig[0x8];                              // 0x3398(0x0008)
	struct FName                                       c_nmDigitizedImaniFaceXParamName;                         // 0x33D8(0x0008)
	struct FName                                       c_nmDigitizedImaniFaceYParamName;                         // 0x33E0(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Imani");
		return ptr;
	}


	bool StartAction(class ATgDevice* Dev, bool bUpdateTimeStamp, TEnumAsByte<EDeviceFailType>* failType);
	void InterruptInhandReload();
	void SetTargetingDevice(class ATgDevice* Dev, const struct FWeaponMeshSwapStrategy& SwapStrategy);
	void STATIC_FinishedStanceSwap();
	void STATIC_SetStanceTargetingDevice();
	void STATIC_SwapToSecondStance(bool bToSecondary);
	void BeginDragonMode();
	void SpectateDragon(bool bUndo);
	void STATIC_AvatarDied(class AActor* Killer);
	void EndDragonMode();
	void InterruptSummon();
	void ClientInterruptSummon(bool bEndMission);
	bool Died(class AController* Killer, class UClass* DamageType, const struct FVector& HitLocation);
	void STATIC_FrostBombDetonated();
	void STATIC_FrostBombFired();
	void STATIC_ClearcastTimeout();
	void ToggleClearcast(bool bActive, bool bForce);
	void STATIC_OnInhandFired();
	void SetSummoningState(TEnumAsByte<ESummonState> eNewState);
	void PropertySet(int nPropertyId, float fPreviousValue, float fNewValue);
	TEnumAsByte<ETG_EQUIP_POINT> OverrideOffhandSlot(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	bool IsSummonFinishedState(TEnumAsByte<ESummonState> eState);
	void STATIC_PrepareForLiveRespawn();
	bool OnLiveRespawn();
	void OnRespawn();
	void ReplicatedEvent(const struct FName& VarName);
	void OnProjectileExploded(class ATgProjectile* ExplodedProjectile, class AActor* HitActor, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_PerformPrePossessionCleanup();
	bool STATIC_IsTimelapseOrSpectating();
	void STATIC_CheckTimelapseViewtarget();
	void ProjectileOnFire(class ATgProjectile* Proj);
	void STATIC_ReportClearcastChange();
	void STATIC_ManaChanged(float fOldValue, float fNewValue);
	void SetSpawnMana();
	void DeviceOnDamaged(struct FOnDamagedParams* Params);
	bool STATIC_IsSwappingStance();
	int STATIC_GetUISkillEqpSlotOverride(int nEquipSlot, TEnumAsByte<EUI_SKILL_EQUIP_SLOT> eUISlot, bool bBaseSkillOnly, bool bGamepadUI);
	class ATgDevice* STATIC_GetCurrentInhandDevice();
	void PawnOnPetAdded(class ATgPawn* pet, class ATgPawn* PetOwner);
	class ATgPawn_ImaniAvatar* STATIC_GetAvatarImani();
	void STATIC_AvatarStateChanged(TEnumAsByte<EAvatarState> eNewState);
	void STATIC_UpdateDragonsFireHud();
	class AActor* STATIC_GetViewTargetOverride();
	void STATIC_PrepareForEndMission();
	TEnumAsByte<EGameplayDesignType> STATIC_GetDesignType();
	bool STATIC_IsJumpDisabled();
	void STATIC_SetInitialGlideBearing();
	void STATIC_ResetAccumulatedGlideDeviation();
	float STATIC_UpdateAccumulatedGlideDeviation(float fDeltaBearing, float fDeltaSeconds);
	void STATIC_ApplyDigitizedImaniFace(TEnumAsByte<EDigitizedImaniFace> eFace);
};


// Class TgGame.TgPawn_ImaniAvatar
// 0x00C4 (0x339C - 0x32D8)
class ATgPawn_ImaniAvatar : public ATgPawn_Character
{
public:
	class ATgPawn_Imani*                               r_CachedImani;                                            // 0x32D8(0x0008) (Net)
	class ATgDevice_DragonFlight*                      m_CachedFlight;                                           // 0x32E0(0x0008)
	float                                              m_fMaxMovementDegPerSec;                                  // 0x32E8(0x0004)
	float                                              m_fAimConstraintAngle;                                    // 0x32EC(0x0004)
	float                                              m_fLastFlightBearing;                                     // 0x32F0(0x0004)
	TEnumAsByte<EAvatarState>                          r_eAvatarState;                                           // 0x32F4(0x0001) (Net)
	TEnumAsByte<EAvatarIntroState>                     c_eIntroState;                                            // 0x32F5(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x32F6(0x0002) MISSED OFFSET
	TArray<struct FScriptDelegate>                     s_OnDeathDelegates;                                       // 0x32F8(0x0010) (NeedCtorLink)
	float                                              m_fHoverSpeedFactor;                                      // 0x3308(0x0004)
	float                                              m_fCruiseSpeedFactor;                                     // 0x330C(0x0004)
	float                                              m_fBoostSpeedFactor;                                      // 0x3310(0x0004)
	float                                              c_fIntroPreparationTime;                                  // 0x3314(0x0004)
	float                                              m_fReadyTimestamp;                                        // 0x3318(0x0004)
	float                                              m_fProjectileSpawnNeckLength;                             // 0x331C(0x0004)
	class UPrimitiveComponent*                         m_DamageCollisionComponent;                               // 0x3320(0x0008) (ExportObject, Component, EditInline)
	int                                                r_nReplicatedAimPitch;                                    // 0x3328(0x0004) (Net)
	int                                                r_nReplicatedAimYaw;                                      // 0x332C(0x0004) (Net)
	float                                              m_fLockedFOV;                                             // 0x3330(0x0004)
	float                                              m_fMinCameraRotationPitch;                                // 0x3334(0x0004)
	float                                              m_fMaxCameraRotationPitch;                                // 0x3338(0x0004)
	float                                              r_fCachedInhandRange;                                     // 0x333C(0x0004) (Net)
	TArray<TEnumAsByte<ETG_EQUIP_POINT>>               c_eAscendInterceptSlots;                                  // 0x3340(0x0010) (NeedCtorLink)
	TArray<TEnumAsByte<ETG_EQUIP_POINT>>               c_eDescendInterceptSlots;                                 // 0x3350(0x0010) (NeedCtorLink)
	unsigned long                                      c_bControlExperiment : 1;                                 // 0x3360(0x0004)
	int                                                m_nFlyUpIconId;                                           // 0x3364(0x0004)
	int                                                m_nFlyDownIconId;                                         // 0x3368(0x0004)
	struct FString                                     m_sFlyUpIcon;                                             // 0x336C(0x0010) (NeedCtorLink)
	struct FString                                     m_sFlyDownIcon;                                           // 0x337C(0x0010) (NeedCtorLink)
	struct FScriptDelegate                             __DestroyedEvent__Delegate;                               // 0x338C(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData01[0x4];                                       // 0x338C(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_ImaniAvatar");
		return ptr;
	}


	bool ShouldCreateCaptureProxy();
	TEnumAsByte<ETG_EQUIP_POINT> OverrideOffhandSlot(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	void AddOnDestroyDelegate(const struct FScriptDelegate& delDestroy);
	bool Died(class AController* Killer, class UClass* DamageType, const struct FVector& HitLocation);
	bool ShouldScoreKill();
	bool CanFlyWithoutHover();
	struct FRotator GetAdjustedAimFor(class AWeapon* W, const struct FVector& StartFireLoc);
	void ScriptPlayIntroAnim();
	void ScriptPrepareIntroAnim();
	struct FVector GetWeaponStartTraceLocation(class ATgDevice* Dev);
	void EndViewTarget(class APlayerController* PC);
	void BecomeViewTarget(class APlayerController* PC);
	bool STATIC_GetCamLocationOffsetOverride(const struct FRotator& vInCameraRotation, float fZoomFactor, TEnumAsByte<ECameraPerspectiveType> ePerspective, struct FVector* vOutCameraSpaceTranslation, struct FVector* vOutCameraPivotLocation);
	void CacheInhandRange(float fNewRange);
	void STATIC_HandleDisconnectedPlayer();
	void RequestEndPossession();
	void STATIC_PrepareForLiveRespawn();
	void PlayDeathAnimation();
	bool AllowRagdoll();
	void HandleDragonSpectator();
	void ReplicatedEvent(const struct FName& VarName);
	struct FVector STATIC_GetCamLocationOffset(const struct FRotator& vCamRot, const struct FVector& vCameraSpaceTx);
	bool STATIC_ShouldPreventCameraPenetration();
	bool ShouldBeFirstPersonThisTick(TEnumAsByte<ECameraPerspectiveType>* ePersectiveType);
	void DeviceOnSetFireMode(class ATgDevice* Dev);
	void STATIC_AdjustAimRestricted(struct FRotator* rAdjustedAim);
	bool STATIC_IsNonCombat();
	bool ShouldInHandDeviceBeHiddenThisTick();
	TEnumAsByte<ETgMeshVisibilityState> STATIC_GetMeshVisibilityStateThisTick();
	void TrackDeath();
	void OnPawnDied();
	void STATIC_SetState(TEnumAsByte<EAvatarState> eNewState, bool bForce);
	bool STATIC_IsStatTrackable();
	void SpawnGuard();
	void SetPetOwner(class ATgPawn* PetOwner);
	void STATIC_PrepareForEndMission();
	TEnumAsByte<EGameplayDesignType> STATIC_GetDesignType();
	bool STATIC_CanPawnParticipateInCapture();
	void STATIC_EndStats();
	void BeginStats();
	void StatsCleanup();
	void STATIC_ValidateStatsTracker();
	void DestroyedEvent(class AActor* Killer);
};


// Class TgGame.TgProj_FrostBomb
// 0x0004 (0x0584 - 0x0580)
class ATgProj_FrostBomb : public ATgProj_FreeGrenade
{
public:
	float                                              m_fDistanceTravelled;                                     // 0x0580(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_FrostBomb");
		return ptr;
	}


	bool CheckTeamPassThrough(class AActor* Other);
};


// Class TgGame.TgProj_Pyreball
// 0x0008 (0x0534 - 0x052C)
class ATgProj_Pyreball : public ATgProj_Simulated
{
public:
	unsigned long                                      r_bIsDragonsFire : 1;                                     // 0x052C(0x0004) (Net)
	int                                                m_nExplodeOnTargetDepth;                                  // 0x0530(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Pyreball");
		return ptr;
	}


	void ExplodeOnTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	struct FName STATIC_GetExplodeInAirFxGroup();
	struct FName STATIC_GetHitWallFxGroup();
	struct FName STATIC_GetHitTargetFxGroup();
};


// Class TgGame.TgWeaponMeshActor_ImaniDragonInhand
// 0x0010 (0x0460 - 0x0450)
class ATgWeaponMeshActor_ImaniDragonInhand : public ATgWeaponMeshActor
{
public:
	TArray<class UTgSpecialFx*>                        m_DragonFireFx;                                           // 0x0450(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgWeaponMeshActor_ImaniDragonInhand");
		return ptr;
	}


	void ActivateFireAimed(bool bSetActive);
	void SetLoopingMuzzleEffects(bool bSetActive, int nEquipSlot, int nFireMode);
	void STATIC_UpdateFireAimedFX();
	void Tick(float DeltaTime);
	struct FVector STATIC_GetAnimationCorrectedAim(const struct FVector& vStartTrace, const struct FVector& vAim);
};


// Class TgGame.TgDeploy_MoonShardTween
// 0x010C (0x05AC - 0x04A0)
class ATgDeploy_MoonShardTween : public ATgDeploy_EffectField
{
public:
	float                                              WalkableFloorZ;                                           // 0x04A0(0x0004) (Const)
	TArray<class ATgPawn_Character*>                   s_PreviouslyAffectedPawns;                                // 0x04A4(0x0010) (NeedCtorLink)
	class ATgPawn_Character*                           r_pAffectedPawns[0x5];                                    // 0x04B4(0x0008) (Net)
	struct FAffectedPawn                               m_AffectedPawnRecords[0x5];                               // 0x04DC(0x001C)
	float                                              m_fPullSpeed;                                             // 0x0568(0x0004)
	float                                              r_fProjectileInitialSpeed;                                // 0x056C(0x0004) (Net)
	float                                              r_fProjectileMaxSpeed;                                    // 0x0570(0x0004) (Net)
	float                                              r_fAccelerationMagnitude;                                 // 0x0574(0x0004) (Net)
	float                                              m_fInnerRadius;                                           // 0x0578(0x0004)
	float                                              m_fGravityFactor;                                         // 0x057C(0x0004)
	float                                              m_fMaxCosineWallSlide;                                    // 0x0580(0x0004)
	struct FVector                                     m_vLastDesiredOrientation;                                // 0x0584(0x000C)
	float                                              m_fMaxRotationSpeedDegPerSec;                             // 0x0590(0x0004)
	unsigned long                                      m_bApplyEffectsOnPawnRelease : 1;                         // 0x0594(0x0004)
	unsigned long                                      m_bNoVerticalAcceleration : 1;                            // 0x0594(0x0004)
	float                                              m_fGrabSourceVerticalPivotOffsetFactor;                   // 0x0598(0x0004)
	float                                              m_fGrabOffsetExtensionFactor;                             // 0x059C(0x0004)
	struct FVector                                     m_vCollisionExtent;                                       // 0x05A0(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_MoonShardTween");
		return ptr;
	}


	void DestroyIt(bool bSkipFx);
	void ProxyTouchHit(class AActor* Other);
	void STATIC_GetPullGrabOffsetFromSource(class ATgPawn* pGrabbedPawn, struct FVector* vOffset, struct FRotator* rRotation);
	void STATIC_UpdateAffectedPawns();
	void DeployComplete();
	void STATIC_ReleaseAllPawns();
	void EndPullGrabByIndex(int nPawnIndex);
	void EndAllPullGrabs();
	void STATIC_EndPullGrab(class ATgPawn* pTarget);
	void STATIC_BeginPullGrabWithIndex(class ATgPawn_Character* pVictim, int nIndex);
	void STATIC_BeginPullGrab(class ATgPawn_Character* pVictim);
	bool STATIC_CanPullGrabTarget(class ATgPawn_Character* pTarget);
	void HitWall(const struct FVector& HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp);
	void ReplicatedEvent(const struct FName& VarName);
	void OnGrabTargetDetach(TEnumAsByte<EGrabState> endingGrabState, class ATgPawn* Target, bool bInterrupted);
	void STATIC_NativeOnGrabEnded(class ATgPawn* pTarget);
	int STATIC_GetBestAvailableGrabPositionIndex(const struct FVector& vLoc);
	struct FVector STATIC_GetGrabOffsetByIndex(int nIndex);
	float STATIC_GetGrabAngle(const struct FVector& vLoc);
	float STATIC_GetProjectileSpeed();
	void STATIC_ForceAllGrabTargetsDetach(TEnumAsByte<EGrabState> eState);
};


// Class TgGame.TgDevice_GuardianChainAttack
// 0x001C (0x0A38 - 0x0A1C)
class ATgDevice_GuardianChainAttack : public ATgDevice_ChainSequence
{
public:
	float                                              m_fPauseAttackChainDuration;                              // 0x0A1C(0x0004)
	struct FVector                                     m_vProjectileSpawnOffset2;                                // 0x0A20(0x000C)
	struct FVector                                     m_vProjectileSpawnOffset3;                                // 0x0A2C(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_GuardianChainAttack");
		return ptr;
	}


	void OnChainReset();
	void STATIC_PauseAttackChain();
	struct FVector GetProjectileSpawnOffset();
	int GetChainMax();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgDevice_DruidInhand
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_DruidInhand : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DruidInhand");
		return ptr;
	}

};


// Class TgGame.TgDevice_DruidLastStand
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_DruidLastStand : public ATgDevice
{
public:
	class ATgPawn_Druid*                               m_CachedDruid;                                            // 0x0A0C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DruidLastStand");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	bool ShouldLockJumping();
	bool StartFire();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgDevice_DruidRMB
// 0x0020 (0x0A2C - 0x0A0C)
class ATgDevice_DruidRMB : public ATgDevice
{
public:
	TArray<struct FDelayedImpactInfo>                  m_DelayedImpacts;                                         // 0x0A0C(0x0010) (Component, NeedCtorLink)
	class ATgPawn_Druid*                               m_CachedDruid;                                            // 0x0A1C(0x0008)
	float                                              m_fMinMoonJuiceToFire;                                    // 0x0A24(0x0004)
	float                                              m_fFailsafeFireloopTimeout;                               // 0x0A28(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DruidRMB");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	bool STATIC_InterceptRightMouseReleased(class ATgPlayerController* TgController);
	void DeliverHit(const struct FImpactInfo& Impact);
	void TrueDeliverHit(const struct FImpactInfo& Impact);
	void InstantFire();
	void STATIC_TimeoutInterrupt();
	bool CanDeviceStartFiringNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDebugRelevant, bool bIgnoreCachedValue, TEnumAsByte<EDeviceFailType>* failType);
	bool ShouldInterruptReloadOnFire();
	float STATIC_GetDelayForPendingImpact(struct FImpactInfo* Impact);
	bool STATIC_ServerIsClientTargetValid(const struct FAimData& Aim);
	bool ShouldBlockReload(class ATgDevice* Dev, bool bIsAutoReload);
	bool STATIC_HasAmmo();
	struct FAimData STATIC_ValidateReceivedAim(float ClientMovementTimeStamp, const struct FAimData& Aim);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgDevice_DruidRMBTargeting
// 0x0020 (0x0A2C - 0x0A0C)
class ATgDevice_DruidRMBTargeting : public ATgDevice
{
public:
	class ATgPawn_Druid*                               m_CachedDruid;                                            // 0x0A0C(0x0008)
	float                                              m_fPreferredTargetGracePeriod;                            // 0x0A14(0x0004)
	float                                              m_fUpdateTargetSamplingInterval;                          // 0x0A18(0x0004)
	float                                              m_fDelayUpdateTargetSample;                               // 0x0A1C(0x0004)
	class ATgPawn*                                     m_pLastPreferredTarget;                                   // 0x0A20(0x0008)
	float                                              m_fTimeOfLastPreferredTargetValidation;                   // 0x0A28(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DruidRMBTargeting");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	bool STATIC_IsTargetValid(class ATgPawn* pTarget, const struct FAimData& Aim, bool bPreferred);
	void STATIC_UpdateTarget();
};


// Class TgGame.TgDevice_DruidUlt
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_DruidUlt : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DruidUlt");
		return ptr;
	}

};


// Class TgGame.TgDevice_GuardianStunRush
// 0x001C (0x0A28 - 0x0A0C)
class ATgDevice_GuardianStunRush : public ATgDevice
{
public:
	class ATgPawn_DruidGuardian*                       m_CachedFox;                                              // 0x0A0C(0x0008)
	class ATgDeployable*                               m_PlaceHolder;                                            // 0x0A14(0x0008)
	float                                              m_fImpactAnimationTime;                                   // 0x0A1C(0x0004)
	class ATgPawn*                                     m_pIntendedRushTarget;                                    // 0x0A20(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_GuardianStunRush");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	bool STATIC_ForwardedPawnTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& vHitLocation, const struct FVector& vHitNormal);
	void ApplyTouchHit(const struct FVector& vHitLocation, const struct FVector& vHitNormal, class AActor* Target);
	void InstantFire();
	void STATIC_StopRush();
	bool STATIC_StartRush();
	void OnDeployableSpawned(class ATgDeployable* deployable);
	bool CanBeInterrupted();
	bool CanBeCanceled();
	void AuthStartCooldown(int nMode, float fCooldownTimeOverride);
	bool STATIC_HasCachedFox();
};


// Class TgGame.TgDevice_DruidLeap
// 0x0000 (0x0A14 - 0x0A14)
class ATgDevice_DruidLeap : public ATgDevice_Leap
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DruidLeap");
		return ptr;
	}


	bool ShouldInterruptReloadOnFire();
	bool ShouldMountCancelFiring();
};


// Class TgGame.TgDevice_DruidSpawnGuardian
// 0x000C (0x0A18 - 0x0A0C)
class ATgDevice_DruidSpawnGuardian : public ATgDevice_Pet
{
public:
	class ATgPawn_Druid*                               m_CachedDruid;                                            // 0x0A0C(0x0008)
	float                                              m_fTraceDownDistance;                                     // 0x0A14(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DruidSpawnGuardian");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	void OnDeployableSpawned(class ATgDeployable* deployable);
	bool ShouldCooldownAfterFire();
	bool CanFireIfLeftMouseDown();
	void STATIC_GetTargetingAim(struct FAimData* Aim);
	bool STATIC_CheckSpotForBaseBelow(const struct FVector& vSpot);
	bool STATIC_IsTargetingModeReady(TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgDeviceFire_DruidRMBTargeting
// 0x0010 (0x0278 - 0x0268)
class UTgDeviceFire_DruidRMBTargeting : public UTgDeviceFire_WorldLOSOnly
{
public:
	float                                              m_fServerScaleBufferMult;                                 // 0x0268(0x0004)
	float                                              m_fBaseEncroachmentActorRange;                            // 0x026C(0x0004)
	float                                              m_fScaleYZ;                                               // 0x0270(0x0004)
	unsigned long                                      m_bFindBestSelection : 1;                                 // 0x0274(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_DruidRMBTargeting");
		return ptr;
	}


	bool STATIC_IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth, bool bInvertTeam);
	bool STATIC_IgnoreTargetForBlocking(class AActor* Target);
};


// Class TgGame.TgDeviceForm_DruidRMB
// 0x0098 (0x0324 - 0x028C)
class UTgDeviceForm_DruidRMB : public UTgDeviceForm
{
public:
	class ATgPawn_Druid*                               m_CachedDruid;                                            // 0x028C(0x0008)
	class AActor*                                      m_pLastTarget;                                            // 0x0294(0x0008)
	struct FDruidHealBeam                              m_DruidHealBeams[0xA];                                    // 0x029C(0x000C)
	int                                                m_nNextBeamIndex;                                         // 0x0314(0x0004)
	struct FVector                                     m_vFireLocationOffset;                                    // 0x0318(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_DruidRMB");
		return ptr;
	}


	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	void Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	int STATIC_ReadyNextBeamIndex();
	bool STATIC_HasCachedDruid();
	void STATIC_PlayDelayedImpactFx(int nIndex);
	void STATIC_KillBeamAtIndex(int nIndex);
	float STATIC_GetDelayForPendingHit(class AActor* pTarget);
};


// Class TgGame.TgPawn_Druid
// 0x0048 (0x3320 - 0x32D8)
class ATgPawn_Druid : public ATgPawn_Character
{
public:
	class ATgDevice_DruidRMBTargeting*                 m_CachedRMBTargeting;                                     // 0x32D8(0x0008)
	class ATgDevice_DruidRMB*                          m_CachedRMB;                                              // 0x32E0(0x0008)
	class ATgDevice_DruidSpawnGuardian*                m_CachedSpawnFox;                                         // 0x32E8(0x0008)
	class ATgPawn*                                     m_GuidedArrowTarget;                                      // 0x32F0(0x0008)
	class ATgPawn_DruidGuardian*                       r_ActiveFox;                                              // 0x32F8(0x0008) (Net)
	float                                              r_fRMBProjectileSpeed;                                    // 0x3300(0x0004) (Net)
	float                                              r_fLastStandAnimTime;                                     // 0x3304(0x0004) (Net)
	int                                                r_nFoxActivityNonce;                                      // 0x3308(0x0004) (Net)
	struct FString                                     m_sDeployRedeployIconOverride;                            // 0x330C(0x0010) (NeedCtorLink)
	unsigned long                                      c_bAcknowledgedIsLeaping : 1;                             // 0x331C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Druid");
		return ptr;
	}


	bool STATIC_RequestFoxRelocation(class ATgDeployable* Placeholder);
	void PawnGeneric1Flashed();
	float STATIC_GetMoonJuice();
	bool STATIC_ShouldPreferExistingTarget();
	void PawnOnPetDied(class ATgPawn* pet, class ATgPawn* PetOwner);
	void PawnOnPetAdded(class ATgPawn* pet, class ATgPawn* PetOwner);
};


// Class TgGame.TgPawn_DruidGuardian
// 0x0088 (0x3360 - 0x32D8)
class ATgPawn_DruidGuardian : public ATgPawn_Character
{
public:
	class ATgPawn_Druid*                               m_CachedDruid;                                            // 0x32D8(0x0008)
	class ATgDevice_GuardianStunRush*                  m_CachedRush;                                             // 0x32E0(0x0008)
	class ATgDeployable*                               r_pRedeployPlaceholder;                                   // 0x32E8(0x0008) (Net)
	float                                              m_fGuardianIntroLockoutTime;                              // 0x32F0(0x0004)
	float                                              m_fRotationRateDegPerSec;                                 // 0x32F4(0x0004)
	float                                              m_fRedeployTweenDuration;                                 // 0x32F8(0x0004)
	float                                              m_fRedeployTweenRampUpDuration;                           // 0x32FC(0x0004)
	float                                              m_fRedeployTweenSpeedFeetPerSecStart;                     // 0x3300(0x0004)
	float                                              m_fRedeployTweenSpeedFeetPerSecEnd;                       // 0x3304(0x0004)
	float                                              m_fRedeployFailsafeTime;                                  // 0x3308(0x0004)
	float                                              m_fStunRushTweenRampUpDuration;                           // 0x330C(0x0004)
	float                                              m_fStunRushTweenSpeedFeetPerSecStart;                     // 0x3310(0x0004)
	float                                              m_fStunRushTweenSpeedFeetPerSecEnd;                       // 0x3314(0x0004)
	float                                              m_fPostRedeployLockout;                                   // 0x3318(0x0004)
	float                                              m_fRedeployVerticalOffset;                                // 0x331C(0x0004)
	float                                              r_fStunRushCooldownTime;                                  // 0x3320(0x0004) (Net)
	unsigned long                                      r_bStunRushInCooldown : 1;                                // 0x3324(0x0004) (Net)
	unsigned long                                      r_bInWispForm : 1;                                        // 0x3324(0x0004) (Net)
	unsigned long                                      r_bStunRushRedeploy : 1;                                  // 0x3324(0x0004) (Net)
	unsigned long                                      r_bAnimatingRushHit : 1;                                  // 0x3324(0x0004) (Net)
	unsigned long                                      c_bPsychicGrowlOnWindupOnly : 1;                          // 0x3324(0x0004)
	int                                                r_nStunRushInCooldownNonce;                               // 0x3328(0x0004) (Net)
	float                                              m_fPostRedeployOutputDuration;                            // 0x332C(0x0004)
	int                                                m_nPostRedeployOutputSlot;                                // 0x3330(0x0004)
	float                                              c_fWispTransitionTime;                                    // 0x3334(0x0004)
	float                                              c_fWispTransitionTimeTotal;                               // 0x3338(0x0004)
	float                                              m_fStunRushPsychicGrowlLockoutTime;                       // 0x333C(0x0004)
	float                                              m_fMaxSeekingTurnDegPerSec;                               // 0x3340(0x0004)
	float                                              m_fSeekingSpeedFeetPerSec;                                // 0x3344(0x0004)
	float                                              m_fRushHitSpeedFactor;                                    // 0x3348(0x0004)
	class ATgPawn*                                     r_pRushTarget;                                            // 0x334C(0x0008) (Net)
	int                                                m_nHealFeedDefaultIconId;                                 // 0x3354(0x0004)
	float                                              c_fPsychicGrowlCooldownTime;                              // 0x3358(0x0004)
	float                                              r_fPsychicGrowlRangeSqr;                                  // 0x335C(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_DruidGuardian");
		return ptr;
	}


	bool ShouldCreateCaptureProxy();
	bool STATIC_AttemptRedeploy(class ATgDeployable* Placeholder);
	void STATIC_EndRedeploy();
	void STATIC_PostRedeployLockout();
	void STATIC_TweenFinished();
	void STATIC_EndRedeployEffects();
	void STATIC_ExitWispForm();
	void STATIC_EnterWispForm();
	void STATIC_BeginRedeploy();
	void STATIC_InRedeploy();
	void STATIC_EndTween(TEnumAsByte<ETweenState> endingTweenState, bool bInterrupted);
	bool STATIC_PerformSavingSwapWithIo(class ATgPawn_Druid* pDruid);
	void STATIC_PrepareForSavingSwapWithIo(float fFireLockTime);
	void STATIC_InSacrificeFireLock();
	struct FVector GetPhysTweenTargetLocation(bool bFinalLocation);
	void PlayDeathAnimation();
	bool AllowRagdoll();
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void Bump(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitNormal);
	void STATIC_LockoutPsychicGrowl();
	void STATIC_FaceRushTarget();
	void OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode, int nAmmoRemaining);
	void STATIC_DruidGuardianPsychicGrowl();
	void ReplicatedEvent(const struct FName& VarName);
	TEnumAsByte<ETgMeshVisibilityState> STATIC_GetMeshVisibilityStateThisTick();
	bool STATIC_CheckForLanePushers();
	bool STATIC_ShouldDisallowTeamPassThroughFrom(class ATgPawn* pOther);
	float STATIC_GetStunRushTurnRate();
	float STATIC_GetStunRushChargeSpeed();
	float STATIC_GetProtectionCC();
	bool STATIC_IsHealingDebuffImmune();
	bool STATIC_IsDebuffImmune();
	bool STATIC_IsCrowdControlImmune();
	bool STATIC_IsDamageOverTimeImmune();
	bool STATIC_IsSuperiorCrowdControlImmune();
	void DeviceOnStopCooldown(class ATgDevice* Dev);
	void DeviceOnStartCooldown(class ATgDevice* Dev, float fCooldownTime);
	void STATIC_SetRotationRate();
	bool ShouldShowHudOverlay(class ATgPawn* PlayerPawn);
	bool STATIC_CanPawnParticipateInCapture();
	void PostPawnSetupServer();
	bool STATIC_IsInFireLock();
	void STATIC_ResolveLanePusherTouch(class ATgPawn_LanePusherBase* pLanePusher, bool bForce);
	int STATIC_GetHealFeedIconOverrideId();
	void PawnOnDamaged(struct FOnDamagedParams* Params);
	bool STATIC_HasCachedDruid();
};


// Class TgGame.TgProj_DruidGuidedArrow
// 0x0000 (0x052C - 0x052C)
class ATgProj_DruidGuidedArrow : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_DruidGuidedArrow");
		return ptr;
	}


	void Tick(float DeltaSeconds);
};


// Class TgGame.TgProj_MoonShard
// 0x0054 (0x0580 - 0x052C)
class ATgProj_MoonShard : public ATgProj_Simulated
{
public:
	struct FPointer                                    VfTable_ITgCallbackInterface;                             // 0x052C(0x0008) (Const, Native, NoExport)
	class UTgCallbackContainer*                        m_CallbackContainer;                                      // 0x0534(0x0008)
	float                                              m_fMaxPullAcceleration;                                   // 0x053C(0x0004)
	float                                              m_fMaxSpeed;                                              // 0x0540(0x0004)
	float                                              m_fPeakLateralDampening;                                  // 0x0544(0x0004)
	float                                              m_fInnerRadius;                                           // 0x0548(0x0004)
	float                                              m_fKnockupRadius;                                         // 0x054C(0x0004)
	float                                              m_fOuterRadius;                                           // 0x0550(0x0004)
	float                                              m_fRadiusExitTolerance;                                   // 0x0554(0x0004)
	float                                              m_fPhysWalkingAccelerationFactor;                         // 0x0558(0x0004)
	unsigned long                                      c_bDebugRadii : 1;                                        // 0x055C(0x0004)
	TArray<class ATgPawn*>                             m_RegisteredPawns;                                        // 0x0560(0x0010) (NeedCtorLink)
	TArray<struct FMoonShardPawnRecord>                m_AffectedPawns;                                          // 0x0570(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_MoonShard");
		return ptr;
	}


	void Destroyed();
	void ClearAllTouched();
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_UnregisterCallbacks();
	void STATIC_RegisterCallbacks();
	void STATIC_RemovePawnEffects(int nIndex);
	void STATIC_CheckInnerRadii(int nIndex);
	void STATIC_AddPawnEffects(class ATgPawn_Character* pPawn);
};


// Class TgGame.TgDevice_RaumUlt
// 0x0028 (0x0AA8 - 0x0A80)
class ATgDevice_RaumUlt : public ATgDevice_Charge
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_MoveSpeedMultiplier;           // 0x0A80(0x0008) (Const, Native, NoExport)
	class ATgPawn_Raum*                                m_CachedRaum;                                             // 0x0A88(0x0008)
	unsigned long                                      m_bLockoutDuringPostFire : 1;                             // 0x0A90(0x0004)
	float                                              m_fChargeDeviationMeanLifetime;                           // 0x0A94(0x0004)
	float                                              m_fAccumulatedChargeDeviation;                            // 0x0A98(0x0004)
	float                                              m_fMaxTurnDegPerSec;                                      // 0x0A9C(0x0004)
	float                                              m_fMaxDirectionShiftDegrees;                              // 0x0AA0(0x0004)
	float                                              m_fPerActorHitPeriod;                                     // 0x0AA4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_RaumUlt");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	void ApplyTouchHit(class ATgPawn* InstigatorPawn, const struct FVector& vHitLocation, const struct FVector& vHitNormal, class AActor* Target);
	void OnValidTargetTouched(class AActor* Other);
	float STATIC_GetActorHitPeriod(class AActor* pQueryActor);
	bool CanBeCanceled();
	bool ShouldLockJumping();
	void STATIC_UpdateChargeDeviation(const struct FVector& vDesiredDirection, float fDeltaSeconds);
	bool STATIC_ShouldUseGradualMovement();
	float STATIC_GetMoveSpeedMultiplier();
	void STATIC_ResetAccumulatedChargeDeviation();
	float STATIC_UpdateAccumulatedChargeDeviation(float fDeltaBearing, float fDeltaSeconds);
};


// Class TgGame.TgDevice_RaumMinigun
// 0x0048 (0x0A54 - 0x0A0C)
class ATgDevice_RaumMinigun : public ATgDevice
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_MoveSpeedMultiplier;           // 0x0A0C(0x0008) (Const, Native, NoExport)
	class ATgPawn_Raum*                                m_CachedRaum;                                             // 0x0A14(0x0008)
	class UTgDeviceForm_RaumInhand*                    m_CachedForm;                                             // 0x0A1C(0x0008)
	class ATgWeaponMeshActor_RaumMinigun*              m_CachedWMA;                                              // 0x0A24(0x0008)
	float                                              m_fCurrentSpinUpTime;                                     // 0x0A2C(0x0004)
	float                                              m_fMinSpinUpToFire;                                       // 0x0A30(0x0004)
	float                                              m_fMaxSpinUpTime;                                         // 0x0A34(0x0004)
	float                                              m_fFastestFireDelay;                                      // 0x0A38(0x0004)
	float                                              m_fImpulseSpinUpTime;                                     // 0x0A3C(0x0004)
	float                                              m_fInvMaxSpinUpTime;                                      // 0x0A40(0x0004)
	float                                              m_fLMBSpinningMovementSpeed;                              // 0x0A44(0x0004)
	float                                              m_fRMBSpinningMovementSpeed;                              // 0x0A48(0x0004)
	float                                              m_fMinimumMoveSlowTime;                                   // 0x0A4C(0x0004)
	float                                              m_fReloadPreSpinResetTime;                                // 0x0A50(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_RaumMinigun");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	void MinimumMoveSlowWindow();
	void STATIC_FireAmmunition();
	void Tick(float DeltaTime);
	bool STATIC_IsSpinningDown();
	bool STATIC_IsSpinningUp();
	void PostBeginPlay();
	bool StartReload(bool bIgnoreCurrentAmmo);
	void STATIC_ResetSpin();
	float STATIC_GetSpinDownRate();
	float STATIC_GetSpinUpRate();
	void STATIC_ApplySpinUpPercent(float fSpinUpPct);
	void STATIC_ApplySpinUpImpulse(float fSpinUpTime);
	void ClientInterruptReload(bool bAllowAmmoFill);
	bool STATIC_InterceptLeftMousePressed(class ATgPlayerController* TgController);
	bool CanBeInterrupted();
	bool STATIC_HasCachedWeaponMesh();
	bool STATIC_HasCachedForm();
	bool STATIC_ShouldUseGradualMovement();
	float STATIC_GetMoveSpeedMultiplier();
	float STATIC_GetRefireTime(int nMode);
	float STATIC_GetSpinUpFactor();
};


// Class TgGame.TgDevice_RaumRevUp
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_RaumRevUp : public ATgDevice
{
public:
	class ATgPawn_Raum*                                m_CachedRaum;                                             // 0x0A0C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_RaumRevUp");
		return ptr;
	}


	void STATIC_DelayedSetRMBFiringOff();
	bool StartFire();
	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	float STATIC_GetPercentRevUp();
	bool STATIC_IsReloading();
};


// Class TgGame.TgDevice_RaumShardTalent
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_RaumShardTalent : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_RaumShardTalent");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
};


// Class TgGame.TgDevice_RaumStomp
// 0x0030 (0x0A3C - 0x0A0C)
class ATgDevice_RaumStomp : public ATgDevice
{
public:
	class ATgPawn_Raum*                                m_CachedRaum;                                             // 0x0A0C(0x0008)
	float                                              m_fProjectileSpreadAngle;                                 // 0x0A14(0x0004)
	struct FRotator                                    m_rInitialStompDirection;                                 // 0x0A18(0x000C)
	float                                              m_fMaxDirectionShiftDegrees;                              // 0x0A24(0x0004)
	float                                              m_fStompProjectileHeightOffset;                           // 0x0A28(0x0004)
	TArray<class AActor*>                              m_HitActors;                                              // 0x0A2C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_RaumStomp");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	bool ShouldLockJumping();
	bool STATIC_OnPotentialTarget(class AActor* NewTarget);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_RaumSuck
// 0x0019 (0x0A25 - 0x0A0C)
class ATgDevice_RaumSuck : public ATgDevice
{
public:
	class ATgPawn_Raum*                                m_CachedRaum;                                             // 0x0A0C(0x0008)
	float                                              m_fSuckTime;                                              // 0x0A14(0x0004)
	int                                                m_nVirtualShardsOnFire;                                   // 0x0A18(0x0004)
	int                                                m_nCachedShards;                                          // 0x0A1C(0x0004)
	float                                              m_fHealthCacheThreshold;                                  // 0x0A20(0x0004)
	TEnumAsByte<ERaumShardCache>                       m_eCacheOn;                                               // 0x0A24(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_RaumSuck");
		return ptr;
	}


	float GetCustomTimerBarMaxTime();
	float GetCustomTimerBarCurrentTime();
	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	void Tick(float DeltaTime);
	float STATIC_GetSuckRate();
	bool ShouldInterruptReloadOnFire();
	bool STATIC_ShouldCache();
	bool STATIC_OnShardConsumed(int nStacks, bool bVirtualShard);
	bool STATIC_UpdateShardStacks();
};


// Class TgGame.TgDeviceFire_RaumStomp
// 0x0004 (0x026C - 0x0268)
class UTgDeviceFire_RaumStomp : public UTgDeviceFire
{
public:
	float                                              m_fCurrentScalingFactor;                                  // 0x0268(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_RaumStomp");
		return ptr;
	}


	bool ApplyHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
	bool STATIC_ShouldAnnihilate(class AActor* Target);
	int STATIC_GetElementsPerProjectile();
	int STATIC_GetShotsPerFire();
	struct FVector STATIC_GetDeviceEncroachmentScale();
};


// Class TgGame.TgDeviceForm_RaumCharge
// 0x000C (0x0298 - 0x028C)
class UTgDeviceForm_RaumCharge : public UTgDeviceForm
{
public:
	float                                              m_fTimeToThrowWeapon;                                     // 0x028C(0x0004)
	class ATgWeaponMeshActor_RaumMinigun*              m_CachedWMA;                                              // 0x0290(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_RaumCharge");
		return ptr;
	}


	void StopFire(int nFireModeNum);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	bool STATIC_HasCachedWeaponMesh();
};


// Class TgGame.TgDeviceForm_RaumInhand
// 0x0088 (0x0314 - 0x028C)
class UTgDeviceForm_RaumInhand : public UTgDeviceForm
{
public:
	struct FName                                       m_SpinnerName;                                            // 0x028C(0x0008) (Const)
	TArray<class UTgSkelCon_Spinner*>                  m_SpinnerSkelControls1p;                                  // 0x0294(0x0010) (NeedCtorLink)
	TArray<class UTgSkelCon_Spinner*>                  m_SpinnerSkelControls3p;                                  // 0x02A4(0x0010) (NeedCtorLink)
	TArray<class UTgAnimBlendByPercent*>               m_BlendByPct1P;                                           // 0x02B4(0x0010) (NeedCtorLink)
	TArray<class UTgAnimBlendByPercent*>               m_BlendByPct3P;                                           // 0x02C4(0x0010) (NeedCtorLink)
	class ATgPawn_Raum*                                m_CachedRaum;                                             // 0x02D4(0x0008)
	unsigned long                                      m_bIsSpinningUp : 1;                                      // 0x02DC(0x0004)
	float                                              m_fMaxHeatBuildup;                                        // 0x02E0(0x0004)
	float                                              m_fHeatBuildup;                                           // 0x02E4(0x0004)
	float                                              m_fHeatDecayFactor;                                       // 0x02E8(0x0004)
	float                                              m_fHeatVisibilityFloor;                                   // 0x02EC(0x0004)
	float                                              m_fPerShotHeatBuildup;                                    // 0x02F0(0x0004)
	float                                              m_fSyntheticShotSpinUpThreshold;                          // 0x02F4(0x0004)
	float                                              m_fSyntheticShotSpinUpNormalization;                      // 0x02F8(0x0004)
	float                                              m_fAccuracyModifier;                                      // 0x02FC(0x0004)
	float                                              m_fLastReceivedRefire;                                    // 0x0300(0x0004)
	float                                              m_fTimeLastStopFire;                                      // 0x0304(0x0004)
	float                                              m_fSustainedFireBeforeCustomPostFire;                     // 0x0308(0x0004)
	float                                              m_fCustomPostFireDuration;                                // 0x030C(0x0004)
	float                                              m_fSustainedFireDuration;                                 // 0x0310(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_RaumInhand");
		return ptr;
	}


	void CacheAnimNode(class UAnimNode* Node, bool bIs3p);
	void ClearAnimNodes(bool bIs3p);
	void SetSpinnersActive(bool bActive);
	void CacheSpinner(class UTgSkeletalMeshComponent* SkelComp, TArray<class UTgSkelCon_Spinner*>* SpinnerSkelControls);
	void Cache3PAnimNodes(class UTgSkeletalMeshComponent* SkelComp);
	void Cache1PAnimNodes(class UTgSkeletalMeshComponent* SkelComp);
	void Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	void STATIC_SetAccuracyModifier(float fNewModifier);
	int STATIC_GetFakedBurstRate();
	void STATIC_CustomPostFire();
	void StopFire(int nFireModeNum);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	void PlayImpactEffects(const struct FVector& HitLocation, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, const struct FVector& FireOrigin, float fHitTraceDistOverride, bool bGenerateUpdatedHitLocation, bool bSyntheticFireEvent);
	float STATIC_GetAccuracy();
	void CacheSkelControls(class UAnimTree* pAnimTree, TArray<class UTgSkelCon_Spinner*>* SpinnerSkelControls);
	bool STATIC_HasCachedRaum();
};


// Class TgGame.TgDeviceForm_RaumRev
// 0x0004 (0x0290 - 0x028C)
class UTgDeviceForm_RaumRev : public UTgDeviceForm
{
public:
	float                                              m_fRevUpSpinDuration;                                     // 0x028C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_RaumRev");
		return ptr;
	}


	float STATIC_GetRevPercent();
};


// Class TgGame.TgInvListener_RaumFullRev
// 0x000C (0x00D0 - 0x00C4)
class UTgInvListener_RaumFullRev : public UTgInvListener
{
public:
	class ATgPawn_Raum*                                m_CachedRaum;                                             // 0x00C4(0x0008)
	unsigned long                                      m_bActiveEffects : 1;                                     // 0x00CC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_RaumFullRev");
		return ptr;
	}


	void STATIC_AttemptTransition(bool bTransitionToActive);
};


// Class TgGame.TgPawn_Raum
// 0x04C8 (0x37A0 - 0x32D8)
class ATgPawn_Raum : public ATgPawn_Character
{
public:
	class ATgDevice_RaumMinigun*                       m_CachedMinigun;                                          // 0x32D8(0x0008)
	class ATgDevice_RaumRevUp*                         m_CachedRev;                                              // 0x32E0(0x0008)
	class ATgDevice_RaumSuck*                          m_CachedSuck;                                             // 0x32E8(0x0008)
	class ATgDevice_RaumUlt*                           m_CachedUlt;                                              // 0x32F0(0x0008)
	class ATgDevice_RaumStomp*                         m_CachedStomp;                                            // 0x32F8(0x0008)
	class ATgDevice_RaumShardTalent*                   m_CachedShardTalent;                                      // 0x3300(0x0008)
	class UTgDeviceForm_RaumInhand*                    c_MinigunForm;                                            // 0x3308(0x0008)
	class UTgDeviceForm_RaumRev*                       c_RevUpForm;                                              // 0x3310(0x0008)
	float                                              m_fShardTimeToLive;                                       // 0x3318(0x0004)
	float                                              m_fShardSuckSpeed;                                        // 0x331C(0x0004)
	float                                              m_fShardSuckAcceleration;                                 // 0x3320(0x0004)
	float                                              m_fShardMinSuckDistance;                                  // 0x3324(0x0004)
	float                                              m_fShardSuckDistanceIncreasePerSec;                       // 0x3328(0x0004)
	float                                              m_fInitialShardSpeed;                                     // 0x332C(0x0004)
	float                                              m_fInitialShardPitch;                                     // 0x3330(0x0004)
	float                                              m_fSpinPercentBonusWhileFiring;                           // 0x3334(0x0004)
	float                                              r_fLastRevUpRateBefore;                                   // 0x3338(0x0004) (Net)
	float                                              r_fLastRevUpRateAfter;                                    // 0x333C(0x0004) (Net)
	unsigned char                                      s_nNextAvailableId;                                       // 0x3340(0x0001)
	TEnumAsByte<ERaumFiringState>                      r_eFiringState;                                           // 0x3341(0x0001) (Net)
	TEnumAsByte<ERaumFiringState>                      c_eFiringStateAckd;                                       // 0x3342(0x0001)
	unsigned char                                      r_nShardNonces[0x14];                                     // 0x3343(0x0001) (Net)
	unsigned char                                      r_nShardIds[0x14];                                        // 0x3357(0x0001) (Net)
	unsigned char                                      r_bShardFlags[0x14];                                      // 0x336B(0x0001) (Net)
	unsigned char                                      UnknownData00[0x1];                                       // 0x337F(0x0001) MISSED OFFSET
	TArray<struct FName>                               m_nmFiringStateDisplayGroups;                             // 0x3380(0x0010) (NeedCtorLink)
	float                                              m_fMinigunSpinningThreshold;                              // 0x3390(0x0004)
	float                                              m_fMinigunFiringHighThreshold;                            // 0x3394(0x0004)
	struct FVector                                     r_vShardLocations[0x14];                                  // 0x3398(0x000C) (Net)
	int                                                r_nShardVelocityYaw[0x14];                                // 0x3488(0x0004) (Net)
	int                                                s_nCurrentShardPoints;                                    // 0x34D8(0x0004)
	float                                              r_fSpinUpPct;                                             // 0x34DC(0x0004) (Net)
	unsigned long                                      r_bIsLMBHeld : 1;                                         // 0x34E0(0x0004) (Net)
	unsigned long                                      r_bIsRMBHeld : 1;                                         // 0x34E0(0x0004) (Net)
	int                                                m_nActiveShards;                                          // 0x34E4(0x0004)
	int                                                m_nPointsPerShot[0x31];                                   // 0x34E8(0x0004)
	int                                                m_nPointsPerShard;                                        // 0x35AC(0x0004)
	int                                                m_nMaxCachedShards;                                       // 0x35B0(0x0004)
	int                                                r_nCachedShards;                                          // 0x35B4(0x0004) (Net)
	int                                                r_nMaxShardStacks;                                        // 0x35B8(0x0004) (Net)
	int                                                r_nCurrentShardStacks;                                    // 0x35BC(0x0004) (Net)
	struct FRaumShard                                  m_LocalShards[0x14];                                      // 0x35C0(0x0018)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Raum");
		return ptr;
	}


	void STATIC_UpdateLifeShards();
	void STATIC_UpdateShard(int I);
	void STATIC_DeactivateShard(int I);
	void DeactivateAllShards();
	void STATIC_LocalActivateShard(int I);
	void SpawnShard(const struct FVector& vSpawnAt);
	int STATIC_GetNextShardIndex();
	void PostBeginPlay();
	bool PostPawnSetup();
	void Tick(float DeltaTime);
	void STATIC_ConsumeShard(int nNdx);
	void STATIC_TickShardSucking(float DeltaTime, int nNdx);
	void STATIC_AuthShardUpdated(int I);
	float STATIC_GetSuckDistance();
	void STATIC_SetShardIsSucking(int nNdx, bool bIsSucking);
	bool STATIC_GetShardIsSucking(int nNdx);
	void STATIC_SetShardIsActive(int nNdx, bool bIsActive);
	bool STATIC_GetShardIsActive(int nNdx);
	void STATIC_UltSecondPhaseAnim();
	void PawnGeneric1Flashed();
	void SetRMBFiring(bool IsFiring);
	void SetLMBFiring(bool IsFiring);
	bool OnLiveRespawn();
	struct FName STATIC_GetFootStepOverride();
	void OnRespawn();
	void OnDeviceFormFire(int nEquipSlot, float fRefireTime, int nFireMode);
	void ReplicatedEvent(const struct FName& VarName);
	int STATIC_GetLifeShardAsmId();
	void STATIC_TransitionToFireState(TEnumAsByte<ERaumFiringState> eTo);
	void STATIC_TransitionFromFireState(TEnumAsByte<ERaumFiringState> eFrom);
	void STATIC_UpdateFiringState();
	void DeviceOnDamaged(struct FOnDamagedParams* Params);
	void STATIC_UpdateMinigunSpinning();
	bool STATIC_IsSpinningDown();
	bool STATIC_IsSpinningUp();
	bool STATIC_IsRevving();
	bool STATIC_HasRevUpFormCached();
	bool STATIC_HasAutoFormCached();
	float STATIC_GetSpinUpPct();
	void OnPawnDied();
};


// Class TgGame.TgProj_RaumStomp
// 0x005C (0x0588 - 0x052C)
class ATgProj_RaumStomp : public ATgProj_Simulated
{
public:
	class ATgDevice_RaumStomp*                         m_StompDev;                                               // 0x052C(0x0008)
	class UTgDeviceFire_RaumStomp*                     m_StompFire;                                              // 0x0534(0x0008)
	float                                              m_fNextDamageTickIn;                                      // 0x053C(0x0004)
	float                                              m_fDamageTickPeriod;                                      // 0x0540(0x0004)
	float                                              m_fScaleIncreasePerFoot;                                  // 0x0544(0x0004)
	TArray<class UTgSpecialFx*>                        c_AlwaysOnFx;                                             // 0x0548(0x0010) (NeedCtorLink)
	struct FVector                                     m_vCollideExtent;                                         // 0x0558(0x000C)
	float                                              m_fCollisionHeightOffset;                                 // 0x0564(0x0004)
	float                                              m_fProjectileElementFanAngle;                             // 0x0568(0x0004)
	float                                              m_fMaxStepUpAngle;                                        // 0x056C(0x0004)
	float                                              m_fTanMaxStepUpAngle;                                     // 0x0570(0x0004)
	float                                              m_fStepUpCollisionDiagonal;                               // 0x0574(0x0004)
	TArray<struct FStompElement>                       m_StompElements;                                          // 0x0578(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_RaumStomp");
		return ptr;
	}


	void STATIC_ProcessTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool ApplyTheHit(class UTgDeviceFire* FireMode, const struct FImpactInfo& Impact, class AActor* DamageInstigator);
	void ShutDown();
	void ExplodeOnTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_DeactivateAllElements();
	float STATIC_GetCurrentScalingFactor();
	bool STATIC_HasCachedAlwaysOnFx();
	bool STATIC_HasCachedFire();
	bool STATIC_HasCachedDevice();
};


// Class TgGame.TgRaumShard
// 0x0003 (0x0294 - 0x0291)
class ATgRaumShard : public ATgPropActor
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0291(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRaumShard");
		return ptr;
	}


	void PostBeginPlay();
};


// Class TgGame.TgSkelCon_RaumSpinner
// 0x0008 (0x014C - 0x0144)
class UTgSkelCon_RaumSpinner : public UTgSkelCon_Spinner
{
public:
	class ATgPawn_Raum*                                m_CachedRaum;                                             // 0x0144(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_RaumSpinner");
		return ptr;
	}


	bool STATIC_HasCachedRaum(class USkeletalMeshComponent* SkelComp);
};


// Class TgGame.TgWeaponMeshActor_RaumMinigun
// 0x0048 (0x0498 - 0x0450)
class ATgWeaponMeshActor_RaumMinigun : public ATgWeaponMeshActor
{
public:
	class ATgPawn_Raum*                                m_CachedRaum;                                             // 0x0450(0x0008)
	class UTgDeviceForm_RaumInhand*                    m_CachedInhandForm;                                       // 0x0458(0x0008)
	class ATgPropActor*                                m_PropWeapon;                                             // 0x0460(0x0008)
	struct FVector                                     m_vPropWeaponOrigin;                                      // 0x0468(0x000C)
	unsigned long                                      m_bPendingThrow : 1;                                      // 0x0474(0x0004)
	unsigned long                                      c_b3PWepHiddenDueToThrow : 1;                             // 0x0474(0x0004)
	float                                              m_fPendingThrowTime;                                      // 0x0478(0x0004)
	float                                              m_fMinimumThrowHistory;                                   // 0x047C(0x0004)
	float                                              m_fWeaponThrownFailsafeTime;                              // 0x0480(0x0004)
	float                                              m_fSyntheticShotAccuracyModifier;                         // 0x0484(0x0004)
	float                                              m_fReloadTimeToThrowWeapon;                               // 0x0488(0x0004)
	float                                              m_fReloadPctWeaponThrown;                                 // 0x048C(0x0004)
	float                                              m_fReloadTimeToRecoverWeapon;                             // 0x0490(0x0004)
	float                                              m_fThrowVelocityFactor;                                   // 0x0494(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgWeaponMeshActor_RaumMinigun");
		return ptr;
	}


	void OverrideTracerEndLocation(const struct FVector& FireLoc, int nIndex, bool bSyntheticShot, struct FVector* endLocation);
	void Tick(float DeltaTime);
	void STATIC_HideWeaponProp();
	void STATIC_ThrowWeapon();
	void STATIC_Initialize3P(unsigned char EquipPoint, int DeviceID);
	struct FName STATIC_GetWeaponReferenceSocket();
	void STATIC_WeaponThrown();
	void PlayReload(int nEqpPoint, float reloadTime, int AmmoRemainingInClip, int ReloadType);
	void STATIC_RecoverWeaponThrown();
	void STATIC_ReloadBeginThrowingWeapon();
	void STATIC_ReloadUnhide3PWep();
	void STATIC_BeginThrowingWeapon();
	void OnBehindViewUpdated(bool bNewBehindView);
	bool STATIC_HasCachedInhandForm();
	bool STATIC_HasCachedRaum();
};


// Class TgGame.TgDeploy_TigronHeavyBlade
// 0x0028 (0x0494 - 0x046C)
class ATgDeploy_TigronHeavyBlade : public ATgDeployable
{
public:
	float                                              m_fPersistTime;                                           // 0x046C(0x0004)
	float                                              m_fPickupRangeSqr;                                        // 0x0470(0x0004)
	unsigned long                                      m_bCanPickUp : 1;                                         // 0x0474(0x0004)
	unsigned long                                      m_bWasDeployedOnInaraWall : 1;                            // 0x0474(0x0004)
	class ATgPawn_Tiberius*                            m_CachedTiberius;                                         // 0x0478(0x0008)
	class ATgDeploy_Geometry*                          m_GeometryWall;                                           // 0x0480(0x0008)
	class ATgDeploy_GeometryEffectField*               m_GeometryEffectWall;                                     // 0x0488(0x0008)
	float                                              m_fScaleMultiplier;                                       // 0x0490(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_TigronHeavyBlade");
		return ptr;
	}


	void DeployComplete();
	void STATIC_SimulateExpired();
	void Tick(float DeltaSeconds);
	void Explode();
	void OnPersistTimerExpire();
	bool HasCachedTiberius();
};


// Class TgGame.TgDevice_TiberiusPounce
// 0x000C (0x0A8C - 0x0A80)
class ATgDevice_TiberiusPounce : public ATgDevice_Charge
{
public:
	class ATgPawn_Tiberius*                            m_CachedTiberius;                                         // 0x0A80(0x0008)
	float                                              m_fUltSpamLockout;                                        // 0x0A88(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_TiberiusPounce");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	void PostHitLockOut();
	void ConsumeAmmoFromFiring(int nAmmoConsumptionOverride, int nFireRequestIDOverride);
	bool HasCachedTiberius();
	void STATIC_PerformConeAttack();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	bool STATIC_IsPostHitLockOutActive();
};


// Class TgGame.TgDevice_TigronHeavyBlade
// 0x0028 (0x0A44 - 0x0A1C)
class ATgDevice_TigronHeavyBlade : public ATgDevice_DualWield
{
public:
	class ATgPawn_Tiberius*                            m_CachedTiberius;                                         // 0x0A1C(0x0008)
	unsigned long                                      s_bBladePickedUp : 1;                                     // 0x0A24(0x0004)
	unsigned long                                      m_bHasQueuedRecall : 1;                                   // 0x0A24(0x0004)
	TEnumAsByte<ETigerBladeState>                      m_eLocalBladeState;                                       // 0x0A28(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0A29(0x0003) MISSED OFFSET
	float                                              m_fSecondaryActivationDelay;                              // 0x0A2C(0x0004)
	float                                              m_fLastProjectileSpawnedTimestamp;                        // 0x0A30(0x0004)
	float                                              m_fDeferredSecondaryActivationTime;                       // 0x0A34(0x0004)
	float                                              m_fActivationLockoutDelay;                                // 0x0A38(0x0004)
	float                                              m_fOffsetPivotBy;                                         // 0x0A3C(0x0004)
	float                                              m_fLastThrowTimestamp;                                    // 0x0A40(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_TigronHeavyBlade");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	void OnOwnerRespawn();
	void OnOwnerLiveRespawn();
	void STATIC_OnRetrieved(bool bPickedUp);
	void BladeInRecallTimeout();
	void BladeThrownTimeout();
	void STATIC_RecallLockoutWindow();
	void STATIC_FireAmmunition();
	bool StartFire();
	bool STATIC_InterceptRightMouseReleased(class ATgPlayerController* TgController);
	bool STATIC_InterceptRightMousePressed(class ATgPlayerController* TgController);
	class AActor* STATIC_GetTrackingTarget();
	bool ShouldCooldownAfterFire();
	void STATIC_RequestSecondaryActivation(float fOffsetDelay);
	void SecondaryActivationRequested();
	void STATIC_ServerRequestSecondaryActivation(float fTimeOfActivation);
	void STATIC_SpawnedNewProjectile(float fTimestamp);
	bool STATIC_BladeIsInRecall();
	bool STATIC_BladeIsAway();
	void STATIC_BladeStateTransitionFrom(TEnumAsByte<ETigerBladeState> eFrom);
	void STATIC_BladeStateTransitionIn(TEnumAsByte<ETigerBladeState> eInto);
	void STATIC_UpdateBladeState(TEnumAsByte<ETigerBladeState> eInto);
	float STATIC_GetCurrentProjectileLifetime();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	void STATIC_GetCachedAim(struct FAimData* Aim);
	bool STATIC_ShouldQueueRecall();
	bool STATIC_CanQueueRecall();
	bool STATIC_UsesTrackingTarget();
	bool STATIC_IsReloading();
};


// Class TgGame.TgDevice_TiberiusLeap
// 0x0008 (0x0A1C - 0x0A14)
class ATgDevice_TiberiusLeap : public ATgDevice_Leap
{
public:
	class ATgPawn_Tiberius*                            m_CachedTiberius;                                         // 0x0A14(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_TiberiusLeap");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	bool ShouldMountCancelFiring();
	void STATIC_NotifyNewLeapDirection(const struct FVector& vNewDir);
	bool STATIC_ShouldLockRotation();
};


// Class TgGame.TgDevice_TiberiusUltSlam
// 0x000C (0x0A20 - 0x0A14)
class ATgDevice_TiberiusUltSlam : public ATgDevice_Leap
{
public:
	class ATgPawn_Tiberius*                            m_CachedTiberius;                                         // 0x0A14(0x0008)
	float                                              m_fUltSpamLockout;                                        // 0x0A1C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_TiberiusUltSlam");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	void ConsumeAmmoFromFiring(int nAmmoConsumptionOverride, int nFireRequestIDOverride);
	bool HasCachedTiberius();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgDevice_TiberiusBladeExplode
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_TiberiusBladeExplode : public ATgDevice
{
public:
	class ATgPawn_Tiberius*                            m_CachedTiberius;                                         // 0x0A0C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_TiberiusBladeExplode");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	bool HasCachedTiberius();
};


// Class TgGame.TgDevice_TiberiusInhand
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_TiberiusInhand : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_TiberiusInhand");
		return ptr;
	}

};


// Class TgGame.TgDevice_TiberiusLeapAssault
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_TiberiusLeapAssault : public ATgDevice
{
public:
	class ATgPawn_Tiberius*                            m_CachedTiberius;                                         // 0x0A0C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_TiberiusLeapAssault");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	bool HasCachedTiberius();
};


// Class TgGame.TgDevice_TigronUlt
// 0x0018 (0x0A24 - 0x0A0C)
class ATgDevice_TigronUlt : public ATgDevice
{
public:
	class ATgPawn_Tiberius*                            m_CachedTiberius;                                         // 0x0A0C(0x0008)
	int                                                m_nNumCharges;                                            // 0x0A14(0x0004)
	float                                              m_fPerChargeEnergyCost;                                   // 0x0A18(0x0004)
	unsigned long                                      m_bPreventRMBSpam : 1;                                    // 0x0A1C(0x0004)
	float                                              m_fAnimationTail;                                         // 0x0A20(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_TigronUlt");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	void PerMoveLockout();
	void STATIC_TriggerPerMoveLockout(float fLockout);
	bool CanBeInterrupted();
	bool CanBeCanceled();
	bool CanFiringBeCanceledByRightMouse();
	bool CanFiringBeCanceledByLeftMouse();
	void TrailOffAndStop();
	bool STATIC_IsAnyUltSkillFiring();
	void EarlyFinish();
	bool CanBeSilenced();
	bool CanBeStunned();
};


// Class TgGame.TgDeviceFire_TiberiusPounce
// 0x0000 (0x0278 - 0x0278)
class UTgDeviceFire_TiberiusPounce : public UTgDeviceFire_EncroachmentFireCone
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_TiberiusPounce");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_TiberiusLeap
// 0x0008 (0x0294 - 0x028C)
class UTgDeviceForm_TiberiusLeap : public UTgDeviceForm
{
public:
	class ATgPawn_Tiberius*                            m_CachedTiberius;                                         // 0x028C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_TiberiusLeap");
		return ptr;
	}


	void Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	void BuildUp(int nFireMode, int nEquipSlot, int nSocketIndex, float fBuildupTime);
	bool HasCachedTiberius();
};


// Class TgGame.TgDeviceForm_TiberiusQ
// 0x0010 (0x029C - 0x028C)
class UTgDeviceForm_TiberiusQ : public UTgDeviceForm
{
public:
	class ATgPawn_Tiberius*                            m_CachedTiberius;                                         // 0x028C(0x0008)
	float                                              m_fLoopingSFXDuration;                                    // 0x0294(0x0004)
	float                                              m_fKillSFXLoopIn;                                         // 0x0298(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_TiberiusQ");
		return ptr;
	}


	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	bool HasCachedTiberius();
};


// Class TgGame.TgDeviceForm_TiberiusRMB
// 0x0050 (0x02DC - 0x028C)
class UTgDeviceForm_TiberiusRMB : public UTgDeviceForm
{
public:
	class ATgPawn_Tiberius*                            m_CachedTiberius;                                         // 0x028C(0x0008)
	unsigned long                                      m_bBladeRetrieve : 1;                                     // 0x0294(0x0004)
	unsigned long                                      m_bBladeInspect : 1;                                      // 0x0294(0x0004)
	unsigned long                                      m_bBladeInRecall : 1;                                     // 0x0294(0x0004)
	unsigned long                                      m_bBladeAway : 1;                                         // 0x0294(0x0004)
	float                                              m_fPostRetrievalTime;                                     // 0x0298(0x0004)
	TArray<class UTgAnimNodeBlendBySimpleStance*>      m_SimpleStanceBladeAway1P;                                // 0x029C(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeBlendBySimpleStance*>      m_SimpleStanceBladeAway3P;                                // 0x02AC(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeBlendBySimpleStance*>      m_SimpleStanceBlendList1P;                                // 0x02BC(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeBlendBySimpleStance*>      m_SimpleStanceBlendList3P;                                // 0x02CC(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_TiberiusRMB");
		return ptr;
	}


	void CacheAnimNode(class UAnimNode* Node, bool bIs3p);
	void ClearAnimNodes(bool bIs3p);
	void StopFire(int nFireModeNum);
	void Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	void STATIC_DisableChannelFireBlendNodes(bool bIsCooldownEnd);
	void STATIC_SetBladeInRecall(bool bBladeInRecall);
	void STATIC_SetBladeAnimatingInRecallInternal(bool bBladeRetrieve, bool bBladeInspect);
	void STATIC_SetBladeAnimatingInRecall(bool bBladeRetrieve);
	void STATIC_CueFinishRetrieve();
	bool HasCachedTiberius();
};


// Class TgGame.TgInventoryObject_Listen_Combo_Tiberius
// 0x0000 (0x00CC - 0x00CC)
class UTgInventoryObject_Listen_Combo_Tiberius : public UTgInventoryObject_Listen_Combo
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Combo_Tiberius");
		return ptr;
	}

};


// Class TgGame.TgPawn_Tiberius
// 0x0088 (0x3360 - 0x32D8)
class ATgPawn_Tiberius : public ATgPawn_Character
{
public:
	class ATgDevice_TigronHeavyBlade*                  m_CachedHeavyBlade;                                       // 0x32D8(0x0008)
	class ATgDevice_TiberiusLeap*                      m_CachedLeap;                                             // 0x32E0(0x0008)
	class ATgDevice_TigronUlt*                         m_CachedUlt;                                              // 0x32E8(0x0008)
	class ATgDevice_TiberiusBladeExplode*              m_CachedBladeDetonateTalent;                              // 0x32F0(0x0008)
	class ATgDevice_TiberiusLeapAssault*               m_CachedLeapAssaultTalent;                                // 0x32F8(0x0008)
	class UTgDeviceForm_TiberiusRMB*                   m_CachedHeavyBladeForm;                                   // 0x3300(0x0008)
	TEnumAsByte<ETigerBladeState>                      r_eRemoteBladeState;                                      // 0x3308(0x0001) (Net)
	unsigned char                                      UnknownData00[0x3];                                       // 0x3309(0x0003) MISSED OFFSET
	class ATgProj_TigronHeavyBlade*                    r_BladeProjectile;                                        // 0x330C(0x0008) (Net)
	class ATgDeploy_TigronHeavyBlade*                  r_BladeDeployable;                                        // 0x3314(0x0008) (Net)
	struct FVector                                     r_vLastLeapDirection;                                     // 0x331C(0x000C) (Net)
	unsigned long                                      r_bHasViciousAssault : 1;                                 // 0x3328(0x0004) (Net)
	unsigned long                                      r_bBladeInRecall : 1;                                     // 0x3328(0x0004) (Net)
	int                                                m_nAltInhandSlot;                                         // 0x332C(0x0004) (Const)
	int                                                m_nAltAltfireSlot;                                        // 0x3330(0x0004) (Const)
	float                                              r_fRemoteUltDurationPercent;                              // 0x3334(0x0004) (Net)
	int                                                r_nRemainingUltCharges;                                   // 0x3338(0x0004) (Net)
	int                                                r_nMaxUltCharges;                                         // 0x333C(0x0004) (Net)
	struct FString                                     m_sSecondaryActivationIconOverride;                       // 0x3340(0x0010) (NeedCtorLink)
	TArray<class USkelControlBase*>                    m_HeavyBladeScaleSkelControls;                            // 0x3350(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Tiberius");
		return ptr;
	}


	void PawnGeneric1Flashed();
	bool StartAction(class ATgDevice* Dev, bool bUpdateTimeStamp, TEnumAsByte<EDeviceFailType>* failType);
	void InterruptInhandReload();
	void SetTargetingDevice(class ATgDevice* Dev, const struct FWeaponMeshSwapStrategy& SwapStrategy);
	void STATIC_SetStanceTargetingDevice();
	void STATIC_ConsumeUltCharge();
	void STATIC_SetRemainingUltCharges(int nRemainingCharges, bool bIsReset);
	TEnumAsByte<ETG_EQUIP_POINT> OverrideOffhandSlot(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	void OnRetrievalFinished();
	void STATIC_PrepareForLiveRespawn();
	bool Died(class AController* Killer, class UClass* dmgType, const struct FVector& HitLocation);
	void STATIC_NotifyNewLeapDirection(const struct FVector& vNewLeapdir);
	void STATIC_HeavyBladeExplodeAt(const struct FVector& vLoc);
	void STATIC_PlayDetonateTalent(const struct FVector& vLoc);
	void PostInitAnimTree(class USkeletalMeshComponent* SkelComp);
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_ResetHeavyBladeSkelControlScale();
	void STATIC_CacheHeavyBladeSkelControls(class UAnimTree* pTree);
	float GetGravityZ();
	bool STATIC_TriggerHeavyBladeSecondaryActivation();
	void STATIC_ForwardSimulateHeavyBlade(float DeltaTime);
	void FaceRotation(const struct FRotator& NewRotation, float DeltaTime);
	bool STATIC_NotifyHeavyBladeExpired();
	bool STATIC_HasCachedHeavyBladeForm();
	void STATIC_SetBladeInRecall(bool bBladeInRecall);
	bool STATIC_SecondaryActivationDetonates();
	bool STATIC_HasSecondaryActivation();
	bool STATIC_HasUltCharges();
	bool STATIC_ShouldUseUltWeapons();
	int STATIC_GetUISkillEqpSlotOverride(int nEquipSlot, TEnumAsByte<EUI_SKILL_EQUIP_SLOT> eUISlot, bool bBaseSkillOnly, bool bGamepadUI);
	class ATgDevice* STATIC_GetCurrentInhandDevice();
	float STATIC_GetRemainingUltPercent();
};


// Class TgGame.TgProj_TigronChakram
// 0x001C (0x059C - 0x0580)
class ATgProj_TigronChakram : public ATgProj_FreeGrenade
{
public:
	float                                              m_fScaleMultiplier;                                       // 0x0580(0x0004)
	float                                              m_fBounceBacktrackDistance;                               // 0x0584(0x0004)
	float                                              m_fBounceBacktrackDuration;                               // 0x0588(0x0004)
	struct FHistoricPosition                           m_LastBounce;                                             // 0x058C(0x0010)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_TigronChakram");
		return ptr;
	}


	bool ShouldHitBounce(class AActor* Target, const struct FVector& HitNormal);
	void PostProjectileInitialize();
	void ApplyBounce(const struct FVector& HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp);
	void STATIC_MarkPosition();
	void STATIC_OnBounceBacktrack();
	struct FVector STATIC_GetPositionAtTime(float fTime);
};


// Class TgGame.TgProj_TigronHeavyBlade
// 0x000C (0x0538 - 0x052C)
class ATgProj_TigronHeavyBlade : public ATgProj_Simulated
{
public:
	class ATgPawn_Tiberius*                            m_CachedTiberius;                                         // 0x052C(0x0008)
	float                                              m_fScaleMultiplier;                                       // 0x0534(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_TigronHeavyBlade");
		return ptr;
	}


	void STATIC_ProcessTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool CheckTeamPassThrough(class AActor* Other);
	void SecondaryExplode(const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_OnRetrieved();
	void PlayHitWallExplosionFX(const struct FVector& HitNormal, const struct FVector& HitLocation);
	bool HasCachedTiberius();
	bool STATIC_GetDeployLocationAndRotation(const struct FVector& vLocation, class AActor* TargetActor, const struct FVector& vNormal, struct FVector* OutLocation, struct FRotator* OutRotation);
	class ATgDeployable* SpawnDeployable(const struct FVector& vLocation, class AActor* TargetActor, const struct FVector& vNormal);
};


// Class TgGame.TgDeploy_ShieldMakoa
// 0x0014 (0x0484 - 0x0470)
class ATgDeploy_ShieldMakoa : public ATgDeploy_Shield
{
public:
	class ATgPawn*                                     m_CachedPawnOwner;                                        // 0x0470(0x0008)
	int                                                r_nCarapaceBonusHealth;                                   // 0x0478(0x0004) (Net)
	unsigned long                                      r_bHasBarrierReef : 1;                                    // 0x047C(0x0004) (Net)
	int                                                m_nBarrierReefDamage;                                     // 0x0480(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_ShieldMakoa");
		return ptr;
	}


	void MitigateHealthDamage(class ATgPawn* pInstigator, class UTgEffectDamage* Effect, const struct FImpactInfo& Impact, bool bIsHeadshot, float* NewValue, float* fPercReduction, unsigned char* bWasCapped);
};


// Class TgGame.TgDevice_ShellSpin
// 0x0004 (0x0A84 - 0x0A80)
class ATgDevice_ShellSpin : public ATgDevice_Charge
{
public:
	float                                              m_fZoomDurationOverride;                                  // 0x0A80(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ShellSpin");
		return ptr;
	}


	float STATIC_GetActorHitPeriod(class AActor* pQueryActor);
	bool CanBeCanceled();
	TEnumAsByte<EChargeState> GetChargeState();
	float GetChargeRange();
	float STATIC_GetChargeSpeed();
	void OutroLockoutTime();
	float STATIC_GetFiringPostHitDelay(int nMode);
};


// Class TgGame.TgDevice_Drag
// 0x0060 (0x0A6C - 0x0A0C)
class ATgDevice_Drag : public ATgDevice
{
public:
	class ATgPawn*                                     m_PullTarget;                                             // 0x0A0C(0x0008)
	struct FRotator                                    m_TargetInitialRotation;                                  // 0x0A14(0x000C)
	float                                              m_fPullStartTime;                                         // 0x0A20(0x0004)
	class ATgPawn*                                     m_StunnedTarget;                                          // 0x0A24(0x0008)
	class ATgPawn*                                     r_ClientPullTarget;                                       // 0x0A2C(0x0008) (Net)
	float                                              m_fTruePostfireTime;                                      // 0x0A34(0x0004)
	float                                              m_fPullVelocityBreakFactor;                               // 0x0A38(0x0004)
	float                                              m_fPullVerticalEndOffset;                                 // 0x0A3C(0x0004) (Const)
	float                                              m_fMaxPullTime;                                           // 0x0A40(0x0004) (Const)
	float                                              m_fPrePullTime;                                           // 0x0A44(0x0004)
	float                                              m_fPullEndOffset;                                         // 0x0A48(0x0004)
	float                                              m_fPullSpeed;                                             // 0x0A4C(0x0004)
	float                                              m_fPullEndStunDuration;                                   // 0x0A50(0x0004)
	unsigned long                                      m_bCanStillPull : 1;                                      // 0x0A54(0x0004)
	unsigned long                                      m_bNeedsDelayedServerEndPull : 1;                         // 0x0A54(0x0004)
	unsigned long                                      m_bNeedsDelayedClientEndPull : 1;                         // 0x0A54(0x0004)
	unsigned long                                      m_bHasPulledOnce : 1;                                     // 0x0A54(0x0004)
	unsigned long                                      m_bPullMissed : 1;                                        // 0x0A54(0x0004)
	struct FVector                                     m_vEndLocation;                                           // 0x0A58(0x000C)
	class ATgPawn*                                     m_CachedPawnOwner;                                        // 0x0A64(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Drag");
		return ptr;
	}


	void EndPostPullStun();
	void ClearPullTarget();
	void SetPullTarget(class ATgPawn* Target);
	void SetPullTargetNoServerCorrectCameraSmoothing(bool bDisallowSmoothing);
	void ClientEndPull(bool bPullMissed);
	void ServerEndPull();
	void EndPull();
	void BreakPull();
	void MissInvalidTarget();
	void MissPull();
	void PrePullTimer();
	bool PullTarget(class AActor* Target, const struct FVector& HitLocation);
	bool StartFire();
	float STATIC_GetLockoutExtensionTime();
};


// Class TgGame.TgDevice_EbbAndFlow
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_EbbAndFlow : public ATgDevice
{
public:
	class ATgDevice*                                   m_ShellSpinDevice;                                        // 0x0A0C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_EbbAndFlow");
		return ptr;
	}


	bool ShouldCooldownAfterFire();
	bool StartFire();
};


// Class TgGame.TgDevice_ShellShield
// 0x0004 (0x0A10 - 0x0A0C)
class ATgDevice_ShellShield : public ATgDevice
{
public:
	unsigned long                                      r_bHasHalfshell : 1;                                      // 0x0A0C(0x0004) (Net)
	unsigned long                                      c_bHalfShellFXOn : 1;                                     // 0x0A0C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ShellShield");
		return ptr;
	}


	float GetCustomTimerBarMaxTime();
	float GetCustomTimerBarCurrentTime();
	bool CanBeCanceled();
	bool CanBeInterrupted();
	void CancelSafetyTimer();
	void ShellShieldFireLockout();
	void OnDeployableDestroyed(class ATgDeployable* deployable);
	void OnDeployableSpawned(class ATgDeployable* deployable);
	void ShieldPersistTime();
	void SetFireMode(int nFireModeNum, bool ForceSet);
};


// Class TgGame.TgDevice_TalentDavyJones
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_TalentDavyJones : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_TalentDavyJones");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
};


// Class TgGame.TgDevice_TurtlePower
// 0x0000 (0x0A10 - 0x0A10)
class ATgDevice_TurtlePower : public ATgDevice_Toggle
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_TurtlePower");
		return ptr;
	}


	void STATIC_InterruptOtherAbilities();
	bool CanBeCanceled();
	void CancelSafetyPeriodTimer();
	bool CanBeSilenced();
};


// Class TgGame.TgDevice_TurtlePowerSmash
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_TurtlePowerSmash : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_TurtlePowerSmash");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	bool CanBeSilenced();
};


// Class TgGame.TgDeviceFire_Smash
// 0x0014 (0x027C - 0x0268)
class UTgDeviceFire_Smash : public UTgDeviceFire
{
public:
	class AActor*                                      m_NormalTargetingEncroachmentActor;                       // 0x0268(0x0008)
	class AActor*                                      m_LargeTargetingEncroachmentActor;                        // 0x0270(0x0008)
	int                                                m_nLargeTargetingMeshID;                                  // 0x0278(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Smash");
		return ptr;
	}


	void ToggleTargetingMesh(bool bEnable);
};


// Class TgGame.TgDeviceForm_Drag
// 0x0085 (0x0311 - 0x028C)
class UTgDeviceForm_Drag : public UTgDeviceForm
{
public:
	class AActor*                                      m_BeamTarget;                                             // 0x028C(0x0008)
	unsigned long                                      m_bIsPawnTarget : 1;                                      // 0x0294(0x0004)
	int                                                m_nPostureID;                                             // 0x0298(0x0004)
	struct FVector                                     m_vReleaseLocation;                                       // 0x029C(0x000C)
	float                                              m_fReleaseTime;                                           // 0x02A8(0x0004)
	float                                              m_fMissNoHitEndDistance;                                  // 0x02AC(0x0004) (Const)
	float                                              m_fMissNoHitEndTime;                                      // 0x02B0(0x0004) (Const)
	float                                              m_fMissInvalidEndDistance;                                // 0x02B4(0x0004) (Const)
	float                                              m_fMissInvalidEndTime;                                    // 0x02B8(0x0004) (Const)
	float                                              m_fCloseRangeEndDistance;                                 // 0x02BC(0x0004) (Const)
	float                                              m_fTruePostfireTime;                                      // 0x02C0(0x0004)
	class UTgSkeletalMeshComponent*                    m_ChainMesh;                                              // 0x02C4(0x0008) (ExportObject, Component, EditInline)
	int                                                m_nChainMeshID;                                           // 0x02CC(0x0004) (Const)
	class UTgSkelCon_HookChain*                        c_ChainSkelCon;                                           // 0x02D0(0x0008)
	struct FName                                       m_ChainSocket;                                            // 0x02D8(0x0008) (Const)
	TArray<class UTgAnimNodeBlendByAbilityDrag*>       m_DragBlendList1P;                                        // 0x02E0(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeBlendByAbilityDrag*>       m_DragBlendList3P;                                        // 0x02F0(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeBlendByAbilityDragChain*>  m_ChainBlendList;                                         // 0x0300(0x0010) (NeedCtorLink)
	TEnumAsByte<EDragState>                            m_DragState;                                              // 0x0310(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Drag");
		return ptr;
	}


	void SetChainLocation(const struct FVector& vLocalChainLocation, const struct FVector& vLocalSocketLocation);
	void StopChainEffects();
	void PlayChainEffects();
	void StopFire(int nFireModeNum);
	void Hit(int nFireMode, class AActor* Target, float fDamageAmount, const struct FVector& HitLocation, const struct FVector& HitNormal, struct FExtraDamageInfo* ExtraInfo);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	void STATIC_HideChain();
	void StartMissInvalidEnd();
	void StartMissNoHitEnd();
	void Generic4(unsigned char byExtraData);
	void Generic3(unsigned char byExtraData);
	void Generic2(unsigned char byExtraData);
	void Generic1(unsigned char byExtraData);
	void ConnectBeamToTarget(class AActor* Target);
	void CacheChainAnimNodes(class UTgSkeletalMeshComponent* SkelComp);
	void CacheAnimNode(class UAnimNode* Node, bool bIs3p);
	void ClearAnimNodes(bool bIs3p);
	struct FVector STATIC_GetChainSocketLocation();
	void STATIC_UpdateChainEffects(const struct FVector& vEndPoint);
	void STATIC_HandleMissConditions();
};


// Class TgGame.TgDeviceForm_ShellShield
// 0x000C (0x0298 - 0x028C)
class UTgDeviceForm_ShellShield : public UTgDeviceForm
{
public:
	unsigned long                                      m_bShouldBeActive : 1;                                    // 0x028C(0x0004)
	float                                              m_fShieldActivationTime;                                  // 0x0290(0x0004)
	float                                              m_fShieldActivationPercent;                               // 0x0294(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_ShellShield");
		return ptr;
	}


	void Generic1(unsigned char byExtraData);
	void StopFire(int nFireModeNum);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	void STATIC_UpdateShieldParameters(float DeltaSeconds);
};


// Class TgGame.TgDeviceForm_TurtlePower
// 0x000C (0x0298 - 0x028C)
class UTgDeviceForm_TurtlePower : public UTgDeviceForm
{
public:
	unsigned long                                      m_bShouldBeActive : 1;                                    // 0x028C(0x0004)
	float                                              m_fRageActivationTime;                                    // 0x0290(0x0004)
	float                                              m_fRageActivationPercent;                                 // 0x0294(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_TurtlePower");
		return ptr;
	}


	void StopFire(int nFireModeNum);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	void STATIC_UpdateRageMeshVisibility(float DeltaSeconds);
};


// Class TgGame.TgInvListener_Halfshell
// 0x0000 (0x00C8 - 0x00C8)
class UTgInvListener_Halfshell : public UTgInventoryObject_Listen_ActiveWhileOffCooldown
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_Halfshell");
		return ptr;
	}

};


// Class TgGame.TgPawn_Makoa
// 0x002C (0x3304 - 0x32D8)
class ATgPawn_Makoa : public ATgPawn_Character
{
public:
	float                                              m_fSmashSpeedModifier;                                    // 0x32D8(0x0004)
	float                                              m_fShellSpinZoomOverride;                                 // 0x32DC(0x0004)
	unsigned long                                      r_bShellShieldIsActive : 1;                               // 0x32E0(0x0004) (Net)
	unsigned long                                      r_bAncientRageActive : 1;                                 // 0x32E0(0x0004) (Net)
	unsigned long                                      r_bAbility1CanEmote : 1;                                  // 0x32E0(0x0004) (Net)
	float                                              m_fShellShieldSpeedModifier;                              // 0x32E4(0x0004)
	float                                              m_fShellShieldZoomOverride;                               // 0x32E8(0x0004)
	class UTgSpecialFx*                                m_ShellShieldMovementFX;                                  // 0x32EC(0x0008)
	class ATgDevice*                                   m_AncientRageInHand;                                      // 0x32F4(0x0008)
	class ATgDevice*                                   m_CachedDavyJones;                                        // 0x32FC(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Makoa");
		return ptr;
	}


	void OnDeviceFormHit(int nEquipSlot, class AActor* Target, float DamageAmount, const struct FVector& HitLocation, const struct FVector& HitNormal, struct FExtraDamageInfo* ExtraInfo);
	struct FName STATIC_GetFootStepOverride();
	float GetAbilityEmoteChance(TEnumAsByte<EEmote> Emote);
	void STATIC_GetCameraZoomOverride(float* fZoom, float* fZoomDuration);
	void SetTargetingDevice(class ATgDevice* Dev, const struct FWeaponMeshSwapStrategy& SwapStrategy);
	void PlayAncientRageEffects(bool bEnabled);
	float GetDavyJonesActorHitPeriod(class AActor* pQueryActor);
	float GetDavyJonesShellSpinSpeed();
	float GetDavyJonesShellSpinTime();
	bool HasDavyJones();
	void ReplicatedEvent(const struct FName& VarName);
	bool STATIC_CanSpawnScalableShields();
};


// Class TgGame.TgProj_Drag
// 0x0010 (0x053C - 0x052C)
class ATgProj_Drag : public ATgProj_Simulated
{
public:
	class UTgDeviceForm_Drag*                          m_DragForm;                                               // 0x052C(0x0008)
	float                                              m_fCollisionHeightScale;                                  // 0x0534(0x0004)
	float                                              m_fInverseSpeed;                                          // 0x0538(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Drag");
		return ptr;
	}


	bool StartDrag(class AActor* Target, const struct FVector& HitLocation);
	void ExplodeOnTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void Fizzle();
	void RangeReached();
	bool CheckProjectileRange(const struct FVector& vLocOverride);
};


// Class TgGame.TgDeploy_DarkConvergence
// 0x008C (0x0510 - 0x0484)
class ATgDeploy_DarkConvergence : public ATgDeploy_Bomb
{
public:
	TArray<struct FPullData>                           m_PullDataList;                                           // 0x0484(0x0010) (NeedCtorLink)
	class ATgPawn_Character*                           r_PulledTargets[0x5];                                     // 0x0494(0x0008) (Net)
	struct FVector                                     r_PulledTargetLocations[0x5];                             // 0x04BC(0x000C) (Net)
	TArray<class UTgBeamHelper*>                       c_Beams;                                                  // 0x04F8(0x0010) (NeedCtorLink)
	float                                              c_fHideBeamsTimer;                                        // 0x0508(0x0004)
	float                                              s_fVerticalTargetLocationOffset;                          // 0x050C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_DarkConvergence");
		return ptr;
	}


	void Tick(float DeltaSeconds);
	void DetermineTeleportLocations();
	void StartPull();
	void ApplyHit(TArray<struct FImpactInfo>* ImpactList);
	void STATIC_UpdateBeams();
	void STATIC_HideBeams();
	void CreateBeams();
	void ApplyForcedView();
	void ReplicatedEvent(const struct FName& VarName);
	float STATIC_GetPullTime();
	float STATIC_GetPullDelay();
};


// Class TgGame.TgDevice_DarkConvergence
// 0x0004 (0x0A10 - 0x0A0C)
class ATgDevice_DarkConvergence : public ATgDevice
{
public:
	unsigned long                                      s_bQueueSoulOrbDeploy : 1;                                // 0x0A0C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DarkConvergence");
		return ptr;
	}


	bool STATIC_InterceptSlotPressed(class ATgPlayerController* TgController);
	void STATIC_ServerDeploySoulOrb();
	bool STATIC_TryDeploySoulOrb();
};


// Class TgGame.TgDevice_RendSoul
// 0x0004 (0x0A10 - 0x0A0C)
class ATgDevice_RendSoul : public ATgDevice
{
public:
	unsigned long                                      m_bApplyCooldown : 1;                                     // 0x0A0C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_RendSoul");
		return ptr;
	}


	bool ShouldCooldownAfterFire();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgDevice_RestoreSoul
// 0x0088 (0x0A94 - 0x0A0C)
class ATgDevice_RestoreSoul : public ATgDevice
{
public:
	class ATgPawn_Oracle*                              m_CachedOraclePawn;                                       // 0x0A0C(0x0008)
	struct FImpactInfo                                 m_CachedImpact;                                           // 0x0A14(0x007C) (Component)
	unsigned long                                      m_bApplyCooldown : 1;                                     // 0x0A90(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_RestoreSoul");
		return ptr;
	}


	void STATIC_UpdateHitTargetInfo(class AActor* HitActor, const struct FVector& HitLocation);
	void OnInstantShotRejected(const struct FImpactToValidate& RejectedPrimaryImpact);
	void OnInstantShotVerified(const struct FImpactInfo& VerifiedPrimaryImpact);
	struct FImpactInfo CalcWeaponFire(const struct FAimData& Aim, TArray<struct FImpactInfo>* ImpactList);
	void DelayedDeliverHit();
	void DeliverHit(const struct FImpactInfo& Impact);
	bool ShouldCooldownAfterFire();
	void DeliverQueuedPendingHits();
	bool STATIC_HasCachedOracle();
	bool CanBeInterrupted();
	bool CanBeCanceled();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgDevice_ShadowTravel
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_ShadowTravel : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ShadowTravel");
		return ptr;
	}


	float STATIC_GetMoveSpeedMultiplier();
	bool ShouldInterruptReloadOnFire();
	bool CanBeCanceled();
};


// Class TgGame.TgDevice_OracleInhand
// 0x0000 (0x0A24 - 0x0A24)
class ATgDevice_OracleInhand : public ATgDevice_ToggleInhand
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_OracleInhand");
		return ptr;
	}


	void DeliverHit(const struct FImpactInfo& Impact);
};


// Class TgGame.TgDeviceFire_OracleInhand
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_OracleInhand : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_OracleInhand");
		return ptr;
	}


	bool ApplyHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
};


// Class TgGame.TgDeviceFire_RendSoul
// 0x0004 (0x026C - 0x0268)
class UTgDeviceFire_RendSoul : public UTgDeviceFire
{
public:
	int                                                s_nStacksConsumed;                                        // 0x0268(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_RendSoul");
		return ptr;
	}


	bool IsSoulCollectorActive();
	bool IsAgonyActive();
	void SubmitEffect(const struct FImpactInfo& Impact, class UTgEffectGroup* effectGroup, bool bRemove, int StackCount, class AActor* InstigatorOverride);
	void CustomFire();
};


// Class TgGame.TgDeviceFire_RestoreSoul
// 0x0008 (0x0270 - 0x0268)
class UTgDeviceFire_RestoreSoul : public UTgDeviceFire
{
public:
	float                                              m_fServerRangeBufferMult;                                 // 0x0268(0x0004)
	float                                              m_fBaseEncroachmentActorRange;                            // 0x026C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_RestoreSoul");
		return ptr;
	}


	float GetAreaHealRadius();
	bool IsAreaHealActive();
	TArray<class ATgPawn*> STATIC_GetAreaHealTargets(class AActor* PrimaryTarget);
	float STATIC_GetPostHitDelay();
	bool STATIC_IgnoreTargetForBlocking(class AActor* Target);
};


// Class TgGame.TgDeviceForm_OracleInhand
// 0x000C (0x02A8 - 0x029C)
class UTgDeviceForm_OracleInhand : public UTgDeviceForm_Inhand
{
public:
	class ATgPawn_Oracle*                              m_CachedOracle;                                           // 0x029C(0x0008)
	float                                              c_fLastReceivedTransitionInTime;                          // 0x02A4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_OracleInhand");
		return ptr;
	}


	void STATIC_UpdateAmmoCountFx(float fPreviousPerc, float fCurrentPerc);
	void STATIC_UpdateAmmoCountSingleFx(class UTgSpecialFx* Fx, float fAmmoPerc);
	void StopFire(int nFireModeNum);
	void RecoverDeviceState(TEnumAsByte<ETG_REP_DEVICE_STATE> DesiredState);
	void PlayToggleTransitionAnimations(float transitionPercent, float totalTransitionTime, bool transitionToActive);
	void Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	class UTgAnimNodeSlot* STATIC_GetFullBodyAnimNode();
	bool STATIC_HasCachedOracle();
};


// Class TgGame.TgEffectForm_Oracle_SoulStacks
// 0x0000 (0x00FC - 0x00FC)
class UTgEffectForm_Oracle_SoulStacks : public UTgEffectForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_Oracle_SoulStacks");
		return ptr;
	}

};


// Class TgGame.TgPawn_Oracle
// 0x0104 (0x33DC - 0x32D8)
class ATgPawn_Oracle : public ATgPawn_Character
{
public:
	class AActor*                                      r_RestoreSoulTarget;                                      // 0x32D8(0x0008) (Net)
	struct FVector                                     r_RestoreSoulHitOffset;                                   // 0x32E0(0x000C) (Net)
	class AActor*                                      r_RestoreSoulSecondaryTargets[0x4];                       // 0x32EC(0x0008) (Net)
	class UTgBeamHelper*                               c_RestoreSoulSecondaryBeams[0x4];                         // 0x330C(0x0008)
	unsigned long                                      r_bRestoreSoulActive : 1;                                 // 0x332C(0x0004) (Net)
	unsigned long                                      r_bHasAgonyTalent : 1;                                    // 0x332C(0x0004) (Net)
	unsigned long                                      m_bIsDetonatedOrbsCanBeRedeemed : 1;                      // 0x332C(0x0004)
	int                                                r_SoulStackTargetPawnId[0xA];                             // 0x3330(0x0004) (Net)
	int                                                r_SoulStackTargetCount[0xA];                              // 0x3358(0x0004) (Net)
	int                                                c_CachedSoulStackTargetCount[0xA];                        // 0x3380(0x0004)
	struct FVector                                     c_InterpRestoreSoulHitOffset;                             // 0x33A8(0x000C)
	float                                              c_fRestoreSoulHitOffsetInterpSpeed;                       // 0x33B4(0x0004)
	float                                              m_fFrictionMultiplier;                                    // 0x33B8(0x0004) (Edit)
	int                                                m_nStackAddedVictimFxId;                                  // 0x33BC(0x0004)
	int                                                m_nStackAddedSourceFxId;                                  // 0x33C0(0x0004)
	int                                                m_nMaxStacksVictimFxId;                                   // 0x33C4(0x0004)
	int                                                m_nMaxStacksSourceFxId;                                   // 0x33C8(0x0004)
	int                                                m_nDetonatedOrbsCount;                                    // 0x33CC(0x0004)
	int                                                r_nSoulCollectorEffectGroupId;                            // 0x33D0(0x0004) (Net)
	int                                                r_nSoulCollectorStacksApplied;                            // 0x33D4(0x0004) (Net)
	float                                              s_fAgonyDenotatedOrbsTimerDuration;                       // 0x33D8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Oracle");
		return ptr;
	}


	void STATIC_UpdateRestoreSoulSecondaryBeams();
	void STATIC_ResetAgonyDetonatedOrbsTimer();
	void OnSoulStacksReplicated();
	void STATIC_UpdateSoulStacks();
	void Tick(float DeltaSeconds);
	void ReplicatedEvent(const struct FName& VarName);
};


// Class TgGame.TgPawnMod_FxAudio_EDMSeris
// 0x0004 (0x00B0 - 0x00AC)
class UTgPawnMod_FxAudio_EDMSeris : public UTgPawnMod_FxAudio
{
public:
	float                                              m_fGlowMultBass;                                          // 0x00AC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawnMod_FxAudio_EDMSeris");
		return ptr;
	}

};


// Class TgGame.TgProj_DarkConvergence
// 0x0000 (0x0580 - 0x0580)
class ATgProj_DarkConvergence : public ATgProj_FreeGrenade
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_DarkConvergence");
		return ptr;
	}

};


// Class TgGame.TgDevice_HealingPotion
// 0x0004 (0x0A10 - 0x0A0C)
class ATgDevice_HealingPotion : public ATgDevice
{
public:
	unsigned long                                      s_bQueueDetonation : 1;                                   // 0x0A0C(0x0004)
	unsigned long                                      m_bAttemptingToDetonate : 1;                              // 0x0A0C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_HealingPotion");
		return ptr;
	}


	void ScaleAbilityRadius();
	void ClientInterrupt(bool bServerFireFailed);
	void InterruptFiring(bool bServerFireFailed);
	void STATIC_ClientClearPostHitDelay();
	void ServerTryDetonate();
	bool TryDetonate();
	bool STATIC_InterceptSlotPressed(class ATgPlayerController* TgController);
	void STATIC_UpdateActiveProjectiles(class ATgProjectile* Proj);
	void ClientEndCooldown();
	void ClientStartCooldown(int nMode, float fCooldownTimeOverride);
	void STATIC_FireAmmunition();
	void DetonationGracePeriod();
	void STATIC_LockOutOtherDevices();
	bool STATIC_IsLeadVialActive();
};


// Class TgGame.TgDevice_Weightless
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_Weightless : public ATgDevice
{
public:
	float                                              r_fSprintHorizontalSpeedMod;                              // 0x0A0C(0x0004) (Net)
	float                                              r_fSprintJumpSpeedMod;                                    // 0x0A10(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Weightless");
		return ptr;
	}


	bool ShouldInterruptReloadOnFire();
	bool CanFiringBeCanceledByReactivation();
	bool CanBeCanceled();
	bool CanFiringBeCanceledByLeftMouse();
	bool ShouldInterruptInhand();
	float CalcWeightlessJumpMultiplier();
	float CalcWeightlessHorizontalMultiplier();
	float STATIC_GetJumpSpeedMultiplier();
	float STATIC_GetHorizontalSpeedMultiplier();
	bool STATIC_InterceptSlotPressed(class ATgPlayerController* TgController);
	bool ShouldInterruptLift();
};


// Class TgGame.TgInventoryObject_Listen_Acrobatics
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_Acrobatics : public UTgInventoryObject_Listen_UseWhileCCed
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Acrobatics");
		return ptr;
	}

};


// Class TgGame.TgInvListener_ChickenTenderizer
// 0x0000 (0x00E0 - 0x00E0)
class UTgInvListener_ChickenTenderizer : public UTgInvListener_DeathAfterHit
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_ChickenTenderizer");
		return ptr;
	}

};


// Class TgGame.TgInvListener_MegaPotion
// 0x0000 (0x00C8 - 0x00C8)
class UTgInvListener_MegaPotion : public UTgInventoryObject_Listen_ActiveWhileOffCooldown
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_MegaPotion");
		return ptr;
	}

};


// Class TgGame.TgPawn_Pip
// 0x0018 (0x32F0 - 0x32D8)
class ATgPawn_Pip : public ATgPawn_Character
{
public:
	unsigned long                                      r_bWeightless : 1;                                        // 0x32D8(0x0004) (Net)
	unsigned long                                      m_bWeightlessDurationEnded : 1;                           // 0x32D8(0x0004)
	unsigned long                                      r_bAcrobaticsActive : 1;                                  // 0x32D8(0x0004) (Net)
	unsigned long                                      r_bHasMegaPotion : 1;                                     // 0x32D8(0x0004) (Net)
	float                                              m_fWeightlessMaxSpeedModifier;                            // 0x32DC(0x0004)
	float                                              m_fWeightlessJumpZModifier;                               // 0x32E0(0x0004)
	float                                              r_fRadiusForHealingPotionFX;                              // 0x32E4(0x0004) (Net)
	class ATgDevice_Weightless*                        m_CachedWeightless;                                       // 0x32E8(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Pip");
		return ptr;
	}


	void Landed(const struct FVector& HitNormal, class AActor* FloorActor);
	bool DoJump(bool bUpdating, float JumpZSpeed);
	void JumpHeldAltPressed();
	float STATIC_GetJumpSpeedMultiplier();
	void STATIC_EndWeightless();
	void StartWeightless(float fMaxSpeedMultiplier, float fJumpZMultiplier);
	void PlayJumpSound();
	bool STATIC_HasCachedWeightless();
};


// Class TgGame.TgPawnMod_FxAudio_EDMPip
// 0x0000 (0x00AC - 0x00AC)
class UTgPawnMod_FxAudio_EDMPip : public UTgPawnMod_FxAudio
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawnMod_FxAudio_EDMPip");
		return ptr;
	}

};


// Class TgGame.TgProj_HealingPotion
// 0x0000 (0x0580 - 0x0580)
class ATgProj_HealingPotion : public ATgProj_FreeGrenade
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_HealingPotion");
		return ptr;
	}


	void PlayAdditionalHitFX(class AActor* HitActor, const struct FVector& FXLocation, const struct FVector& HitNormal, const struct FVector& ProjDir, TArray<struct FParticleSysParam>* ExplosionParams);
	void STATIC_GetExplosionFXParams(TArray<struct FParticleSysParam>* Params);
};


// Class TgGame.TgProj_HealingPotionLeadVial
// 0x0000 (0x0580 - 0x0580)
class ATgProj_HealingPotionLeadVial : public ATgProj_HealingPotion
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_HealingPotionLeadVial");
		return ptr;
	}


	bool CanHitInstigator();
};


// Class TgGame.TgDevice_Enlightenment
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_Enlightenment : public ATgDevice
{
public:
	class ATgPawn_Princess*                            m_CachedPrincess;                                         // 0x0A0C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Enlightenment");
		return ptr;
	}


	void STATIC_WaitForResultOfFire();
	void StartWaitForResultOfFireTimer();
	void TimeOut();
	void StartTimeOut();
	bool CanBeCanceled();
	bool STATIC_HasCachedPrincess();
};


// Class TgGame.TgDevice_EnlightenmentGun
// 0x000C (0x0A18 - 0x0A0C)
class ATgDevice_EnlightenmentGun : public ATgDevice
{
public:
	class ATgPawn_Princess*                            m_CachedPrincess;                                         // 0x0A0C(0x0008)
	unsigned long                                      m_bAutoFireAfterPostHitDelay : 1;                         // 0x0A14(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_EnlightenmentGun");
		return ptr;
	}


	bool ShouldSwitchBackToBasicAttackTargeting(TEnumAsByte<ECastMode> CastMode);
	bool UsesSimulatedAmmo();
	bool STATIC_HasCachedPrincess();
	bool RequiresAmmoToFire();
};


// Class TgGame.TgDevice_Presence
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_Presence : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Presence");
		return ptr;
	}


	bool CanBeFiredWhileGrabbed();
	bool CanBeFiredWhileTweening();
};


// Class TgGame.TgDevice_PrincessFSupport
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_PrincessFSupport : public ATgDevice
{
public:
	class ATgPawn_Princess*                            m_CachedLian;                                             // 0x0A0C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_PrincessFSupport");
		return ptr;
	}


	struct FImpactInfo CalcWeaponFire(const struct FAimData& Aim, TArray<struct FImpactInfo>* ImpactList);
	bool STATIC_HasCachedLian();
	void STATIC_GetTargetingAim(struct FAimData* Aim);
	bool STATIC_UsesCachedAim();
	bool CanFiringBeLocked();
};


// Class TgGame.TgDevice_PrincessInhand
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_PrincessInhand : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_PrincessInhand");
		return ptr;
	}

};


// Class TgGame.TgDevice_PrincessRMB
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_PrincessRMB : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_PrincessRMB");
		return ptr;
	}


	bool CanBeFiredWhileGrabbed();
	bool CanBeFiredWhileTweening();
};


// Class TgGame.TgDeviceFire_PrincessF
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_PrincessF : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_PrincessF");
		return ptr;
	}

};


// Class TgGame.TgInvListener_Enlightenment
// 0x0004 (0x00C8 - 0x00C4)
class UTgInvListener_Enlightenment : public UTgInvListener
{
public:
	unsigned long                                      m_bCanRefundEnergy : 1;                                   // 0x00C4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_Enlightenment");
		return ptr;
	}

};


// Class TgGame.TgLian
// 0x0000 (0x0060 - 0x0060)
class UTgLian : public UObject
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgLian");
		return ptr;
	}

};


// Class TgGame.TgWeaponMeshActor_LianInhand
// 0x0084 (0x04D4 - 0x0450)
class ATgWeaponMeshActor_LianInhand : public ATgWeaponMeshActor
{
public:
	class ATgPawn_Princess*                            m_CachedLian;                                             // 0x0450(0x0008)
	class UTgBeamHelper*                               c_GraceTracers[0xF];                                      // 0x0458(0x0008)
	unsigned long                                      c_bTracersVisible : 1;                                    // 0x04D0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgWeaponMeshActor_LianInhand");
		return ptr;
	}


	void ManageGraceTracers();
	void ManageGraceTracer(int Index);
	void ClearGraceTracer(int Index);
	void ClearGraceTracers();
	void STATIC_HideGraceTracers();
	void ShowGraceTracers();
	bool STATIC_HasCachedLian();
};


// Class TgGame.TgDevice_RepulsorField
// 0x0004 (0x0A70 - 0x0A6C)
class ATgDevice_RepulsorField : public ATgDevice_ActiveAura
{
public:
	float                                              r_fAtTheReadyRadius;                                      // 0x0A6C(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_RepulsorField");
		return ptr;
	}


	bool ShouldInterruptReloadOnFire();
};


// Class TgGame.TgDevice_Advance
// 0x0004 (0x0A84 - 0x0A80)
class ATgDevice_Advance : public ATgDevice_Charge
{
public:
	unsigned long                                      m_bHasCharged : 1;                                        // 0x0A80(0x0004)
	unsigned long                                      r_bHasAerialAssault : 1;                                  // 0x0A80(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Advance");
		return ptr;
	}


	bool ShouldApplyHitSpecialOnTouch(class AActor* Target);
	bool ShouldInterruptReloadOnFire();
	float GetChargeRange();
	void ReplicatedEvent(const struct FName& VarName);
};


// Class TgGame.TgDevice_HexaFireGuns
// 0x0008 (0x0A40 - 0x0A38)
class ATgDevice_HexaFireGuns : public ATgDevice_QuadWield
{
public:
	class ATgPawn_Ruckus*                              m_CachedRuckusOwner;                                      // 0x0A38(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_HexaFireGuns");
		return ptr;
	}


	bool STATIC_HasCachedRuckusOwner();
	bool STATIC_InterceptRightMouseReleased(class ATgPlayerController* TgController);
	bool STATIC_InterceptRightMousePressed(class ATgPlayerController* TgController);
	bool STATIC_InterceptLeftMouseReleased(class ATgPlayerController* TgController);
	bool STATIC_InterceptLeftMousePressed(class ATgPlayerController* TgController);
};


// Class TgGame.TgDevice_RuckusInhand
// 0x0030 (0x0A4C - 0x0A1C)
class ATgDevice_RuckusInhand : public ATgDevice_DualWield
{
public:
	float                                              m_fSpinAmount;                                            // 0x0A1C(0x0004)
	float                                              m_fCurrentSpinScale;                                      // 0x0A20(0x0004)
	float                                              m_fStartingSpinRate;                                      // 0x0A24(0x0004) (Edit)
	float                                              m_fMaxSpinRate;                                           // 0x0A28(0x0004) (Edit)
	float                                              m_fDurationToMaxSpin;                                     // 0x0A2C(0x0004) (Edit)
	float                                              m_fSpinDownRate;                                          // 0x0A30(0x0004) (Edit)
	float                                              m_fSlowestFireDelay;                                      // 0x0A34(0x0004) (Edit)
	float                                              m_fFiringMoveSpeedModifier;                               // 0x0A38(0x0004)
	unsigned long                                      m_bLeftMouseMovePenalty : 1;                              // 0x0A3C(0x0004)
	unsigned long                                      m_bInFireLoop : 1;                                        // 0x0A3C(0x0004)
	unsigned long                                      m_bAltFireSpinning : 1;                                   // 0x0A3C(0x0004)
	unsigned long                                      m_bHexaFireSpinning : 1;                                  // 0x0A3C(0x0004)
	float                                              m_fMoveSpeedDecreaseInterpolationDuration;                // 0x0A40(0x0004) (Edit)
	float                                              m_fMoveSpeedIncreaseInterpolationDuration;                // 0x0A44(0x0004) (Edit)
	float                                              r_fRecyclerPercent;                                       // 0x0A48(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_RuckusInhand");
		return ptr;
	}


	void SetCurrentSpinScale(float fCurrentSpinScale);
	void Tick(float DeltaTime);
	void SetLeftMouseMovePenalty(bool bLeftMouseMovePenalty);
	bool ShouldConsumeAmmo(int nFireRequestId, TArray<struct FImpactToValidate> Impacts);
};


// Class TgGame.TgDevice_Emitter
// 0x0028 (0x0A34 - 0x0A0C)
class ATgDevice_Emitter : public ATgDevice
{
public:
	TArray<class AActor*>                              m_PawnsInRange;                                           // 0x0A0C(0x0010) (NeedCtorLink)
	class ATgCollisionProxy_Cylinder*                  m_CollisionProxy;                                         // 0x0A1C(0x0008)
	unsigned long                                      m_bHasProjector : 1;                                      // 0x0A24(0x0004)
	unsigned long                                      m_bIsOnOwner : 1;                                         // 0x0A24(0x0004)
	float                                              m_fProjectorPercent;                                      // 0x0A28(0x0004)
	class ATgPawn*                                     m_CachedPawnOwner;                                        // 0x0A2C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Emitter");
		return ptr;
	}


	void SpawnCollisionProxy();
	void ClearAllTouched();
	void OnProxyUnTouch(class AActor* Other);
	void OnProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool ShouldInterruptReloadOnFire();
};


// Class TgGame.TgDevice_HexaFire
// 0x0020 (0x0A34 - 0x0A14)
class ATgDevice_HexaFire : public ATgDevice_HitPulse
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_MoveSpeedMultiplier;           // 0x0A14(0x0008) (Const, Native, NoExport)
	struct FVector                                     m_vProjectileSpawnOffset2;                                // 0x0A1C(0x000C) (Edit)
	unsigned long                                      m_bFireLeftWeapon : 1;                                    // 0x0A28(0x0004)
	class ATgPawn_Ruckus*                              m_CachedRuckus;                                           // 0x0A2C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_HexaFire");
		return ptr;
	}


	bool ShouldInterruptReloadOnFire();
	void STATIC_FireAmmunition();
	bool ShouldConsumePowerPoolAfterFire();
	bool ShouldConsumePowerPoolOnStartFire();
	bool CanBeCanceled();
	bool ShouldLockJumping();
	struct FVector GetProjectileSpawnOffset();
	bool STATIC_HasCachedRuckus();
	bool STATIC_ShouldUseGradualMovement();
	float STATIC_GetMoveSpeedMultiplier();
	void STATIC_GetCachedAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_MinigunSpinUp
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_MinigunSpinUp : public ATgDevice
{
public:
	class ATgDevice_RuckusInhand*                      m_CachedRuckusInhand;                                     // 0x0A0C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_MinigunSpinUp");
		return ptr;
	}


	void CacheRuckusInhand();
	void StopSpinningInhand();
	void StartSpinningInhand();
	bool STATIC_IsToggleDevice();
};


// Class TgGame.TgDevice_RocketLauncher
// 0x0010 (0x0A1C - 0x0A0C)
class ATgDevice_RocketLauncher : public ATgDevice
{
public:
	struct FVector                                     m_vProjectileSpawnOffset2;                                // 0x0A0C(0x000C) (Edit)
	int                                                m_nFireCount;                                             // 0x0A18(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_RocketLauncher");
		return ptr;
	}


	bool UsesSimulatedAmmo();
	class AProjectile* ProjectileFire(int ProjectileIndex);
	struct FVector GetProjectileSpawnOffset();
	bool ShouldInterruptReloadOnFire();
	void STATIC_GetAdjustedAim(float AccuracyValueOverride, float RandomValueOverride1, float RandomValueOverride2, int nMultifireIndex, struct FAimData* Aim, float* UsedAccuracyValue, float* UsedRandomValue1, float* UsedRandomValue2);
};


// Class TgGame.TgDeviceFire_RepulsorField
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_RepulsorField : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_RepulsorField");
		return ptr;
	}


	struct FWeaponFireResults CalcWeaponModeFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, bool bNoBodyShotCheck, float RewindTime, TArray<struct FImpactInfo>* ImpactList, TArray<struct FImpactToValidate>* ImpactsToValidate);
	float STATIC_GetDamageRadius();
};


// Class TgGame.TgDeviceForm_RuckusInhand
// 0x0070 (0x02FC - 0x028C)
class UTgDeviceForm_RuckusInhand : public UTgDeviceForm
{
public:
	unsigned long                                      m_bFiredFromLeftGun : 1;                                  // 0x028C(0x0004)
	unsigned long                                      m_bFiredFromTopBarrel : 1;                                // 0x028C(0x0004)
	unsigned long                                      m_bPlayingSpinnerSound : 1;                               // 0x028C(0x0004)
	unsigned long                                      m_bPlayingFireLoopSound : 1;                              // 0x028C(0x0004)
	unsigned long                                      m_bIsFiring : 1;                                          // 0x028C(0x0004)
	class UTgSkelCon_Spinner*                          m_SpinnerSkelControl1P;                                   // 0x0290(0x0008)
	class UTgSkelCon_Spinner*                          m_SpinnerSkelControl3P;                                   // 0x0298(0x0008)
	struct FName                                       c_nmSocketLeft;                                           // 0x02A0(0x0008)
	struct FName                                       c_nmSocketRight;                                          // 0x02A8(0x0008)
	float                                              m_fLoopingSoundThreshold;                                 // 0x02B0(0x0004) (Edit)
	float                                              m_fLastSpinConfirmationTimestamp;                         // 0x02B4(0x0004)
	float                                              m_fSpinConfirmationCooldown;                              // 0x02B8(0x0004)
	class UTgSkelControlSingleBone_PistonBarrel*       m_LowerRightBarrel1P;                                     // 0x02BC(0x0008)
	class UTgSkelControlSingleBone_PistonBarrel*       m_UpperRightBarrel1P;                                     // 0x02C4(0x0008)
	class UTgSkelControlSingleBone_PistonBarrel*       m_LowerLeftBarrel1P;                                      // 0x02CC(0x0008)
	class UTgSkelControlSingleBone_PistonBarrel*       m_UpperLeftBarrel1P;                                      // 0x02D4(0x0008)
	class UTgSkelControlSingleBone_PistonBarrel*       m_LowerRightBarrel3P;                                     // 0x02DC(0x0008)
	class UTgSkelControlSingleBone_PistonBarrel*       m_UpperRightBarrel3P;                                     // 0x02E4(0x0008)
	class UTgSkelControlSingleBone_PistonBarrel*       m_LowerLeftBarrel3P;                                      // 0x02EC(0x0008)
	class UTgSkelControlSingleBone_PistonBarrel*       m_UpperLeftBarrel3P;                                      // 0x02F4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_RuckusInhand");
		return ptr;
	}


	struct FVector GetTracerSocketLocation();
	void Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	void CacheAnimNodesHelper(class UTgSkeletalMeshComponent* SkelComp, class UTgSkelControlSingleBone_PistonBarrel** LowerRightBarrel, class UTgSkelControlSingleBone_PistonBarrel** UpperRightBarrel, class UTgSkelControlSingleBone_PistonBarrel** LowerLeftBarrel, class UTgSkelControlSingleBone_PistonBarrel** UpperLeftBarrel, class UTgSkelCon_Spinner** spinner);
	void Cache3PAnimNodes(class UTgSkeletalMeshComponent* SkelComp);
	void Cache1PAnimNodes(class UTgSkeletalMeshComponent* SkelComp);
	void StopFire(int nFireModeNum);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
};


// Class TgGame.TgInvListener_AerialAssault
// 0x0000 (0x00C8 - 0x00C8)
class UTgInvListener_AerialAssault : public UTgInventoryObject_Listen_ActiveWhileOffCooldown
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_AerialAssault");
		return ptr;
	}

};


// Class TgGame.TgInvListener_Recycler
// 0x0000 (0x00C8 - 0x00C8)
class UTgInvListener_Recycler : public UTgInventoryObject_Listen_ActiveWhileOffCooldown
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_Recycler");
		return ptr;
	}

};


// Class TgGame.TgPawn_Ruckus
// 0x0068 (0x3340 - 0x32D8)
class ATgPawn_Ruckus : public ATgPawn_Character
{
public:
	float                                              m_fDamageAccumulator;                                     // 0x32D8(0x0004)
	unsigned long                                      r_bHexaFireFiring : 1;                                    // 0x32DC(0x0004) (Net)
	unsigned long                                      m_bInstancedGemArmMaterials : 1;                          // 0x32DC(0x0004)
	unsigned long                                      m_bInstancedGemBodyMaterials : 1;                         // 0x32DC(0x0004)
	unsigned long                                      m_bRegisteredAudioCallbacks : 1;                          // 0x32DC(0x0004)
	unsigned long                                      m_bHasBoltGemFX : 1;                                      // 0x32DC(0x0004)
	float                                              r_fBarrelSpinRate;                                        // 0x32E0(0x0004) (Net)
	float                                              r_fBarrelSpinFactor;                                      // 0x32E4(0x0004) (Net)
	class ATgDevice_RuckusInhand*                      m_CachedRuckusInhand;                                     // 0x32E8(0x0008)
	class ATgDevice_HexaFireGuns*                      m_CachedHexaFireGuns;                                     // 0x32F0(0x0008)
	class ATgDevice_Emitter*                           m_CachedEmitter;                                          // 0x32F8(0x0008)
	class ATgDevice_RepulsorField*                     m_CachedRepulsorField;                                    // 0x3300(0x0008)
	TArray<class UMaterialInstanceConstant*>           m_ReplacementArmMICs;                                     // 0x3308(0x0010) (NeedCtorLink)
	TArray<class UMaterialInstanceConstant*>           m_ReplacementBodyMICs;                                    // 0x3318(0x0010) (NeedCtorLink)
	int                                                m_nInstancedGemArmMaterialsHandle;                        // 0x3328(0x0004)
	int                                                m_nInstancedGemBodyMaterialsHandle;                       // 0x332C(0x0004)
	struct Fdword                                      m_dwGemFXBusID;                                           // 0x3330(0x0004)
	float                                              m_fVGSMatBlue;                                            // 0x3334(0x0004)
	class UTgSpecialFx*                                m_IdleFX;                                                 // 0x3338(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Ruckus");
		return ptr;
	}


	void BecomeViewTarget(class APlayerController* PC);
	bool ShouldStopWeaponMeshFireEffectsOnDeviceFormStopFire(int nEquipSlot);
	void SetTargetingDevice(class ATgDevice* Dev, const struct FWeaponMeshSwapStrategy& SwapStrategy);
	void PlayHexaFireEffects(bool bEnabled);
	bool StartAction(class ATgDevice* Dev, bool bUpdateTimeStamp, TEnumAsByte<EDeviceFailType>* failType);
	void ReplicatedEvent(const struct FName& VarName);
	bool STATIC_HasCachedRepulsorField();
	bool STATIC_HasCachedEmitter();
	bool STATIC_HasCachedHexaFireGuns();
	bool STATIC_HasCachedRuckusInhand();
	bool STATIC_CanSpawnScalableShields();
	bool STATIC_InstanceArmMaterials();
	bool STATIC_InstanceBodyMaterials();
	bool STATIC_IsNearAnyObjective();
	void STATIC_UpdateSkinBlueChannel();
	bool STATIC_Is1PWeaponOverlay(TEnumAsByte<EOverlayMICType> Type);
	bool STATIC_Is1PBodyOverlay(TEnumAsByte<EOverlayMICType> Type);
	void PawnOnDamaged(struct FOnDamagedParams* Params);
};


// Class TgGame.TgProj_HexaFireRocket
// 0x0000 (0x052C - 0x052C)
class ATgProj_HexaFireRocket : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_HexaFireRocket");
		return ptr;
	}


	void ClearPersistTimers();
};


// Class TgGame.TgDeploy_Molotov
// 0x00AC (0x1B34 - 0x1A88)
class ATgDeploy_Molotov : public ATgDeploy_EffectSpots
{
public:
	TArray<struct FMolotovPointInfo>                   m_PointInfos;                                             // 0x1A88(0x0010) (NeedCtorLink)
	struct FMolotovCenterInfo                          m_CenterInfo;                                             // 0x1A98(0x0048)
	TArray<struct FMolotovTriangleInfo>                m_TriInfos;                                               // 0x1AE0(0x0010) (NeedCtorLink)
	TArray<struct FMolotovStrandInfo>                  m_StrandInfos;                                            // 0x1AF0(0x0010) (NeedCtorLink)
	struct FMolotovGrowthInfo                          m_GrowthInfo;                                             // 0x1B00(0x001C)
	struct FMolotovGeneralSettings                     m_Settings;                                               // 0x1B1C(0x0018)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Molotov");
		return ptr;
	}


	void DestroyIt(bool bSkipFx);
	void STATIC_UpdateParticleParams(int spotIndex);
	bool SpawnStrandFromCenter(int region);
	void SpawnInitialStrands();
	void SpawnInitialCenter();
	void DeployComplete();
	void SetPointIntensity(int PointIndex, int nIntensityLevel);
	int AddNewPoint(const struct FVector& vLocation, const struct FRotator& rRotation, bool bAddEffectSpot, bool bSkipEligibilityCheck);
	struct FRotator AlignSpotByRotation(const struct FVector& HitNormal, const struct FRotator& rRotation);
	void SetMomentumDirection(const struct FVector& projVelocity, const struct FVector& HitNormal);
	void STATIC_UpdateAllRanks();
	void STATIC_LinkNeighbors(int triIndex);
	int SpawnFromTriangle(int triIndex, int neighborNum);
	struct FVector STATIC_GetNewSpotLocation(int index1, int index2);
	void SpawnFromCenter();
	bool STATIC_IsSaturated(int triIndex);
	void SpawnFromPeripheral();
	void SpawnFromStrand(int strandNum);
	void PushStrandToTip(int strandNum);
	float STATIC_GetStrandSpreadWeight(int strandNum, int neighborNum);
	bool STATIC_IsInStrand(int triIndex, int strandIndex);
	void STATIC_UpdateStrandAllowances();
	float CalcHeatLevel(int triIndex);
	void STATIC_UpdateHeatLevels();
	void CompleteSaturationLevel5Points();
	void Tick(float DeltaSeconds);
	bool CheckItemShopVolumeFailure(const struct FVector& TestLocation);
	void RemoveEffects(class AActor* Target);
	struct FMolotovEligibilityRecord STATIC_GetSpawnEligibility(const struct FVector& StartLocation, float Radius, float Height);
};


// Class TgGame.TgDevice_HuntersMark
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_HuntersMark : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_HuntersMark");
		return ptr;
	}


	struct FImpactInfo CalcWeaponFire(const struct FAimData& Aim, TArray<struct FImpactInfo>* ImpactList);
	struct FAimData STATIC_ValidateReceivedAim(float ClientMovementTimeStamp, const struct FAimData& Aim);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
	float STATIC_GetConePullbackDistance();
};


// Class TgGame.TgDevice_TyraUlt
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_TyraUlt : public ATgDevice_Stim
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_TyraUlt");
		return ptr;
	}


	void TransitionOut();
	bool CanBeCanceled();
};


// Class TgGame.TgDevice_TyraInhand
// 0x0004 (0x0A10 - 0x0A0C)
class ATgDevice_TyraInhand : public ATgDevice
{
public:
	unsigned long                                      m_bUltIsActive : 1;                                       // 0x0A0C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_TyraInhand");
		return ptr;
	}


	class UTgGameplayCurvesSet_RecoilSimple* STATIC_GetRecoilCurve();
	void SetAmmo(int AmmoCount, int ClipSize, bool bShouldValidate, int ValidationIDOverride);
	bool ShouldShowAmmoCount();
	bool RequiresAmmoToFire();
	bool CheckAutoReload();
};


// Class TgGame.TgPawn_Tyra
// 0x0018 (0x32F0 - 0x32D8)
class ATgPawn_Tyra : public ATgPawn_Character
{
public:
	class ATgDevice_HuntersMark*                       m_HuntersMarkDevice;                                      // 0x32D8(0x0008)
	TArray<class ATgPawn*>                             m_HuntersMarkTargets;                                     // 0x32E0(0x0010) (AlwaysInit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Tyra");
		return ptr;
	}


	void STATIC_EffectGroupOnSetActive(bool bActive, bool bRemoving, class UTgEffectGroup* effectGroup);
};


// Class TgGame.TgProj_Molotov
// 0x0000 (0x0580 - 0x0580)
class ATgProj_Molotov : public ATgProj_FreeGrenade
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Molotov");
		return ptr;
	}


	class ATgDeployable* SpawnDeployable(const struct FVector& vLocation, class AActor* TargetActor, const struct FVector& vNormal);
};


// Class TgGame.TgDeploy_ToxicTimeBomb
// 0x0000 (0x0484 - 0x0484)
class ATgDeploy_ToxicTimeBomb : public ATgDeploy_Bomb
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_ToxicTimeBomb");
		return ptr;
	}


	void DestroyIt(bool bSkipFx);
};


// Class TgGame.TgDeploy_SmokeScreen
// 0x0010 (0x04C0 - 0x04B0)
class ATgDeploy_SmokeScreen : public ATgDeploy_EffectAura
{
public:
	class ATgPawn*                                     m_CachedPawnOwner;                                        // 0x04B0(0x0008)
	unsigned long                                      m_bHasAppliedOwnerStealth : 1;                            // 0x04B8(0x0004)
	float                                              r_fRadiusForFX;                                           // 0x04BC(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_SmokeScreen");
		return ptr;
	}


	void ScaleFX();
	void ReplicatedEvent(const struct FName& VarName);
	void RemoveEffects(class AActor* Target);
	void ApplyEffects(class AActor* Target);
};


// Class TgGame.TgDevice_EmergencyExit
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_EmergencyExit : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_EmergencyExit");
		return ptr;
	}


	bool StartFire();
};


// Class TgGame.TgDevice_SkyeInhand
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_SkyeInhand : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_SkyeInhand");
		return ptr;
	}

};


// Class TgGame.TgDevice_SmokeScreen
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_SmokeScreen : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_SmokeScreen");
		return ptr;
	}


	bool ShouldInterruptStealth();
};


// Class TgGame.TgDevice_Stealth
// 0x0004 (0x0A10 - 0x0A0C)
class ATgDevice_Stealth : public ATgDevice
{
public:
	unsigned long                                      m_bIsInCombat : 1;                                        // 0x0A0C(0x0004)
	unsigned long                                      m_bCanFireInCombat : 1;                                   // 0x0A0C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Stealth");
		return ptr;
	}


	bool ShouldMountCancelFiring();
	bool ShouldInterruptMount();
	bool ShouldCancelStealth();
	bool CanBeCanceled();
	bool StartFire();
	bool CanBeInterrupted();
	bool ShouldInterruptReloadOnFire();
	float STATIC_GetFiringPostHitDelay(int nMode);
	bool STATIC_NativeCanBeCanceled();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	bool CanFireWhileMounted();
	bool ShouldInterruptStealth();
};


// Class TgGame.TgPawn_Skye
// 0x0000 (0x32D8 - 0x32D8)
class ATgPawn_Skye : public ATgPawn_Character
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Skye");
		return ptr;
	}


	void ApplyStealthClient();
	float STATIC_GetDamageToLeaveStealth();
	void STATIC_UpdateStealthBoltMaterial();
};


// Class TgGame.TgDeploy_Barrage
// 0x0010 (0x047C - 0x046C)
class ATgDeploy_Barrage : public ATgDeployable
{
public:
	class UTgCameraShake*                              m_CameraShake;                                            // 0x046C(0x0008)
	float                                              m_fAllowableGroundTraceDist;                              // 0x0474(0x0004)
	unsigned long                                      m_bShouldAirBurst : 1;                                    // 0x0478(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Barrage");
		return ptr;
	}


	void PlayFireFx();
	void TriggerHitFX();
	void AdjustMeshToGround();
};


// Class TgGame.TgDevice_Barrage
// 0x0010 (0x0A1C - 0x0A0C)
class ATgDevice_Barrage : public ATgDevice
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_MoveSpeedMultiplier;           // 0x0A0C(0x0008) (Const, Native, NoExport)
	class ATgDevice_BarrageFire*                       m_BarrageFireDevice;                                      // 0x0A14(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Barrage");
		return ptr;
	}


	void LinkedDeviceEquipped(class ATgDevice* Dev);
	void STATIC_LastShotCancelTimer();
	bool CanBeInterrupted();
	bool ShouldInterruptReloadOnFire();
	bool CanFireIfLeftMouseDown();
	bool ShouldConsumePowerPoolOnStartFire();
	void CustomFire();
	bool CanBeCanceled();
	float STATIC_GetLockoutExtensionTime();
	bool STATIC_IsToggleDevice();
	bool CanBeSilenced();
	void ExitTargetingMode();
	void TickTargetingMode(float DeltaSeconds);
	bool STATIC_UsesTargetingMode();
	bool STATIC_ShouldUseGradualMovement();
	float STATIC_GetMoveSpeedMultiplier();
};


// Class TgGame.TgDevice_BarrageFire
// 0x000C (0x0A18 - 0x0A0C)
class ATgDevice_BarrageFire : public ATgDevice
{
public:
	int                                                m_nChainedBarrageNum;                                     // 0x0A0C(0x0004)
	class ATgDevice_Barrage*                           m_BarrageDevice;                                          // 0x0A10(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_BarrageFire");
		return ptr;
	}


	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
	void STATIC_HandleDeviceFormStartFire(int nDeviceModeNum, float fRefireTime, struct FAimData* Aim);
	void CustomFire();
	bool ShouldConsumePowerPoolAfterFire();
	bool ShouldConsumePowerPoolOnStartFire();
	bool STATIC_InterceptLeftMouseReleased(class ATgPlayerController* TgController);
	bool STATIC_InterceptLeftMousePressed(class ATgPlayerController* TgController);
	void ResetBarrage();
	float STATIC_GetCurrentShotCost();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	struct FAimData STATIC_ValidateReceivedAim(float ClientMovementTimeStamp, const struct FAimData& Aim);
	float STATIC_GetConePullbackDistance();
	void STATIC_GetTargetingAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_FragGrenade
// 0x000C (0x0A18 - 0x0A0C)
class ATgDevice_FragGrenade : public ATgDevice
{
public:
	class ATgPawn_Viktor*                              m_CachedViktor;                                           // 0x0A0C(0x0008)
	unsigned long                                      m_bEndCook : 1;                                           // 0x0A14(0x0004)
	unsigned long                                      m_bThrownGrenade : 1;                                     // 0x0A14(0x0004)
	unsigned long                                      s_bCanPickUpNuggetRefills : 1;                            // 0x0A14(0x0004)
	unsigned long                                      s_bFullCook : 1;                                          // 0x0A14(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_FragGrenade");
		return ptr;
	}


	bool ShouldCooldownAfterFire();
	bool CanBeCanceled();
	bool CanBeInterrupted();
	void ClientInterrupt(bool bServerFireFailed);
	void InterruptFiring(bool bServerFireFailed);
	bool STATIC_HasCachedViktor();
	void ServerEndCook(float fCookPct);
	void SetAndSendGrenadeTimingsViaStartThrowTimer();
	bool STATIC_InterceptSlotReleased(class ATgPlayerController* TgController);
	void SetGrenadeCookTime(float fCookAmt, bool bSendToServer);
	void StartThrow();
	void StartThrowValidation();
	void CooldownTimerExpired(int nTimerId, TEnumAsByte<ETGT_EVENT> eEvent, bool bNoBecomeActive);
	void STATIC_FireAmmunition();
	void STATIC_DropGrenade();
	void SetThrowSpeedMultiplier(float Mult);
	bool RequiresAmmoToFire();
};


// Class TgGame.TgDevice_Hustle
// 0x0018 (0x0A24 - 0x0A0C)
class ATgDevice_Hustle : public ATgDevice
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_MoveSpeedMultiplier;           // 0x0A0C(0x0008) (Const, Native, NoExport)
	float                                              m_fMinSprintSpeedSq;                                      // 0x0A14(0x0004) (Edit)
	float                                              m_fAllowableSprintAngle;                                  // 0x0A18(0x0004) (Edit)
	float                                              m_fSprintFailSafetyTime;                                  // 0x0A1C(0x0004) (Edit)
	float                                              m_fSprintFailTimeAccumulator;                             // 0x0A20(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Hustle");
		return ptr;
	}


	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
	void CompleteInterrupt();
	void CancelSafetyTimer();
	void FiringEndTransition();
	bool CanSprint();
	bool ShouldInterruptReloadOnFire();
	bool STATIC_InterceptSlotReleased(class ATgPlayerController* TgController);
	bool CanFiringBeCanceledByReactivation();
	void OnCripple();
	bool CanBeInterrupted();
	bool CanBeCanceled();
	bool ShouldInterruptLift();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	bool STATIC_IsDeviceFiringLockedForUI();
	bool STATIC_ShouldUseGradualMovement();
	float STATIC_GetMoveSpeedMultiplier();
	bool ShouldBlockReload(class ATgDevice* Dev, bool bIsAutoReload);
};


// Class TgGame.TgDevice_Scramble
// 0x0014 (0x0A20 - 0x0A0C)
class ATgDevice_Scramble : public ATgDevice
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_MoveSpeedMultiplier;           // 0x0A0C(0x0008) (Const, Native, NoExport)
	class ATgDevice_Hustle*                            m_CachedHustleDevice;                                     // 0x0A14(0x0008)
	float                                              m_fSprintEndTimestamp;                                    // 0x0A1C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Scramble");
		return ptr;
	}


	void LinkedDeviceEquipped(class ATgDevice* Dev);
	void CheckStartSprintBoost();
	void ClientStartSpeedBoost();
	bool STATIC_ShouldUseGradualMovement();
	float STATIC_GetMoveSpeedMultiplier();
};


// Class TgGame.TgDevice_SecondWind
// 0x0014 (0x0A20 - 0x0A0C)
class ATgDevice_SecondWind : public ATgDevice
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_MoveSpeedMultiplier;           // 0x0A0C(0x0008) (Const, Native, NoExport)
	class ATgDevice_Hustle*                            m_CachedHustleDevice;                                     // 0x0A14(0x0008)
	float                                              m_fSprintEndTimestamp;                                    // 0x0A1C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_SecondWind");
		return ptr;
	}


	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
	void CheckStartSprintBoost();
	bool STATIC_ShouldUseGradualMovement();
	float STATIC_GetMoveSpeedMultiplier();
};


// Class TgGame.TgDevice_IronSights
// 0x0010 (0x0A34 - 0x0A24)
class ATgDevice_IronSights : public ATgDevice_ToggleADS
{
public:
	class ATgDevice_ViktorInhand*                      m_CachedViktorInhand;                                     // 0x0A24(0x0008)
	class ATgDevice_Hustle*                            m_CachedHustleDevice;                                     // 0x0A2C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_IronSights");
		return ptr;
	}


	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	bool ShouldAltFireOnTick();
};


// Class TgGame.TgDevice_ViktorInhand
// 0x001C (0x0A28 - 0x0A0C)
class ATgDevice_ViktorInhand : public ATgDevice
{
public:
	unsigned long                                      m_bIsADS : 1;                                             // 0x0A0C(0x0004)
	struct FVector                                     m_vADSProjectileSpawnOffset;                              // 0x0A10(0x000C) (Edit)
	float                                              m_fADSRecoilMultiplier;                                   // 0x0A1C(0x0004) (Edit)
	class ATgPawn_Character*                           m_CachedPawnOwner;                                        // 0x0A20(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ViktorInhand");
		return ptr;
	}


	void STATIC_HandleDeviceFormStartFire(int nDeviceModeNum, float fRefireTime, struct FAimData* Aim);
	float STATIC_GetMinAccuracy();
	float STATIC_GetRecoilMultiplier();
	class UTgGameplayCurvesSet_RecoilSimple* STATIC_GetRecoilCurve();
	bool STATIC_HasCachedCharacter();
	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
	void STATIC_EndADSBonuses();
	void StartADSBonuses();
	void ShowReticle(bool bShow);
	void SetAmmo(int AmmoCount, int ClipSize, bool bShouldValidate, int ValidationIDOverride);
	struct FVector GetProjectileSpawnOffset();
	bool ShouldForce1P(class UTgDeviceForm* DeviceForm, bool bOnlyCheckDeviceForm);
};


// Class TgGame.TgDeviceForm_BarrageFire
// 0x0020 (0x02AC - 0x028C)
class UTgDeviceForm_BarrageFire : public UTgDeviceForm
{
public:
	class AActor*                                      m_LastTargetedActor;                                      // 0x028C(0x0008)
	class ATgPlayerController*                         m_CachedActiveOverlayController;                          // 0x0294(0x0008)
	float                                              m_fIncomingTime;                                          // 0x029C(0x0004)
	int                                                m_nActiveShotNum;                                         // 0x02A0(0x0004)
	float                                              m_fIncomingTimeCurrentShot;                               // 0x02A4(0x0004)
	float                                              m_fRemainingDurationPct;                                  // 0x02A8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_BarrageFire");
		return ptr;
	}


	bool STATIC_UsesTargetingMode();
	void STATIC_UpdateBinocularSettings();
	void ExitTargetingMode();
	void EnterTargetingMode();
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
};


// Class TgGame.TgInvListener_Firefight
// 0x0000 (0x00C4 - 0x00C4)
class UTgInvListener_Firefight : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_Firefight");
		return ptr;
	}

};


// Class TgGame.TgInvListener_Gunnery
// 0x0000 (0x00C4 - 0x00C4)
class UTgInvListener_Gunnery : public UTgInvListener_Firefight
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_Gunnery");
		return ptr;
	}

};


// Class TgGame.TgPawn_Viktor
// 0x0048 (0x3320 - 0x32D8)
class ATgPawn_Viktor : public ATgPawn_Character
{
public:
	float                                              r_fFragGrenadeExplodeTime;                                // 0x32D8(0x0004) (Net)
	unsigned long                                      r_bFragGrenadeExplodeOnTouch : 1;                         // 0x32DC(0x0004) (Net)
	float                                              m_fBounceDampingVertMin;                                  // 0x32E0(0x0004) (Edit)
	float                                              m_fBounceDampingVertMax;                                  // 0x32E4(0x0004) (Edit)
	float                                              m_fBounceDampingHorizMin;                                 // 0x32E8(0x0004) (Edit)
	float                                              m_fBounceDampingHorizMax;                                 // 0x32EC(0x0004) (Edit)
	unsigned char                                      r_nGrenadeRefreshSound;                                   // 0x32F0(0x0001) (Net)
	unsigned char                                      r_nAmmoRefreshSound;                                      // 0x32F1(0x0001) (Net)
	unsigned char                                      UnknownData00[0x2];                                       // 0x32F2(0x0002) MISSED OFFSET
	class ATgDevice_Hustle*                            m_CachedHustleDevice;                                     // 0x32F4(0x0008)
	struct FVector                                     c_vForced3pAdditionalOffsetADS;                           // 0x32FC(0x000C) (Config)
	float                                              m_fUnderheadADSDistanceClampAngle;                        // 0x3308(0x0004) (Config)
	float                                              m_fUnderheadADSDistanceClampPushIn;                       // 0x330C(0x0004) (Config)
	float                                              m_fUnderheadADSDistanceClampOvershoot;                    // 0x3310(0x0004) (Config)
	float                                              m_fOverheadADSDistanceClampAngle;                         // 0x3314(0x0004) (Config)
	float                                              m_fOverheadADSDistanceClampPushIn;                        // 0x3318(0x0004) (Config)
	float                                              m_fOverheadADSDistanceClampOvershoot;                     // 0x331C(0x0004) (Config)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Viktor");
		return ptr;
	}


	float STATIC_GetCameraPenetrationCheckRadius();
	struct FVector STATIC_GetCameraOffsetOverride(const struct FVector& originalOffset, TEnumAsByte<ECameraPerspectiveType> ePerspectiveType);
	struct FVector STATIC_GetCameraOriginOverride(const struct FVector& originalOrigin, TEnumAsByte<ECameraPerspectiveType> ePerspectiveType);
	TEnumAsByte<ETG_EQUIP_POINT> STATIC_GetPerCharacterAltEquipPoint();
	void PlayLocalPawnFX(const struct FName& nmDisplayGroup);
	void ReplicatedEvent(const struct FName& VarName);
	void SetTargetingDevice(class ATgDevice* Dev, const struct FWeaponMeshSwapStrategy& SwapStrategy);
	bool StartAction(class ATgDevice* Dev, bool bUpdateTimeStamp, TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgPawn_Stoker
// 0x0034 (0x3354 - 0x3320)
class ATgPawn_Stoker : public ATgPawn_Viktor
{
public:
	struct FVector                                     m_vCurrentWallRunNormal;                                  // 0x3320(0x000C)
	unsigned long                                      m_bIsWallRunning : 1;                                     // 0x332C(0x0004)
	unsigned long                                      r_bWantsWallRun : 1;                                      // 0x332C(0x0004)
	unsigned long                                      m_bHasDoubleJumped : 1;                                   // 0x332C(0x0004)
	float                                              m_fWallMagnetMovePerSec;                                  // 0x3330(0x0004) (Edit)
	float                                              m_fWallRunStickinessDuration;                             // 0x3334(0x0004) (Edit)
	float                                              m_fWallRunStickinessTimer;                                // 0x3338(0x0004)
	float                                              m_fWallRunLockoutJumpDuration;                            // 0x333C(0x0004) (Edit)
	float                                              m_fWallRunLockoutJumpTimer;                               // 0x3340(0x0004)
	float                                              m_fWallJumpZSpeed;                                        // 0x3344(0x0004) (Edit)
	float                                              m_fDoubleJumpZSpeed;                                      // 0x3348(0x0004) (Edit)
	float                                              m_fNewWallAllowableRunAngle;                              // 0x334C(0x0004) (Edit)
	float                                              m_fWallRunTime;                                           // 0x3350(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Stoker");
		return ptr;
	}


	void Tick(float DeltaSeconds);
	bool CannotJumpNow();
	bool DoJump(bool bUpdating, float JumpZSpeed);
	float GetGravityZ();
};


// Class TgGame.TgProj_FragGrenade
// 0x0000 (0x0580 - 0x0580)
class ATgProj_FragGrenade : public ATgProj_FreeGrenade
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_FragGrenade");
		return ptr;
	}


	void PlayBounceSound();
	void ApplyBounce(const struct FVector& HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp);
	void SetCookedInfo();
	void PostBeginPlay();
};


// Class TgGame.TgDeploy_DreadSerpent
// 0x0008 (0x04A8 - 0x04A0)
class ATgDeploy_DreadSerpent : public ATgDeploy_EffectField
{
public:
	float                                              m_fReCheckProxyTouchHit;                                  // 0x04A0(0x0004)
	float                                              m_fReCheckProxyTouchHitInterval;                          // 0x04A4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_DreadSerpent");
		return ptr;
	}


	bool STATIC_CheckQuadrant(class AActor* Target, int Quadrant);
	bool STATIC_CheckAltHorizontalLocation(const struct FVector& StartingLocation, const struct FVector& AltOrigin);
	bool STATIC_FindTargetQuadrant(class AActor* Target);
	struct FVector STATIC_CheckAltZLocation(float MaxHeight, float Sign);
	bool STATIC_CheckBlockingWithGrace(class AActor* Other);
	void ProxyTouchHit(class AActor* Other);
};


// Class TgGame.TgDeploy_Gourd
// 0x0000 (0x04A0 - 0x04A0)
class ATgDeploy_Gourd : public ATgDeploy_EffectField
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Gourd");
		return ptr;
	}


	void OnProxyUnTouch(class AActor* Other);
	void OnProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgDevice_DreadSerpent
// 0x0004 (0x0A10 - 0x0A0C)
class ATgDevice_DreadSerpent : public ATgDevice
{
public:
	unsigned long                                      s_bQueueVoodooDeploy : 1;                                 // 0x0A0C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DreadSerpent");
		return ptr;
	}


	bool STATIC_InterceptSlotPressed(class ATgPlayerController* TgController);
	bool STATIC_InterceptLeftMousePressed(class ATgPlayerController* TgController);
	void ClientInterrupt(bool bServerFireFailed);
	void InterruptFiring(bool bServerFireFailed);
	void ServerDeployVoodoo();
	void STATIC_UpdateActiveProjectiles(class ATgProjectile* Proj);
	bool TryDeployVoodoo();
	float STATIC_GetLockoutExtensionTime();
};


// Class TgGame.TgDevice_GourdMod
// 0x0020 (0x0A2C - 0x0A0C)
class ATgDevice_GourdMod : public ATgDevice
{
public:
	TArray<class AActor*>                              m_ImmuneTargets;                                          // 0x0A0C(0x0010) (NeedCtorLink)
	TArray<float>                                      m_ImmuneTimes;                                            // 0x0A1C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_GourdMod");
		return ptr;
	}


	void RemoveEffect(class ATgDeploy_Gourd* gourd, class AActor* Target);
	void ApplyEffect(class ATgDeploy_Gourd* gourd, class AActor* Target);
	void ApplyOnTouchEffect(class AActor* Target);
};


// Class TgGame.TgDevice_MalDambaInhand
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_MalDambaInhand : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_MalDambaInhand");
		return ptr;
	}


	void PreReloadTimer();
};


// Class TgGame.TgDevice_SnakeToss
// 0x000C (0x0A18 - 0x0A0C)
class ATgDevice_SnakeToss : public ATgDevice
{
public:
	int                                                r_nAmmoCharge;                                            // 0x0A0C(0x0004) (Net)
	class ATgDevice_MalDambaInhand*                    m_CachedInhand;                                           // 0x0A10(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_SnakeToss");
		return ptr;
	}


	void LinkedDeviceEquipped(class ATgDevice* Dev);
	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void STATIC_UseNow();
	void STATIC_UpdateAmmoCharge();
	bool ShouldInterruptReloadOnFire();
};


// Class TgGame.TgDeviceFire_SnakeToss
// 0x0010 (0x0278 - 0x0268)
class UTgDeviceFire_SnakeToss : public UTgDeviceFire
{
public:
	TArray<struct FRecentStunnedTarget>                m_RecentStunnedTargets;                                   // 0x0268(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_SnakeToss");
		return ptr;
	}


	bool ApplyHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
};


// Class TgGame.TgInvListener_SpiritsChosen
// 0x0000 (0x00E0 - 0x00E0)
class UTgInvListener_SpiritsChosen : public UTgInventoryObject_Listen_MendingSpiritsActive
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_SpiritsChosen");
		return ptr;
	}

};


// Class TgGame.TgPawn_MalDamba
// 0x0008 (0x32E0 - 0x32D8)
class ATgPawn_MalDamba : public ATgPawn_Character
{
public:
	class UTgDeviceFire_SnakeToss*                     m_CachedSnakeTossDeviceFire;                              // 0x32D8(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_MalDamba");
		return ptr;
	}

};


// Class TgGame.TgDeploy_Illusion
// 0x0060 (0x04CC - 0x046C)
class ATgDeploy_Illusion : public ATgDeployable
{
public:
	struct FPointer                                    VfTable_ITgInterface_YingIllusion;                        // 0x046C(0x0008) (Const, Native, NoExport)
	float                                              r_fShatterDelay;                                          // 0x0474(0x0004) (Net)
	int                                                m_nShatterDeviceID;                                       // 0x0478(0x0004) (Const)
	class UTgDeviceFire_ShatterExplosion*              m_ShatterFiremode;                                        // 0x047C(0x0008)
	int                                                s_nNumBeamHits;                                           // 0x0484(0x0004)
	struct FVector                                     s_BeamAimDir;                                             // 0x0488(0x000C)
	class AActor*                                      s_BeamTargetActor;                                        // 0x0494(0x0008)
	struct FVector                                     r_BeamTargetPos;                                          // 0x049C(0x000C) (Net)
	unsigned char                                      r_nPlayShatterFX;                                         // 0x04A8(0x0001) (Net)
	unsigned char                                      UnknownData00[0x3];                                       // 0x04A9(0x0003) MISSED OFFSET
	TArray<struct FScriptDelegate>                     s_OnDestroyDelegates;                                     // 0x04AC(0x0010) (NeedCtorLink)
	struct FScriptDelegate                             __DestroyedEvent__Delegate;                               // 0x04BC(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData01[0x4];                                       // 0x04BC(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Illusion");
		return ptr;
	}


	class ATgPawn_Ying* STATIC_GetOwningYing();
	void PlayDimensionalLinkFX();
	bool STATIC_IsNotDestroyed();
	class AActor* STATIC_GetActorFromInterface();
	void AddOnDestroyDelegate(const struct FScriptDelegate& delDestroy);
	void PlayShatterFX();
	void Shatter();
	void TriggerShatter(float fDelay);
	void DestroyIt(bool bPlayShatter);
	void ReplicatedEvent(const struct FName& VarName);
	void BeamUpdatePSC();
	void BeamUpdateFireFXTarget();
	void STATIC_FireShatterDevice();
	void TakeDamage(int Damage, class AController* EventInstigator, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void ClearBeamTarget();
	void BeamFireAtTarget();
	void StartBeamFire();
	bool AcquireTarget();
	void TryBeamFire();
	void DestroyedEvent(class AActor* destroyedActor);
};


// Class TgGame.TgDevice_DimensionalLink
// 0x0390 (0x0D9C - 0x0A0C)
class ATgDevice_DimensionalLink : public ATgDevice
{
public:
	class ATgPawn_Ying*                                m_CachedYingPawn;                                         // 0x0A0C(0x0008)
	class AActor*                                      s_CycleTargets[0xA];                                      // 0x0A14(0x0008)
	int                                                s_nNumCycleTargets;                                       // 0x0A64(0x0004)
	int                                                s_nCurrentCycleTargetIndex;                               // 0x0A68(0x0004)
	TArray<struct FDLTeleportTargets>                  m_TeleportTargets;                                        // 0x0A6C(0x0010) (NeedCtorLink)
	TArray<struct FDLDeadTeleportTargets>              m_DeadTeleportTargets;                                    // 0x0A7C(0x0010) (NeedCtorLink)
	struct FDLRewindTargets                            m_RewindTargets[0x1E];                                    // 0x0A8C(0x0018)
	int                                                m_CurrentRewindIndex;                                     // 0x0D5C(0x0004)
	int                                                m_ValidRewindIndex1;                                      // 0x0D60(0x0004)
	int                                                m_ValidRewindIndex2;                                      // 0x0D64(0x0004)
	int                                                m_nNumPrevRewindsToCheck;                                 // 0x0D68(0x0004)
	float                                              m_fRewindMinTargetDist;                                   // 0x0D6C(0x0004)
	float                                              m_fRewindMinNextPointDist;                                // 0x0D70(0x0004)
	float                                              m_fLastRewindTimestamp;                                   // 0x0D74(0x0004)
	unsigned long                                      m_bRequiresReset : 1;                                     // 0x0D78(0x0004)
	unsigned long                                      m_bSwappingPeriodEnded : 1;                               // 0x0D78(0x0004)
	class AActor*                                      r_nCurrentCycleTarget;                                    // 0x0D7C(0x0008) (Net)
	class ATgDevice_Rewind*                            m_CachedCardRewind;                                       // 0x0D84(0x0008)
	struct FScriptDelegate                             __PawnEvent__Delegate;                                    // 0x0D8C(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData00[0x4];                                       // 0x0D8C(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DimensionalLink");
		return ptr;
	}


	void LinkedDeviceEquipped(class ATgDevice* Dev);
	void ClientSetRequiresReset();
	void SetRequiresReset();
	void STATIC_IsFullyReset();
	void STATIC_EndSwappingPeriod();
	void STATIC_IllusionDied(class AActor* illusion);
	void PawnEvent(class ATgPawn* DeadPawn);
	bool ShouldCooldownAfterFire();
	void STATIC_FireAmmunition();
	void STATIC_GenerateCycleTargets();
	class AActor* CreateTeleportTargetDeployable(const struct FVector& TargetLocation, const struct FRotator& TargetRotation);
	bool STATIC_HasCachedYingPawn();
	bool STATIC_UsesCachedAim();
	void STATIC_GetTargetingAim(struct FAimData* Aim);
	bool STATIC_IsTargetingModeReady(TEnumAsByte<EDeviceFailType>* failType);
	void TickTargetingMode(float DeltaSeconds);
	struct FAimData STATIC_ValidateReceivedAim(float ClientMovementTimeStamp, const struct FAimData& Aim);
};


// Class TgGame.TgDevice_IllusoryRift
// 0x0004 (0x0A10 - 0x0A0C)
class ATgDevice_IllusoryRift : public ATgDevice
{
public:
	unsigned long                                      m_bDeviceLockout : 1;                                     // 0x0A0C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_IllusoryRift");
		return ptr;
	}


	void STATIC_EndDeviceLockout();
	void STATIC_FireAmmunition();
	void ApplyHealingToAllies();
};


// Class TgGame.TgDevice_Lifelike
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_Lifelike : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Lifelike");
		return ptr;
	}

};


// Class TgGame.TgDevice_Illusion
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_Illusion : public ATgDevice_Pet
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Illusion");
		return ptr;
	}


	void CustomFire();
	class ATgPawn* SpawnIllusionAtLocation(const struct FVector& pos, const struct FRotator& Rot);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_Shatter
// 0x000C (0x0A18 - 0x0A0C)
class ATgDevice_Shatter : public ATgDevice
{
public:
	class ATgPawn_Ying*                                m_CachedYingPawn;                                         // 0x0A0C(0x0008)
	int                                                m_nIllusionsShattered;                                    // 0x0A14(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Shatter");
		return ptr;
	}


	bool STATIC_HasYingPawn();
	void CustomFire();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgDevice_YingInhand
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_YingInhand : public ATgDevice
{
public:
	class ATgPawn_Ying*                                m_CachedYingPawn;                                         // 0x0A0C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_YingInhand");
		return ptr;
	}


	void STATIC_HandleClientReportedInstantShot(int nFireRequestId, const struct FAimData& InServerAim, const struct FAimData& InClientAim, const struct FImpactToValidate& InPrimaryImpact, TArray<struct FImpactToValidate> InClientImpacts);
	void STATIC_UpdateInhandTargetInfo(class AActor* HitActor, const struct FVector& HitLocation);
	void OnInstantShotVerified(const struct FImpactInfo& VerifiedPrimaryImpact);
	struct FImpactInfo CalcWeaponFire(const struct FAimData& Aim, TArray<struct FImpactInfo>* ImpactList);
	bool STATIC_HasCachedYingPawn();
	bool ShouldCooldownAfterFire();
	bool CanBeInterrupted();
	bool CanBeCanceled();
};


// Class TgGame.TgDeviceFire_DimensionalLink
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_DimensionalLink : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_DimensionalLink");
		return ptr;
	}


	void TeleportFire();
	bool CanSimulateTeleportFire();
};


// Class TgGame.TgDeviceFire_Illusion
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_Illusion : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Illusion");
		return ptr;
	}


	void CustomFire();
};


// Class TgGame.TgDeviceFire_IllusoryRift
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_IllusoryRift : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_IllusoryRift");
		return ptr;
	}


	void CustomFire();
};


// Class TgGame.TgDeviceFire_ShatterHeal
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_ShatterHeal : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_ShatterHeal");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_ShatterExplosion
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_ShatterExplosion : public UTgDeviceFire_WorldLOSOnly
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_ShatterExplosion");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_YingIllusionInhand
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_YingIllusionInhand : public UTgDeviceFire_WorldLOSOnly
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_YingIllusionInhand");
		return ptr;
	}

};


// Class TgGame.TgPawn_Ying
// 0x003C (0x3314 - 0x32D8)
class ATgPawn_Ying : public ATgPawn_Character
{
public:
	class AActor*                                      r_InhandTarget;                                           // 0x32D8(0x0008) (Net)
	struct FVector                                     r_InhandHitOffset;                                        // 0x32E0(0x000C) (Net)
	class ATgPawn_Character*                           m_TeleportTarget;                                         // 0x32EC(0x0008)
	unsigned long                                      m_bRetrievedIllusionListThisTick : 1;                     // 0x32F4(0x0004)
	unsigned long                                      m_bHasShatterableIllusionsThisTick : 1;                   // 0x32F4(0x0004)
	unsigned long                                      r_bHasCompensate : 1;                                     // 0x32F4(0x0004) (Net)
	unsigned long                                      m_bPulledTargetFromList : 1;                              // 0x32F4(0x0004)
	TArray<TScriptInterface<class UTgInterface_YingIllusion>> m_ActiveIllusions;                                        // 0x32F8(0x0010) (NeedCtorLink)
	float                                              m_fFrictionMultiplier;                                    // 0x3308(0x0004) (Edit)
	float                                              m_fGravityMultiplier;                                     // 0x330C(0x0004) (Edit)
	float                                              m_fMaxFallSpeed;                                          // 0x3310(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Ying");
		return ptr;
	}


	void ClearDimensionalLink();
	bool Died(class AController* Killer, class UClass* dmgType, const struct FVector& HitLocation);
	bool OnLiveRespawn();
	void KillAllOwnedPets(bool bGameModeSource);
	bool PopulateActiveDecoyList(unsigned char* bHasShatterableIllusions);
	float GetGravityZ();
};


// Class TgGame.TgPawn_Illusion
// 0x0088 (0x339C - 0x3314)
class ATgPawn_Illusion : public ATgPawn_Ying
{
public:
	struct FPointer                                    VfTable_ITgInterface_YingIllusion;                        // 0x3314(0x0008) (Const, Native, NoExport)
	TEnumAsByte<EDecoyAIState>                         m_eAIState;                                               // 0x331C(0x0001)
	TEnumAsByte<EINITIALIZEABLE_BOOL>                  r_eLifelike;                                              // 0x331D(0x0001) (Net)
	unsigned char                                      UnknownData00[0x2];                                       // 0x331E(0x0002) MISSED OFFSET
	float                                              m_fDamageScale;                                           // 0x3320(0x0004)
	float                                              m_fDamageAccumulator;                                     // 0x3324(0x0004)
	float                                              m_fDamageAccumulatorReductionRatePerSec;                  // 0x3328(0x0004)
	float                                              m_fFlickerDamageMin;                                      // 0x332C(0x0004)
	float                                              m_fFlickerDamageMax;                                      // 0x3330(0x0004)
	float                                              m_fDamageAccumulatorCap;                                  // 0x3334(0x0004)
	float                                              m_fPrevFrameHealth;                                       // 0x3338(0x0004)
	float                                              m_fTimedDestroyedFXDuration;                              // 0x333C(0x0004) (Const)
	float                                              m_fTimedDestroyedFXMeshHiddenTime;                        // 0x3340(0x0004) (Const)
	float                                              m_fEarlyShatterRecheckTime;                               // 0x3344(0x0004) (Const)
	unsigned long                                      m_bCanShatterEarly : 1;                                   // 0x3348(0x0004) (Const)
	unsigned long                                      m_bUsingReplacementMIC : 1;                               // 0x3348(0x0004)
	unsigned long                                      m_bSpringBloomFlag : 1;                                   // 0x3348(0x0004)
	unsigned long                                      c_BeamsCreated : 1;                                       // 0x3348(0x0004)
	float                                              r_fShatterDelay;                                          // 0x334C(0x0004) (Net)
	class ATgDevice*                                   m_CachedShatterDevice;                                    // 0x3350(0x0008)
	TArray<struct FScriptDelegate>                     s_OnDeathDelegates;                                       // 0x3358(0x0010) (NeedCtorLink)
	class ATgPawn_Character*                           r_Targets[0x2];                                           // 0x3368(0x0008) (Net)
	TArray<class UTgBeamHelper*>                       c_Beams;                                                  // 0x3378(0x0010) (NeedCtorLink)
	int                                                r_nBeamSpawnIterator;                                     // 0x3388(0x0004) (Net)
	struct FScriptDelegate                             __DestroyedEvent__Delegate;                               // 0x338C(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData01[0x4];                                       // 0x338C(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Illusion");
		return ptr;
	}


	bool ShouldCreateCaptureProxy();
	class ATgPawn_Ying* STATIC_GetOwningYing();
	bool AllowRagdoll();
	void PlayDimensionalLinkFX();
	bool STATIC_IsNotDestroyed();
	class AActor* STATIC_GetActorFromInterface();
	void AddOnDestroyDelegate(const struct FScriptDelegate& delDestroy);
	void ClearDimensionalLink();
	void Shatter();
	void Suicide();
	void ApplyStartShatterEffects();
	void TriggerShatter(float fDelay);
	void TimedDestroyedFX();
	void CacheShatterDevice();
	bool Died(class AController* Killer, class UClass* DamageType, const struct FVector& HitLocation);
	void PlayDyingEffects();
	int STATIC_GetNumNeededBeams();
	void CreateBeams();
	void UpdateBeamAttachments();
	void ConsiderCreateBeams();
	void PlayInitialSpawnFX();
	bool ShouldScoreKill();
	void UpdateWeaponMesh();
	void ReplicatedEvent(const struct FName& VarName);
	bool STATIC_IsNonCombat();
	bool ShouldInHandDeviceBeHiddenThisTick();
	TEnumAsByte<ETgMeshVisibilityState> STATIC_GetMeshVisibilityStateThisTick();
	bool STATIC_CanPawnParticipateInCapture();
	bool STATIC_IsStatTrackable();
	void CheckEarlyShatter();
	void ReplaceWithDestroyedMaterial();
	void ReplaceWithHitOverlayMaterial();
	void ReplaceWithShatterMaterial();
	void PostPawnSetupServer();
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void DeviceAdjustDamage(struct FAdjustDamageParams* Params, float* fDamage);
	void STATIC_InitializeInhandWeapon(int DeviceID);
	void STATIC_DropHealthNuggetTeamOnly(int nTaskForce, const struct FVector& SpawnVelocity, float fHealOverride, float fHoTOverride);
	void STATIC_DropHealthNugget(const struct FVector& SpawnVelocity, float fHealOverride, float fHoTOverride);
	void SpawnGuard();
	void SetPetOwner(class ATgPawn* PetOwner);
	void DestroyedEvent(class AActor* destroyedActor);
};


// Class TgGame.TgDeploy_DominanceFlag
// 0x0004 (0x04A4 - 0x04A0)
class ATgDeploy_DominanceFlag : public ATgDeploy_EffectField
{
public:
	float                                              r_fRadiusForFX;                                           // 0x04A0(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_DominanceFlag");
		return ptr;
	}


	void ScaleAbilityFX();
	void ReplicatedEvent(const struct FName& VarName);
};


// Class TgGame.TgDeploy_ShieldSiegeUnit
// 0x0044 (0x04B0 - 0x046C)
class ATgDeploy_ShieldSiegeUnit : public ATgDeployable
{
public:
	struct FRotator                                    m_InitRotation;                                           // 0x046C(0x000C)
	class UMeshComponent*                              m_VFXCollisionMesh;                                       // 0x0478(0x0008) (ExportObject, Component, EditInline)
	class ATgCollisionProxy_Cylinder*                  m_CollisionProxy;                                         // 0x0480(0x0008)
	class UTgDeviceFire*                               m_WatchtowerFiremode;                                     // 0x0488(0x0008)
	class ATgDevice*                                   m_CachedWatchtowerCard;                                   // 0x0490(0x0008)
	float                                              r_GroundSpeed;                                            // 0x0498(0x0004) (Net)
	unsigned long                                      m_bOnlyHitOnce : 1;                                       // 0x049C(0x0004)
	TArray<class AActor*>                              m_TouchingPawns;                                          // 0x04A0(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_ShieldSiegeUnit");
		return ptr;
	}


	struct FName GetDestroyedDisplayGroup();
	struct FName GetWhileAliveDisplayGroup();
	bool STATIC_IsFortressBreakerEquipped();
	void ClearAllTouched();
	void DestroyIt(bool bSkipFx);
	void SpawnCollisionProxy(class UTgDeviceFire* FireMode);
	void OnProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void OnProxyUnTouch(class AActor* Other);
	void Landed(const struct FVector& HitNormal, class AActor* FloorActor);
	void OnHealthUpdated();
};


// Class TgGame.TgDevice_ShoulderBash
// 0x0018 (0x0A98 - 0x0A80)
class ATgDevice_ShoulderBash : public ATgDevice_Charge
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_MoveSpeedMultiplier;           // 0x0A80(0x0008) (Const, Native, NoExport)
	unsigned long                                      m_bHasHitTarget : 1;                                      // 0x0A88(0x0004)
	struct FVector                                     m_vLastChargeStartLocation;                               // 0x0A8C(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ShoulderBash");
		return ptr;
	}


	bool ShouldStopOnThisHit(class AActor* Other);
	void ApplyTouchHit(class ATgPawn* InstigatorPawn, const struct FVector& vHitLocation, const struct FVector& vHitNormal, class AActor* Target);
	void STATIC_ValidateChargeHit(class AActor* Other);
	bool STATIC_ShouldUseGradualMovement();
	float STATIC_GetMoveSpeedMultiplier();
	bool STATIC_UsesTargetingMode();
};


// Class TgGame.TgDevice_FlakInhand
// 0x0010 (0x0A1C - 0x0A0C)
class ATgDevice_FlakInhand : public ATgDevice
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_MoveSpeedMultiplier;           // 0x0A0C(0x0008) (Const, Native, NoExport)
	class ATgDevice_KineticBurst*                      m_KineticDevice;                                          // 0x0A14(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_FlakInhand");
		return ptr;
	}


	bool CanBeCanceled();
	bool CanBeInterrupted();
	void STATIC_FireAmmunition();
	bool STATIC_HasKineticDevice();
	bool STATIC_ShouldUseGradualMovement();
	float STATIC_GetMoveSpeedMultiplier();
};


// Class TgGame.TgDevice_KineticBurst
// 0x000C (0x0A18 - 0x0A0C)
class ATgDevice_KineticBurst : public ATgDevice
{
public:
	class ATgDevice_FlakInhand*                        m_CachedInhand;                                           // 0x0A0C(0x0008)
	unsigned long                                      m_bInterruptedByInhand : 1;                               // 0x0A14(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_KineticBurst");
		return ptr;
	}


	bool ShouldInterruptInhand();
	bool ShouldMountCancelFiring();
	bool ShouldCooldownAfterFire();
	void STATIC_FireAmmunition();
	bool STATIC_HasCachedInhand();
	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
	bool IsFunctionallyToggleDevice();
	bool CanBeCanceled();
	void STATIC_KineticBurstToggleReactivationLockout();
	void STATIC_KineticBurstCancelTimer();
	bool STATIC_InterceptSlotPressed(class ATgPlayerController* TgController);
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgDevice_AssertDominance
// 0x0000 (0x0A14 - 0x0A14)
class ATgDevice_AssertDominance : public ATgDevice_Leap
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_AssertDominance");
		return ptr;
	}


	bool ShouldInterruptReloadOnFire();
	bool ShouldMountCancelFiring();
	void ClientInterrupt(bool bServerFireFailed);
	bool ShouldInterruptLift();
	bool ShouldLiftInterrupt();
	float STATIC_GetCachedFiringPostHitDelay();
};


// Class TgGame.TgDevice_SiegeUnit
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_SiegeUnit : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_SiegeUnit");
		return ptr;
	}


	bool ShouldInterruptInhand();
	bool ShouldCooldownAfterFire();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgDevice_SuperSmash
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_SuperSmash : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_SuperSmash");
		return ptr;
	}

};


// Class TgGame.TgDevice_Watchtower
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_Watchtower : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Watchtower");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_FlakInHand
// 0x0004 (0x026C - 0x0268)
class UTgDeviceFire_FlakInHand : public UTgDeviceFire
{
public:
	int                                                m_BaseKnockback;                                          // 0x0268(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_FlakInHand");
		return ptr;
	}


	bool ApplyHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
	void AddEffectiveRangeReduction(class AActor* DamageInstigator, const struct FVector& OriginLocation, bool bUseRadius, struct FImpactInfo* Impact);
};


// Class TgGame.TgDeviceFire_SiegeUnit
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_SiegeUnit : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_SiegeUnit");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Dominance
// 0x0008 (0x0294 - 0x028C)
class UTgDeviceForm_Dominance : public UTgDeviceForm
{
public:
	class USkelControlBase*                            m_SKCFlagScale;                                           // 0x028C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Dominance");
		return ptr;
	}


	void ShowFlag();
	void HideFlag();
	void Cache3PAnimNodes(class UTgSkeletalMeshComponent* SkelComp);
};


// Class TgGame.TgDeviceForm_FlakInhand
// 0x0000 (0x028C - 0x028C)
class UTgDeviceForm_FlakInhand : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_FlakInhand");
		return ptr;
	}


	void Hit(int nFireMode, class AActor* Target, float fDamageAmount, const struct FVector& HitLocation, const struct FVector& HitNormal, struct FExtraDamageInfo* ExtraInfo);
	void Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	void PlayHitSound(const struct FVector& Location, class ATgPawn* Target);
	void TraceForImpactFX();
};


// Class TgGame.TgDeviceForm_KineticBurst
// 0x0010 (0x029C - 0x028C)
class UTgDeviceForm_KineticBurst : public UTgDeviceForm
{
public:
	float                                              RampUpTime;                                               // 0x028C(0x0004)
	float                                              RampDownTime;                                             // 0x0290(0x0004)
	class UMaterialInstanceConstant*                   GlowMIC;                                                  // 0x0294(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_KineticBurst");
		return ptr;
	}


	void Cooldown(int nFireModeNum, float fCooldownTime);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	bool STATIC_HasCachedMIC();
};


// Class TgGame.TgDeviceForm_ShoulderBash
// 0x0004 (0x0290 - 0x028C)
class UTgDeviceForm_ShoulderBash : public UTgDeviceForm
{
public:
	int                                                moveAmount;                                               // 0x028C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_ShoulderBash");
		return ptr;
	}


	void EnterTargetingMode();
	bool STATIC_UsesTargetingMode();
	void STATIC_UpdateTargetingModeLocation(const struct FVector& NewLocation, const struct FRotator& NewRotation, float DistanceScale);
};


// Class TgGame.TgInvListener_RallyHere
// 0x0000 (0x00C8 - 0x00C8)
class UTgInvListener_RallyHere : public UTgInventoryObject_Listen_MoraleBoost
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_RallyHere");
		return ptr;
	}

};


// Class TgGame.TgInvListener_FortressBreaker
// 0x0000 (0x00C4 - 0x00C4)
class UTgInvListener_FortressBreaker : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_FortressBreaker");
		return ptr;
	}

};


// Class TgGame.TgPawn_Flak
// 0x0034 (0x330C - 0x32D8)
class ATgPawn_Flak : public ATgPawn_Character
{
public:
	class ATgDevice_KineticBurst*                      m_CachedKineticBurstDevice;                               // 0x32D8(0x0008)
	class ATgDevice_SiegeUnit*                         m_CachedSiegeUnitDevice;                                  // 0x32E0(0x0008)
	class ATgDevice_AssertDominance*                   m_CachedUltimateDevice;                                   // 0x32E8(0x0008)
	class ATgDevice_ShoulderBash*                      m_CachedShoulderBashDevice;                               // 0x32F0(0x0008)
	class UTgSpecialFx*                                m_WepIdleSound;                                           // 0x32F8(0x0008)
	float                                              m_PreviousZHeight;                                        // 0x3300(0x0004)
	float                                              m_GravityMultiplier;                                      // 0x3304(0x0004)
	unsigned long                                      m_bUseShoulderBashRetrieve : 1;                           // 0x3308(0x0004)
	unsigned long                                      m_bUseShoulderBashZoom : 1;                               // 0x3308(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Flak");
		return ptr;
	}


	void STATIC_GetCameraZoomOverride(float* fZoom, float* fZoomDuration);
	void ResetInhandFiremode();
	bool OnLiveRespawn();
	void OnRespawn();
	void RampDownTimer();
	void RampUpTimer();
	bool STATIC_CanSpawnScalableShields();
	void PawnOnLandAfterLeap();
	bool STATIC_HasCachedKineticBurstDevice();
	void DeployableOnDestroyed(class ATgDeployable* dep);
	void ResetGravTimers();
	void SpawnFlagDeployable();
	float GetGravityZ();
	void MaxOutGravity();
	void StartZTracking();
};


// Class TgGame.TgWeaponMeshActor_FlakInhand
// 0x0000 (0x0450 - 0x0450)
class ATgWeaponMeshActor_FlakInhand : public ATgWeaponMeshActor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgWeaponMeshActor_FlakInhand");
		return ptr;
	}


	void PlayInstantHitImpactEffects(const struct FVector& HitLocation, bool bSuccessfulHit, class AActor* HitActor, const struct FVector& HitNormal, const struct FVector& FireOrigin, int nEquipSlot);
};


// Class TgGame.TgDevice_OwlInhand
// 0x0014 (0x0A20 - 0x0A0C)
class ATgDevice_OwlInhand : public ATgDevice
{
public:
	class ATgDevice*                                   m_CachedSwapDevice;                                       // 0x0A0C(0x0008)
	class ATgDevice*                                   m_CachedScopeDevice;                                      // 0x0A14(0x0008)
	unsigned long                                      bUsePerfectAccuracy : 1;                                  // 0x0A1C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_OwlInhand");
		return ptr;
	}


	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
	void RemoveAccuracyDelayed();
	void RemoveScopeEffects();
	void ApplyScopeEffects();
	void ShowReticle(bool bShow);
	float STATIC_GetAccuracy(int nMode);
};


// Class TgGame.TgDevice_OwlSidearm
// 0x000C (0x0A18 - 0x0A0C)
class ATgDevice_OwlSidearm : public ATgDevice
{
public:
	float                                              m_fQueueFireTime;                                         // 0x0A0C(0x0004)
	float                                              m_fQueueFireTimeThreshold;                                // 0x0A10(0x0004) (Const)
	unsigned long                                      m_bEnableContinuousFire : 1;                              // 0x0A14(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_OwlSidearm");
		return ptr;
	}


	float STATIC_GetRecoilMultiplier();
	float STATIC_GetMinAccuracy();
	bool CanEnterCombat();
	void StopFire();
	bool STATIC_InterceptLeftMousePressed(class ATgPlayerController* TgController);
	bool CanFireIfLeftMouseDown();
	void EnterTargetingMode();
};


// Class TgGame.TgDevice_OwlStealth
// 0x0014 (0x0A20 - 0x0A0C)
class ATgDevice_OwlStealth : public ATgDevice
{
public:
	class ATgPawn_Owl*                                 m_CachedOwl;                                              // 0x0A0C(0x0008)
	class ATgDevice_Roost*                             m_RoostCard;                                              // 0x0A14(0x0008)
	unsigned long                                      c_bAlreadyConsumedStealthJuice : 1;                       // 0x0A1C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_OwlStealth");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	bool ShouldInterruptReloadOnFire();
	bool ShouldCancelStealth();
	bool IsFunctionallyToggleDevice();
	bool CanFiringBeCanceledByReactivation();
	void ClientConsumeStealthJuiceOnFire(int nAmtModified);
	void ConsumeStealthJuiceOnFire();
	bool CanDeviceStartFiringNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDebugRelevant, bool bIgnoreCachedValue, TEnumAsByte<EDeviceFailType>* failType);
	bool STATIC_IsDeviceFiringLockedForUI();
	bool STATIC_HasEnoughStealthJuiceToFire();
	void DeviceConsumePowerPool(unsigned char FireModeNum);
	float STATIC_GetStealthJuicePerSec();
	bool ShouldBlockReload(class ATgDevice* Dev, bool bIsAutoReload);
};


// Class TgGame.TgDevice_Roost
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_Roost : public ATgDevice
{
public:
	class ATgDevice*                                   m_ScopeDevice;                                            // 0x0A0C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Roost");
		return ptr;
	}


	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
	float STATIC_GetStealthJuiceDiscount();
};


// Class TgGame.TgDevice_Scope
// 0x000C (0x0A24 - 0x0A18)
class ATgDevice_Scope : public ATgDevice_ToggleWithLockout
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_MoveSpeedMultiplier;           // 0x0A18(0x0008) (Const, Native, NoExport)
	unsigned long                                      m_bDelayMoveSpeedPenalty : 1;                             // 0x0A20(0x0004)
	unsigned long                                      m_bIsZoomed : 1;                                          // 0x0A20(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Scope");
		return ptr;
	}


	bool ShouldStopActionOnOffhandSlotReleased();
	bool IsFunctionallyToggleDevice();
	bool STATIC_InterceptSlotReleased(class ATgPlayerController* TgController);
	void STATIC_InterruptForSwap();
	void CompleteInterrupt();
	bool STATIC_IsPlayerToggleZoomSet();
	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
	bool CanBeInterrupted();
	bool CanBeCanceled();
	void STATIC_FireDescopeTimer();
	void StartFireDescopeTimer();
	bool STATIC_ShouldUseGradualMovement();
	float STATIC_GetMoveSpeedMultiplier();
};


// Class TgGame.TgDevice_WeaponSwap
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_WeaponSwap : public ATgDevice
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_MoveSpeedMultiplier;           // 0x0A0C(0x0008) (Const, Native, NoExport)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_WeaponSwap");
		return ptr;
	}


	bool STATIC_ShouldUseGradualMovement();
	float STATIC_GetMoveSpeedMultiplier();
	void FiringEndTransition();
	void STATIC_HandleDeviceFormStartFire(int nDeviceModeNum, float fRefireTime, struct FAimData* Aim);
	bool ShouldMountCancelFiring();
	bool IsFunctionallyToggleDevice();
	bool CanBeCanceled();
	void NotifyWeaponSwap(float fSwapTime);
};


// Class TgGame.TgDeviceForm_OwlStealth
// 0x0000 (0x028C - 0x028C)
class UTgDeviceForm_OwlStealth : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_OwlStealth");
		return ptr;
	}


	void RecoverDeviceState(TEnumAsByte<ETG_REP_DEVICE_STATE> DesiredState);
	void DoInterrupt();
	void StopFire(int nFireModeNum);
	void BuildUp(int nFireMode, int nEquipSlot, int nSocketIndex, float fBuildupTime);
	void StealthTransition(bool bStealthActivating, float fTransitionTime);
};


// Class TgGame.TgDeviceForm_Scope
// 0x0008 (0x0294 - 0x028C)
class UTgDeviceForm_Scope : public UTgDeviceForm_ToggleWithLockout
{
public:
	float                                              m_fTransitionAmount;                                      // 0x028C(0x0004)
	float                                              m_fTransitionPerSec;                                      // 0x0290(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Scope");
		return ptr;
	}


	void STATIC_EnableZoom(bool bIsActive);
	void PlayToggleTransitionAnimations(float transitionPercent, float totalTransitionTime, bool transitionToActive);
	void SetToggleState(bool bIsActive);
	void StopFire(int nFireModeNum);
};


// Class TgGame.TgDeviceForm_WeaponSwap
// 0x0040 (0x02CC - 0x028C)
class UTgDeviceForm_WeaponSwap : public UTgDeviceForm
{
public:
	TArray<class UTgSkelControlSingleBone*>            m_PistolScale1p;                                          // 0x028C(0x0010) (NeedCtorLink)
	TArray<class UTgSkelControlSingleBone*>            m_PistolScale3p;                                          // 0x029C(0x0010) (NeedCtorLink)
	TArray<class UTgSkelControlSingleBone*>            m_RifleScale1p;                                           // 0x02AC(0x0010) (NeedCtorLink)
	TArray<class UTgSkelControlSingleBone*>            m_RifleScale3p;                                           // 0x02BC(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_WeaponSwap");
		return ptr;
	}


	void RecoverDeviceState(TEnumAsByte<ETG_REP_DEVICE_STATE> DesiredState);
	void SetSkelControlsActive(bool bActive, TArray<class UTgSkelControlSingleBone*>* SkelControls);
	void CacheControls(class UTgSkeletalMeshComponent* SkelComp, const struct FName& nmPistol, const struct FName& nmRifle, TArray<class UTgSkelControlSingleBone*>* PistolSkelControls, TArray<class UTgSkelControlSingleBone*>* RifleSkelControls);
	void Cache3PAnimNodes(class UTgSkeletalMeshComponent* SkelComp);
	void Cache1PAnimNodes(class UTgSkeletalMeshComponent* SkelComp);
	void CacheSkelControls(class UAnimTree* pAnimTree, const struct FName& nmPistol, const struct FName& nmRifle, TArray<class UTgSkelControlSingleBone*>* PistolSkelControls, TArray<class UTgSkelControlSingleBone*>* RifleSkelControls);
};


// Class TgGame.TgInvListener_CrackShot2
// 0x0000 (0x00C8 - 0x00C8)
class UTgInvListener_CrackShot2 : public UTgInvListener_SetChildFiremode
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_CrackShot2");
		return ptr;
	}

};


// Class TgGame.TgInvListener_ActiveWhileWeaponSwap
// 0x000C (0x00D0 - 0x00C4)
class UTgInvListener_ActiveWhileWeaponSwap : public UTgInvListener
{
public:
	class ATgPawn_Owl*                                 m_CachedOwlPawn;                                          // 0x00C4(0x0008)
	unsigned long                                      m_bActivateWhileInhandActive : 1;                         // 0x00CC(0x0004)
	unsigned long                                      m_bIsActive : 1;                                          // 0x00CC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_ActiveWhileWeaponSwap");
		return ptr;
	}

};


// Class TgGame.TgInvListener_CooledMags
// 0x001C (0x00E0 - 0x00C4)
class UTgInvListener_CooledMags : public UTgInvListener
{
public:
	class ATgPawn_Owl*                                 m_CachedOwlPawn;                                          // 0x00C4(0x0008)
	class ATgDevice*                                   m_CachedSidearm;                                          // 0x00CC(0x0008)
	class ATgDevice*                                   m_CachedInhand;                                           // 0x00D4(0x0008)
	float                                              m_fAmmoFillTime;                                          // 0x00DC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_CooledMags");
		return ptr;
	}

};


// Class TgGame.TgInvListener_CrackShot
// 0x0010 (0x00D4 - 0x00C4)
class UTgInvListener_CrackShot : public UTgInvListener
{
public:
	TArray<struct FCrackShotBonusDamageTarget>         m_Targets;                                                // 0x00C4(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_CrackShot");
		return ptr;
	}

};


// Class TgGame.TgInvListener_GuerillaTactics
// 0x0008 (0x00CC - 0x00C4)
class UTgInvListener_GuerillaTactics : public UTgInvListener
{
public:
	class ATgPawn_Owl*                                 m_CachedOwlPawn;                                          // 0x00C4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_GuerillaTactics");
		return ptr;
	}

};


// Class TgGame.TgPawn_Owl
// 0x0024 (0x32FC - 0x32D8)
class ATgPawn_Owl : public ATgPawn_Character
{
public:
	unsigned long                                      m_bUseSecondWeapon : 1;                                   // 0x32D8(0x0004)
	unsigned long                                      m_bSwappingWeapons : 1;                                   // 0x32D8(0x0004)
	unsigned long                                      c_bUseSecondDeathAnim : 1;                                // 0x32D8(0x0004)
	int                                                m_nAltInhandSlot;                                         // 0x32DC(0x0004) (Const)
	int                                                m_nAltAltfireSlot;                                        // 0x32E0(0x0004) (Const)
	float                                              m_fOwlStealthJuice;                                       // 0x32E4(0x0004)
	float                                              m_fMaxOwlStealthJuice;                                    // 0x32E8(0x0004)
	float                                              r_fRemoteOwlStealthJuice;                                 // 0x32EC(0x0004) (Net)
	float                                              c_fOldRemoteOwlStealthJuice;                              // 0x32F0(0x0004)
	class ATgDevice_OwlStealth*                        m_CachedOwlStealth;                                       // 0x32F4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Owl");
		return ptr;
	}


	void STATIC_UpdateOwlStealthFX(float fPrevStealthJuice, float fCurrentStealthJuice);
	void ClientModifyStealthJuice(int nAmtModified);
	void ModifyStealthJuice(int nAmtModified, bool bSendToClient);
	void ApplyStealthServer(TEnumAsByte<ESTEALTH_TYPE> eStealthed, float fRate, bool bForce);
	void InterruptStealth(class ATgDevice* OriginatingDevice);
	bool StartAction(class ATgDevice* Dev, bool bUpdateTimeStamp, TEnumAsByte<EDeviceFailType>* failType);
	void InterruptInhandReload();
	void SetTargetingDevice(class ATgDevice* Dev, const struct FWeaponMeshSwapStrategy& SwapStrategy);
	void ShowReticle(bool bShow, class ATgPlayerController* TgPC);
	void STATIC_FinishedWeaponSwap();
	void SwapToSecondWeapon(bool bSecondWeaponActive);
	struct FName GetDeathAnimName();
	void STATIC_PlayDying(class UClass* dmgType, const struct FVector& HitLoc);
	void BecomeViewTarget(class APlayerController* PC);
	void EndViewTarget(class APlayerController* PC);
	void ReplicatedEvent(const struct FName& VarName);
	void OnPawnDied();
	bool STATIC_IsInScope();
	int STATIC_GetUISkillEqpSlotOverride(int nEquipSlot, TEnumAsByte<EUI_SKILL_EQUIP_SLOT> eUISlot, bool bBaseSkillOnly, bool bGamepadUI);
	class ATgDevice* STATIC_GetCurrentInhandDevice();
};


// Class TgGame.TgPawnMod_FxAudio_EDMStrix
// 0x0004 (0x00B0 - 0x00AC)
class UTgPawnMod_FxAudio_EDMStrix : public UTgPawnMod_FxAudio
{
public:
	float                                              m_fGlowMultBass;                                          // 0x00AC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawnMod_FxAudio_EDMStrix");
		return ptr;
	}

};


// Class TgGame.TgProj_Flare
// 0x0008 (0x0588 - 0x0580)
class ATgProj_Flare : public ATgProj_FreeGrenade
{
public:
	unsigned long                                      m_bStartedPulse : 1;                                      // 0x0580(0x0004)
	float                                              m_fLifetimeForPhysicsSubstep;                             // 0x0584(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Flare");
		return ptr;
	}


	float GetGravityZ();
	bool UseAOE();
	void PulseVisibility();
	void PostProjectileInitialize();
	void StartPulse();
};


// Class TgGame.TgDeploy_AbsorptionField
// 0x0004 (0x0474 - 0x0470)
class ATgDeploy_AbsorptionField : public ATgDeploy_Shield
{
public:
	float                                              r_ControllerPitch;                                        // 0x0470(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_AbsorptionField");
		return ptr;
	}


	void DestroyIt(bool bSkipFx);
	void PlayGenericTakeHit(const struct FVector& HitLocation, const struct FVector& HitNormal, const struct FExtraDamageInfo& Info);
	bool BenefitsFromPctShieldIncrease();
	void TakeDamage(int Damage, class AController* EventInstigator, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void STATIC_GetParticleParams(TArray<struct FParticleSysParam>* Params);
	void MitigateHealthDamage(class ATgPawn* pInstigator, class UTgEffectDamage* Effect, const struct FImpactInfo& Impact, bool bIsHeadshot, float* NewValue, float* fPercReduction, unsigned char* bWasCapped);
};


// Class TgGame.TgDevice_AbsorptionField
// 0x0018 (0x0A24 - 0x0A0C)
class ATgDevice_AbsorptionField : public ATgDevice
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_MoveSpeedMultiplier;           // 0x0A0C(0x0008) (Const, Native, NoExport)
	struct FScriptDelegate                             __InterruptFiringDelegate__Delegate;                      // 0x0A14(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData00[0x4];                                       // 0x0A14(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_AbsorptionField");
		return ptr;
	}


	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
	void OnLinkDevice(class ATgPawn* TgP);
	void InterruptFiringDelegate();
	void CancelSafetyPeriodTimer();
	bool CanBeInterrupted();
	bool CanBeCanceled();
	void STATIC_FireAmmunition();
	bool CanBeSilenced();
	bool STATIC_IsToggleDevice();
	bool ShouldAutoFire();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	bool STATIC_ShouldUseGradualMovement();
	float STATIC_GetMoveSpeedMultiplier();
};


// Class TgGame.TgDevice_LazarusInhand
// 0x0024 (0x0A40 - 0x0A1C)
class ATgDevice_LazarusInhand : public ATgDevice_ChainSequence
{
public:
	TArray<struct FHitSoundData>                       HitActorsAngles;                                          // 0x0A1C(0x0010) (NeedCtorLink)
	int                                                m_nHitIndex;                                              // 0x0A2C(0x0004)
	struct FScriptDelegate                             __InterruptFiringAndResetChainDelegate__Delegate;         // 0x0A30(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData00[0x4];                                       // 0x0A30(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_LazarusInhand");
		return ptr;
	}


	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
	void InterruptFiringAndResetChainDelegate();
	void PlayHitSounds();
	struct FImpactInfo CalcWeaponFire(const struct FAimData& Aim, TArray<struct FImpactInfo>* ImpactList);
	bool CanBeInterrupted();
	void DeviceLockout();
	void STATIC_FireAmmunition();
	int GetChainMax();
	void SortAngles();
};


// Class TgGame.TgDevice_ChargeBurst
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_ChargeBurst : public ATgDevice
{
public:
	class ATgPawn_Lazarus*                             m_CachedLazarus;                                          // 0x0A0C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ChargeBurst");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	void ServerStartFire(float MovementTimeStamp, const struct FVector& MovementInAccel, const struct FVector& MovementClientLoc, unsigned char MovementNewFlags, unsigned char MovementClientRoll, int MovementView, int ClientFireRequestId, unsigned char ClientFireMode, class AActor* HitActor, float StartTraceX, float StartTraceY, float StartTraceZ, float EndTraceX, float EndTraceY, float EndTraceZ, int nCompressedAimVector, bool bFirstBurstShot, float fAttackSpeedPercChange);
	void CallServerStartFire(const struct FAimData& Aim, bool bPendingUpdate);
	void STATIC_FireAmmunition();
	void STATIC_InterruptOtherDevices(class ATgPawn* TgP);
	bool ShouldAutoFire();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgDevice_ItFollows
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_ItFollows : public ATgDevice
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_MoveSpeedMultiplier;           // 0x0A0C(0x0008) (Const, Native, NoExport)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ItFollows");
		return ptr;
	}


	bool STATIC_ShouldUseGradualMovement();
	float STATIC_GetMoveSpeedMultiplier();
};


// Class TgGame.TgDevice_ItWaits
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_ItWaits : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ItWaits");
		return ptr;
	}

};


// Class TgGame.TgDevice_Shatterfall
// 0x0000 (0x0A14 - 0x0A14)
class ATgDevice_Shatterfall : public ATgDevice_Leap
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Shatterfall");
		return ptr;
	}


	void DeliverHit(const struct FImpactInfo& Impact);
	bool ShouldInterruptReloadOnFire();
	bool ShouldMountCancelFiring();
	void ClientInterrupt(bool bServerFireFailed);
	void STATIC_InterruptOtherDevices(class ATgPawn* TgP);
	bool ShouldLiftInterrupt();
	float STATIC_GetCachedFiringPostHitDelay();
};


// Class TgGame.TgDevice_PlayingGod
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_PlayingGod : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_PlayingGod");
		return ptr;
	}

};


// Class TgGame.TgDevice_ReanimateSupporting
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_ReanimateSupporting : public ATgDevice
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_MoveSpeedMultiplier;           // 0x0A0C(0x0008) (Const, Native, NoExport)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ReanimateSupporting");
		return ptr;
	}


	bool STATIC_ShouldUseGradualMovement();
	float STATIC_GetMoveSpeedMultiplier();
	bool CanFiringBeLocked();
};


// Class TgGame.TgDevice_SelfResurrection
// 0x0004 (0x0A10 - 0x0A0C)
class ATgDevice_SelfResurrection : public ATgDevice
{
public:
	unsigned long                                      m_bFiringLockout : 1;                                     // 0x0A0C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_SelfResurrection");
		return ptr;
	}


	bool ShouldConsumePowerPoolAfterFire();
	bool ShouldConsumePowerPoolOnStartFire();
	void ReleaseFiringLockout();
	void STATIC_UnlockInput();
	void STATIC_FireAmmunition();
	bool CanBeInterrupted();
	bool CanBeCanceled();
	bool ShouldInterruptMount();
	void OnBecomeActive();
	void ApplyActiveEffects();
	void STATIC_FinishResurrection();
	void Suicide();
	void STATIC_EnterBuildupState();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	bool CanFireWhileMounted();
	bool CanFiringBeLocked();
};


// Class TgGame.TgDevice_StoneStrength
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_StoneStrength : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_StoneStrength");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_LazarusInhand
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_LazarusInhand : public UTgDeviceFire_Melee
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_LazarusInhand");
		return ptr;
	}


	bool STATIC_IgnoreTargetForBlocking(class AActor* Target);
};


// Class TgGame.TgDeviceFire_Shatterfall
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_Shatterfall : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Shatterfall");
		return ptr;
	}


	bool STATIC_IgnoreTargetForBlocking(class AActor* Target);
};


// Class TgGame.TgDeviceForm_LazarusInhand
// 0x0010 (0x029C - 0x028C)
class UTgDeviceForm_LazarusInhand : public UTgDeviceForm
{
public:
	TArray<struct FHitPawn>                            m_pHitPawnsList;                                          // 0x028C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_LazarusInhand");
		return ptr;
	}


	void Hit(int nFireMode, class AActor* Target, float fDamageAmount, const struct FVector& HitLocation, const struct FVector& HitNormal, struct FExtraDamageInfo* ExtraInfo);
	void Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	void TraceForImpactFX();
};


// Class TgGame.TgDeviceForm_SelfResurrection
// 0x0008 (0x0294 - 0x028C)
class UTgDeviceForm_SelfResurrection : public UTgDeviceForm
{
public:
	class USkelControlBase*                            m_SKCCrystalScale;                                        // 0x028C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_SelfResurrection");
		return ptr;
	}


	void Generic1(unsigned char byExtraData);
	void Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	void Cache3PAnimNodes(class UTgSkeletalMeshComponent* SkelComp);
};


// Class TgGame.TgInvListener_CalamityChargeOnChildHit
// 0x0000 (0x00C4 - 0x00C4)
class UTgInvListener_CalamityChargeOnChildHit : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_CalamityChargeOnChildHit");
		return ptr;
	}

};


// Class TgGame.TgInvListener_PowerSiphonOnChildHit
// 0x0000 (0x00C4 - 0x00C4)
class UTgInvListener_PowerSiphonOnChildHit : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_PowerSiphonOnChildHit");
		return ptr;
	}

};


// Class TgGame.TgPawn_Lazarus
// 0x00C0 (0x3398 - 0x32D8)
class ATgPawn_Lazarus : public ATgPawn_Character
{
public:
	class ATgDeployable*                               m_pCrystalDeployable;                                     // 0x32D8(0x0008)
	class ATgDevice_SelfResurrection*                  m_SelfResurrectionDevice;                                 // 0x32E0(0x0008)
	class ATgDevice_AbsorptionField*                   m_AbsorptionFieldDevice;                                  // 0x32E8(0x0008)
	class ATgDevice_ChargeBurst*                       m_ChargeBurstDevice;                                      // 0x32F0(0x0008)
	class ATgDevice_Shatterfall*                       m_ShatterfallDevice;                                      // 0x32F8(0x0008)
	class ATgDevice*                                   m_SeethingRageCard;                                       // 0x3300(0x0008)
	class ATgDevice_PlayingGod*                        m_PlayingGodCard;                                         // 0x3308(0x0008)
	class ATgDevice_ItWaits*                           m_ItWaitsCard;                                            // 0x3310(0x0008)
	class ATgDevice_StoneStrength*                     m_StoneStrengthCard;                                      // 0x3318(0x0008)
	class ATgDevice_ItFollows*                         m_ItFollowsCard;                                          // 0x3320(0x0008)
	class UTgCameraShake*                              m_CameraShake;                                            // 0x3328(0x0008)
	class UTgCameraShake*                              m_CameraShakeOwner;                                       // 0x3330(0x0008)
	class UTgCameraShake*                              m_InhandShake0;                                           // 0x3338(0x0008)
	class UTgCameraShake*                              m_InhandShake1;                                           // 0x3340(0x0008)
	class UTgCameraShake*                              m_UltimateShake;                                          // 0x3348(0x0008)
	class AController*                                 m_Killer;                                                 // 0x3350(0x0008)
	unsigned long                                      r_bShouldRez : 1;                                         // 0x3358(0x0004) (Net)
	unsigned long                                      m_bUseShatterFallZoom : 1;                                // 0x3358(0x0004)
	unsigned long                                      m_bUsingDeathMesh : 1;                                    // 0x3358(0x0004)
	float                                              r_fEnergy;                                                // 0x335C(0x0004) (Net)
	float                                              r_fAccumulatedDamage;                                     // 0x3360(0x0004) (Net)
	TEnumAsByte<EResurrectionState>                    r_mCurrentState;                                          // 0x3364(0x0001) (Net)
	unsigned char                                      UnknownData00[0x3];                                       // 0x3365(0x0003) MISSED OFFSET
	int                                                m_nChargeNumber;                                          // 0x3368(0x0004)
	float                                              m_PreviousZHeight;                                        // 0x336C(0x0004)
	float                                              m_GravityMultiplier;                                      // 0x3370(0x0004)
	float                                              m_fItWaitsTimer;                                          // 0x3374(0x0004)
	float                                              m_fItFollowsMovementSpeedMult;                            // 0x3378(0x0004)
	float                                              m_fStrengthOfStoneDamageReduction;                        // 0x337C(0x0004)
	int                                                m_nDeathMeshAsmId;                                        // 0x3380(0x0004)
	int                                                m_nQueuedFireDevice;                                      // 0x3384(0x0004)
	TArray<struct FBloodStoneTarget>                   m_BloodStoneTargets;                                      // 0x3388(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Lazarus");
		return ptr;
	}


	bool STATIC_CanPawnParticipateInCapture();
	void STATIC_RefundUltimateEnergy();
	bool Died(class AController* Killer, class UClass* dmgType, const struct FVector& HitLocation);
	void STATIC_GetCameraZoomOverride(float* fZoom, float* fZoomDuration);
	void PlayUltimateCameraShake();
	void PlayInhandCameraShake(int nShakeID, class ATgPawn* pActor);
	void STATIC_PlayCameraShake();
	bool StartAction(class ATgDevice* Dev, bool bUpdateTimeStamp, TEnumAsByte<EDeviceFailType>* failType);
	void FakeDeath(class AController* Killer);
	bool ShouldScoreKill();
	void PlayDeathAnimation();
	void ForceMount();
	void PostActivateUlt();
	bool OnLiveRespawn();
	void OnRespawn();
	void FinishSelfResurrection();
	class UClass* STATIC_GetDamageTypeOverride(class UClass* dmgType);
	void ReloadMeshAssemblies();
	bool STATIC_ShouldUseDeathMesh();
	void PawnOnLandAfterLeap();
	void ApplyResurrectionBuff();
	void STATIC_FinishResurrection();
	void Suicide();
	void STATIC_UpdateUltimateState(unsigned char NewState);
	bool ShouldShowHudOverlay(class ATgPawn* PlayerPawn);
	float AdjustRespawnTime(float InRespawnTime);
	bool STATIC_IsLifeStealTarget(class ATgPawn* Target);
	bool ShouldRagdollOnDeath(class UClass* DamageType);
	void AttachDeathAnimationFX(int SpecialFXId, const struct FName& SocketName);
	void STATIC_GetMeshAssemblyToUse(int* nBodyAsmId, int* nCoreAsmId);
	void ResetGravTimers();
	float GetAirControl();
	float GetGravityZ();
	void MaxOutGravity();
	void StartZTracking();
	void STATIC_GetAdditionalDamageTakenMultipliers(class ATgDevice* damagingDevice, struct FDiminishedEffectInfo* DiminishingInfo, struct FImpactInfo* Impact);
	void STATIC_UpdateChargeNumber();
	void STATIC_IncrementDamageCharge(float pDamageAmt);
	bool STATIC_HandleAutofireDevices();
	bool ShouldBeFirstPersonThisTick(TEnumAsByte<ECameraPerspectiveType>* ePersectiveType);
	void SpawnCrystalDeployable();
	void OnDismount();
	void OnPawnDied();
	void ReplicatedEvent(const struct FName& VarName);
};


// Class TgGame.TgWeaponMeshActor_LazarusInhand
// 0x0004 (0x0454 - 0x0450)
class ATgWeaponMeshActor_LazarusInhand : public ATgWeaponMeshActor
{
public:
	int                                                m_nFiremode;                                              // 0x0450(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgWeaponMeshActor_LazarusInhand");
		return ptr;
	}


	void PlayFireEffects(int nEquipSlot, float fRefireTime, int nFireMode);
	void PlayInstantHitImpactEffects(const struct FVector& HitLocation, bool bSuccessfulHit, class AActor* HitActor, const struct FVector& HitNormal, const struct FVector& FireOrigin, int nEquipSlot);
};


// Class TgGame.TgDeploy_ChurchillTurret
// 0x001C (0x0488 - 0x046C)
class ATgDeploy_ChurchillTurret : public ATgDeployable
{
public:
	struct FVector                                     m_vDroneSocketOffset;                                     // 0x046C(0x000C)
	unsigned long                                      r_bLeftDrone : 1;                                         // 0x0478(0x0004) (Net)
	struct FVector                                     m_vCurrentAccumulatedVelocity;                            // 0x047C(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_ChurchillTurret");
		return ptr;
	}


	struct FVector STATIC_GetPhysicalFireAimDirection(const struct FVector& FireLoc, const struct FVector& TargetLocation);
	void PlayFireFx();
	void STATIC_FireAmmunitionDeployable();
	void DestroyIt(bool bSkipFx);
	void ReplacedByNewDeployable();
	void PlayLowHealthFX(bool bEnable);
	void TakeDamage(int Damage, class AController* EventInstigator, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void ReplicatedEvent(const struct FName& VarName);
	void StartDeploy();
	struct FVector STATIC_GetDesiredLocation();
};


// Class TgGame.TgDeploy_ChurchillWard
// 0x0010 (0x047C - 0x046C)
class ATgDeploy_ChurchillWard : public ATgDeployable
{
public:
	unsigned long                                      r_bTargetVisible : 1;                                     // 0x046C(0x0004) (Net)
	float                                              r_fRadiusScale;                                           // 0x0470(0x0004) (Net)
	class ATgPawn_Churchill*                           m_CachedChurchill;                                        // 0x0474(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_ChurchillWard");
		return ptr;
	}


	bool STATIC_HasCachedChurchill();
	void STATIC_UpdateDetectedColor(bool bDetected);
	void ScaleFX();
	void ApplyHit(TArray<struct FImpactInfo>* ImpactList);
	bool DamageShouldEnterCombat();
	void DestroyIt(bool bSkipFx);
	void ReplicatedEvent(const struct FName& VarName);
};


// Class TgGame.TgDeploy_ChurchillShield
// 0x0004 (0x0474 - 0x0470)
class ATgDeploy_ChurchillShield : public ATgDeploy_Shield
{
public:
	float                                              m_fMinPitch;                                              // 0x0470(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_ChurchillShield");
		return ptr;
	}


	void TakeDamage(int Damage, class AController* EventInstigator, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void OnHealthUpdated();
	void StartDeploy();
};


// Class TgGame.TgDevice_ChurchillInhand
// 0x0024 (0x0A30 - 0x0A0C)
class ATgDevice_ChurchillInhand : public ATgDevice
{
public:
	unsigned long                                      m_bIsADS : 1;                                             // 0x0A0C(0x0004)
	struct FVector                                     m_vADSProjectileSpawnOffset;                              // 0x0A10(0x000C) (Edit)
	float                                              m_fADSRecoilMultiplier;                                   // 0x0A1C(0x0004)
	float                                              m_fAmmoRefundChanceADS;                                   // 0x0A20(0x0004)
	float                                              m_fAmmoRefundPercOnHit;                                   // 0x0A24(0x0004)
	class ATgPawn_Character*                           m_CachedPawnOwner;                                        // 0x0A28(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ChurchillInhand");
		return ptr;
	}


	float STATIC_GetMinAccuracy();
	float STATIC_GetRecoilMultiplier();
	class UTgGameplayCurvesSet_RecoilSimple* STATIC_GetRecoilCurve();
	bool STATIC_HasCachedCharacter();
	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
	void STATIC_EndADSBonuses();
	void StartADSBonuses();
	void ShowReticle(bool bShow);
	bool ShouldConsumeAmmo(int nFireRequestId, TArray<struct FImpactToValidate> Impacts);
	struct FVector GetProjectileSpawnOffset();
};


// Class TgGame.TgDevice_SpinningShield
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_SpinningShield : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_SpinningShield");
		return ptr;
	}


	void OnDeployableSpawned(class ATgDeployable* deployable);
};


// Class TgGame.TgDevice_ChurchillADS
// 0x0008 (0x0A2C - 0x0A24)
class ATgDevice_ChurchillADS : public ATgDevice_ToggleADS
{
public:
	class ATgDevice_ChurchillInhand*                   m_CachedInhand;                                           // 0x0A24(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ChurchillADS");
		return ptr;
	}


	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	float STATIC_GetMoveSpeedMultiplier();
};


// Class TgGame.TgDevice_ChurchillShield
// 0x0008 (0x0A18 - 0x0A10)
class ATgDevice_ChurchillShield : public ATgDevice_Toggle
{
public:
	class ATgPawn_Churchill*                           m_CachedPawn;                                             // 0x0A10(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ChurchillShield");
		return ptr;
	}


	bool CanBeCanceled();
	bool STATIC_HasCachedPawn();
	bool CanBeInterrupted();
	void CancelSafetyPeriodTimer();
	bool CanBeSilenced();
};


// Class TgGame.TgDeviceForm_ChurchillInhand
// 0x0000 (0x02B8 - 0x02B8)
class UTgDeviceForm_ChurchillInhand : public UTgDeviceForm_SpinnerWhileFiring
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_ChurchillInhand");
		return ptr;
	}

};


// Class TgGame.TgInvListener_OpportunityInChaos
// 0x0004 (0x00C8 - 0x00C4)
class UTgInvListener_OpportunityInChaos : public UTgInvListener
{
public:
	float                                              m_fStartFireTime;                                         // 0x00C4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_OpportunityInChaos");
		return ptr;
	}

};


// Class TgGame.TgInvListener_Scapegoat
// 0x0008 (0x00CC - 0x00C4)
class UTgInvListener_Scapegoat : public UTgInvListener
{
public:
	class ATgDeploy_ChurchillShield*                   m_CachedShield;                                           // 0x00C4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_Scapegoat");
		return ptr;
	}

};


// Class TgGame.TgInvListener_SuspectEveryone
// 0x0000 (0x00C4 - 0x00C4)
class UTgInvListener_SuspectEveryone : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_SuspectEveryone");
		return ptr;
	}

};


// Class TgGame.TgInvListener_VivianRevealOnKill
// 0x0000 (0x00C4 - 0x00C4)
class UTgInvListener_VivianRevealOnKill : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_VivianRevealOnKill");
		return ptr;
	}

};


// Class TgGame.TgPawn_Churchill
// 0x0054 (0x332C - 0x32D8)
class ATgPawn_Churchill : public ATgPawn_Character
{
public:
	class ATgDeploy_ChurchillTurret*                   r_LeftDrone;                                              // 0x32D8(0x0008) (Net)
	class ATgDeploy_ChurchillTurret*                   r_RightDrone;                                             // 0x32E0(0x0008) (Net)
	unsigned long                                      s_bFireLeftDroneNext : 1;                                 // 0x32E8(0x0004)
	unsigned long                                      s_bStopDroneFiring : 1;                                   // 0x32E8(0x0004)
	unsigned long                                      s_bLeftDroneInFireTimeout : 1;                            // 0x32E8(0x0004)
	unsigned long                                      s_bRightDroneInFireTimeout : 1;                           // 0x32E8(0x0004)
	TArray<class UTgAnimBlendByChurchillDrone*>        m_ChurchillDroneAnims1p;                                  // 0x32EC(0x0010) (NeedCtorLink)
	float                                              r_fVisualRecoilMultiplier;                                // 0x32FC(0x0004) (Net)
	struct FVector                                     c_vForced3pAdditionalOffsetADS;                           // 0x3300(0x000C) (Config)
	float                                              m_fUnderheadADSDistanceClampAngle;                        // 0x330C(0x0004) (Config)
	float                                              m_fUnderheadADSDistanceClampPushIn;                       // 0x3310(0x0004) (Config)
	float                                              m_fUnderheadADSDistanceClampOvershoot;                    // 0x3314(0x0004) (Config)
	float                                              m_fOverheadADSDistanceClampAngle;                         // 0x3318(0x0004) (Config)
	float                                              m_fOverheadADSDistanceClampPushIn;                        // 0x331C(0x0004) (Config)
	float                                              m_fOverheadADSDistanceClampOvershoot;                     // 0x3320(0x0004) (Config)
	class ATgDevice_BoobyTrap*                         m_EquippedBoobyTrap;                                      // 0x3324(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Churchill");
		return ptr;
	}


	float STATIC_GetCameraPenetrationCheckRadius();
	void STATIC_ForceUpdateDroneState();
	void PostTimeLapse(bool bPlayOfTheGame);
	void PreTimeLapse(bool bPlayOfTheGame);
	struct FVector STATIC_GetCameraOffsetOverride(const struct FVector& originalOffset, TEnumAsByte<ECameraPerspectiveType> ePerspectiveType);
	struct FVector STATIC_GetCameraOriginOverride(const struct FVector& originalOrigin, TEnumAsByte<ECameraPerspectiveType> ePerspectiveType);
	void OnInhandAmmoCountUpdated();
	void ForceUpdateAmmoAnim();
	void AddVisualRecoil(int nEquipSlot, float fFireDuration);
	void STATIC_DroneLowHealth(bool bLeftDrone, bool bIsLowHealth);
	void STATIC_DroneDestroyed(bool bLeftDrone);
	void STATIC_DroneFired(bool bLeftDrone);
	void STATIC_DroneSpawned(bool bLeftDrone);
	void FireDrone();
	void OnDeviceFormFire(int nEquipSlot, float fRefireTime, int nFireMode);
	void ReplicatedEvent(const struct FName& VarName);
	void ResetPermanentEffects();
	bool STATIC_CanSpawnScalableShields();
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnStartBuildup(class ATgDevice* Dev);
};


// Class TgGame.TgProj_ChurchillWard
// 0x0000 (0x0580 - 0x0580)
class ATgProj_ChurchillWard : public ATgProj_FreeGrenade
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_ChurchillWard");
		return ptr;
	}


	bool ShouldHitBounce(class AActor* Target, const struct FVector& HitNormal);
	class AActor* CalculateHitActor(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, struct FTraceHitInfo* HitInfo);
	float GetGravityZ();
};


// Class TgGame.TgWeaponMeshActor_ChurchillInhand
// 0x0050 (0x04A4 - 0x0454)
class ATgWeaponMeshActor_ChurchillInhand : public ATgWeaponMeshActor_ADS
{
public:
	struct FPointer                                    VfTable_ITgObserver_ViewTargetChanged;                    // 0x0454(0x0008) (Const, Native, NoExport)
	class ATgPawn_Churchill*                           m_CachedChurchill;                                        // 0x045C(0x0008)
	float                                              m_fShieldLagStrength;                                     // 0x0464(0x0004)
	float                                              m_fShieldMinPitch;                                        // 0x0468(0x0004)
	float                                              m_fShieldMinPitchMaxTranslate;                            // 0x046C(0x0004)
	struct FLinearColor                                m_cDefaultColorizeRed1p;                                  // 0x0470(0x0010)
	struct FLinearColor                                m_cDefaultColorizeRed3p;                                  // 0x0480(0x0010)
	int                                                m_nColorizeRedChnageSource;                               // 0x0490(0x0004)
	struct FLinearColor                                DetectedColorWeapon;                                      // 0x0494(0x0010) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgWeaponMeshActor_ChurchillInhand");
		return ptr;
	}


	void SetCrystalDetected(bool bDetected, int nSource);
	void CacheColorizeRedOnMesh(class USkeletalMeshComponent* weaponMesh, struct FLinearColor* cDefaultColor);
	void Tick(float DeltaTime);
	void STATIC_Initialize3P(unsigned char EquipPoint, int DeviceID);
	void STATIC_FixUpReferencesToWeaponMesh1P(class USkeletalMeshComponent* weaponMesh);
	void Toggle1PVisibility(bool bVisible);
	void SetDeployablesHidden(bool bShouldHide);
	void OnViewTargetChanged(class AActor* aNewViewTarget);
};


// Class TgGame.TgAnimNodeBlendByAbilityVanguardGrab
// 0x0000 (0x0168 - 0x0168)
class UTgAnimNodeBlendByAbilityVanguardGrab : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByAbilityVanguardGrab");
		return ptr;
	}


	void STATIC_InterruptAbility();
	void STATIC_UpdateVanguardGrabAnim(TEnumAsByte<EVanguardGrabAnimUpdate> eState);
};


// Class TgGame.TgAnimNodeBlendByAbilityVanguardUlt
// 0x0000 (0x0168 - 0x0168)
class UTgAnimNodeBlendByAbilityVanguardUlt : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByAbilityVanguardUlt");
		return ptr;
	}


	void STATIC_UpdateVanguardUltAnim(TEnumAsByte<EVanguardUltAnimUpdate> eState);
};


// Class TgGame.TgAnimNodeChannelFire_VanguardShield
// 0x0000 (0x0180 - 0x0180)
class UTgAnimNodeChannelFire_VanguardShield : public UTgAnimNodeChannelFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeChannelFire_VanguardShield");
		return ptr;
	}

};


// Class TgGame.TgDeploy_VanguardShield
// 0x0000 (0x0470 - 0x0470)
class ATgDeploy_VanguardShield : public ATgDeploy_Shield
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_VanguardShield");
		return ptr;
	}


	void OnHealthUpdated();
	void TakeDamage(int Damage, class AController* EventInstigator, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
};


// Class TgGame.TgDevice_VanguardGrab
// 0x0014 (0x0A94 - 0x0A80)
class ATgDevice_VanguardGrab : public ATgDevice_Charge
{
public:
	class ATgPawn_Vanguard*                            m_CachedVanguard;                                         // 0x0A80(0x0008)
	class ATgPawn_Character*                           m_GrabTarget;                                             // 0x0A88(0x0008)
	unsigned long                                      c_bServerChargeEnded : 1;                                 // 0x0A90(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_VanguardGrab");
		return ptr;
	}


	bool STATIC_HasCachedVanguard();
	void ClientFailGrab(class AActor* Other);
	void ClientStartGrab(class AActor* Other);
	void ClientThrowTarget();
	void NotifyClientServerChargeStopped();
	void ServerStartGrab(class AActor* Other);
	bool STATIC_GrabTarget(class AActor* Other);
	bool ShouldLiftInterrupt();
};


// Class TgGame.TgDevice_VortexGrip
// 0x0000 (0x0A80 - 0x0A80)
class ATgDevice_VortexGrip : public ATgDevice_Charge
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_VortexGrip");
		return ptr;
	}

};


// Class TgGame.TgDevice_LiansShield
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_LiansShield : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_LiansShield");
		return ptr;
	}

};


// Class TgGame.TgDevice_VanguardShield
// 0x0018 (0x0A24 - 0x0A0C)
class ATgDevice_VanguardShield : public ATgDevice
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_MoveSpeedMultiplier;           // 0x0A0C(0x0008) (Const, Native, NoExport)
	struct FScriptDelegate                             __InterruptFiringDelegate__Delegate;                      // 0x0A14(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData00[0x4];                                       // 0x0A14(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_VanguardShield");
		return ptr;
	}


	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
	void InterruptFiringDelegate();
	void STATIC_UpdateOutroLockoutTime();
	void CancelSafetyTimer();
	void ClientNotifyShieldWasDestroyed();
	void ShieldWasDestroyed();
	bool ShouldInterruptReloadOnFire();
	bool STATIC_InterceptSlotReleased(class ATgPlayerController* TgController);
	bool STATIC_InterceptLeftMousePressed(class ATgPlayerController* TgController);
	bool CanFiringBeCanceledByLeftMouse();
	bool CanBeInterrupted();
	bool CanBeCanceled();
	bool STATIC_InterceptSlotPressed(class ATgPlayerController* TgController);
	bool CanDeviceStartFiringNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDebugRelevant, bool bIgnoreCachedValue, TEnumAsByte<EDeviceFailType>* failType);
	bool STATIC_ShouldUseGradualMovement();
	float STATIC_GetMoveSpeedMultiplier();
	bool ShouldAltFireOnTick();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgDevice_VanguardShout
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_VanguardShout : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_VanguardShout");
		return ptr;
	}

};


// Class TgGame.TgDevice_VanguardUlt
// 0x002C (0x0A38 - 0x0A0C)
class ATgDevice_VanguardUlt : public ATgDevice
{
public:
	class ATgPawn_Vanguard*                            m_CachedVanguard;                                         // 0x0A0C(0x0008)
	class ATgPawn_Character*                           s_Target;                                                 // 0x0A14(0x0008)
	struct FVector                                     m_vThrowVector;                                           // 0x0A1C(0x000C)
	struct FVector                                     s_vServerGrabOffset;                                      // 0x0A28(0x000C)
	unsigned long                                      c_bWaitingForHit : 1;                                     // 0x0A34(0x0004)
	unsigned long                                      m_bGrabFailed : 1;                                        // 0x0A34(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_VanguardUlt");
		return ptr;
	}


	float GetCustomTimerBarMaxTime();
	float GetCustomTimerBarCurrentTime();
	void TriggerAoE(class AActor* Target, const struct FVector& vLocation, const struct FVector& vNormal);
	bool HandleCustomPlayerKnockbackHit(class AActor* TargetPrimary, const struct FImpactInfo& ImpactPrimary, class AActor* TargetSecondary, const struct FImpactInfo& ImpactSecondary);
	bool HandleCustomWallKnockbackHit(class AActor* Target, const struct FImpactInfo& Impact);
	void ServerAltUse(const struct FRotator& AimRotation);
	void ClientEnterAimMode(float fDuration);
	void DeliverQueuedPendingHits();
	void DeliverHit(const struct FImpactInfo& Impact);
	void StartThrowOnClient();
	void ApplyThrowEffects();
	void Throw(const struct FVector& AimVector);
	void STATIC_EnterAimMode();
	void TransitionToHold();
	void StartPull();
	void StartGrab(class ATgPawn_Character* Target);
	void RemoveForcedViewTarget();
	void STATIC_EarlyEndPullDelegate();
	void ConsumeRemainingEnergy();
	void STATIC_ClientGrabStarted();
	void OnInstantShotRejected(const struct FImpactToValidate& RejectedPrimaryImpact);
	void STATIC_GrabFailed();
	void STATIC_ClientGrabFailed();
	void ApplyGrabHitToTarget(bool bActive, int nHitType);
	bool CanBeCanceled();
	bool ShouldForce3P(class UTgDeviceForm* DeviceForm, bool bOnlyCheckDeviceForm);
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgDeviceForm_VanguardUlt
// 0x0035 (0x02C1 - 0x028C)
class UTgDeviceForm_VanguardUlt : public UTgDeviceForm
{
public:
	class UTgBeamHelper*                               m_PullBeam;                                               // 0x028C(0x0008)
	TArray<class UTgAnimNodeBlendByAbilityVanguardUlt*> m_VanguardUltNodes3p;                                     // 0x0294(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeBlendByAbilityVanguardUlt*> m_VanguardUltNodes1p;                                     // 0x02A4(0x0010) (NeedCtorLink)
	class ATgPawn_Character*                           m_Target;                                                 // 0x02B4(0x0008)
	int                                                m_nPosture;                                               // 0x02BC(0x0004)
	TEnumAsByte<EVanguardUltAnimUpdate>                m_eVanguardUltAnimState;                                  // 0x02C0(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_VanguardUlt");
		return ptr;
	}


	void RecoverDeviceState(TEnumAsByte<ETG_REP_DEVICE_STATE> DesiredState);
	void STATIC_UpdateVanguardUltAnim(TEnumAsByte<EVanguardUltAnimUpdate> eState);
	void SetPostureOnTarget(TEnumAsByte<ETG_POSTURE> Posture);
	void ClearTarget();
	void StopFire(int nFireModeNum);
	void DoInterrupt();
	void StartGrab();
	void Generic1(unsigned char byExtraData);
	void Hit(int nFireMode, class AActor* Target, float fDamageAmount, const struct FVector& HitLocation, const struct FVector& HitNormal, struct FExtraDamageInfo* ExtraInfo);
	void CacheAnimNode(class UAnimNode* Node, bool bIs3p);
	void ClearAnimNodes(bool bIs3p);
	void ConnectBeamToTarget(bool bActivate);
	void BuildUp(int nFireMode, int nEquipSlot, int nSocketIndex, float fBuildupTime);
	bool ShouldForce3P();
};


// Class TgGame.TgInvListener_FiringLine
// 0x0000 (0x00D8 - 0x00D8)
class UTgInvListener_FiringLine : public UTgInventoryObject_Listen_HitWithDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_FiringLine");
		return ptr;
	}

};


// Class TgGame.TgPawn_Vanguard
// 0x0064 (0x333C - 0x32D8)
class ATgPawn_Vanguard : public ATgPawn_Character
{
public:
	class ATgDeploy_VanguardShield*                    r_ActiveShield;                                           // 0x32D8(0x0008) (Net)
	unsigned long                                      r_bShieldWasDestroyed : 1;                                // 0x32E0(0x0004) (Net)
	class ATgPawn_Character*                           c_UltTarget;                                              // 0x32E4(0x0008)
	class ATgPawn*                                     r_UltTargetForKillCam;                                    // 0x32EC(0x0008) (Net)
	struct FMap_Mirror                                 m_CachedDevices;                                          // 0x32F4(0x0048) (Native)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Vanguard");
		return ptr;
	}


	void STATIC_GetCameraZoomOverride(float* fZoom, float* fZoomDuration);
	TEnumAsByte<EEmoteCategory> GetEmoteCategory(TEnumAsByte<EEmote> Emote);
	bool STATIC_CanSpawnScalableShields();
	class ATgDevice* STATIC_HasCachedDevice(int nDeviceId);
	float STATIC_GetManaRegen();
};


// Class TgGame.TgDevice_MorningBreath
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_MorningBreath : public ATgDevice
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_ListenConsumeMarks;            // 0x0A0C(0x0008) (Const, Native, NoExport)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_MorningBreath");
		return ptr;
	}


	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
	void OnMarksConsumed(class AActor* Target, class ATgDevice* instigatingDevice, float fNumMarks, float fBaseDamage, float fBonusDamage);
};


// Class TgGame.TgDevice_RiderAlt
// 0x0018 (0x0A24 - 0x0A0C)
class ATgDevice_RiderAlt : public ATgDevice
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_ListenConsumeMarks;            // 0x0A0C(0x0008) (Const, Native, NoExport)
	TArray<TScriptInterface<class UTgDeviceInterface_ListenConsumeMarks>> m_CachedListenConsumeMarks;                               // 0x0A14(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_RiderAlt");
		return ptr;
	}


	bool CanBeSilenced();
	void OnMarksConsumed(class AActor* Target, class ATgDevice* instigatingDevice, float fNumMarks, float fBaseDamage, float fBonusDamage);
	bool CanEnterCombat();
};


// Class TgGame.TgDevice_RiderInhand
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_RiderInhand : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_RiderInhand");
		return ptr;
	}

};


// Class TgGame.TgDevice_RiderLegMarksExplode
// 0x000C (0x0A18 - 0x0A0C)
class ATgDevice_RiderLegMarksExplode : public ATgDevice
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_ListenConsumeMarks;            // 0x0A0C(0x0008) (Const, Native, NoExport)
	float                                              s_fDamage;                                                // 0x0A14(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_RiderLegMarksExplode");
		return ptr;
	}


	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
	void OnMarksConsumed(class AActor* Target, class ATgDevice* instigatingDevice, float fNumMarks, float fBaseDamage, float fBonusDamage);
};


// Class TgGame.TgDevice_RiderMovement
// 0x0014 (0x0A20 - 0x0A0C)
class ATgDevice_RiderMovement : public ATgDevice
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_AccelMultiplier;               // 0x0A0C(0x0008) (Const, Native, NoExport)
	struct FPointer                                    VfTable_ITgDeviceInterface_MoveSpeedMultiplier;           // 0x0A14(0x0008) (Const, Native, NoExport)
	float                                              m_fLastMultiplierUsed;                                    // 0x0A1C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_RiderMovement");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
	bool IsFunctionallyToggleDevice();
	bool CanBeCanceled();
	bool STATIC_ShouldUseGradualMovement();
	float STATIC_GetMoveSpeedMultiplier();
	float STATIC_GetAccelMultiplier();
};


// Class TgGame.TgDevice_RiderUlt
// 0x0009 (0x0A15 - 0x0A0C)
class ATgDevice_RiderUlt : public ATgDevice
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_MoveSpeedMultiplier;           // 0x0A0C(0x0008) (Const, Native, NoExport)
	unsigned char                                      r_nEatingCookie;                                          // 0x0A14(0x0001) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_RiderUlt");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	void STATIC_EatingCookie();
	void STATIC_EatTarget(class ATgPawn* TgP);
	void STATIC_SendEatDamageDoneMessages(class ATgPawn* TgP);
	bool STATIC_ShouldUseGradualMovement();
	float STATIC_GetMoveSpeedMultiplier();
	void ReplicatedEvent(const struct FName& VarName);
};


// Class TgGame.TgDeviceFire_RiderAlt
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_RiderAlt : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_RiderAlt");
		return ptr;
	}

};


// Class TgGame.TgInvListener_NaturesBlessing
// 0x0000 (0x00C4 - 0x00C4)
class UTgInvListener_NaturesBlessing : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_NaturesBlessing");
		return ptr;
	}

};


// Class TgGame.TgInvListener_RiderLegMarksExplode
// 0x0000 (0x00C4 - 0x00C4)
class UTgInvListener_RiderLegMarksExplode : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_RiderLegMarksExplode");
		return ptr;
	}

};


// Class TgGame.TgInvListener_RiderShield
// 0x0010 (0x00D4 - 0x00C4)
class UTgInvListener_RiderShield : public UTgInvListener
{
public:
	TArray<struct FRiderShieldPerTargetHistory>        s_PerTargetLockout;                                       // 0x00C4(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_RiderShield");
		return ptr;
	}

};


// Class TgGame.TgPawn_Rider
// 0x0088 (0x3360 - 0x32D8)
class ATgPawn_Rider : public ATgPawn_Character
{
public:
	class ATgDevice_RiderUlt*                          m_CachedRiderUlt;                                         // 0x32D8(0x0008)
	class ATgDevice_RiderMovement*                     m_CachedRiderMovement;                                    // 0x32E0(0x0008)
	float                                              m_fLastSelfShieldFxTimestamp;                             // 0x32E8(0x0004)
	unsigned long                                      m_bUseCameraOffsetOverride : 1;                           // 0x32EC(0x0004)
	struct FVector                                     m_vCameraOffsetOverride;                                  // 0x32F0(0x000C)
	float                                              m_fVelocityLag;                                           // 0x32FC(0x0004)
	float                                              m_fPrevSpeed;                                             // 0x3300(0x0004)
	float                                              m_fVelocityLagRecoverySpeed;                              // 0x3304(0x0004) (Edit)
	float                                              m_fVelocityLagStrength;                                   // 0x3308(0x0004) (Edit)
	float                                              m_fSmoothedVelocityLag;                                   // 0x330C(0x0004)
	float                                              m_fSmoothedVelocityLagSpeed;                              // 0x3310(0x0004) (Edit)
	float                                              m_fDeathFadeMaterialEndTimestamp;                         // 0x3314(0x0004)
	float                                              m_fDeathFadeMaterialTime;                                 // 0x3318(0x0004) (Edit)
	struct FVector                                     m_vLastAccelDir;                                          // 0x331C(0x000C)
	float                                              m_fMaxMovementDegPerSec;                                  // 0x3328(0x0004) (Edit)
	float                                              m_fGreaterGoodLifesteal;                                  // 0x332C(0x0004)
	struct FRiderMarkedTargetInfo                      r_RiderMarkedTargets[0x5];                                // 0x3330(0x0008) (Net)
	struct FRiderLastMaxMarkedTarget                   r_RiderLastMaxMarkedTarget;                               // 0x3358(0x0008) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Rider");
		return ptr;
	}


	void SetWeaponMaterialScalarParams(const struct FName& nmParamName, float fValue);
	void SetCameraOffsetOverride(bool bUseOverride, const struct FVector& vOffsetOverride);
	struct FVector STATIC_GetCameraOffsetOverride(const struct FVector& originalOffset, TEnumAsByte<ECameraPerspectiveType> ePerspectiveType);
	void PawnGeneric1Flashed();
	void Bump(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitNormal);
	int STATIC_GetUISkillEqpSlotOverride_Rider(int nEquipSlot, TEnumAsByte<EUI_SKILL_EQUIP_SLOT> eUISlot, bool bShouldSwapAltAndInhandInputs, int nFallThroughValue);
	int STATIC_GetUISkillEqpSlotOverrideStaticDefault(int nEquipSlot, TEnumAsByte<EUI_SKILL_EQUIP_SLOT> eUISlot);
	int STATIC_GetUISkillEqpSlotOverride(int nEquipSlot, TEnumAsByte<EUI_SKILL_EQUIP_SLOT> eUISlot, bool bBaseSkillOnly, bool bGamepadUI);
	float STATIC_CheckMaxMarksTimestamp(int nTargetPawnId);
	void STATIC_SetMaxMarksTimestamp(int nTargetPawnId);
	int STATIC_GetNumMarks(int nTargetPawnId);
	void OnMarkedTarget(int nTargetPawnId, int nMarkCountChange);
	void STATIC_GetAdditionalLifestealMultipliers(struct FDiminishedEffectInfo* DiminishingInfo, struct FImpactInfo* Impact);
	bool ShouldBeFirstPersonThisTick(TEnumAsByte<ECameraPerspectiveType>* ePersectiveType);
	bool ShouldSwapAltAndInhandInputs();
	void PlaySpecialEffectEvent(int PlaySpecialEffectIndex, const struct FVector& vLoc, const struct FVector& vHitNormal, class AActor* inActor);
};


// Class TgGame.TgDevice_FuriaFProjSpawner
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_FuriaFProjSpawner : public ATgDevice
{
public:
	class ATgDevice*                                   m_CachedFuriaF;                                           // 0x0A0C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_FuriaFProjSpawner");
		return ptr;
	}


	void LinkedDeviceEquipped(class ATgDevice* Dev);
	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void STATIC_UseNow();
	void STATIC_GetTargetingAim(struct FAimData* Aim);
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgDevice_FuriaInhand
// 0x0010 (0x0A1C - 0x0A0C)
class ATgDevice_FuriaInhand : public ATgDevice
{
public:
	class ATgPawn_Furia*                               m_Furia;                                                  // 0x0A0C(0x0008)
	float                                              s_fCurrentAttackSpeedTier;                                // 0x0A14(0x0004)
	float                                              s_fHolyWrathDecayStartTime;                               // 0x0A18(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_FuriaInhand");
		return ptr;
	}


	void STATIC_UpdateAttackSpeed();
	void AddHolyWrath(float fAmt);
};


// Class TgGame.TgDevice_FuriaQ
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_FuriaQ : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_FuriaQ");
		return ptr;
	}


	void STATIC_ServerHaltBeam();
	bool STATIC_InterceptSlotPressed(class ATgPlayerController* TgController);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_FuriaRMB
// 0x0084 (0x0A90 - 0x0A0C)
class ATgDevice_FuriaRMB : public ATgDevice
{
public:
	class ATgPawn_Furia*                               m_Furia;                                                  // 0x0A0C(0x0008)
	struct FImpactInfo                                 m_CachedImpact;                                           // 0x0A14(0x007C) (Component)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_FuriaRMB");
		return ptr;
	}


	bool ShouldCooldownAfterFire();
	void DeliverDelayedHits();
	void DeliverHit(const struct FImpactInfo& Impact);
	void DeliverQueuedPendingHits();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgDeviceFire_FuriaQ
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_FuriaQ : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_FuriaQ");
		return ptr;
	}


	bool STATIC_IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth, bool bInvertTeam);
};


// Class TgGame.TgDeviceFire_FuriaRMB
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_FuriaRMB : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_FuriaRMB");
		return ptr;
	}


	bool STATIC_IgnoreTargetForBlocking(class AActor* Target);
};


// Class TgGame.TgInvListener_FuriaQ_Exterminate
// 0x0000 (0x00DC - 0x00DC)
class UTgInvListener_FuriaQ_Exterminate : public UTgInvListener_ConsecutiveInhandHits
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_FuriaQ_Exterminate");
		return ptr;
	}

};


// Class TgGame.TgInvListener_FuriaInhand
// 0x0000 (0x00C4 - 0x00C4)
class UTgInvListener_FuriaInhand : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_FuriaInhand");
		return ptr;
	}

};


// Class TgGame.TgInvListener_FuriaQ
// 0x0000 (0x00C4 - 0x00C4)
class UTgInvListener_FuriaQ : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_FuriaQ");
		return ptr;
	}

};


// Class TgGame.TgInvListener_FuriaUlt
// 0x0000 (0x00C4 - 0x00C4)
class UTgInvListener_FuriaUlt : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_FuriaUlt");
		return ptr;
	}

};


// Class TgGame.TgPawn_Furia
// 0x0034 (0x330C - 0x32D8)
class ATgPawn_Furia : public ATgPawn_Character
{
public:
	class ATgPawn*                                     r_RMBTarget;                                              // 0x32D8(0x0008) (Net)
	float                                              m_fDelayTargetValid;                                      // 0x32E0(0x0004)
	float                                              r_fHolyWrathBuff;                                         // 0x32E4(0x0004) (Net)
	unsigned long                                      r_bStopFuriaQProjOnHit : 1;                               // 0x32E8(0x0004) (Net)
	unsigned long                                      r_bFuriaQHitAllies : 1;                                   // 0x32E8(0x0004) (Net)
	unsigned long                                      m_bUltimateReadyDisplayGroupOn : 1;                       // 0x32E8(0x0004)
	float                                              c_fMinBladeGlow;                                          // 0x32EC(0x0004)
	float                                              c_fMaxBladeGlow;                                          // 0x32F0(0x0004)
	float                                              c_fMinCrystalGlow;                                        // 0x32F4(0x0004)
	float                                              c_fMaxCrystalGlow;                                        // 0x32F8(0x0004)
	float                                              m_fLastWrathAmt;                                          // 0x32FC(0x0004)
	int                                                m_nLastWrathTier;                                         // 0x3300(0x0004)
	float                                              m_fGravityMultiplier;                                     // 0x3304(0x0004) (Edit)
	float                                              m_fMaxFallSpeed;                                          // 0x3308(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Furia");
		return ptr;
	}


	bool STATIC_HasRMBTarget();
	void STATIC_SetRMBTarget(class ATgPawn* pChar);
	float GetGravityZ();
	int STATIC_GetHolyWrathBuffTier();
	void ModifyAccuracyForReticleBloom(float* fAccuracy);
};


// Class TgGame.TgProj_FuriaQ
// 0x0020 (0x054C - 0x052C)
class ATgProj_FuriaQ : public ATgProj_Simulated
{
public:
	TArray<class AActor*>                              m_StunnedTargets;                                         // 0x052C(0x0010) (NeedCtorLink)
	unsigned long                                      m_bShouldCheckStop : 1;                                   // 0x053C(0x0004)
	unsigned long                                      m_bStopped : 1;                                           // 0x053C(0x0004)
	struct FVector                                     vTargetStopLocation;                                      // 0x0540(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_FuriaQ");
		return ptr;
	}


	float STATIC_GetRemainingTime();
	void STATIC_HaltBeam(const struct FVector& vHitLocation);
	void CheckStopProjectile(class AActor* Target, const struct FVector& vHitLocation);
	void ClientHitUpdate(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
	bool ApplyTheHit(class UTgDeviceFire* FireMode, const struct FImpactInfo& Impact, class AActor* DamageInstigator);
	void Tick(float DeltaSeconds);
	void STATIC_HandleTick();
	void CompleteInitialization(unsigned char ExtraInfo);
	void STATIC_HideProjectile();
	float CheckOcclusion();
};


// Class TgGame.TgDeploy_DredgeF
// 0x002C (0x0498 - 0x046C)
class ATgDeploy_DredgeF : public ATgDeployable
{
public:
	class ATgDeploy_DredgeF*                           r_ConnectedPortal;                                        // 0x046C(0x0008) (Net)
	unsigned long                                      m_bPortalActive : 1;                                      // 0x0474(0x0004)
	TArray<struct FTargetToTeleport>                   s_PendingTeleports;                                       // 0x0478(0x0010) (NeedCtorLink)
	TArray<struct FTargetToTeleport>                   s_RecentAllyTeleports;                                    // 0x0488(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_DredgeF");
		return ptr;
	}


	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void ActivatePortal();
	void SetPortalActive(bool bActive, class ATgDeploy_DredgeF* connectedPortal);
	void ConnectPortal(class ATgDeploy_DredgeF* connectedPortal);
	void StartDeploy();
	void PlayActiveFx(bool bActive);
	void ReplicatedEvent(const struct FName& VarName);
	void AttemptTeleport(class ATgPawn* TgP);
	void ClearPendingTeleports();
	void DeployableDestroyed();
};


// Class TgGame.TgDeploy_DredgeUlt
// 0x0000 (0x046C - 0x046C)
class ATgDeploy_DredgeUlt : public ATgDeployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_DredgeUlt");
		return ptr;
	}


	class AActor* STATIC_GetLookAtTarget();
	void OnPersistTimerExpire();
};


// Class TgGame.TgDevice_DredgeInhand
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_DredgeInhand : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DredgeInhand");
		return ptr;
	}


	void PreReloadTimer();
};


// Class TgGame.TgDevice_DredgeQ
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_DredgeQ : public ATgDevice
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_MoveSpeedMultiplier;           // 0x0A0C(0x0008) (Const, Native, NoExport)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DredgeQ");
		return ptr;
	}


	bool STATIC_ShouldUseGradualMovement();
	float STATIC_GetMoveSpeedMultiplier();
};


// Class TgGame.TgDevice_DredgeRMB
// 0x0010 (0x0A1C - 0x0A0C)
class ATgDevice_DredgeRMB : public ATgDevice
{
public:
	class ATgDevice*                                   m_CachedInhand;                                           // 0x0A0C(0x0008)
	class ATgDevice_SpyGlass*                          m_RevealDev;                                              // 0x0A14(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DredgeRMB");
		return ptr;
	}


	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
	void ReloadAmmo(bool bToFull, bool bShouldValidate);
	void SetAmmo(int AmmoCount, int ClipSize, bool bShouldValidate, int ValidationIDOverride);
	bool CanEnterCombat();
	bool STATIC_InterceptRightMouseReleased(class ATgPlayerController* TgController);
	void SetFireMode(int nFireModeNum, bool ForceSet);
	bool STATIC_IsReloading();
	bool ShouldBlockReload(class ATgDevice* Dev, bool bIsAutoReload);
	int STATIC_GetCurrentAmmoAmount();
	bool RequiresAmmoToFire();
};


// Class TgGame.TgDevice_DredgeUlt
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_DredgeUlt : public ATgDevice
{
public:
	float                                              m_fWaitForClientDeployAimTime;                            // 0x0A0C(0x0004)
	unsigned long                                      s_bHasCurrentUltAim : 1;                                  // 0x0A10(0x0004)
	unsigned long                                      s_bForcingDeploy : 1;                                     // 0x0A10(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DredgeUlt");
		return ptr;
	}


	struct FAimData STATIC_GetUltAim();
	void STATIC_ForceUltDeployOnServer();
	void STATIC_ServerDeployNewAim(const struct FAimData& NewAim);
	bool STATIC_HasUpdatedAimInfo();
	void CustomFire();
	bool StartFire();
	void STATIC_GetTargetingAim(struct FAimData* Aim);
};


// Class TgGame.TgDeviceFire_DredgeUlt
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_DredgeUlt : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_DredgeUlt");
		return ptr;
	}


	bool DeviceHasUpdatedAimInfo();
	bool STATIC_GetDeployLocationAndRotation(struct FVector* OutLocation, struct FRotator* OutRotation);
	TEnumAsByte<EDeviceTargetMode> STATIC_GetTargetingMode();
	void CustomFire();
};


// Class TgGame.TgPawn_Dredge
// 0x000C (0x32E4 - 0x32D8)
class ATgPawn_Dredge : public ATgPawn_Character
{
public:
	float                                              m_fBoostedJumpMultiplier;                                 // 0x32D8(0x0004)
	float                                              m_fBoostedJumpGravityMultiplier;                          // 0x32DC(0x0004)
	unsigned long                                      m_bIsBoostedJumping : 1;                                  // 0x32E0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Dredge");
		return ptr;
	}


	void PawnGeneric2Flashed();
	void PawnGeneric1Flashed();
	float STATIC_GetJumpHeightMultiplier();
	bool DoJump(bool bUpdating, float JumpZSpeed);
	float GetGravityZ();
};


// Class TgGame.TgProj_DredgeQ
// 0x0000 (0x052C - 0x052C)
class ATgProj_DredgeQ : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_DredgeQ");
		return ptr;
	}


	void PlayAdditionalHitFX(class AActor* HitActor, const struct FVector& FXLocation, const struct FVector& HitNormal, const struct FVector& ProjDir, TArray<struct FParticleSysParam>* ExplosionParams);
	void PostProjectileInitialize();
	bool STATIC_GetDeployLocationAndRotation(const struct FVector& vLocation, class AActor* TargetActor, const struct FVector& vNormal, struct FVector* OutLocation, struct FRotator* OutRotation);
	class ATgDeployable* SpawnDeployable(const struct FVector& vLocation, class AActor* TargetActor, const struct FVector& vNormal);
};


// Class TgGame.TgProj_DredgeInhand
// 0x0008 (0x0588 - 0x0580)
class ATgProj_DredgeInhand : public ATgProj_FreeGrenade
{
public:
	float                                              m_fMaxUndampenedZBounce;                                  // 0x0580(0x0004)
	float                                              m_fBounceGravityZMultiplier;                              // 0x0584(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_DredgeInhand");
		return ptr;
	}


	void ApplyBounceDamping(float fBounceDamping, struct FVector* vBounceVelocity);
	void ApplyBounce(const struct FVector& HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp);
	void OnLand();
	void LoadFiremodeProp(int nPropId, float fValue);
};


// Class TgGame.TgProj_DredgeRMB
// 0x0000 (0x0588 - 0x0588)
class ATgProj_DredgeRMB : public ATgProj_DredgeInhand
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_DredgeRMB");
		return ptr;
	}


	void TriggerReveal();
	void OnLand();
	void PlayLandExplodeFX();
	void ApplyBounceDamping(float fBounceDamping, struct FVector* vBounceVelocity);
};


// Class TgGame.TgAnimNodeBlendByAbilityAtlasF
// 0x0000 (0x0168 - 0x0168)
class UTgAnimNodeBlendByAbilityAtlasF : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByAbilityAtlasF");
		return ptr;
	}


	void STATIC_RewindEnded();
	void STATIC_StartRewind();
	void STATIC_FireProjectile();
};


// Class TgGame.TgDeploy_AtlasF
// 0x0018 (0x0484 - 0x046C)
class ATgDeploy_AtlasF : public ATgDeployable
{
public:
	class ATgPawn_Character*                           m_Target;                                                 // 0x046C(0x0008)
	class UStaticMeshComponent*                        m_CountdownIndicator;                                     // 0x0474(0x0008) (Edit, ExportObject, Component, EditInline)
	class UMaterialInstanceConstant*                   m_CountdownIndicatorMIC;                                  // 0x047C(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_AtlasF");
		return ptr;
	}


	void DestroyIt(bool bSkipFx);
	void DeviceFired();
	void STATIC_StartRewind();
	void STATIC_SetPlayerToRewind(class ATgPawn_Character* Player);
	void Tick(float DeltaSeconds);
	void PostBeginPlay();
};


// Class TgGame.TgDeploy_AtlasQ
// 0x0040 (0x04AC - 0x046C)
class ATgDeploy_AtlasQ : public ATgDeployable
{
public:
	TArray<class ATgProjectile*>                       m_ProjectilesToDestroy;                                   // 0x046C(0x0010) (NeedCtorLink)
	float                                              fInterpSpeed;                                             // 0x047C(0x0004) (Edit)
	float                                              fTimeToDestroy;                                           // 0x0480(0x0004) (Edit)
	float                                              fVelInterpSpeed;                                          // 0x0484(0x0004) (Edit)
	class UTgSpecialFx*                                c_TakeHitOverride;                                        // 0x0488(0x0008)
	int                                                c_nTakeHitEffectId;                                       // 0x0490(0x0004)
	class ATgPawn_Atlas*                               s_CachedAtlas;                                            // 0x0494(0x0008)
	TArray<class AActor*>                              s_TouchedActors;                                          // 0x049C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_AtlasQ");
		return ptr;
	}


	void Destroyed();
	void STATIC_AddProjectileToSlow(class ATgProjectile* Proj);
	bool STATIC_IsProjectileAlreadyHandled(class ATgProjectile* Proj);
	void STATIC_PerformTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal, bool bForce);
	bool ShouldDisableProjectile(class ATgProjectile* Proj);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_NotifyQueuedLagCompWorldExplosion(class ATgProj_Simulated* Proj, const struct FVector& HitLocation, const struct FVector& HitVelocity);
	bool STATIC_CanQueueLagCompWorldExplosion(class ATgProj_Simulated* Proj, unsigned char* bHideProjectile);
	class UTgSpecialFx* STATIC_GetTakeHitFxOverride(class UTgSpecialFx* TakeHit);
};


// Class TgGame.TgDeploy_UnstableRift
// 0x0000 (0x0484 - 0x0484)
class ATgDeploy_UnstableRift : public ATgDeploy_Bomb
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_UnstableRift");
		return ptr;
	}


	void PostBeginPlay();
	void DestroyIt(bool bSkipFx);
};


// Class TgGame.TgDevice_AtlasBarrage
// 0x0010 (0x0A1C - 0x0A0C)
class ATgDevice_AtlasBarrage : public ATgDevice
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_MoveSpeedMultiplier;           // 0x0A0C(0x0008) (Const, Native, NoExport)
	class ATgDevice_AtlasBarrageFire*                  m_FireDevice;                                             // 0x0A14(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_AtlasBarrage");
		return ptr;
	}


	void LinkedDeviceEquipped(class ATgDevice* Dev);
	void STATIC_LastShotCancelTimer();
	bool CanBeInterrupted();
	bool ShouldInterruptReloadOnFire();
	bool CanFireIfLeftMouseDown();
	bool ShouldConsumePowerPoolOnStartFire();
	void CustomFire();
	bool CanBeCanceled();
	void STATIC_UpdateHud();
	bool CanBeSilenced();
	bool STATIC_ShouldUseGradualMovement();
	float STATIC_GetMoveSpeedMultiplier();
	float STATIC_GetLockoutExtensionTime();
	bool STATIC_IsToggleDevice();
};


// Class TgGame.TgDevice_AtlasBarrageFire
// 0x0010 (0x0A1C - 0x0A0C)
class ATgDevice_AtlasBarrageFire : public ATgDevice
{
public:
	int                                                m_nChainedBarrageNum;                                     // 0x0A0C(0x0004)
	int                                                m_nShotsRemaining;                                        // 0x0A10(0x0004)
	class ATgDevice_AtlasBarrage*                      m_BarrageDevice;                                          // 0x0A14(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_AtlasBarrageFire");
		return ptr;
	}


	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
	void STATIC_HandleDeviceFormStartFire(int nDeviceModeNum, float fRefireTime, struct FAimData* Aim);
	void STATIC_FireAmmunition();
	bool ShouldConsumePowerPoolAfterFire();
	bool ShouldConsumePowerPoolOnStartFire();
	bool STATIC_InterceptLeftMouseReleased(class ATgPlayerController* TgController);
	bool STATIC_InterceptLeftMousePressed(class ATgPlayerController* TgController);
	void ResetBarrage();
	float STATIC_GetCurrentShotCost();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgDevice_AtlasF
// 0x0018 (0x0A24 - 0x0A0C)
class ATgDevice_AtlasF : public ATgDevice
{
public:
	struct FPointer                                    VfTable_ITgCallbackInterface;                             // 0x0A0C(0x0008) (Const, Native, NoExport)
	class ATgPawn_Atlas*                               m_CachedAtlas;                                            // 0x0A14(0x0008)
	class UTgCallbackContainer*                        m_CallbackContainer;                                      // 0x0A1C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_AtlasF");
		return ptr;
	}


	void STATIC_PlayRewindEndFx();
	void STATIC_PlayRewindSelfFx();
	void OnLinkDevice(class ATgPawn* TgP);
	bool CanBeInterrupted();
	bool CanBeCanceled();
	void STATIC_StartRewindPlayback();
	void STATIC_InitializeRewindCapability(class ATgPawn* TgP);
};


// Class TgGame.TgDevice_AtlasInhand
// 0x001C (0x0A28 - 0x0A0C)
class ATgDevice_AtlasInhand : public ATgDevice
{
public:
	class ATgPawn_Atlas*                               m_CachedAtlas;                                            // 0x0A0C(0x0008)
	float                                              m_fLastFireHoldPct;                                       // 0x0A14(0x0004)
	float                                              m_fFireReleasePercent;                                    // 0x0A18(0x0004)
	float                                              m_fReticleReleaseAnimationDuration;                       // 0x0A1C(0x0004) (Edit)
	int                                                m_nSelectedFireLevel;                                     // 0x0A20(0x0004)
	int                                                m_nAmmoToRegain;                                          // 0x0A24(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_AtlasInhand");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	void ConsumeAmmo(int Amount, bool bShouldValidate);
	void PlayClientFireFx(const struct FVector& HitLocation, int nSocketIndex, bool bSuccessfulHit, float fRefireTime, int nShotsFired);
	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
	bool CanBeInterrupted();
	void ReleaseFireHoldInternal();
	bool StartFireHold();
	void ReleaseFireHold();
	void ServerReleaseFireHold(float fClientFireHoldPercent, int nClientFireRequestId);
	void SetFireHoldAmt(float fFireHoldTime);
	bool CanEnterCombat();
	bool CanBeCanceled();
	bool ReleaseHoldOnRightMouseReleased();
	void SelectFireModeByHold(float fFireHoldPct);
	int STATIC_GetIntendedFireLevel(float fFireHoldPct);
	bool STATIC_IsInFinalPostFire();
	bool STATIC_UsesCachedAim();
	int STATIC_GetCurrentRecoilSettingsIdx();
	int STATIC_GetCurrentAccuracySettingsIdx();
	class UTgGameplayCurvesSet* STATIC_GetCurrentGameplayCurveSet(TEnumAsByte<ECurveSetTypes> Type);
	class UTgGameplayCurves* STATIC_GetCurrentGameplayCurves();
	float STATIC_GetBaseDamageMultiplier(struct FImpactInfo* Impact);
	float STATIC_GetAccuracy(int nMode);
	void STATIC_SelectFireLevel(int nLevel);
	void STATIC_SelectFireLevelBurstRounds(int nLevel);
	bool STATIC_IsBurstFiring();
};


// Class TgGame.TgDevice_AtlasRMB
// 0x001C (0x0A28 - 0x0A0C)
class ATgDevice_AtlasRMB : public ATgDevice
{
public:
	class ATgPawn_Atlas*                               m_CachedAtlas;                                            // 0x0A0C(0x0008)
	unsigned long                                      m_bCCReducesRate : 1;                                     // 0x0A14(0x0004)
	TArray<struct FQueuedRewind>                       s_RewindQueue;                                            // 0x0A18(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_AtlasRMB");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	bool CanBeInterrupted();
	bool CanBeCanceled();
	float STATIC_GetRewindProtection(class ATgPawn* pTarget);
	bool STATIC_QueueRewindTarget(class ATgPawn* pTarget, float fDelay, float fDuration, float fRate);
};


// Class TgGame.TgDevice_AtlasRMBInhand
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_AtlasRMBInhand : public ATgDevice
{
public:
	class ATgDevice*                                   m_CachedInhand;                                           // 0x0A0C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_AtlasRMBInhand");
		return ptr;
	}


	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
	void STATIC_CopyAmmoAmt();
	void ReloadAmmo(bool bToFull, bool bShouldValidate);
	void SetAmmo(int AmmoCount, int ClipSize, bool bShouldValidate, int ValidationIDOverride);
	bool StartReload(bool bIgnoreCurrentAmmo);
	bool CanEnterCombat();
	bool STATIC_IsReloading();
	bool ShouldBlockReload(class ATgDevice* Dev, bool bIsAutoReload);
	int STATIC_GetCurrentAmmoAmount();
	bool RequiresAmmoToFire();
};


// Class TgGame.TgDevice_AtlasUlt
// 0x000C (0x0A18 - 0x0A0C)
class ATgDevice_AtlasUlt : public ATgDevice
{
public:
	float                                              m_fTimeDilation;                                          // 0x0A0C(0x0004)
	float                                              m_fRampUpTime;                                            // 0x0A10(0x0004)
	int                                                s_nTimeDilationWindowId;                                  // 0x0A14(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_AtlasUlt");
		return ptr;
	}


	void Tick(float DeltaTime);
};


// Class TgGame.TgDeviceForm_AtlasInhand
// 0x0044 (0x02D0 - 0x028C)
class UTgDeviceForm_AtlasInhand : public UTgDeviceForm
{
public:
	unsigned long                                      m_bCharging : 1;                                          // 0x028C(0x0004)
	unsigned long                                      m_bFullyCharged : 1;                                      // 0x028C(0x0004)
	float                                              m_fChargingPercentage;                                    // 0x0290(0x0004)
	float                                              m_fChargingStartPercentage;                               // 0x0294(0x0004)
	float                                              m_fChargingTime;                                          // 0x0298(0x0004)
	float                                              m_fChargingTotalDuration;                                 // 0x029C(0x0004)
	float                                              m_fTimeToEnterIdle;                                       // 0x02A0(0x0004)
	float                                              m_fTimeToEnterIdleTotal;                                  // 0x02A4(0x0004)
	class ATgPawn_Atlas*                               m_CachedAtlas;                                            // 0x02A8(0x0008)
	TArray<class UTgAnimBlendByPercent*>               m_BlendByPct1P;                                           // 0x02B0(0x0010) (NeedCtorLink)
	TArray<class UTgAnimBlendByPercent*>               m_BlendByPct3P;                                           // 0x02C0(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_AtlasInhand");
		return ptr;
	}


	void SetToggleState(bool IsActive);
	void PlayToggleTransitionAnimations(float transitionPercent, float totalTransitionTime, bool transitionToActive);
	void Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	void GoToIdle();
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	void StopFire(int nFireModeNum);
	void DoInterrupt();
	void Generic1(unsigned char byExtraData);
	void CacheAnimNode(class UAnimNode* Node, bool bIs3p);
	void ClearAnimNodes(bool bIs3p);
	bool STATIC_HasCachedAtlas();
	void STATIC_UpdateFullyChargedFx();
};


// Class TgGame.TgInvListener_HellHunter
// 0x0000 (0x00D8 - 0x00D8)
class UTgInvListener_HellHunter : public UTgInventoryObject_Listen_HitWithDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_HellHunter");
		return ptr;
	}

};


// Class TgGame.TgPawn_Atlas
// 0x003C (0x3314 - 0x32D8)
class ATgPawn_Atlas : public ATgPawn_Character
{
public:
	int                                                r_nReplicatedInhandFireLevel;                             // 0x32D8(0x0004) (Net)
	class ATgDevice_AtlasRMB*                          m_CachedRMB;                                              // 0x32DC(0x0008)
	class ATgDevice_BeyondTheVeil*                     m_CachedBeyondTheVeil;                                    // 0x32E4(0x0008)
	TArray<struct FRewindingPawn>                      s_PawnsRewinding;                                         // 0x32EC(0x0010) (NeedCtorLink)
	struct FName                                       m_nmXenoName;                                             // 0x32FC(0x0008) (Const)
	unsigned long                                      m_bMeshSwappedDirty : 1;                                  // 0x3304(0x0004)
	int                                                m_nSuperWarpTalentId;                                     // 0x3308(0x0004)
	class ATgDevice*                                   m_SuperWarpTalent;                                        // 0x330C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Atlas");
		return ptr;
	}


	void UpdateWeaponMesh();
	void ReplicatedEvent(const struct FName& VarName);
	float STATIC_GetYawZeroOne();
	void STATIC_RemoveRewindingPawn(class ATgPawn* pTarget);
	void STATIC_AddRewindingPawn(class ATgPawn* pTarget, int nFireMode, float fFailsafeTTL);
	void STATIC_SetFireLevel(int nFireLevel);
};


// Class TgGame.TgPawnMod_RewindTween
// 0x00D0 (0x0140 - 0x0070)
class UTgPawnMod_RewindTween : public UTgPawnMod
{
public:
	int                                                m_nPlaybackEndCheckCallbackHandle;                        // 0x0070(0x0004)
	int                                                m_nPendingRewindCallbackHandle;                           // 0x0074(0x0004)
	int                                                m_nRecordingCallbackHandle;                               // 0x0078(0x0004)
	int                                                m_nPhysTweenCallbackHandle;                               // 0x007C(0x0004)
	int                                                m_nRewindHealthCallbackHandle;                            // 0x0080(0x0004)
	TArray<struct FSavedRewindVals>                    m_RewindVals;                                             // 0x0084(0x0010) (NeedCtorLink)
	float                                              m_fPlaybackRate;                                          // 0x0094(0x0004)
	float                                              m_fTimeBetweenSaves;                                      // 0x0098(0x0004)
	float                                              m_fTotalSaveTime;                                         // 0x009C(0x0004)
	unsigned long                                      m_bFinalLocationFailsafe : 1;                             // 0x00A0(0x0004)
	unsigned long                                      c_bNoRewindLagCompensation : 1;                           // 0x00A0(0x0004)
	unsigned long                                      m_bRewindIsBuff : 1;                                      // 0x00A0(0x0004)
	float                                              m_fFailsafeDuration;                                      // 0x00A4(0x0004)
	struct FVector                                     m_vStartLocation;                                         // 0x00A8(0x000C)
	float                                              m_fDoNotRecordTimestamp;                                  // 0x00B4(0x0004)
	float                                              m_fDoNotRecordSafetyPeriod;                               // 0x00B8(0x0004)
	float                                              m_fPlaybackStartTime;                                     // 0x00BC(0x0004)
	float                                              m_fPlaybackEndTime;                                       // 0x00C0(0x0004)
	int                                                m_nPostureID;                                             // 0x00C4(0x0004)
	int                                                m_nCurrentIndex;                                          // 0x00C8(0x0004)
	int                                                m_nLastValidIndex;                                        // 0x00CC(0x0004)
	int                                                m_nCurrentPlaybackLocIndex;                               // 0x00D0(0x0004)
	struct FInterpCurveVector                          m_RewindCurveLoc;                                         // 0x00D4(0x0014) (NeedCtorLink)
	struct FInterpCurveFloat                           m_RewindCurveYaw;                                         // 0x00E8(0x0014) (NeedCtorLink)
	struct FInterpCurveFloat                           m_RewindCurvePitch;                                       // 0x00FC(0x0014) (NeedCtorLink)
	struct FInterpCurveFloat                           m_RewindCurveHealth;                                      // 0x0110(0x0014) (NeedCtorLink)
	TArray<unsigned long>                              m_bRewindCollideWorld;                                    // 0x0124(0x0010) (NeedCtorLink)
	int                                                m_nRewindEveryNYawPitchPoints;                            // 0x0134(0x0004)
	float                                              m_fMinPositionDistance;                                   // 0x0138(0x0004)
	float                                              m_fMaxPositionTimeDelta;                                  // 0x013C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawnMod_RewindTween");
		return ptr;
	}


	void Generic2(class AActor* Owner, int nParamA, int nParamB);
	void Generic1(class AActor* Owner, int nParamA, int nParamB);
	bool STATIC_IsSafeSpot(class ATgPawn* Owner);
	bool STATIC_GetRewindPitch(float fTime, float* fPitch);
	bool STATIC_GetRewindYaw(float fTime, float* fYaw);
	bool STATIC_GetRewindLocation(float fTime, struct FVector* vLoc);
	bool STATIC_GetRewindHealth(float fTime, float* fHealth);
	void Initialize(class AActor* Owner);
};


// Class TgGame.TgProj_AtlasF
// 0x0000 (0x052C - 0x052C)
class ATgProj_AtlasF : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_AtlasF");
		return ptr;
	}


	class ATgDeployable* SpawnDeployable(const struct FVector& vLocation, class AActor* TargetActor, const struct FVector& vNormal);
};


// Class TgGame.TgProj_AtlasRMB
// 0x0008 (0x0534 - 0x052C)
class ATgProj_AtlasRMB : public ATgProj_Simulated
{
public:
	float                                              m_fGravityZ;                                              // 0x052C(0x0004)
	unsigned long                                      m_bIsAOE : 1;                                             // 0x0530(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_AtlasRMB");
		return ptr;
	}


	void ExplodeOnTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool ApplyTheHit(class UTgDeviceFire* FireMode, const struct FImpactInfo& Impact, class AActor* DamageInstigator);
	struct FName STATIC_GetExplodeInAirFxGroup();
	struct FName STATIC_GetHitWallFxGroup();
	struct FName STATIC_GetHitTargetFxGroup();
	bool STATIC_RewindTarget(class AActor* Target);
	float GetGravityZ();
};


// Class TgGame.TgAnimNodeBlendByAbilityYagorathUlt
// 0x0000 (0x0168 - 0x0168)
class UTgAnimNodeBlendByAbilityYagorathUlt : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByAbilityYagorathUlt");
		return ptr;
	}


	void STATIC_UpdateYagorathUltAnim(TEnumAsByte<EYagorathUltAnimState> eState);
};


// Class TgGame.TgDeploy_YagoHardenPoison
// 0x0008 (0x04A8 - 0x04A0)
class ATgDeploy_YagoHardenPoison : public ATgDeploy_EffectField
{
public:
	float                                              m_fRadiusIncPerSec;                                       // 0x04A0(0x0004)
	float                                              m_fMaxRadiusScale;                                        // 0x04A4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_YagoHardenPoison");
		return ptr;
	}


	void StartFire();
};


// Class TgGame.TgDeploy_YagoPoison
// 0x0000 (0x04A0 - 0x04A0)
class ATgDeploy_YagoPoison : public ATgDeploy_EffectField
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_YagoPoison");
		return ptr;
	}

};


// Class TgGame.TgDevice_YagoChargeUp
// 0x000C (0x0A8C - 0x0A80)
class ATgDevice_YagoChargeUp : public ATgDevice_Charge
{
public:
	class ATgDevice_YagoTravel*                        m_YagoTravelDevice;                                       // 0x0A80(0x0008)
	float                                              m_fPerActorHitPeriod;                                     // 0x0A88(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_YagoChargeUp");
		return ptr;
	}


	void LinkedDeviceEquipped(class ATgDevice* Dev);
	float STATIC_GetActorHitPeriod(class AActor* pQueryActor);
	float STATIC_GetChargeSpeed();
	bool CanBeCanceled();
};


// Class TgGame.TgDevice_YagoReveal
// 0x0000 (0x0A14 - 0x0A14)
class ATgDevice_YagoReveal : public ATgDevice_HitPulse
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_YagoReveal");
		return ptr;
	}

};


// Class TgGame.TgDevice_YagoAcidDeploy
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_YagoAcidDeploy : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_YagoAcidDeploy");
		return ptr;
	}

};


// Class TgGame.TgDevice_YagoNeedler
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_YagoNeedler : public ATgDevice
{
public:
	class ATgPawn_Yagorath*                            m_CachedYagorath;                                         // 0x0A0C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_YagoNeedler");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	bool CanBeInterrupted();
	bool CanBeCanceled();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgDevice_YagoPoisonMod
// 0x0020 (0x0A2C - 0x0A0C)
class ATgDevice_YagoPoisonMod : public ATgDevice
{
public:
	TArray<class AActor*>                              m_ImmuneTargets;                                          // 0x0A0C(0x0010) (NeedCtorLink)
	TArray<float>                                      m_ImmuneTimes;                                            // 0x0A1C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_YagoPoisonMod");
		return ptr;
	}


	void RemoveEffect(class ATgDeploy_YagoPoison* YagoPoisonDeploy, class AActor* Target);
	void ApplyEffect(class ATgDeploy_YagoPoison* YagoPoisonDeploy, class AActor* Target);
	void ApplyOnTouchEffect(class AActor* Target);
};


// Class TgGame.TgDevice_YagorathQ
// 0x0004 (0x0A10 - 0x0A0C)
class ATgDevice_YagorathQ : public ATgDevice
{
public:
	float                                              m_fHardenDamage;                                          // 0x0A0C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_YagorathQ");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	bool ShouldInterruptReloadOnFire();
	bool ShouldMountCancelFiring();
	void CustomFire();
	void STATIC_PostHardenDamageReduc();
	void STATIC_ServerHardenExplode();
	void STATIC_HardenExplode();
	bool IsFunctionallyToggleDevice();
	bool CanBeCanceled();
	bool STATIC_InterceptSlotPressed(class ATgPlayerController* TgController);
	void DeviceAdjustDamage(int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
};


// Class TgGame.TgDevice_YagorathUlt
// 0x002C (0x0A38 - 0x0A0C)
class ATgDevice_YagorathUlt : public ATgDevice
{
public:
	class ATgPawn_Yagorath*                            m_CachedYagorath;                                         // 0x0A0C(0x0008)
	class ATgPawn_Character*                           m_Target;                                                 // 0x0A14(0x0008)
	float                                              m_fPrePullTime;                                           // 0x0A1C(0x0004)
	unsigned long                                      m_bGrabFailed : 1;                                        // 0x0A20(0x0004)
	unsigned long                                      m_bPullHit : 1;                                           // 0x0A20(0x0004)
	unsigned long                                      m_bPullCancelledByCollision : 1;                          // 0x0A20(0x0004)
	float                                              m_fPreUltHealth;                                          // 0x0A24(0x0004)
	float                                              m_fPreUltMaxHealth;                                       // 0x0A28(0x0004)
	float                                              m_fPullSpeedBreakFactor;                                  // 0x0A2C(0x0004)
	float                                              m_fDistanceBreakFactor;                                   // 0x0A30(0x0004)
	float                                              m_fTargetBounceVel;                                       // 0x0A34(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_YagorathUlt");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	void STATIC_ClearUltTimers();
	void ClearPullTarget();
	void SetPullTargetNoServerCorrectCameraSmoothing(bool bDisallowSmoothing);
	void ClientEndPull(bool bPullHit);
	void ServerEndPull();
	void STATIC_BounceTarget();
	void STATIC_ClientPullInterrupted();
	void STATIC_PullInterrupted();
	void EndPull(bool bInterrupted);
	void MissInvalidTarget();
	void MissPull();
	void STATIC_EarlyEndPullDelegate();
	void ConsumeRemainingEnergy();
	void STATIC_EatTarget();
	void STATIC_EndFireTime();
	void TransitionToHold();
	void StartPull();
	void STATIC_ClientStartPull(bool bPullHit);
	bool StartGrab(class AActor* Target);
	void OnInstantShotRejected(const struct FImpactToValidate& RejectedPrimaryImpact);
	void STATIC_GrabFailed();
	void STATIC_ClientGrabFailed();
	void ApplyGrabHitToTarget(bool bActive, int nHitType);
	void DeliverQueuedPendingHits();
	void STATIC_GetTargetingAim(struct FAimData* Aim);
	bool ShouldForce3P(class UTgDeviceForm* DeviceForm, bool bOnlyCheckDeviceForm);
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgDevice_YagoSpray
// 0x0010 (0x0A1C - 0x0A0C)
class ATgDevice_YagoSpray : public ATgDevice
{
public:
	class ATgPawn_Yagorath*                            m_CachedYagorath;                                         // 0x0A0C(0x0008)
	float                                              m_fMinAcidJuiceToFire;                                    // 0x0A14(0x0004)
	float                                              m_fFailsafeFireloopTimeout;                               // 0x0A18(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_YagoSpray");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	void STATIC_AcidPoolCooldown();
	bool STATIC_InterceptRightMouseReleased(class ATgPlayerController* TgController);
	void STATIC_SmoothCameraSpeedTransition();
	void STATIC_TimeoutInterrupt();
	bool CanDeviceStartFiringNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDebugRelevant, bool bIgnoreCachedValue, TEnumAsByte<EDeviceFailType>* failType);
	bool CanReload(bool bIsAutoReload);
	bool STATIC_HasAmmo();
	bool ShouldShowAmmoCount();
	bool CanBeSilenced();
};


// Class TgGame.TgDevice_YagoTravel
// 0x0040 (0x0A4C - 0x0A0C)
class ATgDevice_YagoTravel : public ATgDevice
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_MoveSpeedMultiplier;           // 0x0A0C(0x0008) (Const, Native, NoExport)
	class ATgPawn_Yagorath*                            m_CachedYagorath;                                         // 0x0A14(0x0008)
	TEnumAsByte<EYagoTravelState>                      m_eYagoTravelState;                                       // 0x0A1C(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0A1D(0x0003) MISSED OFFSET
	class ATgDevice_YagoChargeUp*                      m_YagoChargeUp;                                           // 0x0A20(0x0008)
	float                                              m_fPreviousSpeedMultiplier;                               // 0x0A28(0x0004)
	float                                              m_fSpeedMultiplierDuringAcceleration;                     // 0x0A2C(0x0004)
	float                                              m_fSpeedMultiplierDuringDeceleration;                     // 0x0A30(0x0004)
	float                                              m_fSpeedMultiplierDuringPassiveDeceleration;              // 0x0A34(0x0004)
	float                                              m_fSpeedMultiplierDuringChargeUp;                         // 0x0A38(0x0004)
	struct FScriptDelegate                             __InterruptFiringDelegate__Delegate;                      // 0x0A3C(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData01[0x4];                                       // 0x0A3C(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_YagoTravel");
		return ptr;
	}


	void LinkedDeviceEquipped(class ATgDevice* Dev);
	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	void InterruptFiringDelegate();
	void STATIC_DeActivationLockout();
	void STATIC_DeActivationCooldown();
	void STATIC_ActivationCooldown();
	void ShowReticle(bool bShow);
	void ServerUpdateTravelState(TEnumAsByte<EYagoTravelState> eInto);
	void OnOwnerRespawn();
	void ClientActivateTravelForm();
	bool CanFiringBeCanceledByReactivation();
	bool CanFiringBeCanceledByLeftMouse();
	bool CanBeCanceled();
	bool CanBeInterrupted();
	bool STATIC_IsOwnerOnGround();
	bool ShouldCooldownAfterFire();
	bool STATIC_ShouldUseGradualMovement();
	float STATIC_GetMoveSpeedMultiplier();
	bool STATIC_IsSafeToCancel();
	bool ShouldInterruptLift();
	bool CanBeSilenced();
	bool CanBeCrippled();
	bool STATIC_CanFireWhileMovementDisabled();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	bool STATIC_IsDeviceFiringLockedForUI();
	bool STATIC_IsDeviceFiringForUI();
	void STATIC_TravelStateTransitionFrom(TEnumAsByte<EYagoTravelState> eFrom);
	void STATIC_TravelStateTransitionIn(TEnumAsByte<EYagoTravelState> eInto);
	void STATIC_UpdateTravelState(TEnumAsByte<EYagoTravelState> eInto);
};


// Class TgGame.TgDeviceFire_YagoSpray
// 0x0000 (0x0278 - 0x0278)
class UTgDeviceFire_YagoSpray : public UTgDeviceFire_EncroachmentFireCone
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_YagoSpray");
		return ptr;
	}


	bool STATIC_GetDeployLocationAndRotation(struct FVector* OutLocation, struct FRotator* OutRotation);
	void CustomFire();
};


// Class TgGame.TgDeviceFire_YagoHardenAcid
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_YagoHardenAcid : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_YagoHardenAcid");
		return ptr;
	}


	void CustomFire();
};


// Class TgGame.TgDeviceFire_YagorathSpray
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_YagorathSpray : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_YagorathSpray");
		return ptr;
	}


	void STATIC_VerifyProjectile();
};


// Class TgGame.TgDeviceForm_YagoTravel
// 0x0020 (0x02D8 - 0x02B8)
class UTgDeviceForm_YagoTravel : public UTgDeviceForm_SpinnerWhileFiring
{
public:
	TArray<class UTgAnimNodeBlendBySimpleStance*>      m_SimpleStanceTravelForm1P;                               // 0x02B8(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeBlendBySimpleStance*>      m_SimpleStanceTravelForm3P;                               // 0x02C8(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_YagoTravel");
		return ptr;
	}


	void DoInterrupt();
	void StopFire(int nFireModeNum);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	void CacheAnimNode(class UAnimNode* Node, bool bIs3p);
	void ClearAnimNodes(bool bIs3p);
};


// Class TgGame.TgDeviceForm_YagorathUlt
// 0x0040 (0x02CC - 0x028C)
class UTgDeviceForm_YagorathUlt : public UTgDeviceForm
{
public:
	class ATgPawn_Character*                           m_Target;                                                 // 0x028C(0x0008)
	int                                                m_nPosture;                                               // 0x0294(0x0004)
	float                                              m_fZoomOutTimer;                                          // 0x0298(0x0004)
	float                                              m_fZoomOutDist;                                           // 0x029C(0x0004)
	float                                              m_fZoomInDist;                                            // 0x02A0(0x0004)
	float                                              m_fDisableEatFxTimer;                                     // 0x02A4(0x0004)
	TEnumAsByte<EYagorathUltAnimState>                 m_eYagorathUltAnimState;                                  // 0x02A8(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x02A9(0x0003) MISSED OFFSET
	TArray<class UTgAnimNodeBlendByAbilityYagorathUlt*> m_YagorathUltNodes3p;                                     // 0x02AC(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeBlendByAbilityYagorathUlt*> m_YagorathUltNodes1p;                                     // 0x02BC(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_YagorathUlt");
		return ptr;
	}


	void STATIC_UpdateYagorathUltAnim(TEnumAsByte<EYagorathUltAnimState> eState);
	void DisableEatFx();
	void StopFire(int nFireModeNum);
	void DoInterrupt();
	void ZoomOutTarget();
	void StartGrab();
	void Generic2(unsigned char byExtraData);
	void Generic1(unsigned char byExtraData);
	void Hit(int nFireMode, class AActor* Target, float fDamageAmount, const struct FVector& HitLocation, const struct FVector& HitNormal, struct FExtraDamageInfo* ExtraInfo);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	void SetPostureOnTarget(TEnumAsByte<ETG_POSTURE> Posture);
	void ClearTarget();
	void STATIC_ShowSpecialHealth(bool bShow);
	void CacheAnimNode(class UAnimNode* Node, bool bIs3p);
	void ClearAnimNodes(bool bIs3p);
};


// Class TgGame.TgInventoryObject_Listen_YagorathObjectiveTalent
// 0x0008 (0x00D8 - 0x00D0)
class UTgInventoryObject_Listen_YagorathObjectiveTalent : public UTgInventoryObject_Listen_NearObjective
{
public:
	float                                              m_fExitObjectiveTimeStamp;                                // 0x00D0(0x0004)
	float                                              m_fEffectDeactivationPeriod;                              // 0x00D4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_YagorathObjectiveTalent");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_YagorathUltimate
// 0x0000 (0x00C4 - 0x00C4)
class UTgInventoryObject_Listen_YagorathUltimate : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_YagorathUltimate");
		return ptr;
	}

};


// Class TgGame.TgPawn_Yagorath
// 0x009C (0x3374 - 0x32D8)
class ATgPawn_Yagorath : public ATgPawn_Character
{
public:
	TArray<struct FName>                               CritPointBoneNames;                                       // 0x32D8(0x0010) (NeedCtorLink)
	float                                              m_fCritDamageMult;                                        // 0x32E8(0x0004)
	float                                              m_fDamageReductionMult;                                   // 0x32EC(0x0004)
	class ATgDevice_YagoSpray*                         m_CachedYagoSpray;                                        // 0x32F0(0x0008)
	float                                              m_fTurnModifierDuringSpray;                               // 0x32F8(0x0004)
	float                                              m_fLookUpModifierDuringSpray;                             // 0x32FC(0x0004)
	class ATgDevice_YagoTravel*                        m_CachedYagoTravel;                                       // 0x3300(0x0008)
	unsigned long                                      r_bTravelFormActive : 1;                                  // 0x3308(0x0004) (Net)
	unsigned long                                      m_bIsMovingForward : 1;                                   // 0x3308(0x0004)
	unsigned long                                      m_bForcedAcceleration : 1;                                // 0x3308(0x0004)
	unsigned long                                      m_bForcedDeceleration : 1;                                // 0x3308(0x0004)
	unsigned long                                      m_bShowUltUI : 1;                                         // 0x3308(0x0004)
	float                                              r_TravelFormCurrSpeedMult;                                // 0x330C(0x0004) (Net)
	float                                              m_fTravelFormTurnRateMult;                                // 0x3310(0x0004)
	float                                              m_TravelFormMaxSpeedMult;                                 // 0x3314(0x0004)
	float                                              m_fYagorathPlantedHeightOffset;                           // 0x3318(0x0004)
	class UPrimitiveComponent*                         m_PlantedFormCollisionComponent;                          // 0x331C(0x0008) (ExportObject, Component, EditInline)
	class ATgDevice_YagorathQ*                         m_CachedYagoQ;                                            // 0x3324(0x0008)
	float                                              m_fAccumulatedMovementDeviation;                          // 0x332C(0x0004)
	float                                              m_fMovementDeviationMeanLifetime;                         // 0x3330(0x0004)
	float                                              m_fAccelerationStartTime;                                 // 0x3334(0x0004)
	float                                              m_fDecelerationStartTime;                                 // 0x3338(0x0004)
	float                                              m_fPassiveDecelerationStartTime;                          // 0x333C(0x0004)
	float                                              r_fMaxMovementDegPerSec;                                  // 0x3340(0x0004) (Net)
	float                                              m_fLastMovementBearing;                                   // 0x3344(0x0004)
	int                                                m_nAltInhandSlot;                                         // 0x3348(0x0004) (Const)
	int                                                m_nAltAltfireSlot;                                        // 0x334C(0x0004) (Const)
	int                                                m_nAltQAbilitySlot;                                       // 0x3350(0x0004) (Const)
	struct FString                                     m_sSkillIconOverride;                                     // 0x3354(0x0010) (NeedCtorLink)
	class ATgDevice_YagorathUlt*                       m_CachedYagoUlt;                                          // 0x3364(0x0008)
	class ATgPawn_Character*                           m_UltTarget;                                              // 0x336C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Yagorath");
		return ptr;
	}


	void STATIC_GetPullGrabSourceLocation(struct FVector* vSourceLoc);
	bool StartAction(class ATgDevice* Dev, bool bUpdateTimeStamp, TEnumAsByte<EDeviceFailType>* failType);
	void SetTargetingDevice(class ATgDevice* Dev, const struct FWeaponMeshSwapStrategy& SwapStrategy);
	void STATIC_SetYagoTargetingDevice(bool bTravelFormActive);
	void STATIC_SetPlantedFormCollision(bool IsActive);
	TEnumAsByte<ETG_EQUIP_POINT> OverrideOffhandSlot(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	bool CanBeRewound();
	bool CanBeGrabbed();
	void ClientSetStun();
	bool STATIC_ShouldSetStunPosture();
	int PushPosture(TEnumAsByte<ETG_POSTURE> Posture);
	void StartFlourish();
	void ReplicatedEvent(const struct FName& VarName);
	bool STATIC_ShouldNeverBeHealed();
	bool STATIC_CanSpawnScalableShields();
	float STATIC_GetTravelFormSpeedMultPercent();
	float STATIC_GetAcidJuice();
	bool STATIC_IsJumpDisabled();
	void STATIC_SetInitialMovementBearing();
	void STATIC_ResetAccumulatedMovementDeviation();
	float STATIC_UpdateAccumulatedMovementDeviation(float fDeltaBearing, float fDeltaSeconds);
	void STATIC_ResetRewindModOnPlanted();
	void FaceRotation(const struct FRotator& NewRotation, float DeltaTime);
	int STATIC_GetUISkillEqpSlotOverride(int nEquipSlot, TEnumAsByte<EUI_SKILL_EQUIP_SLOT> eUISlot, bool bBaseSkillOnly, bool bGamepadUI);
	class ATgDevice* STATIC_GetCurrentInhandDevice();
	void PawnOnPreDamageMitigation(class ATgPawn* attacker, class UTgEffectGroup* eg, int nPropertyId, float* fDamage);
	bool STATIC_CanPawnMountUp();
	void STATIC_OnAutoMount();
};


// Class TgGame.TgProj_YagoSprayProj
// 0x0000 (0x0468 - 0x0468)
class ATgProj_YagoSprayProj : public ATgProj_NonSimulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_YagoSprayProj");
		return ptr;
	}


	void STATIC_HitPassThroughTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	class ATgDeployable* SpawnDeployable(const struct FVector& vLocation, class AActor* TargetActor, const struct FVector& vNormal);
};


// Class TgGame.TgProj_YagoNeedler
// 0x007C (0x05A8 - 0x052C)
class ATgProj_YagoNeedler : public ATgProj_Simulated
{
public:
	struct FImpactInfo                                 m_CachedTargetImpact;                                     // 0x052C(0x007C) (Component)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_YagoNeedler");
		return ptr;
	}


	void PlayHitTargetFX(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, bool bExploded);
	void STATIC_DelayExplodeOnTarget();
	void ExplodeOnTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_HitPassThroughTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgProj_YagorathUltProj
// 0x0008 (0x0534 - 0x052C)
class ATgProj_YagorathUltProj : public ATgProj_Simulated
{
public:
	class UTgDeviceForm_YagorathUlt*                   m_YagorathUltForm;                                        // 0x052C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_YagorathUltProj");
		return ptr;
	}

};


// Class TgGame.TgSkelCon_YagorathSpinner
// 0x0008 (0x014C - 0x0144)
class UTgSkelCon_YagorathSpinner : public UTgSkelCon_Spinner
{
public:
	class ATgPawn_Yagorath*                            m_CachedYagorath;                                         // 0x0144(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_YagorathSpinner");
		return ptr;
	}


	bool STATIC_HasCachedYagorath(class USkeletalMeshComponent* SkelComp);
};


// Class TgGame.TgAnimNodeChannelFire_VatuUlt
// 0x0001 (0x0181 - 0x0180)
class UTgAnimNodeChannelFire_VatuUlt : public UTgAnimNodeChannelFire
{
public:
	TEnumAsByte<EVatuUltAnimState>                     m_eAnimState;                                             // 0x0180(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeChannelFire_VatuUlt");
		return ptr;
	}


	void SetAnimState(TEnumAsByte<EVatuUltAnimState> animState);
	void STATIC_ReplayAnim();
	void STATIC_EndChannel();
};


// Class TgGame.TgDevice_ShadowDash
// 0x0008 (0x0A88 - 0x0A80)
class ATgDevice_ShadowDash : public ATgDevice_Charge
{
public:
	class ATgPawn_Shadow*                              m_ShadowPawn;                                             // 0x0A80(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ShadowDash");
		return ptr;
	}


	void STATIC_GetTargetingAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_ShadowUlt
// 0x0034 (0x0AB4 - 0x0A80)
class ATgDevice_ShadowUlt : public ATgDevice_Charge
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_MoveSpeedMultiplier;           // 0x0A80(0x0008) (Const, Native, NoExport)
	class ATgPawn_Shadow*                              m_Shadow;                                                 // 0x0A88(0x0008)
	unsigned long                                      m_bHasHitTarget : 1;                                      // 0x0A90(0x0004)
	struct FVector                                     m_vLastChargeStartLocation;                               // 0x0A94(0x000C)
	float                                              m_fChargePercent;                                         // 0x0AA0(0x0004)
	float                                              m_fInitalEnergyCost;                                      // 0x0AA4(0x0004) (Const)
	struct FVector                                     m_vCachedTargeterEndpoint;                                // 0x0AA8(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ShadowUlt");
		return ptr;
	}


	void StopFire();
	bool ShouldLockJumping();
	void ServerReleaseFireHold(float fClientFireHoldPercent, int nClientFireRequestId);
	void ReleaseFireHold();
	bool ShouldStopOnThisHit(class AActor* Other);
	float GetChargeTime();
	float GetChargeRange();
	void ReleaseFireHoldInternal();
	void ApplyTouchHit(class ATgPawn* InstigatorPawn, const struct FVector& vHitLocation, const struct FVector& vHitNormal, class AActor* Target);
	bool STATIC_InterceptLeftMousePressed(class ATgPlayerController* TgController);
	bool StartFireHold();
	void STATIC_MinChargeTime();
	bool STATIC_HasCachedShadow();
	bool ShouldConsumePowerPoolAfterFire();
	bool ShouldConsumePowerPoolOnStartFire();
	void STATIC_ValidateChargeHit(class AActor* Other);
	float STATIC_GetChargePercent(bool bForUIOnly);
	void EnterTargetingMode();
	void TickTargetingMode(float DeltaSeconds);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
	TEnumAsByte<EDeviceTargetMode> STATIC_GetTargetingMode();
	bool STATIC_ShouldUseGradualMovement();
	float STATIC_GetMoveSpeedMultiplier();
};


// Class TgGame.TgDevice_Kunai
// 0x001C (0x0A28 - 0x0A0C)
class ATgDevice_Kunai : public ATgDevice
{
public:
	float                                              m_fBurstSpreadHalfAngleDeg;                               // 0x0A0C(0x0004)
	struct FVector                                     m_vProjectileSpawnOffsetLeft;                             // 0x0A10(0x000C)
	struct FVector                                     m_vProjectileSpawnOffsetRight;                            // 0x0A1C(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Kunai");
		return ptr;
	}


	struct FVector GetProjectileSpawnOffset();
	bool STATIC_ShouldUseGradualMovement();
	float STATIC_GetMoveSpeedMultiplier();
	void STATIC_GetAdjustedAim(float AccuracyValueOverride, float RandomValueOverride1, float RandomValueOverride2, int nMultifireIndex, struct FAimData* Aim, float* UsedAccuracyValue, float* UsedRandomValue1, float* UsedRandomValue2);
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgDevice_ShadowTeleport
// 0x001C (0x0A28 - 0x0A0C)
class ATgDevice_ShadowTeleport : public ATgDevice
{
public:
	class ATgPawn_Shadow*                              m_Shadow;                                                 // 0x0A0C(0x0008)
	int                                                m_nShotsFired;                                            // 0x0A14(0x0004)
	float                                              m_fShadowTargetTimerCurrent;                              // 0x0A18(0x0004)
	float                                              m_fShadowTargetTimerTotal;                                // 0x0A1C(0x0004) (Const)
	class ATgPawn_Character*                           m_pPrevTeleportedTo;                                      // 0x0A20(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ShadowTeleport");
		return ptr;
	}


	void ServerStartFire(float MovementTimeStamp, const struct FVector& MovementInAccel, const struct FVector& MovementClientLoc, unsigned char MovementNewFlags, unsigned char MovementClientRoll, int MovementView, int ClientFireRequestId, unsigned char ClientFireMode, class AActor* HitActor, float StartTraceX, float StartTraceY, float StartTraceZ, float EndTraceX, float EndTraceY, float EndTraceZ, int nCompressedAimVector, bool bFirstBurstShot, float fAttackSpeedPercChange);
	void CallServerStartFire(const struct FAimData& Aim, bool bPendingUpdate);
	int STATIC_GetTotalNumberOfShots();
	bool ShouldCooldownAfterFire();
	void ClientStartCooldown(int nMode, float fCooldownTime);
	void StartCooldown(int nMode, float fCooldownTimeOverride);
	bool STATIC_HasCachedShadow();
	void RefireTimer();
	bool STATIC_IsValidTeleportTarget(class ATgPawn_Character* Character);
};


// Class TgGame.TgDevice_StickyBombs
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_StickyBombs : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_StickyBombs");
		return ptr;
	}

};


// Class TgGame.TgDevice_SuckSlash
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_SuckSlash : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_SuckSlash");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_SuckSlash
// 0x0004 (0x027C - 0x0278)
class UTgDeviceFire_SuckSlash : public UTgDeviceFire_EncroachmentFireCone
{
public:
	float                                              m_fMaxPullin;                                             // 0x0278(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_SuckSlash");
		return ptr;
	}


	bool ApplyHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
};


// Class TgGame.TgDeviceForm_Kunai
// 0x0000 (0x028C - 0x028C)
class UTgDeviceForm_Kunai : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Kunai");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_ShadowDash
// 0x0004 (0x0290 - 0x028C)
class UTgDeviceForm_ShadowDash : public UTgDeviceForm
{
public:
	int                                                nDashFXIndex;                                             // 0x028C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_ShadowDash");
		return ptr;
	}


	void Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	int STATIC_GetFormIndex();
};


// Class TgGame.TgDeviceForm_ShadowStickyBomb
// 0x0000 (0x028C - 0x028C)
class UTgDeviceForm_ShadowStickyBomb : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_ShadowStickyBomb");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_ShadowUlt
// 0x0030 (0x02BC - 0x028C)
class UTgDeviceForm_ShadowUlt : public UTgDeviceForm
{
public:
	class UTgBeamHelper*                               m_pBeam;                                                  // 0x028C(0x0008)
	class ATgPawn_Shadow*                              m_pShadow;                                                // 0x0294(0x0008)
	TArray<class UTgAnimNodeChannelFire_VatuUlt*>      m_VatuUltNodes3p;                                         // 0x029C(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeChannelFire_VatuUlt*>      m_VatuUltNodes1p;                                         // 0x02AC(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_ShadowUlt");
		return ptr;
	}


	void ExitTargetingMode();
	void EnterTargetingMode();
	void Generic2(unsigned char byExtraData);
	void Generic1(unsigned char byExtraData);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	void CacheAnimNode(class UAnimNode* Node, bool bIs3p);
	void ClearAnimNodes(bool bIs3p);
	bool STATIC_HasCachedShadow();
	void STATIC_UpdateUltAnimState(TEnumAsByte<EVatuUltAnimState> eNewState);
};


// Class TgGame.TgPawn_Shadow
// 0x0030 (0x3308 - 0x32D8)
class ATgPawn_Shadow : public ATgPawn_Character
{
public:
	class ATgPawn_Character*                           m_pTeleportTarget;                                        // 0x32D8(0x0008)
	float                                              fInputForward;                                            // 0x32E0(0x0004)
	float                                              fInputStrafe;                                             // 0x32E4(0x0004)
	class ATgShadowStickProp*                          m_StickyBombProps[0x3];                                   // 0x32E8(0x0008)
	int                                                m_nNextStickyBombIndex;                                   // 0x3300(0x0004)
	int                                                m_BeamFXId;                                               // 0x3304(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Shadow");
		return ptr;
	}


	bool PostPawnSetup();
	int STATIC_GetStickyBombAsmId();
};


// Class TgGame.TgProj_ShadowStickyBomb
// 0x009C (0x05C8 - 0x052C)
class ATgProj_ShadowStickyBomb : public ATgProj_Simulated
{
public:
	struct FImpactInfo                                 m_CachedTargetImpact;                                     // 0x052C(0x007C) (Component)
	class AActor*                                      prevHitTarget;                                            // 0x05A8(0x0008)
	class ATgShadowStickProp*                          m_pStickyProp;                                            // 0x05B0(0x0008)
	unsigned long                                      m_bHasMadeContact : 1;                                    // 0x05B8(0x0004)
	float                                              m_fExplodeDelay;                                          // 0x05BC(0x0004) (Const)
	float                                              m_fNormalOffsetMultiplier;                                // 0x05C0(0x0004) (Const)
	float                                              m_fMaxAcceptableBulletToTargetDist;                       // 0x05C4(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_ShadowStickyBomb");
		return ptr;
	}


	void ShutDown();
	void Destroyed();
	void PlayHitTargetFX(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, bool bExploded);
	void STATIC_DelayExplodeOnTarget();
	void ExplodeOnTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool STATIC_MoveSticky(const struct FVector& Loc);
};


// Class TgGame.TgProj_ShadowStickyBombHoming
// 0x0008 (0x05D0 - 0x05C8)
class ATgProj_ShadowStickyBombHoming : public ATgProj_ShadowStickyBomb
{
public:
	float                                              m_fRetargetTime;                                          // 0x05C8(0x0004)
	float                                              m_fRetargetingTimer;                                      // 0x05CC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_ShadowStickyBombHoming");
		return ptr;
	}


	void STATIC_UpdateTrackingTargetActor();
	void Tick(float DeltaSeconds);
};


// Class TgGame.TgShadowStickProp
// 0x0017 (0x02A8 - 0x0291)
class ATgShadowStickProp : public ATgPropActor
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0291(0x0003) MISSED OFFSET
	float                                              m_fCheckFallTimer;                                        // 0x0294(0x0004)
	float                                              m_fCheckFallFrequency;                                    // 0x0298(0x0004) (Const)
	unsigned long                                      m_bAttachedToPersonalShield : 1;                          // 0x029C(0x0004)
	unsigned long                                      m_bAttachedToDeployable : 1;                              // 0x029C(0x0004)
	unsigned long                                      m_bAttachedToPet : 1;                                     // 0x029C(0x0004)
	unsigned long                                      m_bSkipClosenessCheck : 1;                                // 0x029C(0x0004)
	class AActor*                                      attachedToTarget;                                         // 0x02A0(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgShadowStickProp");
		return ptr;
	}


	void STATIC_ClientStickToSocket(class ATgPawn* TargetPawn);
	void PostBeginPlay();
};


// Class TgGame.TgDeploy_SaatiCoin
// 0x0010 (0x047C - 0x046C)
class ATgDeploy_SaatiCoin : public ATgDeploy_MatchParentFireMode
{
public:
	unsigned long                                      m_bUseAoeFiremode : 1;                                    // 0x046C(0x0004)
	class UTgDeviceFire*                               m_AoeFiremode;                                            // 0x0470(0x0008)
	int                                                m_nCoinFlatDamageTaken;                                   // 0x0478(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_SaatiCoin");
		return ptr;
	}


	void CollisionChanged();
	void PlayTracerEffects();
	void PlayFireFx();
	void ApplyHit(TArray<struct FImpactInfo>* ImpactList);
	struct FImpactInfo CalcDeviceFire(const struct FVector& StartTrace, const struct FVector& EndTrace, TArray<struct FImpactInfo>* ImpactList);
	void STATIC_InstantFireDeployable();
	void TakeDamage(int Damage, class AController* EventInstigator, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void STATIC_ExplodeOnUltHit();
};


// Class TgGame.TgDevice_BlastBack
// 0x0000 (0x0A14 - 0x0A14)
class ATgDevice_BlastBack : public ATgDevice_Leap
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_BlastBack");
		return ptr;
	}


	bool ShouldInterruptReloadOnFire();
	bool ShouldMountCancelFiring();
};


// Class TgGame.TgDevice_SaatiDecoy
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_SaatiDecoy : public ATgDevice_Pet
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_SaatiDecoy");
		return ptr;
	}


	bool ShouldCancelStealth();
	bool ShouldInterruptStealth();
};


// Class TgGame.TgDevice_SaatiCoin
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_SaatiCoin : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_SaatiCoin");
		return ptr;
	}

};


// Class TgGame.TgDevice_SaatiDecoyExplosion
// 0x0010 (0x0A1C - 0x0A0C)
class ATgDevice_SaatiDecoyExplosion : public ATgDevice
{
public:
	class ATgPawn_SaatiDecoy*                          m_CachedSaatiDecoy;                                       // 0x0A0C(0x0008)
	float                                              m_fCheckDecoyExplosionTime;                               // 0x0A14(0x0004)
	float                                              m_fCheckExplosionTracker;                                 // 0x0A18(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_SaatiDecoyExplosion");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
};


// Class TgGame.TgDevice_SaatiDecoyInhand
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_SaatiDecoyInhand : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_SaatiDecoyInhand");
		return ptr;
	}

};


// Class TgGame.TgDevice_SaatiInhand
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_SaatiInhand : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_SaatiInhand");
		return ptr;
	}

};


// Class TgGame.TgDevice_SaatiPassive
// 0x0014 (0x0A20 - 0x0A0C)
class ATgDevice_SaatiPassive : public ATgDevice
{
public:
	class ATgPawn_Saati*                               m_CachedSaati;                                            // 0x0A0C(0x0008)
	TEnumAsByte<ESaatiBuffType>                        m_eSaatiBuff;                                             // 0x0A14(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0A15(0x0003) MISSED OFFSET
	float                                              m_fUpperBuffActivationPoint;                              // 0x0A18(0x0004)
	float                                              m_fLowerBuffActivationPoint;                              // 0x0A1C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_SaatiPassive");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	void STATIC_ManagePassiveBuff();
};


// Class TgGame.TgDevice_WallBang
// 0x000C (0x0A18 - 0x0A0C)
class ATgDevice_WallBang : public ATgDevice
{
public:
	class ATgDevice_WallBangFire*                      m_SaatiUltFireDevice;                                     // 0x0A0C(0x0008)
	unsigned long                                      m_bShouldShowUltUI : 1;                                   // 0x0A14(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_WallBang");
		return ptr;
	}


	void LinkedDeviceEquipped(class ATgDevice* Dev);
	void STATIC_LastShotCancelTimer();
	bool ShouldInterruptReloadOnFire();
	bool CanBeCanceled();
	void STATIC_UpdateHud();
	bool CanBeSilenced();
	bool CanFireIfLeftMouseDown();
	bool STATIC_IsToggleDevice();
};


// Class TgGame.TgDevice_WallBangFire
// 0x0014 (0x0A20 - 0x0A0C)
class ATgDevice_WallBangFire : public ATgDevice
{
public:
	int                                                m_nShotsRemaining;                                        // 0x0A0C(0x0004)
	class ATgPawn_Saati*                               m_CachedSaati;                                            // 0x0A10(0x0008)
	class ATgDevice_WallBang*                          m_SaatiUltDevice;                                         // 0x0A18(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_WallBangFire");
		return ptr;
	}


	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
	bool ShouldConsumePowerPoolAfterFire();
	bool ShouldConsumePowerPoolOnStartFire();
	bool STATIC_InterceptLeftMouseReleased(class ATgPlayerController* TgController);
	bool STATIC_InterceptLeftMousePressed(class ATgPlayerController* TgController);
	void STATIC_SetUpWallBang();
	bool STATIC_HasCachedSaati();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgDeviceFire_BlastBack
// 0x0000 (0x0278 - 0x0278)
class UTgDeviceFire_BlastBack : public UTgDeviceFire_EncroachmentFireCone
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_BlastBack");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_WallBang
// 0x0000 (0x0278 - 0x0278)
class UTgDeviceFire_WallBang : public UTgDeviceFire_EncroachmentFireCone
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_WallBang");
		return ptr;
	}


	bool ApplyHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
	bool STATIC_IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth, bool bInvertTeam);
};


// Class TgGame.TgDeviceFire_SaatiCoin
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_SaatiCoin : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_SaatiCoin");
		return ptr;
	}


	bool STATIC_IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth, bool bInvertTeam);
};


// Class TgGame.TgDeviceFire_SaatiCoinTalent
// 0x0004 (0x026C - 0x0268)
class UTgDeviceFire_SaatiCoinTalent : public UTgDeviceFire_SaatiCoin
{
public:
	float                                              m_fBonusShieldDamagePerc;                                 // 0x0268(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_SaatiCoinTalent");
		return ptr;
	}


	float STATIC_GetBonusShieldDamagePerc();
};


// Class TgGame.TgDeviceFire_SaatiDecoy
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_SaatiDecoy : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_SaatiDecoy");
		return ptr;
	}


	class ATgPawn* SpawnPet(bool bPet);
};


// Class TgGame.TgDeviceFire_SaatiInhand
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_SaatiInhand : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_SaatiInhand");
		return ptr;
	}


	bool ApplyHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
	bool STATIC_IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth, bool bInvertTeam);
};


// Class TgGame.TgDeviceFire_WallBangProj
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_WallBangProj : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_WallBangProj");
		return ptr;
	}


	bool ApplyHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
	bool STATIC_IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth, bool bInvertTeam);
};


// Class TgGame.TgInvListener_SaatiCoin
// 0x0000 (0x00C4 - 0x00C4)
class UTgInvListener_SaatiCoin : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_SaatiCoin");
		return ptr;
	}

};


// Class TgGame.TgPawn_Saati
// 0x0004 (0x32DC - 0x32D8)
class ATgPawn_Saati : public ATgPawn_Character
{
public:
	unsigned long                                      m_bUltimateReadyDisplayGroupOn : 1;                       // 0x32D8(0x0004)
	unsigned long                                      m_bHasDecoyTalent : 1;                                    // 0x32D8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Saati");
		return ptr;
	}

};


// Class TgGame.TgPawn_SaatiDecoy
// 0x0008 (0x2F30 - 0x2F28)
class ATgPawn_SaatiDecoy : public ATgPawn_Pet
{
public:
	class ATgDevice*                                   m_CachedSpawningDevice;                                   // 0x2F28(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_SaatiDecoy");
		return ptr;
	}


	void PlayDyingEffects();
	void RevealEnemy(class ATgPawn* enemyPawn);
	bool Died(class AController* Killer, class UClass* DamageType, const struct FVector& HitLocation);
	void TakeDamage(int Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	bool PostPawnSetup();
	bool STATIC_IsDebuffImmune();
	bool STATIC_IsCrowdControlImmune();
};


// Class TgGame.TgProj_SaatiCoin
// 0x0008 (0x0588 - 0x0580)
class ATgProj_SaatiCoin : public ATgProj_FreeGrenade
{
public:
	class UPrimitiveComponent*                         m_CoinHitBoxCollisionComponent;                           // 0x0580(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_SaatiCoin");
		return ptr;
	}


	void ExplodeOnTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool CheckTeamPassThrough(class AActor* Other);
	void EnableCoinCollision();
};


// Class TgGame.TgAnimBlendByPaladinsCharacter_Azaan
// 0x0009 (0x054D - 0x0544)
class UTgAnimBlendByPaladinsCharacter_Azaan : public UTgAnimBlendByPaladinsCharacter
{
public:
	class ATgPawn_Azaan*                               m_CachedAzaanPawn;                                        // 0x0544(0x0008)
	TEnumAsByte<EAzaanRetrieveState>                   m_CurrentRetrieveState;                                   // 0x054C(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByPaladinsCharacter_Azaan");
		return ptr;
	}


	void OnRetrieve();
};


// Class TgGame.TgAnimNodeChannelFire_AzaanUlt
// 0x0001 (0x0181 - 0x0180)
class UTgAnimNodeChannelFire_AzaanUlt : public UTgAnimNodeChannelFire
{
public:
	TEnumAsByte<EAzaanUltAnimState>                    m_eAnimState;                                             // 0x0180(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeChannelFire_AzaanUlt");
		return ptr;
	}


	void SetAnimState(TEnumAsByte<EAzaanUltAnimState> animState);
	void STATIC_EndChannel();
};


// Class TgGame.TgDeploy_AzaanWall
// 0x0000 (0x04C8 - 0x04C8)
class ATgDeploy_AzaanWall : public ATgDeploy_GeometryEffectField
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_AzaanWall");
		return ptr;
	}


	void OnHealthUpdated();
};


// Class TgGame.TgDevice_AzaanUlt
// 0x0010 (0x0A1C - 0x0A0C)
class ATgDevice_AzaanUlt : public ATgDevice
{
public:
	class ATgDevice_AzaanUltSlam*                      m_AzaanUltSlamDevice;                                     // 0x0A0C(0x0008)
	class ATgPawn_Azaan*                               m_pAzaan;                                                 // 0x0A14(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_AzaanUlt");
		return ptr;
	}


	float GetCustomTimerBarMaxTime();
	float GetCustomTimerBarCurrentTime();
	void STATIC_OriginalPostHitTimer();
	void LinkedDeviceEquipped(class ATgDevice* Dev);
	void STATIC_LastShotCancelTimer();
	bool CanBeInterrupted();
	bool ShouldSwitchBackToBasicAttackTargeting(TEnumAsByte<ECastMode> CastMode);
	bool HasCachedAzaan();
	bool CanBeCanceled();
	bool ShouldForce3P(class UTgDeviceForm* DeviceForm, bool bOnlyCheckDeviceForm);
	bool CanFireIfLeftMouseDown();
	void ExitTargetingMode();
	void STATIC_UpdateTargetingModeStatus(struct FAimData* Aim);
	void TickTargetingMode(float DeltaSeconds);
	bool STATIC_UsesTargetingMode();
	bool STATIC_IsToggleDevice();
};


// Class TgGame.TgDevice_AzaanUltSlam
// 0x0038 (0x0A44 - 0x0A0C)
class ATgDevice_AzaanUltSlam : public ATgDevice
{
public:
	class ATgDevice_AzaanUlt*                          m_AzaanUltDevice;                                         // 0x0A0C(0x0008)
	float                                              m_fTraceDownDistance;                                     // 0x0A14(0x0004) (Const)
	float                                              m_fLerpDelayTimer;                                        // 0x0A18(0x0004) (Const)
	float                                              m_fPostLerp3P;                                            // 0x0A1C(0x0004) (Const)
	float                                              m_fPostAttackLockout;                                     // 0x0A20(0x0004) (Const)
	float                                              m_fHammerTravelTimeSafety;                                // 0x0A24(0x0004) (Const)
	float                                              m_fLerpTime;                                              // 0x0A28(0x0004) (Const)
	float                                              m_fEndpointZForgiveness;                                  // 0x0A2C(0x0004) (Const)
	class ATgPawn_Azaan*                               m_pAzaan;                                                 // 0x0A30(0x0008)
	struct FVector                                     m_vCachedEndpoint;                                        // 0x0A38(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_AzaanUltSlam");
		return ptr;
	}


	void ServerStartFire(float MovementTimeStamp, const struct FVector& MovementInAccel, const struct FVector& MovementClientLoc, unsigned char MovementNewFlags, unsigned char MovementClientRoll, int MovementView, int ClientFireRequestId, unsigned char ClientFireMode, class AActor* HitActor, float StartTraceX, float StartTraceY, float StartTraceZ, float EndTraceX, float EndTraceY, float EndTraceZ, int nCompressedAimVector, bool bFirstBurstShot, float fAttackSpeedPercChange);
	void CallServerStartFire(const struct FAimData& Aim, bool bPendingUpdate);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
	void STATIC_PerProjectileFired(class ATgProjectile* Proj);
	void STATIC_StartLerpTimer();
	void STATIC_ClientStartLerpTimer();
	void STATIC_Lerp3PTimer();
	void STATIC_StartLerpSequence();
	void STATIC_ClientEndUlt();
	void STATIC_EndUlt();
	void STATIC_DoLerp(const struct FTeleportParams& Params, float fLerpTime);
	void STATIC_ZeroPitchTimer();
	void STATIC_Land();
	void STATIC_DoShockwave();
	void STATIC_ClientStartLerpSequence();
	void STATIC_DoFirstShockwave();
	bool ShouldConsumePowerPoolAfterFire();
	bool ShouldConsumePowerPoolOnStartFire();
	bool STATIC_InterceptLeftMouseReleased(class ATgPlayerController* TgController);
	bool STATIC_InterceptLeftMousePressed(class ATgPlayerController* TgController);
	bool HasCachedAzaan();
	void STATIC_GetTargetingAim(struct FAimData* Aim);
	TEnumAsByte<EDeviceTargetMode> STATIC_GetTargetingMode();
	void STATIC_GetGroundTargetAim(struct FAimData* Aim);
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgDevice_AzaanWalls
// 0x005C (0x0A68 - 0x0A0C)
class ATgDevice_AzaanWalls : public ATgDevice
{
public:
	int                                                m_nWallMeshId;                                            // 0x0A0C(0x0004)
	class ATgPawn_Azaan*                               m_pAzaan;                                                 // 0x0A10(0x0008)
	unsigned long                                      m_bWasAboveThreshold : 1;                                 // 0x0A18(0x0004)
	float                                              m_fWallDistToFocalPoint;                                  // 0x0A1C(0x0004) (Const)
	float                                              m_fWallSpread;                                            // 0x0A20(0x0004) (Const)
	float                                              m_fWallDepthCheck;                                        // 0x0A24(0x0004) (Const)
	float                                              m_fWallZForgiveness;                                      // 0x0A28(0x0004) (Const)
	struct FRotator                                    m_rCachedWallAim;                                         // 0x0A2C(0x000C)
	struct FVector                                     m_vOpenSpotExtent;                                        // 0x0A38(0x000C) (Const)
	struct FVector                                     m_vCachedWallFocus;                                       // 0x0A44(0x000C)
	int                                                m_nNumberOfWalls;                                         // 0x0A50(0x0004) (Const)
	int                                                r_nActiveDeployableWalls;                                 // 0x0A54(0x0004) (Net)
	TArray<class ATgDeployable*>                       s_ActiveDeployables;                                      // 0x0A58(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_AzaanWalls");
		return ptr;
	}


	bool STATIC_InterceptSlotPressed(class ATgPlayerController* TgController);
	void STATIC_UpdateWallCount();
	void STATIC_ServerDestroyWalls();
	bool CanBeCanceled();
	void STATIC_SafetyEffectRemoval();
	bool HasCachedAzaan();
	void ServerStartFire(float MovementTimeStamp, const struct FVector& MovementInAccel, const struct FVector& MovementClientLoc, unsigned char MovementNewFlags, unsigned char MovementClientRoll, int MovementView, int ClientFireRequestId, unsigned char ClientFireMode, class AActor* HitActor, float StartTraceX, float StartTraceY, float StartTraceZ, float EndTraceX, float EndTraceY, float EndTraceZ, int nCompressedAimVector, bool bFirstBurstShot, float fAttackSpeedPercChange);
	void CallServerStartFire(const struct FAimData& Aim, bool bPendingUpdate);
	void OnDeployableDestroyed(class ATgDeployable* deployable);
	void OnDeployableSpawned(class ATgDeployable* deployable);
	void STATIC_GuardMultiProc();
	void CustomFire();
	bool Use();
	bool STATIC_IsDeviceFiringForUI();
	bool STATIC_UsesTargetingMode();
	bool STATIC_ShouldBankCooldown();
	void STATIC_NativeSpawnFlankingWalls();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgDevice_AzaanInhand
// 0x000C (0x0A28 - 0x0A1C)
class ATgDevice_AzaanInhand : public ATgDevice_ChainSequence
{
public:
	class ATgPawn_Azaan*                               m_pAzaan;                                                 // 0x0A1C(0x0008)
	float                                              m_fServerThresholdForgiveness;                            // 0x0A24(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_AzaanInhand");
		return ptr;
	}


	int GetChainMax();
	unsigned char STATIC_GetProjectileExtraInfo(unsigned char FromClient, bool bValidating);
	bool HasCachedAzaan();
};


// Class TgGame.TgDevice_AzaanDash
// 0x0018 (0x0A98 - 0x0A80)
class ATgDevice_AzaanDash : public ATgDevice_Charge
{
public:
	class ATgPawn_Azaan*                               m_pAzaan;                                                 // 0x0A80(0x0008)
	float                                              m_fWalkableFloorZ;                                        // 0x0A88(0x0004)
	class ATgPawn*                                     r_PawnTarget;                                             // 0x0A8C(0x0008) (Net)
	unsigned long                                      m_bWasAboveThreshold : 1;                                 // 0x0A94(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_AzaanDash");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	void RemoveGrabWallHitDetection(class ATgPawn* Target);
	void ApplyGrabWallHitDetection(class ATgPawn* Target);
	void BounceOff(class AActor* Target);
	bool HandleCustomWallGrabbedHit(class AActor* Target, const struct FImpactInfo& Impact, class AActor* HitActor);
	bool CanFiringBeCanceledByReactivation();
	bool CanFiringBeCanceledByRightMouse();
	bool CanFiringBeCanceledByLeftMouse();
	bool HasCachedAzaan();
	float STATIC_GetFiringPostHitDelay(int nMode);
	float STATIC_GetMoveSpeedMultiplier();
	bool PredictChargeInterrupt(const struct FVector& StartLocation, const struct FVector& endLocation);
};


// Class TgGame.TgDevice_HammerSlam
// 0x0034 (0x0A40 - 0x0A0C)
class ATgDevice_HammerSlam : public ATgDevice
{
public:
	struct FVector                                     m_vFireLoc;                                               // 0x0A0C(0x000C)
	struct FVector                                     m_vFireAim;                                               // 0x0A18(0x000C)
	TArray<class AActor*>                              m_ProjectileHits;                                         // 0x0A24(0x0010) (NeedCtorLink)
	class ATgPawn_Azaan*                               m_pAzaan;                                                 // 0x0A34(0x0008)
	unsigned long                                      m_bWasAboveThreshold : 1;                                 // 0x0A3C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_HammerSlam");
		return ptr;
	}


	void STATIC_FireAmmunition();
	bool HasCachedAzaan();
	float STATIC_GetTargetingMinRange(class UTgDeviceFire* FireMode);
	bool ShouldAltFireOnTick();
	void STATIC_DoRectangleSlam();
};


// Class TgGame.TgDeviceFire_HammerSlam
// 0x0004 (0x0278 - 0x0274)
class UTgDeviceFire_HammerSlam : public UTgDeviceFire_EncroachmentActorScale
{
public:
	unsigned long                                      m_bBlockedByWorldOnly : 1;                                // 0x0274(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_HammerSlam");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_HammerSlamStart
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_HammerSlamStart : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_HammerSlamStart");
		return ptr;
	}


	float GetCooldownTime();
};


// Class TgGame.TgDeviceForm_AzaanDash
// 0x001C (0x02A8 - 0x028C)
class UTgDeviceForm_AzaanDash : public UTgDeviceForm
{
public:
	TArray<class UTgAnimBlendByPaladinsCharacter_Azaan*> m_AzaanNodes1p;                                           // 0x028C(0x0010) (NeedCtorLink)
	int                                                m_nLastPosture;                                           // 0x029C(0x0004)
	class ATgPawn_Character*                           m_Target;                                                 // 0x02A0(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_AzaanDash");
		return ptr;
	}


	void SetPostureOnTarget(TEnumAsByte<ETG_POSTURE> newPosture);
	void StopFire(int nFireModeNum);
	void DoInterrupt();
	void Hit(int nFireMode, class AActor* Target, float fDamageAmount, const struct FVector& HitLocation, const struct FVector& HitNormal, struct FExtraDamageInfo* ExtraInfo);
	void Generic2(unsigned char byExtraData);
	void Generic1(unsigned char byExtraData);
	void CacheAnimNode(class UAnimNode* Node, bool bIs3p);
};


// Class TgGame.TgDeviceForm_AzaanUlt
// 0x0020 (0x02AC - 0x028C)
class UTgDeviceForm_AzaanUlt : public UTgDeviceForm
{
public:
	TArray<class UTgAnimNodeChannelFire_AzaanUlt*>     m_AzaanUltNodes3p;                                        // 0x028C(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeChannelFire_AzaanUlt*>     m_AzaanUltNodes1p;                                        // 0x029C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_AzaanUlt");
		return ptr;
	}


	void Generic2(unsigned char byExtraData);
	void Generic1(unsigned char byExtraData);
	void CacheAnimNode(class UAnimNode* Node, bool bIs3p);
	void ClearAnimNodes(bool bIs3p);
};


// Class TgGame.TgDeviceForm_AzaanUltSlam
// 0x0010 (0x029C - 0x028C)
class UTgDeviceForm_AzaanUltSlam : public UTgDeviceForm
{
public:
	TArray<class UTgAnimBlendByPaladinsCharacter_Azaan*> m_AzaanNodes1p;                                           // 0x028C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_AzaanUltSlam");
		return ptr;
	}


	void Generic2(unsigned char byExtraData);
	void Generic1(unsigned char byExtraData);
	void CacheAnimNode(class UAnimNode* Node, bool bIs3p);
};


// Class TgGame.TgDeviceForm_HammerSlam
// 0x0000 (0x028C - 0x028C)
class UTgDeviceForm_HammerSlam : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_HammerSlam");
		return ptr;
	}


	void STATIC_SpawnRectangleFX(const struct FVector& vLocation);
	bool STATIC_UsesTargetingMode();
};


// Class TgGame.TgInventoryObject_Listen_AzaanAbilityStartAboveThreshold
// 0x0008 (0x00D4 - 0x00CC)
class UTgInventoryObject_Listen_AzaanAbilityStartAboveThreshold : public UTgInventoryObject_Listen_AbilityStart
{
public:
	class ATgPawn_Azaan*                               m_CachedAzaan;                                            // 0x00CC(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AzaanAbilityStartAboveThreshold");
		return ptr;
	}


	bool HasCachedAzaan();
};


// Class TgGame.TgInvListener_AzaanIreConsumed
// 0x000C (0x00D0 - 0x00C4)
class UTgInvListener_AzaanIreConsumed : public UTgInvListener
{
public:
	class ATgPawn_Azaan*                               m_CachedAzaan;                                            // 0x00C4(0x0008)
	int                                                m_nPercentMultiplier;                                     // 0x00CC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_AzaanIreConsumed");
		return ptr;
	}


	bool HasCachedAzaan();
};


// Class TgGame.TgPawn_Azaan
// 0x007C (0x3354 - 0x32D8)
class ATgPawn_Azaan : public ATgPawn_Character
{
public:
	float                                              r_fIreBuff;                                               // 0x32D8(0x0004) (Net)
	float                                              m_fMaxIre;                                                // 0x32DC(0x0004)
	float                                              m_fIreDamagePercent;                                      // 0x32E0(0x0004)
	float                                              m_fIreDamageDonePercent;                                  // 0x32E4(0x0004)
	float                                              s_fIreDecayStartTime;                                     // 0x32E8(0x0004)
	float                                              m_fIreThreshold;                                          // 0x32EC(0x0004)
	float                                              m_fDRAtMax;                                               // 0x32F0(0x0004)
	float                                              m_fIreDecayDelay;                                         // 0x32F4(0x0004)
	float                                              m_fIreDecayRate;                                          // 0x32F8(0x0004)
	float                                              m_fIreDamageIncreasePercent;                              // 0x32FC(0x0004)
	float                                              m_fIreDamageDecreasePercent;                              // 0x3300(0x0004)
	float                                              m_fFrictionMultiplier;                                    // 0x3304(0x0004) (Edit)
	unsigned long                                      m_bAboveIre : 1;                                          // 0x3308(0x0004)
	unsigned long                                      m_bHasIreDrainStopTalent : 1;                             // 0x3308(0x0004)
	class ATgDevice_AzaanUlt*                          m_CachedUlt;                                              // 0x330C(0x0008)
	class ATgDevice_AzaanDash*                         m_CachedDash;                                             // 0x3314(0x0008)
	class UTgInvListener_AzaanIreConsumed*             m_CachedListener;                                         // 0x331C(0x0008)
	float                                              m_fFlightMaxRiseSpeed;                                    // 0x3324(0x0004)
	float                                              m_fUltStartHeight;                                        // 0x3328(0x0004)
	float                                              m_fMaxHoverDistance;                                      // 0x332C(0x0004) (Const)
	float                                              m_fDampenVelocityFactor;                                  // 0x3330(0x0004) (Const)
	float                                              m_fMaxUpwardsVelocity;                                    // 0x3334(0x0004) (Const)
	float                                              m_fMinUpwardsVelocity;                                    // 0x3338(0x0004) (Const)
	float                                              m_fUpwardsAccel;                                          // 0x333C(0x0004) (Const)
	struct FName                                       m_nmIreAboveThreshold;                                    // 0x3340(0x0008)
	struct FName                                       m_nmIreDropBelowThreshold;                                // 0x3348(0x0008)
	int                                                m_nIreDrainDeviceID;                                      // 0x3350(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Azaan");
		return ptr;
	}


	void OnGrabTargetDetach(TEnumAsByte<EGrabState> endingGrabState, class ATgPawn* Target, bool bInterrupted);
	void OnGrabTargetAttach(TEnumAsByte<EGrabState> newGrabState, class ATgPawn* Target);
	void STATIC_DashFearSafetyTimer();
	bool STATIC_ShouldUseGradualMovement();
	bool STATIC_IsAboveThreshold(float fForgiveness);
	void PawnOnDamageMitigation(class ATgPawn* attacker, class UTgEffectGroup* eg, int nPropertyId, float* fDamage);
	void DeviceAdjustDamage(struct FAdjustDamageParams* Params, float* fDamage);
	void STATIC_AddIre(float fAmt);
	void STATIC_SpendIre(float fAmt, bool bFromDecay);
	void DeviceOnDamaged(struct FOnDamagedParams* Params);
	void PawnOnDamaged(struct FOnDamagedParams* Params);
	void OnPawnDied();
};


// Class TgGame.TgProj_AzaanHammer
// 0x0024 (0x0550 - 0x052C)
class ATgProj_AzaanHammer : public ATgProj_Simulated
{
public:
	unsigned long                                      m_bShouldExplode : 1;                                     // 0x052C(0x0004)
	class ATgPawn_Azaan*                               m_CachedAzaan;                                            // 0x0530(0x0008)
	class AActor*                                      m_DirectHitActor;                                         // 0x0538(0x0008)
	struct FName                                       m_FxForChargedHammer;                                     // 0x0540(0x0008)
	struct FName                                       m_FxForHammerExplode;                                     // 0x0548(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_AzaanHammer");
		return ptr;
	}


	bool ApplyTheHit(class UTgDeviceFire* FireMode, const struct FImpactInfo& Impact, class AActor* DamageInstigator);
	void ExplodeOnTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool UseAOE();
	struct FName STATIC_GetExplodeInAirFxGroup();
	struct FName STATIC_GetHitWallFxGroup();
	struct FName STATIC_GetHitTargetFxGroup();
	void STATIC_HideProjectile();
	void ApplySpawnParams(float fDamageRadius, float fGeneric2);
	void CompleteInitialization(unsigned char ExtraInfo);
};


// Class TgGame.TgProj_AzaanUlt
// 0x0000 (0x052C - 0x052C)
class ATgProj_AzaanUlt : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_AzaanUlt");
		return ptr;
	}


	void RangeReached();
};


// Class TgGame.TgProj_HammerSlam
// 0x0000 (0x052C - 0x052C)
class ATgProj_HammerSlam : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_HammerSlam");
		return ptr;
	}


	void ClientExplode(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void RangeReached();
	void STATIC_HitPassThroughTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgAnimNodeBlendBySevenFireMode
// 0x0000 (0x0168 - 0x0168)
class UTgAnimNodeBlendBySevenFireMode : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendBySevenFireMode");
		return ptr;
	}


	void SetAnimState(unsigned char FireMode);
};


// Class TgGame.TgAnimNodeBlendBySevenLatch
// 0x0000 (0x0168 - 0x0168)
class UTgAnimNodeBlendBySevenLatch : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendBySevenLatch");
		return ptr;
	}


	void SetAnimState(unsigned char animState);
};


// Class TgGame.TgDevice_DropAndRoll
// 0x0008 (0x0A88 - 0x0A80)
class ATgDevice_DropAndRoll : public ATgDevice_Charge
{
public:
	class ATgPawn_Seven*                               m_CachedSeven;                                            // 0x0A80(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DropAndRoll");
		return ptr;
	}


	bool STATIC_HasCachedSevenPawn();
	bool STATIC_HasDoubleDropTalentEquipped();
};


// Class TgGame.TgDevice_SevenMaskedFear
// 0x002C (0x0A40 - 0x0A14)
class ATgDevice_SevenMaskedFear : public ATgDevice_HitPulse
{
public:
	class ATgPawn_Seven*                               m_CachedSeven;                                            // 0x0A14(0x0008)
	class AActor*                                      previousClosestTarget;                                    // 0x0A1C(0x0008)
	int                                                ULT_EYE_SOCKET;                                           // 0x0A24(0x0004) (Const)
	TArray<struct FFearTarget>                         m_TrackedFearedTargets;                                   // 0x0A28(0x0010) (NeedCtorLink)
	float                                              m_fTimeFocusedOnThreshold;                                // 0x0A38(0x0004)
	float                                              m_fTimeFocusedOnThresholdExplosionTalent;                 // 0x0A3C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_SevenMaskedFear");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	void STATIC_UseUltEnergy();
	bool STATIC_HasCachedSevenPawn();
	void STATIC_UpdateBeamVFXStandalone(class AActor* TargetActor);
	void STATIC_UpdateUltHUD(bool bShow);
	void STATIC_ApplyUltExplosion(class AActor* HitActor);
	void STATIC_IgnoreDeliverHit();
	void STATIC_ClientUpdateMarkForFearTarget(class AActor* actorFearTarget, bool bAdd);
	void STATIC_ClientUpdateTrackedUITargets(class AActor* actorUITarget, bool bAdd);
	bool STATIC_IsValidUltTarget(class AActor* pTarget);
	float Distance(const struct FVector& v1, const struct FVector& v2);
	void DeliverHit(const struct FImpactInfo& Impact);
	void DeliverQueuedPendingHits();
	void STATIC_BreakBeamEffects();
	bool CanFiringBeCanceledByLeftMouse();
	bool CanBeCanceled();
};


// Class TgGame.TgDevice_SevenLatch
// 0x0018 (0x0A6C - 0x0A54)
class ATgDevice_SevenLatch : public ATgDevice_Latch
{
public:
	class ATgPawn_Seven*                               m_CachedSeven;                                            // 0x0A54(0x0008)
	unsigned long                                      m_bIsReadyForLatch : 1;                                   // 0x0A5C(0x0004)
	unsigned long                                      m_bIsReadyForUnLatchLaunch : 1;                           // 0x0A5C(0x0004)
	unsigned long                                      m_bHasLatched : 1;                                        // 0x0A5C(0x0004)
	int                                                m_nWallUnlatchImpulseSpeed;                               // 0x0A60(0x0004)
	int                                                m_nTotalLatchTime;                                        // 0x0A64(0x0004) (Const)
	int                                                m_nFrontLineNum;                                          // 0x0A68(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_SevenLatch");
		return ptr;
	}


	float GetCustomTimerBarMaxTime();
	float GetCustomTimerBarCurrentTime();
	bool ShouldCancelStealth();
	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	void STATIC_StartFlyingAnimation();
	void STATIC_FireAmmunition();
	void STATIC_DelayedDeactivateHover();
	void STATIC_ClientClearUnlatchTimer();
	void STATIC_ClearUnlatchTimers();
	void STATIC_RemoveSelfStealth();
	void UnlatchFromWall(bool bShouldNotPushOffWall);
	void STATIC_ClientStartUnlatchTimer();
	void STATIC_SetUpUnlatchTimers();
	void StartWallLatch();
	void EndPull();
	void STATIC_ResetGrappleAnim();
	void STATIC_Yank();
	bool StartFire();
	void OnOwnerLiveRespawn();
	void OnOwnerRespawn();
	void STATIC_ActivateHover();
	bool STATIC_SpawnDoorBlocks(class AActor* pTarget);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
	bool ShouldInterruptStealth();
};


// Class TgGame.TgDevice_SevenInhand
// 0x0030 (0x0A3C - 0x0A0C)
class ATgDevice_SevenInhand : public ATgDevice
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_MoveSpeedMultiplier;           // 0x0A0C(0x0008) (Const, Native, NoExport)
	int                                                m_nBurstModTotalShots[0x5];                               // 0x0A14(0x0004)
	float                                              m_fPerFiremodeRecoil[0x5];                                // 0x0A28(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_SevenInhand");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	void PlayClientFireFx(const struct FVector& HitLocation, int nSocketIndex, bool bSuccessfulHit, float fRefireTime, int nShotsFired);
	bool STATIC_HasElementalTalentEquipped();
	void STATIC_ProcessElementalEffects(const struct FImpactInfo& Impact);
	void DeliverHit(const struct FImpactInfo& Impact);
	float STATIC_GetMagDumpRecoilMultiplier();
	float STATIC_GetRecoilMultiplier();
	void OnOwnerRespawn();
	void OnOwnerLiveRespawn();
	bool STATIC_ShouldUseGradualMovement();
	float STATIC_GetMoveSpeedMultiplier();
	void SetFireMode(int nFireModeNum, bool ForceSet);
};


// Class TgGame.TgDevice_SevenLatchMod
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_SevenLatchMod : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_SevenLatchMod");
		return ptr;
	}

};


// Class TgGame.TgDevice_SevenDROnLatch
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_SevenDROnLatch : public ATgDevice_SevenLatchMod
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_SevenDROnLatch");
		return ptr;
	}

};


// Class TgGame.TgDevice_SevenHealOnLatch
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_SevenHealOnLatch : public ATgDevice_SevenLatchMod
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_SevenHealOnLatch");
		return ptr;
	}

};


// Class TgGame.TgDevice_SevenSwitchFiremode
// 0x0000 (0x0A14 - 0x0A14)
class ATgDevice_SevenSwitchFiremode : public ATgDevice_ToggleInhandFiremode
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_SevenSwitchFiremode");
		return ptr;
	}


	bool ShouldInterruptInhand();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgDeviceForm_SevenLatch
// 0x0028 (0x02EC - 0x02C4)
class UTgDeviceForm_SevenLatch : public UTgDeviceForm_Latch
{
public:
	TArray<class UTgAnimNodeBlendBySevenLatch*>        m_SevenLatchNodes3p;                                      // 0x02C4(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeBlendBySevenLatch*>        m_SevenLatchNodes1p;                                      // 0x02D4(0x0010) (NeedCtorLink)
	class UTgSkelCon_RotateToNormal*                   m_SkelRotateNode;                                         // 0x02E4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_SevenLatch");
		return ptr;
	}


	void Cache3PAnimNodes(class UTgSkeletalMeshComponent* SkelComp);
	void Generic2(unsigned char byExtraData);
	void CacheAnimNode(class UAnimNode* Node, bool bIs3p);
	void ClearAnimNodes(bool bIs3p);
	void STATIC_SetSkelNormal(const struct FVector& vNormal);
};


// Class TgGame.TgDeviceForm_SevenInhand
// 0x0040 (0x02CC - 0x028C)
class UTgDeviceForm_SevenInhand : public UTgDeviceForm
{
public:
	TArray<class UTgAnimNodeBlendBySevenFireMode*>     m_SevenInhandNodes3p;                                     // 0x028C(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeBlendBySevenFireMode*>     m_SevenInhandNodes1p;                                     // 0x029C(0x0010) (NeedCtorLink)
	class ATgPawn_Seven*                               m_CachedSeven;                                            // 0x02AC(0x0008)
	float                                              m_fHeatBuildup;                                           // 0x02B4(0x0004)
	float                                              m_fHeatBuildupPerShotPerFireMode[0x3];                    // 0x02B8(0x0004)
	float                                              m_fMaxHeatBuildup;                                        // 0x02C4(0x0004)
	float                                              m_fHeatDecayFactor;                                       // 0x02C8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_SevenInhand");
		return ptr;
	}


	void Generic1(unsigned char byExtraData);
	void CacheAnimNode(class UAnimNode* Node, bool bIs3p);
	void ClearAnimNodes(bool bIs3p);
	void Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	bool STATIC_HasCachedSeven();
};


// Class TgGame.TgDeviceForm_SevenUlt
// 0x0018 (0x02A4 - 0x028C)
class UTgDeviceForm_SevenUlt : public UTgDeviceForm
{
public:
	class UTgBeamHelper*                               m_Beam;                                                   // 0x028C(0x0008)
	class ATgPawn_Seven*                               m_CachedSeven;                                            // 0x0294(0x0008)
	class UTgSkeletalMeshComponent_Weapon*             m_Cached1PWepMesh;                                        // 0x029C(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_SevenUlt");
		return ptr;
	}


	bool STATIC_HasCached1PWeaponMesh();
	bool STATIC_HasCachedSevenPawn();
	void StopFire(int nFireModeNum);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	void ConnectBeamToTarget(class AActor* Target);
	void STATIC_UpdateBeamFromStandalone(class AActor* Target);
	void STATIC_UpdateBeamByTarget();
};


// Class TgGame.TgPawn_Seven
// 0x007C (0x3354 - 0x32D8)
class ATgPawn_Seven : public ATgPawn_Character
{
public:
	class ATgDevice_SevenLatch*                        m_CachedLatch;                                            // 0x32D8(0x0008)
	class ATgDevice_SevenInhand*                       m_CachedInhand;                                           // 0x32E0(0x0008)
	class ATgDevice_SevenMaskedFear*                   m_CachedUltDevice;                                        // 0x32E8(0x0008)
	class ATgDevice_SevenExplosiveUltTalent*           m_CachedExplosiveUltTalent;                               // 0x32F0(0x0008)
	float                                              m_fMiniumHeightFromGroundForLatch;                        // 0x32F8(0x0004)
	unsigned long                                      r_bHasElementalTalent : 1;                                // 0x32FC(0x0004) (Net)
	unsigned long                                      r_bHasDoubleDropTalent : 1;                               // 0x32FC(0x0004) (Net)
	int                                                r_nClosestTargetDistance;                                 // 0x3300(0x0004) (Net)
	class AActor*                                      r_BeamTarget;                                             // 0x3304(0x0008) (Net)
	struct FSevenMarkedTargetInfo                      r_SevenMarkedTargets[0x5];                                // 0x330C(0x0008) (Net)
	TArray<int>                                        m_ClientMarkedForFearTargets;                             // 0x3334(0x0010) (NeedCtorLink)
	TArray<class AActor*>                              m_ClientUITrackedTargets;                                 // 0x3344(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Seven");
		return ptr;
	}


	void STATIC_UpdateBeam();
	void ReplicatedEvent(const struct FName& VarName);
	void UpdateSevenSkelNormal(const struct FVector& vNormal);
	void STATIC_EndWallLatchForRoll();
	int STATIC_GetUISkillEqpSlotOverride(int nEquipSlot, TEnumAsByte<EUI_SKILL_EQUIP_SLOT> eUISlot, bool bBaseSkillOnly, bool bGamepadUI);
	void OnMarkedTarget(int nTargetPawnId, int nMarkCountChange);
};


// Class TgGame.TgDeploy_BombQueenBombBag
// 0x0068 (0x04D4 - 0x046C)
class ATgDeploy_BombQueenBombBag : public ATgDeployable
{
public:
	class UTgDeviceMod_Burst*                          m_BurstMod;                                               // 0x046C(0x0008)
	TArray<int>                                        m_nDeployIndices;                                         // 0x0474(0x0010) (NeedCtorLink)
	TArray<struct FVector>                             m_vDeployLocations;                                       // 0x0484(0x0010) (NeedCtorLink)
	float                                              m_fZOffSet;                                               // 0x0494(0x0004) (Const)
	struct FVector                                     m_vSpawnFocusOffset;                                      // 0x0498(0x000C) (Const)
	int                                                m_nRandIterations;                                        // 0x04A4(0x0004) (Const)
	float                                              m_fRandOffsetMult;                                        // 0x04A8(0x0004) (Const)
	float                                              m_fMaxSeedRange;                                          // 0x04AC(0x0004) (Const)
	float                                              m_fBombExplodeTime;                                       // 0x04B0(0x0004) (Const)
	float                                              m_fBombFXTimer;                                           // 0x04B4(0x0004) (Const)
	float                                              m_fBombInitVelocity;                                      // 0x04B8(0x0004) (Const)
	int                                                m_nSubDeviceID;                                           // 0x04BC(0x0004) (Const)
	float                                              m_fSeed;                                                  // 0x04C0(0x0004)
	class ATgDevice_BombQueenAbility1*                 m_SpawnerDevice;                                          // 0x04C4(0x0008)
	struct FPointer                                    m_RandomShotSpreadStream;                                 // 0x04CC(0x0008) (Const, Native, Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_BombQueenBombBag");
		return ptr;
	}


	class AProjectile* ProjectileFireDeployable();
	struct FVector STATIC_GetPhysicalFireAimDirection(const struct FVector& FireLoc, const struct FVector& TargetLocation);
	struct FVector STATIC_GetPhysicalFireStartLoc();
	void STATIC_RandomizeDeployIndices(class ATgPawn_BombQueen* PawnOwner);
	float STATIC_GetCustomValue2();
	float STATIC_GetCustomValue1();
	class UTgDeviceFire* STATIC_GetUpdatableFiremode();
	void STATIC_SetSeedAndDelayBegin(float fSeed, float fTimeToStart, class ATgPawn_BombQueen* bombQueen);
	void STATIC_InitializeDeployIndices();
	void TimeDeviceFiring();
	void STATIC_FireAmmunitionDeployable();
	void RefireCheckTimer();
	void STATIC_DelayedBeginLogic();
	void STATIC_ClientControllerStartBombBag(int nPawnId, const struct FCLIENT_PAWN_FUNCTION_ARGS& args);
	float STATIC_GetRandFraction();
	void STATIC_SetSeed(float fSeed);
};


// Class TgGame.TgDevice_BombQueenAbility1
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_BombQueenAbility1 : public ATgDevice
{
public:
	class ATgPawn_BombQueen*                           m_pBombQueen;                                             // 0x0A0C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_BombQueenAbility1");
		return ptr;
	}


	bool STATIC_HasCachedBombQueen();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgDevice_BombQueenAltfire
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_BombQueenAltfire : public ATgDevice
{
public:
	class ATgPawn_BombQueen*                           m_pBombQueen;                                             // 0x0A0C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_BombQueenAltfire");
		return ptr;
	}


	bool STATIC_HasCachedBombQueen();
	void DeviceAdjustDamage(int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
};


// Class TgGame.TgDevice_BombQueenBagSubdevice
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_BombQueenBagSubdevice : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_BombQueenBagSubdevice");
		return ptr;
	}

};


// Class TgGame.TgDevice_BombQueenInhand
// 0x0008 (0x0A34 - 0x0A2C)
class ATgDevice_BombQueenInhand : public ATgDevice_BuckInhand
{
public:
	class ATgPawn_BombQueen*                           m_pBombQueen;                                             // 0x0A2C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_BombQueenInhand");
		return ptr;
	}


	void PlayClientFireFx(const struct FVector& HitLocation, int nSocketIndex, bool bSuccessfulHit, float fRefireTime, int nShotsFired);
	bool STATIC_HasCachedBombQueen();
	bool CanSpawnOnClientFirst(class UClass* ProjectileClass, bool bUsesTrackingTarget);
};


// Class TgGame.TgDevice_BombQueenUlt
// 0x0018 (0x0A98 - 0x0A80)
class ATgDevice_BombQueenUlt : public ATgDevice_Charge
{
public:
	float                                              m_fHasExplodedResetFailsafeTime;                          // 0x0A80(0x0004)
	unsigned long                                      m_bHasExploded : 1;                                       // 0x0A84(0x0004)
	unsigned long                                      s_bAllowServerChargeStop : 1;                             // 0x0A84(0x0004)
	float                                              m_fFireMissileDelay;                                      // 0x0A88(0x0004)
	class ATgPawn_BombQueen*                           m_CachedBombQueen;                                        // 0x0A8C(0x0008)
	float                                              m_fChargeSpeed;                                           // 0x0A94(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_BombQueenUlt");
		return ptr;
	}


	void BounceOff();
	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	bool STATIC_HasCachedBombQueen();
	class ATgProj_Simulated* SpawnMissile();
	bool STATIC_OverrideProjectileAim(struct FAimData* Aim);
	class AProjectile* ProjectileFire(int ProjectileIndex);
	void STATIC_FireAmmunition();
	void STATIC_UnlockInputSafely();
	void STATIC_LockInputSafely();
	bool STATIC_DoReactivationCancelLogic(unsigned char* bSuccessfulCancel);
	bool CanBeCanceled();
	void ExplodeAt(const struct FVector& vLoc);
	void ServerCueEarlyEnd(bool bProjectileFire, float fTotalPrefire);
	void ClientAckEarlyEnd(bool bProjectileFire, float fTotalPrefire);
	bool STATIC_InterceptLeftMousePressed(class ATgPlayerController* TgController);
	bool CanFiringBeCanceledByLeftMouse();
	void STATIC_ClientInitiateFireMissile();
	void STATIC_CueFireMissile(float fDelay, bool bForce);
	void STATIC_PerformFireMissile();
	void STATIC_AnticipateFireMissile();
	void OnHitValidWall(class AActor* HitActor);
	float STATIC_GetChargeSpeed();
	bool STATIC_ShouldExplode();
	void STATIC_ResetHasExploded();
	bool ShouldInstigatorCollideWith(class AActor* Other);
};


// Class TgGame.TgDevice_ExplosiveJumps
// 0x000C (0x0A20 - 0x0A14)
class ATgDevice_ExplosiveJumps : public ATgDevice_Leap
{
public:
	int                                                m_nShotsFired;                                            // 0x0A14(0x0004)
	class ATgDevice_BombQueenInhand*                   m_Inhand;                                                 // 0x0A18(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ExplosiveJumps");
		return ptr;
	}


	bool ShouldInterruptReloadOnFire();
	int STATIC_GetTotalNumberOfShots();
	void StartCooldown(int nMode, float fCooldownTimeOverride);
	bool ShouldCooldownAfterFire();
	void RefireTimer();
	struct FVector STATIC_ApplyRandomRotation(const struct FVector& vJumpVelocity);
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgDeviceFire_BombBag
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_BombBag : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_BombBag");
		return ptr;
	}

};


// Class TgGame.TgPawn_BombQueen
// 0x00A8 (0x3380 - 0x32D8)
class ATgPawn_BombQueen : public ATgPawn_Character
{
public:
	class ATgDevice_BombQueenUlt*                      m_CachedUlt;                                              // 0x32D8(0x0008)
	class ATgBombBagBombProp*                          m_Props[0x10];                                            // 0x32E0(0x0008)
	int                                                m_nPropIndex;                                             // 0x3360(0x0004)
	int                                                m_nDefaultBombPropId;                                     // 0x3364(0x0004) (Const)
	int                                                m_nTalent1DeviceId;                                       // 0x3368(0x0004)
	float                                              m_fTalent3Scaling;                                        // 0x336C(0x0004)
	class UTgDeviceFire*                               m_RangeCardFiremode;                                      // 0x3370(0x0008)
	class UTgDeviceFire*                               m_Talent1Firemode;                                        // 0x3378(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_BombQueen");
		return ptr;
	}


	void STATIC_GameSpawnBombProp(const struct FVector& vLocation, const struct FVector& vRotation, class UTgDeviceFire* FireMode, float fInitVelocityMult, float fExplodeTime, float fFXSafetyTime);
	class ATgBombBagBombProp* STATIC_GetBombProp();
	bool PostPawnSetup();
	void PostBeginPlay();
	void STATIC_InitBombProps();
	void STATIC_ClientBombBagDelayBegin(float fSeed, float fTimeAfterCreation, class ATgDeployable* pDeploy);
	void StartClientBombBagDelayBegin(float fSeed, float fTimeAfterCreation, class ATgDeployable* pDeploy);
	int STATIC_GetBombPropAsmId();
	float STATIC_GetDiminishedGroundSpeed();
	struct FVector STATIC_GetChargeDirection();
	void DeviceOnDamaged(struct FOnDamagedParams* Params);
};


// Class TgGame.TgProj_BombBagBomb
// 0x0008 (0x0588 - 0x0580)
class ATgProj_BombBagBomb : public ATgProj_FreeGrenade
{
public:
	float                                              m_fMaxUndampenedZBounce;                                  // 0x0580(0x0004)
	float                                              m_fBounceGravityZMultiplier;                              // 0x0584(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_BombBagBomb");
		return ptr;
	}


	void ApplyBounceDamping(float fBounceDamping, struct FVector* vBounceVelocity);
	void ApplyBounce(const struct FVector& HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp);
	void OnLand();
	void LoadFiremodeProp(int nPropId, float fValue);
};


// Class TgGame.TgProj_BombBagSpawn
// 0x0008 (0x0588 - 0x0580)
class ATgProj_BombBagSpawn : public ATgProj_FreeGrenade
{
public:
	class ATgDeploy_BombQueenBombBag*                  m_SpawnedDeployable;                                      // 0x0580(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_BombBagSpawn");
		return ptr;
	}


	void ExplodeOnTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	class ATgDeployable* SpawnDeployable(const struct FVector& vLocation, class AActor* TargetActor, const struct FVector& vNormal);
};


// Class TgGame.TgProj_BombQueenInhand
// 0x0000 (0x0580 - 0x0580)
class ATgProj_BombQueenInhand : public ATgProj_FreeGrenade
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_BombQueenInhand");
		return ptr;
	}


	void PostProjectileInitialize();
	void ExplodeOnTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgProj_ClusterGrenade
// 0x0050 (0x05D0 - 0x0580)
class ATgProj_ClusterGrenade : public ATgProj_FreeGrenade
{
public:
	int                                                m_nSecondaryProjToSpawn;                                  // 0x0580(0x0004)
	int                                                m_nSpawnsRemaining;                                       // 0x0584(0x0004)
	class USkeletalMeshComponent*                      m_CachedSMC;                                              // 0x0588(0x0008) (ExportObject, Component, EditInline)
	class UTgSkelControlSingleBone*                    m_GrenadeSkelControl;                                     // 0x0590(0x0008)
	class UTgSkelControlSingleBone*                    m_SpikesSkelControl;                                      // 0x0598(0x0008)
	class UMaterialInstanceConstant*                   m_fCachedMIC;                                             // 0x05A0(0x0008)
	struct FRotator                                    m_rRotationalVelocity;                                    // 0x05A8(0x000C)
	class UTgSilhouetteComponent*                      m_Silhouette;                                             // 0x05B4(0x0008) (ExportObject, Component, EditInline)
	struct FLinearColor                                m_LocalSilhouetteColor;                                   // 0x05BC(0x0010)
	unsigned long                                      m_bSilhouetteInitialized : 1;                             // 0x05CC(0x0004)
	unsigned long                                      m_bSilhouetteAllowed : 1;                                 // 0x05CC(0x0004)
	unsigned long                                      m_bBuildupSoundPlayed : 1;                                // 0x05CC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_ClusterGrenade");
		return ptr;
	}


	void StartLandExplodeTimer();
	float STATIC_GetPostLandDuration();
	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
	void PostBeginPlay();
	void InitializeSilhouetteComponent();
	struct FVector STATIC_GetRotatedAim(const struct FVector& initialAim, int Angle);
};


// Class TgGame.TgProj_ClusterGrenadeSecondary
// 0x0008 (0x05D8 - 0x05D0)
class ATgProj_ClusterGrenadeSecondary : public ATgProj_ClusterGrenade
{
public:
	unsigned long                                      m_bInitialized : 1;                                       // 0x05D0(0x0004)
	float                                              m_fGrowthLifetime;                                        // 0x05D4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_ClusterGrenadeSecondary");
		return ptr;
	}

};


// Class TgGame.TgBombBagBombProp
// 0x0013 (0x02A4 - 0x0291)
class ATgBombBagBombProp : public ATgPropActor
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0291(0x0003) MISSED OFFSET
	class ATgPawn*                                     m_Owner;                                                  // 0x0294(0x0008)
	class UTgDeviceFire*                               m_FireMode;                                               // 0x029C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBombBagBombProp");
		return ptr;
	}


	void STATIC_SafetyClearExplodeFX();
	void Explode();
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgDeploy_VampireBloodPool
// 0x0008 (0x04A8 - 0x04A0)
class ATgDeploy_VampireBloodPool : public ATgDeploy_EffectField
{
public:
	float                                              c_BloodPoolAdjustCollisionRadius;                         // 0x04A0(0x0004) (Const)
	float                                              r_fRadiusForFX;                                           // 0x04A4(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_VampireBloodPool");
		return ptr;
	}


	void ScaleAbilityFX();
	void ScaleCollisionProxy();
	void ReplicatedEvent(const struct FName& VarName);
};


// Class TgGame.TgDevice_VampireMovement
// 0x0010 (0x0A24 - 0x0A14)
class ATgDevice_VampireMovement : public ATgDevice_Leap
{
public:
	class ATgPawn_Vampire*                             m_CacheVampire;                                           // 0x0A14(0x0008)
	float                                              m_fLerpTime;                                              // 0x0A1C(0x0004)
	unsigned long                                      m_bShouldSpawnBloodPool : 1;                              // 0x0A20(0x0004)
	unsigned long                                      m_bFoundGroundSpot : 1;                                   // 0x0A20(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_VampireMovement");
		return ptr;
	}


	void STATIC_SpawnBloodPoolAfterPlunge();
	void STATIC_SpendBloodVampireF();
	void DoVampirePlunge(const struct FVector& vTargetLocation);
	void STATIC_ServerFindGroundBeneath();
	bool STATIC_InterceptSlotPressed(class ATgPlayerController* TgController);
	void STATIC_FindGroundBeneathForPlunge();
	bool STATIC_HasCachedVampire();
	float STATIC_GetMovementBloodDiscount();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgDevice_VampireAltfire
// 0x002C (0x0A38 - 0x0A0C)
class ATgDevice_VampireAltfire : public ATgDevice
{
public:
	class ATgPawn_Vampire*                             m_CachedVampire;                                          // 0x0A0C(0x0008)
	int                                                m_nMaxMarks;                                              // 0x0A14(0x0004)
	unsigned long                                      m_bFoundTarget : 1;                                       // 0x0A18(0x0004)
	float                                              m_fDefaultAllyHealingInterval;                            // 0x0A1C(0x0004)
	class ATgPawn_Character*                           m_CandidateMarkTarget;                                    // 0x0A20(0x0008)
	class ATgPawn_Character*                           m_CurrentMarkTarget;                                      // 0x0A28(0x0008)
	class UTgDeviceFire_CustomEffect*                  m_MarkDeviceMode;                                         // 0x0A30(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_VampireAltfire");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	bool CanDeviceStartFiringNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDebugRelevant, bool bIgnoreCachedValue, TEnumAsByte<EDeviceFailType>* failType);
	void ServerStartFire(float MovementTimeStamp, const struct FVector& MovementInAccel, const struct FVector& MovementClientLoc, unsigned char MovementNewFlags, unsigned char MovementClientRoll, int MovementView, int ClientFireRequestId, unsigned char ClientFireMode, class AActor* HitActor, float StartTraceX, float StartTraceY, float StartTraceZ, float EndTraceX, float EndTraceY, float EndTraceZ, int nCompressedAimVector, bool bFirstBurstShot, float fAttackSpeedPercChange);
	void CallServerStartFire(const struct FAimData& Aim, bool bPendingUpdate);
	void StartCooldown(int nMode, float fCooldownTimeOverride);
	void InstantFire();
	bool STATIC_HasMarkDeviceMode();
	void STATIC_ApplyAllyHealing(class ATgPawn* Target, int nStackAmount);
	class ATgPawn_Character* STATIC_QueryForTarget();
	int STATIC_GetMaxMarks();
};


// Class TgGame.TgDevice_VampireBloodManager
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_VampireBloodManager : public ATgDevice
{
public:
	class ATgPawn_Vampire*                             m_CacheVampire;                                           // 0x0A0C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_VampireBloodManager");
		return ptr;
	}


	void STATIC_VampireOutOfCombatBloodRegen();
	bool STATIC_HasCachedVampire();
};


// Class TgGame.TgDevice_VampireInhand
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_VampireInhand : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_VampireInhand");
		return ptr;
	}

};


// Class TgGame.TgDevice_VampireQ
// 0x0024 (0x0A30 - 0x0A0C)
class ATgDevice_VampireQ : public ATgDevice
{
public:
	class ATgPawn_Vampire*                             m_CacheVampire;                                           // 0x0A0C(0x0008)
	float                                              m_fTraceDownDistance;                                     // 0x0A14(0x0004)
	float                                              m_fBloodRegenPrecent;                                     // 0x0A18(0x0004)
	float                                              m_fCachedChargedTime;                                     // 0x0A1C(0x0004)
	TArray<class ATgDeploy_VampireBloodPool*>          s_BloodPools;                                             // 0x0A20(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_VampireQ");
		return ptr;
	}


	void STATIC_SpendBloodVampireQ();
	int GetDeloyFireModeOverride();
	void SetFireHoldAmt(float fFireHoldTime);
	void OnDeployableDestroyed(class ATgDeployable* deployable);
	void OnDeployableSpawned(class ATgDeployable* deployable);
	bool STATIC_InterceptRightMousePressed(class ATgPlayerController* TgController);
	bool CanBeCanceled();
	float STATIC_GetFirstChargeValueForUIBar();
	void STATIC_UpdateTargetingModeStatus(struct FAimData* Aim);
	void STATIC_GetGroundTargetAim(struct FAimData* Aim);
	bool STATIC_HasCachedVampire();
	float STATIC_GetQBloodDiscount();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgDevice_VampireUlt
// 0x000C (0x0A18 - 0x0A0C)
class ATgDevice_VampireUlt : public ATgDevice
{
public:
	class ATgPawn_Vampire*                             m_CacheVampire;                                           // 0x0A0C(0x0008)
	unsigned long                                      m_bCanBlockShootingDuringUlt : 1;                         // 0x0A14(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_VampireUlt");
		return ptr;
	}


	void STATIC_AutoBloodRegen();
	void STATIC_ApplyEffectsToPawns();
	bool STATIC_HasCachedVampire();
};


// Class TgGame.TgInventoryObject_Listen_Combo_Vampire
// 0x0004 (0x00D0 - 0x00CC)
class UTgInventoryObject_Listen_Combo_Vampire : public UTgInventoryObject_Listen_Combo
{
public:
	int                                                m_nNumContacts;                                           // 0x00CC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Combo_Vampire");
		return ptr;
	}

};


// Class TgGame.TgPawn_Vampire
// 0x0038 (0x3310 - 0x32D8)
class ATgPawn_Vampire : public ATgPawn_Character
{
public:
	float                                              m_fMarkBreakDelay;                                        // 0x32D8(0x0004) (Const)
	float                                              m_fMaxMarkRangeFeet;                                      // 0x32DC(0x0004) (Const)
	unsigned long                                      m_bMarkViewConstraint : 1;                                // 0x32E0(0x0004) (Const)
	unsigned long                                      m_bMarkLoSConstraint : 1;                                 // 0x32E0(0x0004) (Const)
	unsigned long                                      m_bMarkRefreshesEffects : 1;                              // 0x32E0(0x0004) (Const)
	unsigned long                                      m_bWhileEnemyMarkedEffectsApplied : 1;                    // 0x32E0(0x0004)
	unsigned long                                      m_bWhileFriendlyMarkedEffectsApplied : 1;                 // 0x32E0(0x0004)
	unsigned long                                      m_bMarkedPawnsNetworkUpdate : 1;                          // 0x32E0(0x0004)
	float                                              m_fMarkLoSFoVClient;                                      // 0x32E4(0x0004) (Const)
	float                                              m_fMarkLoSFoVServerGrace;                                 // 0x32E8(0x0004) (Const)
	class ATgDevice_VampireAltfire*                    m_CachedVampireMark;                                      // 0x32EC(0x0008)
	float                                              m_fBloodReduceCostMulti;                                  // 0x32F4(0x0004)
	int                                                r_nMarkedPawnIds[0x2];                                    // 0x32F8(0x0004) (Net)
	TArray<struct FVampMark>                           m_ActiveMarks;                                            // 0x3300(0x0010) (AlwaysInit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Vampire");
		return ptr;
	}


	void STATIC_SpendBlood(float fBloodAmount, bool bConsumeAllRemaingBlood);
	void PostBeginPlay();
	void ReplicatedEvent(const struct FName& VarName);
	void DeviceOnDamaged(struct FOnDamagedParams* Params);
	void TakeHealing(float fHealAmount, bool bSelf, int nHealingDeviceId);
	void STATIC_BloodHealing(float fHealAmount);
	bool STATIC_HasEnoughBlood(float fHealthAmount);
	void STATIC_ClientUpdateMarkedPawns();
	bool STATIC_IsPawnMarked(class ATgPawn* QueryTarget);
	void STATIC_RemoveMark(class ATgPawn* MarkTarget);
	void RemoveMarkByIndex(int nIndex);
	void AddMark(class ATgPawn* MarkedTarget);
	bool STATIC_RemoveMarkedEffects(class ATgPawn* MarkedTarget);
	bool STATIC_ApplyMarkedEffects(class ATgPawn* MarkedTarget);
	float STATIC_GetMarkBreakDelay();
	void STATIC_PawnOnKilledGlobal(class AActor* Victim, class AActor* Killer, TArray<class ATgRepInfo_Player*> AssistingPlayers);
	void STATIC_ApplyMarkKillBonus(class ATgPawn* InstigatedBy, bool bAssist);
	class UTgDeviceFire* STATIC_GetBloodBonusFiremode();
};


// Class TgGame.TgAnimNodeChannelFire_CaspianMovement
// 0x0001 (0x0181 - 0x0180)
class UTgAnimNodeChannelFire_CaspianMovement : public UTgAnimNodeChannelFire
{
public:
	TEnumAsByte<ECaspianMovementAnimState>             m_eAnimState;                                             // 0x0180(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeChannelFire_CaspianMovement");
		return ptr;
	}


	void SetAnimState(TEnumAsByte<ECaspianMovementAnimState> animState);
};


// Class TgGame.TgDevice_CaspianAltfire
// 0x0014 (0x0A20 - 0x0A0C)
class ATgDevice_CaspianAltfire : public ATgDevice
{
public:
	class ATgPawn_Caspian*                             m_pCaspian;                                               // 0x0A0C(0x0008)
	class ATgDevice*                                   m_CachedInhand;                                           // 0x0A14(0x0008)
	float                                              m_fPostHitLockOutThreshold;                               // 0x0A1C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CaspianAltfire");
		return ptr;
	}


	void STATIC_PrepReload();
	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
	void ReloadAmmo(bool bToFull, bool bShouldValidate);
	void SetAmmo(int AmmoCount, int ClipSize, bool bShouldValidate, int ValidationIDOverride);
	bool UsesSimulatedAmmo();
	void ConsumeAmmo(int Amount, bool bShouldValidate);
	void STATIC_FireAmmunition();
	bool STATIC_HasCachedCaspian();
	float STATIC_GetFiringPostHitDelay(int nMode);
	float STATIC_GetFiringPreHitDelay(int nMode);
	bool CanBeSilenced();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	bool ShouldBlockReload(class ATgDevice* Dev, bool bIsAutoReload);
	bool STATIC_HasAmmo();
	bool STATIC_IsReloading();
	int STATIC_GetCurrentAmmoAmount();
	bool RequiresAmmoToFire();
};


// Class TgGame.TgDevice_CaspianQ
// 0x000C (0x0A18 - 0x0A0C)
class ATgDevice_CaspianQ : public ATgDevice
{
public:
	float                                              m_fValidationWindowTime;                                  // 0x0A0C(0x0004)
	class ATgPawn_Caspian*                             m_pCaspian;                                               // 0x0A10(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CaspianQ");
		return ptr;
	}


	unsigned char STATIC_GetProjectileExtraInfo(unsigned char FromClient, bool bValidating);
	bool STATIC_HasCachedCaspian();
};


// Class TgGame.TgDevice_CaspianQTalent
// 0x0000 (0x0A18 - 0x0A18)
class ATgDevice_CaspianQTalent : public ATgDevice_CaspianQ
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CaspianQTalent");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	bool CanSpawnOnClientFirst(class UClass* ProjectileClass, bool bUsesTrackingTarget);
};


// Class TgGame.TgDevice_CaspianUlt
// 0x0018 (0x0A24 - 0x0A0C)
class ATgDevice_CaspianUlt : public ATgDevice
{
public:
	class ATgDevice_CaspianUltFire*                    m_CaspianUltFire;                                         // 0x0A0C(0x0008)
	class ATgPawn_Caspian*                             m_pCaspian;                                               // 0x0A14(0x0008)
	float                                              c_fClientFalsePostHitTime;                                // 0x0A1C(0x0004)
	float                                              m_fSwordInitializationTimeout;                            // 0x0A20(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CaspianUlt");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
	void DeactivateAllSwords();
	void EarlyOut();
	void STATIC_FireAmmunition();
	void Tick(float DeltaSeconds);
	bool ShouldInterruptInhand();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	bool STATIC_IsDeviceFiringForUI();
	bool STATIC_IsInFalsePostfire();
};


// Class TgGame.TgDevice_CaspianUltFire
// 0x0010 (0x0A1C - 0x0A0C)
class ATgDevice_CaspianUltFire : public ATgDevice
{
public:
	class ATgDevice_CaspianUlt*                        m_CaspianUlt;                                             // 0x0A0C(0x0008)
	class ATgPawn_Caspian*                             m_pCaspian;                                               // 0x0A14(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CaspianUltFire");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
	struct FVector GetProjectileSpawnOffset();
	bool ShouldInterruptInhand();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgDevice_CaspianInhand
// 0x0018 (0x0A34 - 0x0A1C)
class ATgDevice_CaspianInhand : public ATgDevice_ChainSequence
{
public:
	class ATgPawn_Caspian*                             m_pCaspian;                                               // 0x0A1C(0x0008)
	TArray<class AActor*>                              m_HitActors;                                              // 0x0A24(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CaspianInhand");
		return ptr;
	}


	void PlayClientFireFx(const struct FVector& HitLocation, int nSocketIndex, bool bSuccessfulHit, float fRefireTime, int nShotsFired);
	int GetChainMax();
	void ConsumeAmmo(int Amount, bool bShouldValidate);
	void STATIC_FireAmmunition();
	void ClientDeactivateTalentThreeEvent();
	void ClientActivateTalentThreeEvent();
	void STATIC_ClientDeactivateTalentThree();
	void STATIC_ClientActivateTalentThree();
	void STATIC_DeactivateTalentThree();
	void STATIC_ActivateTalentThree();
	bool STATIC_HasCachedCaspian();
	void DeviceAdjustDamage(int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
	float STATIC_GetFiringPostHitDelay(int nMode);
	float STATIC_GetFiringPreHitDelay(int nMode);
	void SetFireMode(int nFireModeNum, bool ForceSet);
};


// Class TgGame.TgDevice_CaspianMovement
// 0x0020 (0x0AA0 - 0x0A80)
class ATgDevice_CaspianMovement : public ATgDevice_Charge
{
public:
	class ATgPawn_Caspian*                             m_pCachedCaspian;                                         // 0x0A80(0x0008)
	float                                              m_fSecondaryActivationDelay;                              // 0x0A88(0x0004)
	unsigned long                                      r_bReactivationRequested : 1;                             // 0x0A8C(0x0004) (Net)
	unsigned long                                      r_bHasTalentTwo : 1;                                      // 0x0A8C(0x0004) (Net)
	TArray<class AActor*>                              s_talentTwoAppliedList;                                   // 0x0A90(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CaspianMovement");
		return ptr;
	}


	float GetChargeTime();
	void CancelSafetyTimer();
	void STATIC_DeactivateTalentTwo();
	void STATIC_ActivateTalentTwo();
	void STATIC_ResetTimers();
	void STATIC_ResetPhys();
	void STATIC_EndPhys();
	bool CanBeInterrupted();
	bool CanFiringBeCanceledByReactivation();
	bool CanFiringBeCanceledByRightMouse();
	bool CanFiringBeCanceledByLeftMouse();
	bool CanBeCanceled();
	void ApplyTouchHit(class ATgPawn* InstigatorPawn, const struct FVector& vHitLocation, const struct FVector& vHitNormal, class AActor* Target);
	void STATIC_CheckTalentTwoStack(class AActor* Target);
	void STATIC_BeginSpinningSwords();
	void STATIC_ClientBeginSpinningSwords();
	void STATIC_BeginSpinningSwordsTimer();
	void STATIC_EndSpinningSwordsTimer();
	void STATIC_ClientEndSpinningSwords();
	void STATIC_EndSpinningSwords();
	bool STATIC_TrySpinningSwords(float fOffsetDelay);
	void STATIC_ServerTrySpinningSwords(float fTimeOfActivation);
	bool STATIC_InterceptSlotReleased(class ATgPlayerController* TgController);
	bool STATIC_InterceptSlotPressed(class ATgPlayerController* TgController);
	bool STATIC_CheckSpinningSwords();
	void STATIC_FireAmmunition();
	bool STATIC_HasCachedCaspian();
	void StartCooldown(int nMode, float fCooldownTimeOverride);
	bool STATIC_ShouldBankCooldown();
};


// Class TgGame.TgDeviceFire_CaspianInHand
// 0x0010 (0x0278 - 0x0268)
class UTgDeviceFire_CaspianInHand : public UTgDeviceFire
{
public:
	class ATgDevice_CaspianInhand*                     m_pCachedInHandDevice;                                    // 0x0268(0x0008)
	float                                              m_fFirePostHitDelayOverride;                              // 0x0270(0x0004)
	float                                              m_fRangeOverrideMultiplier;                               // 0x0274(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_CaspianInHand");
		return ptr;
	}


	float GetRange();
};


// Class TgGame.TgDeviceFire_CaspianInHandAOE
// 0x000C (0x0274 - 0x0268)
class UTgDeviceFire_CaspianInHandAOE : public UTgDeviceFire
{
public:
	class ATgDevice_CaspianInhand*                     m_pCachedInHandDevice;                                    // 0x0268(0x0008)
	float                                              m_fRangeOverrideMultiplier;                               // 0x0270(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_CaspianInHandAOE");
		return ptr;
	}


	float GetRange();
};


// Class TgGame.TgDeviceFire_CaspianInHandAOETwo
// 0x0000 (0x0274 - 0x0274)
class UTgDeviceFire_CaspianInHandAOETwo : public UTgDeviceFire_CaspianInHandAOE
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_CaspianInHandAOETwo");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_CaspianMovement
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_CaspianMovement : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_CaspianMovement");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_CaspianSpinningSwords
// 0x0000 (0x0274 - 0x0274)
class UTgDeviceFire_CaspianSpinningSwords : public UTgDeviceFire_EncroachmentActorScale
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_CaspianSpinningSwords");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_CaspianInHandAOEThree
// 0x000C (0x0284 - 0x0278)
class UTgDeviceFire_CaspianInHandAOEThree : public UTgDeviceFire_EncroachmentFireCone
{
public:
	class ATgDevice_CaspianInhand*                     m_pCachedInHandDevice;                                    // 0x0278(0x0008)
	float                                              m_fRangeOverrideMultiplier;                               // 0x0280(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_CaspianInHandAOEThree");
		return ptr;
	}


	float GetRange();
};


// Class TgGame.TgDeviceForm_CaspianInhand
// 0x0000 (0x028C - 0x028C)
class UTgDeviceForm_CaspianInhand : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_CaspianInhand");
		return ptr;
	}


	void Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
};


// Class TgGame.TgDeviceForm_CaspianMovement
// 0x0038 (0x02C4 - 0x028C)
class UTgDeviceForm_CaspianMovement : public UTgDeviceForm
{
public:
	TArray<class UTgAnimNodeChannelFire_CaspianMovement*> m_CaspianMovementNodes3p;                                 // 0x028C(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeChannelFire_CaspianMovement*> m_CaspianMovementNodes1p;                                 // 0x029C(0x0010) (NeedCtorLink)
	class ATgPawn_Caspian*                             m_pCachedCaspian;                                         // 0x02AC(0x0008)
	struct FName                                       m_nmWhirlActivation;                                      // 0x02B4(0x0008)
	struct FName                                       m_nmDashConeActivation;                                   // 0x02BC(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_CaspianMovement");
		return ptr;
	}


	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	void CacheAnimNode(class UAnimNode* Node, bool bIs3p);
	void ClearAnimNodes(bool bIs3p);
	bool STATIC_HasCachedCaspian();
	void STATIC_PlayEndSound();
	void Generic1(unsigned char byExtraData);
	void STATIC_UpdateMovementAnimState(TEnumAsByte<ECaspianMovementAnimState> eNewState);
};


// Class TgGame.TgInvListener_CaspianAddStacks
// 0x0008 (0x00CC - 0x00C4)
class UTgInvListener_CaspianAddStacks : public UTgInvListener
{
public:
	class ATgPawn_Caspian*                             m_CachedCaspian;                                          // 0x00C4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_CaspianAddStacks");
		return ptr;
	}


	bool STATIC_HasCachedCaspian();
};


// Class TgGame.TgInvListener_CaspianExtendStackLifetime
// 0x0008 (0x00CC - 0x00C4)
class UTgInvListener_CaspianExtendStackLifetime : public UTgInvListener
{
public:
	class ATgPawn_Caspian*                             m_CachedCaspian;                                          // 0x00C4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_CaspianExtendStackLifetime");
		return ptr;
	}


	bool STATIC_HasCachedCaspian();
};


// Class TgGame.TgInvListener_CaspianStackExpired
// 0x0008 (0x00CC - 0x00C4)
class UTgInvListener_CaspianStackExpired : public UTgInvListener
{
public:
	class ATgPawn_Caspian*                             m_CachedCaspian;                                          // 0x00C4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_CaspianStackExpired");
		return ptr;
	}


	bool STATIC_HasCachedCaspian();
};


// Class TgGame.TgInvListener_CaspianTalentThree
// 0x0008 (0x00CC - 0x00C4)
class UTgInvListener_CaspianTalentThree : public UTgInvListener
{
public:
	class ATgPawn_Caspian*                             m_CachedCaspian;                                          // 0x00C4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_CaspianTalentThree");
		return ptr;
	}


	bool STATIC_HasCachedCaspian();
};


// Class TgGame.TgPawn_Caspian
// 0x0194 (0x346C - 0x32D8)
class ATgPawn_Caspian : public ATgPawn_Character
{
public:
	TArray<struct FCaspianStackCountHistoryEntry>      s_StackCountHistory;                                      // 0x32D8(0x0010) (NeedCtorLink)
	float                                              s_fStackHistoryWindow;                                    // 0x32E8(0x0004)
	TArray<struct FCaspianPassiveStack>                s_Stacks;                                                 // 0x32EC(0x0010) (NeedCtorLink)
	struct FCaspianStackConfig                         m_InhandStackConfig;                                      // 0x32FC(0x0008)
	struct FCaspianStackConfig                         m_AltfireStackConfig;                                     // 0x3304(0x0008)
	unsigned long                                      m_bStacksExpireIndividually : 1;                          // 0x330C(0x0004)
	unsigned long                                      m_bIsSpinningSwords : 1;                                  // 0x330C(0x0004)
	unsigned long                                      s_bHasBonusProjectileTalent : 1;                          // 0x330C(0x0004)
	unsigned long                                      m_bHasTalentThree : 1;                                    // 0x330C(0x0004)
	int                                                m_nLastAcknowledgedInhandStacks;                          // 0x3310(0x0004)
	int                                                m_nLastAcknowledgedAltfireStacks;                         // 0x3314(0x0004)
	int                                                r_nCurrentInhandStacks;                                   // 0x3318(0x0004) (Net)
	int                                                r_nCurrentAltfireStacks;                                  // 0x331C(0x0004) (Net)
	TArray<struct FName>                               m_nmSwordMissileSockets;                                  // 0x3320(0x0010) (NeedCtorLink)
	class ATgDevice_CaspianUlt*                        m_CaspianUlt;                                             // 0x3330(0x0008)
	class ATgDevice_CaspianUltFire*                    m_CaspianUltFire;                                         // 0x3338(0x0008)
	class ATgDevice_CaspianQTalent*                    m_CachedProjTalent;                                       // 0x3340(0x0008)
	int                                                s_nCurrentAmmoConsumed;                                   // 0x3348(0x0004)
	int                                                s_nAmmoConsumedThreshold;                                 // 0x334C(0x0004)
	TArray<class UTgInvListener_CaspianStackExpired*>  m_CachedStackExpiredListeners;                            // 0x3350(0x0010) (NeedCtorLink)
	class UTgInvListener_CaspianAddStacks*             m_CachedStackAdderListener;                               // 0x3360(0x0008)
	unsigned char                                      s_nNextAvailableId;                                       // 0x3368(0x0001)
	unsigned char                                      r_nSwordNonces[0x5];                                      // 0x3369(0x0001) (Net)
	unsigned char                                      r_nSwordIds[0x5];                                         // 0x336E(0x0001) (Net)
	unsigned char                                      r_bSwordFlags[0x5];                                       // 0x3373(0x0001) (Net)
	float                                              c_fSwordAttemptedFireLockout;                             // 0x3378(0x0004)
	struct FCaspianSword                               m_LocalSwords[0x5];                                       // 0x337C(0x002C)
	int                                                r_nSwordPositions[0x5];                                   // 0x3458(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Caspian");
		return ptr;
	}


	int STATIC_GetNextSwordToFire();
	struct FVector STATIC_GetNextSwordProjectileFireOffset();
	void STATIC_RollbackSimulatedSwordMissileFire(int Index);
	void STATIC_DeactivateSwordFx(int Index);
	void STATIC_DeactivateSword(int I);
	void STATIC_ActivateSwordFx(int Index);
	int STATIC_GetNextFreeSwordIndex();
	void STATIC_LocalActivateSword(int I);
	void SpawnSword(int nPosition);
	void STATIC_UpdateSwordMissiles();
	void STATIC_UpdateSword(int Index);
	void OnSwordExploded(class ATgProjectile* SwordProjectile);
	void OnSwordFired(class ATgProjectile* SwordProjectile);
	void STATIC_AttemptFireUltSword();
	void STATIC_AuthSwordUpdated(int I);
	void Tick(float DeltaSeconds);
	bool CanFlyWithoutHover();
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_ClearStacksOnRespawn();
	bool OnLiveRespawn();
	void OnRespawn();
	int STATIC_GetUISkillEqpSlotOverride_Caspian(int nEquipSlot, TEnumAsByte<EUI_SKILL_EQUIP_SLOT> eUISlot, bool bShouldSwapAltAndInhandInputs, int nFallThroughValue);
	int STATIC_GetUISkillEqpSlotOverrideStaticDefault(int nEquipSlot, TEnumAsByte<EUI_SKILL_EQUIP_SLOT> eUISlot);
	int STATIC_GetUISkillEqpSlotOverride(int nEquipSlot, TEnumAsByte<EUI_SKILL_EQUIP_SLOT> eUISlot, bool bBaseSkillOnly, bool bGamepadUI);
	bool ShouldSwapAltAndInhandInputs();
	void OnProjectileExploded(class ATgProjectile* ExplodedProjectile, class AActor* HitActor, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void ProjectileOnFire(class ATgProjectile* Proj);
	struct FVector STATIC_GetSwordMissileLocation(int nIndex);
	struct FName STATIC_GetSwordMissileSocketName(int nIndex);
	bool STATIC_ValidateClientStacks(TEnumAsByte<ECaspianStackSource> eSource, float fRewindAmount, int* nStacks);
	void STATIC_TrackAmmoConsumed(int nAmount);
	void DeviceOnDamaged(struct FOnDamagedParams* Params);
	void STATIC_UpdateStackCounts();
	void STATIC_OnStackExpired(unsigned char eSource);
	void STATIC_AddStackHistoryRecord(unsigned char eSource);
	int STATIC_GetCurrentStacks(TEnumAsByte<ECaspianStackSource> eSource);
	void STATIC_AddStack(TEnumAsByte<ECaspianStackSource> eSource);
	float STATIC_GetTimeSinceLastStack(TEnumAsByte<ECaspianStackSource> eSource);
	void STATIC_CullStacks();
	int STATIC_CountStacks_Internal(TEnumAsByte<ECaspianStackSource> eSource);
	void STATIC_ClientOnCurrentStacksUpdated();
	bool STATIC_GetSwordIsFiredSimulated(int nNdx);
	void STATIC_SetSwordPositionIndex(int nNdx, int nPosition);
	void STATIC_SetSwordIsFired(int nNdx, bool bIsFired);
	void STATIC_SetSwordIsActive(int nNdx, bool bIsActive);
	int STATIC_NumSwordsReadyToFire(bool bAuthoritativeOnly);
	bool STATIC_GetSwordIsActive(int nNdx, bool byRep);
	int STATIC_GetSwordPositionIndex(int nNdx, bool byRep);
	bool STATIC_GetSwordIsFired(int nNdx, bool byRep);
	bool STATIC_IsSimulatingSpeculativeSwordFired(int Index);
	void STATIC_LocalOnSwordFired(int nSwordIndex);
};


// Class TgGame.TgProj_PiercingCaspianQ
// 0x0008 (0x0534 - 0x052C)
class ATgProj_PiercingCaspianQ : public ATgProj_Piercing
{
public:
	int                                                m_nMaxStacksForBonus;                                     // 0x052C(0x0004)
	float                                              m_fSpeedBonusPerStack;                                    // 0x0530(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_PiercingCaspianQ");
		return ptr;
	}

};


// Class TgGame.TgDevice_FlagBall
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_FlagBall : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_FlagBall");
		return ptr;
	}


	void ServerExitTargetingMode();
	void ExitTargetingMode();
	void STATIC_FireAmmunition();
	bool STATIC_InterceptRightMouseReleased(class ATgPlayerController* TgController);
	bool STATIC_InterceptRightMousePressed(class ATgPlayerController* TgController);
	bool ShouldSwitchBackToBasicAttackTargeting(TEnumAsByte<ECastMode> CastMode);
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgFlagballSpawnPoint
// 0x0010 (0x0290 - 0x0280)
class ATgFlagballSpawnPoint : public AActor
{
public:
	int                                                m_nFlagBallFiremodeID;                                    // 0x0280(0x0004) (Edit)
	class UTgDeviceFire*                               m_FireMode;                                               // 0x0284(0x0008)
	unsigned long                                      m_bSetupFireMode : 1;                                     // 0x028C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgFlagballSpawnPoint");
		return ptr;
	}


	void SpawnFlagball();
	void SetupFireMode();
};


// Class TgGame.TgFlagBall
// 0x0028 (0x05A8 - 0x0580)
class ATgFlagBall : public ATgProj_FreeGrenade
{
public:
	class UParticleSystem*                             m_ballFX;                                                 // 0x0580(0x0008)
	unsigned long                                      m_bAvoidInstigator : 1;                                   // 0x0588(0x0004)
	unsigned long                                      m_bSilhouetteAllowed : 1;                                 // 0x0588(0x0004)
	unsigned long                                      m_bSilhouetteInitialized : 1;                             // 0x0588(0x0004)
	float                                              m_fAvoidInstigatorDuration;                               // 0x058C(0x0004)
	class UTgSilhouetteComponent*                      m_Silhouette;                                             // 0x0590(0x0008) (ExportObject, Component, EditInline)
	struct FLinearColor                                m_LocalSilhouetteColor;                                   // 0x0598(0x0010)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgFlagBall");
		return ptr;
	}


	void ExplodeOnTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool CanHitTarget(class AActor* Other);
	bool CanHitInstigator();
	void STATIC_EndAvoidInstigator();
	void PostProjectileInitialize();
	void InitializeSilhouetteComponent();
};


// Class TgGame.TgRepInfo_Game_Flagball
// 0x0078 (0x067C - 0x0604)
class ATgRepInfo_Game_Flagball : public ATgRepInfo_Game
{
public:
	float                                              c_fFlagballCorrectInterval;                               // 0x0604(0x0004)
	float                                              c_fFlagballCorrectTimer;                                  // 0x0608(0x0004)
	unsigned long                                      c_bInFarMoveState : 1;                                    // 0x060C(0x0004)
	unsigned long                                      r_bPassingEnabled : 1;                                    // 0x060C(0x0004) (Net)
	unsigned long                                      r_bBallActive : 1;                                        // 0x060C(0x0004) (Net)
	unsigned long                                      r_bBallExists : 1;                                        // 0x060C(0x0004) (Net)
	class ATgFlagBall*                                 c_Flagball;                                               // 0x0610(0x0008)
	class ATgFlagballGoal*                             c_TF1Goal;                                                // 0x0618(0x0008)
	class ATgFlagballGoal*                             c_TF2Goal;                                                // 0x0620(0x0008)
	float                                              r_nTimeRemaining;                                         // 0x0628(0x0004) (Net)
	class ATgPawn_Character*                           r_BallCarrier;                                            // 0x062C(0x0008) (Net)
	struct FVector                                     r_vBallPosition;                                          // 0x0634(0x000C) (Net)
	struct FVector                                     r_vBallVelocity;                                          // 0x0640(0x000C) (Net)
	struct FVector                                     r_vBallPositionForHUD;                                    // 0x064C(0x000C) (Net)
	struct FVector                                     r_vTF1GoalLocation;                                       // 0x0658(0x000C) (Net)
	struct FVector                                     r_vTF2GoalLocation;                                       // 0x0664(0x000C) (Net)
	int                                                c_nFlagballDeviceFireID;                                  // 0x0670(0x0004)
	class ATgDeploy_FlagballGoalMarker*                r_GoalMarker;                                             // 0x0674(0x0008) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRepInfo_Game_Flagball");
		return ptr;
	}


	void STATIC_EndFarMoveState();
	void BeginFarMovestate();
	void Tick(float fDeltaTime);
	void PurgeAllFlagballsExcept(class ATgFlagBall* FlagballToKeep);
	void PurgeAllFlagballs();
	void STATIC_UnregisterFlagballForTracking(class ATgFlagBall* Flagball);
	void RegisterFlagballForTracking(class ATgFlagBall* Flagball);
	void SetBallCarrier(class ATgPawn_Character* BallCarrier);
};


// Class TgGame.TgAbyssalEchoes
// 0x0028 (0x0088 - 0x0060)
class UTgAbyssalEchoes : public UObject
{
public:
	float                                              m_fAbyssalEchoPercent;                                    // 0x0060(0x0004) (Config)
	float                                              m_fViktorOverridePercent;                                 // 0x0064(0x0004) (Config)
	class ATgGame_Paladins*                            m_parentGame;                                             // 0x0068(0x0008)
	float                                              m_fEchoSpawnDuration;                                     // 0x0070(0x0004)
	float                                              m_fEchoSpawnTimer;                                        // 0x0074(0x0004)
	float                                              m_fEchoTimeoutTimer;                                      // 0x0078(0x0004)
	unsigned long                                      m_bSpawnedEcho : 1;                                       // 0x007C(0x0004)
	unsigned long                                      m_bEchoEnraged : 1;                                       // 0x007C(0x0004)
	unsigned long                                      m_bSpawnAttempt1 : 1;                                     // 0x007C(0x0004)
	unsigned long                                      m_bSpawnAttempt2 : 1;                                     // 0x007C(0x0004)
	unsigned long                                      m_bSpawnAttempt3 : 1;                                     // 0x007C(0x0004)
	int                                                m_nHighestTDMScore;                                       // 0x0080(0x0004)
	int                                                m_nHighestOnslaughtScore;                                 // 0x0084(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAbyssalEchoes");
		return ptr;
	}


	void DeactivateEcho();
	void STATIC_EchoDies(class AController* Killer);
	void STATIC_EchoEnrage();
	void STATIC_EchoTimeout();
	void STATIC_EchoStartTimeout();
	void NotifyDeathEchoes();
	void NotifyTimeoutEchoes();
	void NotifySpawnEchoes();
	void SpawnEcho();
	struct FVector STATIC_GetEchoSpawnLocation();
	void ConsiderSpawningEchoForOnslaught();
	void ConsiderSpawningEchoForTDM();
	void ConsiderSpawningEchoForSiege();
	void Tick(float DeltaSeconds);
	void SelectAbyssalEcho();
	void STATIC_InitEcho(class ATgPawn_Character* pChar);
};


// Class TgGame.TgGameplayCurveOwner
// 0x0000 (0x0060 - 0x0060)
class UTgGameplayCurveOwner : public UInterface
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurveOwner");
		return ptr;
	}


	bool STATIC_UseRangeFalloffCurve();
	class UTgGameplayCurvesSet* STATIC_GetCurrentGameplayCurveSet(TEnumAsByte<ECurveSetTypes> Type);
};


// Class TgGame.TgGameplayCurves
// 0x002C (0x008C - 0x0060)
class UTgGameplayCurves : public UObject
{
public:
	TArray<class UTgGameplayCurvesSet*>                CurveSets;                                                // 0x0060(0x0010) (Edit, NeedCtorLink, NoClear, EditInline)
	TArray<class UTgGameplayCurves*>                   InheritedCurves;                                          // 0x0070(0x0010) (Edit, NeedCtorLink, NoClear, EditInline, EditInlineUse)
	unsigned long                                      bShowInheritedCurves : 1;                                 // 0x0080(0x0004) (Edit, Transient)
	unsigned long                                      bInheritedCurvesShareEditorTab : 1;                       // 0x0080(0x0004) (Edit, Transient)
	class UInterpCurveEdSetup*                         CurveEdSetup;                                             // 0x0084(0x0008) (ExportObject)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurves");
		return ptr;
	}


	bool STATIC_GetPrimaryDistributionValueByType(TEnumAsByte<ECurveSetTypes> curveType, float T, float* Value);
	TArray<class UTgGameplayCurvesSet*> STATIC_GetAllCurvesSetsByType(TEnumAsByte<ECurveSetTypes> curveTypes);
	class UTgGameplayCurvesSet* STATIC_GetCurvesSetByType(TEnumAsByte<ECurveSetTypes> curveType);
};


// Class TgGame.TgGameplayCurvesSet
// 0x0001 (0x0061 - 0x0060)
class UTgGameplayCurvesSet : public UObject
{
public:
	TEnumAsByte<ECurveSetTypes>                        CurveSetType;                                             // 0x0060(0x0001) (Edit, Const, EditConst)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet");
		return ptr;
	}


	bool STATIC_GetPrimaryDistributionValue(float T, float* Value);
	float STATIC_GetDistributionValue(float T, struct FRawDistributionFloat* Distribution);
};


// Class TgGame.TgGameplayCurvesSet_AimAcceleration
// 0x0013 (0x0074 - 0x0061)
class UTgGameplayCurvesSet_AimAcceleration : public UTgGameplayCurvesSet
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0061(0x0003) MISSED OFFSET
	TArray<class UTgAimAccelerationCurves*>            AimAccelerationCurves;                                    // 0x0064(0x0010) (Edit, NeedCtorLink, NoClear, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_AimAcceleration");
		return ptr;
	}


	void STATIC_UpdateAimAcceleration(float DeltaTime, int CurveSetToUse, int AccelerationBoost, int Algorithm, float* TurnSpeedX, float* TurnSpeedY, float* aTurn, float* aLookUp);
};


// Class TgGame.TgGameplayCurvesSet_AimAssistBounds
// 0x0057 (0x00B8 - 0x0061)
class UTgGameplayCurvesSet_AimAssistBounds : public UTgGameplayCurvesSet
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0061(0x0003) MISSED OFFSET
	struct FRawDistributionFloat                       BoundsScaleHorizByDistance;                               // 0x0064(0x0024) (Edit, Component, NeedCtorLink)
	struct FRawDistributionFloat                       BoundsScaleVertByDistance;                                // 0x0088(0x0024) (Edit, Component, NeedCtorLink)
	unsigned long                                      bUseHorizCurveForVert : 1;                                // 0x00AC(0x0004) (Edit)
	float                                              fBaseHorizMultiplier;                                     // 0x00B0(0x0004) (Edit)
	float                                              fBaseVertMultiplier;                                      // 0x00B4(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_AimAssistBounds");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_AimAssistKeyframes
// 0x0053 (0x00B4 - 0x0061)
class UTgGameplayCurvesSet_AimAssistKeyframes : public UTgGameplayCurvesSet
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0061(0x0003) MISSED OFFSET
	TArray<class UTgAimAssistKeyframe*>                HorizMagnetKeyframes;                                     // 0x0064(0x0010) (Edit, NeedCtorLink, NoClear, EditInline)
	TArray<class UTgAimAssistKeyframe*>                VertMagnetKeyframes;                                      // 0x0074(0x0010) (Edit, NeedCtorLink, NoClear, EditInline)
	TArray<class UTgAimAssistKeyframe*>                FrictionKeyframes;                                        // 0x0084(0x0010) (Edit, NeedCtorLink, NoClear, EditInline)
	TArray<class UTgAimAssistKeyframe*>                TrackingByAccuracyKeyframes;                              // 0x0094(0x0010) (Edit, NeedCtorLink, NoClear, EditInline)
	TArray<class UTgAimAssistKeyframe*>                TrackingByAngleKeyframes;                                 // 0x00A4(0x0010) (Edit, NeedCtorLink, NoClear, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_AimAssistKeyframes");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_BulletMagnetOverDist
// 0x004C (0x00AD - 0x0061)
class UTgGameplayCurvesSet_BulletMagnetOverDist : public UTgGameplayCurvesSet
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0061(0x0003) MISSED OFFSET
	struct FRawDistributionFloat                       BulletMagnetDegOverDist;                                  // 0x0064(0x0024) (Edit, Component, NeedCtorLink)
	struct FRawDistributionFloat                       BulletMagnetMaxDegOverDist;                               // 0x0088(0x0024) (Edit, Component, NeedCtorLink)
	TEnumAsByte<EPaladinsBulletMagnetType>             BulletMagnetActiveType;                                   // 0x00AC(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_BulletMagnetOverDist");
		return ptr;
	}


	float STATIC_GetBulletMagnetStrength(const struct FVector& vCurrent, const struct FVector& vToTarget, float fDist);
};


// Class TgGame.TgGameplayCurvesSet_DamageFalloff
// 0x002B (0x008C - 0x0061)
class UTgGameplayCurvesSet_DamageFalloff : public UTgGameplayCurvesSet
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0061(0x0003) MISSED OFFSET
	struct FRawDistributionFloat                       DamageFalloff;                                            // 0x0064(0x0024) (Edit, Component, NeedCtorLink)
	unsigned long                                      bIsRangeNormalized : 1;                                   // 0x0088(0x0004) (Edit)
	unsigned long                                      bExcludeEffectiveRange : 1;                               // 0x0088(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_DamageFalloff");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_DamageFalloffAOE
// 0x002B (0x008C - 0x0061)
class UTgGameplayCurvesSet_DamageFalloffAOE : public UTgGameplayCurvesSet
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0061(0x0003) MISSED OFFSET
	struct FRawDistributionFloat                       DamageFalloff;                                            // 0x0064(0x0024) (Edit, Component, NeedCtorLink)
	unsigned long                                      bIsRangeNormalized : 1;                                   // 0x0088(0x0004) (Edit)
	unsigned long                                      bExcludeEffectiveRange : 1;                               // 0x0088(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_DamageFalloffAOE");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_HitReactions
// 0x006F (0x00D0 - 0x0061)
class UTgGameplayCurvesSet_HitReactions : public UTgGameplayCurvesSet
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0061(0x0003) MISSED OFFSET
	struct FRawDistributionFloat                       ReactionStrengthOverTime;                                 // 0x0064(0x0024) (Edit, Component, NeedCtorLink)
	struct FRawDistributionFloat                       ReactionStrengthOverTimeDelayed;                          // 0x0088(0x0024) (Edit, Component, NeedCtorLink)
	struct FRawDistributionFloat                       ReactionStrengthByDamage;                                 // 0x00AC(0x0024) (Edit, Component, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_HitReactions");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_PositionFromPitch
// 0x004B (0x00AC - 0x0061)
class UTgGameplayCurvesSet_PositionFromPitch : public UTgGameplayCurvesSet
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0061(0x0003) MISSED OFFSET
	struct FRawDistributionFloat                       ForwardTranslation;                                       // 0x0064(0x0024) (Edit, Component, NeedCtorLink)
	struct FRawDistributionFloat                       UpTranslation;                                            // 0x0088(0x0024) (Edit, Component, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_PositionFromPitch");
		return ptr;
	}


	struct FVector STATIC_GetTranslationFromPitch(float fPitch);
};


// Class TgGame.TgGameplayCurvesSet_Recoil
// 0x0024 (0x0085 - 0x0061)
class UTgGameplayCurvesSet_Recoil : public UTgGameplayCurvesSet
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0061(0x0003) MISSED OFFSET
	TArray<class UTgRecoilKeyframe*>                   HorizRecoil;                                              // 0x0064(0x0010) (Edit, NeedCtorLink, NoClear, EditInline)
	TArray<class UTgRecoilKeyframe*>                   VertRecoil;                                               // 0x0074(0x0010) (Edit, NeedCtorLink, NoClear, EditInline)
	TEnumAsByte<EPaladinsRecoilType>                   RecoilType;                                               // 0x0084(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_Recoil");
		return ptr;
	}


	float STATIC_GetInterpValBetweenFrames(float Time, float inKeyTime, float outKeyTime);
	bool STATIC_GetRecoilValue(float firingTime, float randInput, float* recoilAmt, TArray<class UTgRecoilKeyframe*>* keyframesToCheck);
	bool STATIC_GetVertRecoilValue(float firingTime, float randInput, float* recoilAmt);
	bool STATIC_GetHorizRecoilValue(float firingTime, float randInput, float* recoilAmt);
};


// Class TgGame.TgGameplayCurvesSet_RecoilSimple
// 0x0094 (0x00F5 - 0x0061)
class UTgGameplayCurvesSet_RecoilSimple : public UTgGameplayCurvesSet
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0061(0x0003) MISSED OFFSET
	struct FRawDistributionFloat                       HorizRecoil1;                                             // 0x0064(0x0024) (Edit, Component, NeedCtorLink)
	struct FRawDistributionFloat                       HorizRecoil2;                                             // 0x0088(0x0024) (Edit, Component, NeedCtorLink)
	struct FRawDistributionFloat                       VertRecoil1;                                              // 0x00AC(0x0024) (Edit, Component, NeedCtorLink)
	struct FRawDistributionFloat                       VertRecoil2;                                              // 0x00D0(0x0024) (Edit, Component, NeedCtorLink)
	TEnumAsByte<EPaladinsRecoilType>                   RecoilType;                                               // 0x00F4(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_RecoilSimple");
		return ptr;
	}


	float STATIC_GetVertRecoilValue(float firingTime, float randInput);
	float STATIC_GetHorizRecoilValue(float firingTime, float randInput);
};


// Class TgGame.TgGameplayCurvesSet_RecoilVisual
// 0x0093 (0x00F4 - 0x0061)
class UTgGameplayCurvesSet_RecoilVisual : public UTgGameplayCurvesSet
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0061(0x0003) MISSED OFFSET
	struct FRawDistributionFloat                       AngleDistribution;                                        // 0x0064(0x0024) (Edit, Component, NeedCtorLink)
	struct FRawDistributionFloat                       StrengthDegreesByAngleMin;                                // 0x0088(0x0024) (Edit, Component, NeedCtorLink)
	struct FRawDistributionFloat                       StrengthDegreesByAngleMax;                                // 0x00AC(0x0024) (Edit, Component, NeedCtorLink)
	struct FRawDistributionFloat                       RecoilApplicationCurve;                                   // 0x00D0(0x0024) (Edit, Component, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_RecoilVisual");
		return ptr;
	}


	struct FRotator STATIC_GetRecoilValue(float fRandInput1, float fRandInput2);
};


// Class TgGame.TgGameplayCurvesSet_Simple
// 0x0037 (0x0098 - 0x0061)
class UTgGameplayCurvesSet_Simple : public UTgGameplayCurvesSet
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0061(0x0003) MISSED OFFSET
	struct FRawDistributionFloat                       PrimaryCurve;                                             // 0x0064(0x0024) (Edit, Component, NeedCtorLink)
	struct FName                                       PrimaryCurveTabName;                                      // 0x0088(0x0008) (Const)
	struct FName                                       PrimaryCurveName;                                         // 0x0090(0x0008) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_Simple");
		return ptr;
	}


	bool STATIC_GetPrimaryDistributionValue(float T, float* Value);
};


// Class TgGame.TgGameplayCurvesSet_TargetAimTracking
// 0x0053 (0x00B4 - 0x0061)
class UTgGameplayCurvesSet_TargetAimTracking : public UTgGameplayCurvesSet
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0061(0x0003) MISSED OFFSET
	TArray<class UTgTargetAimTrackingCurves*>          TargetTrackingCurves;                                     // 0x0064(0x0010) (Edit, NeedCtorLink, NoClear, EditInline)
	struct FTargetAimTrackingDebugVals                 DebugVals;                                                // 0x0074(0x003C) (Transient)
	unsigned long                                      bSaveDebugVals : 1;                                       // 0x00B0(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_TargetAimTracking");
		return ptr;
	}


	void SaveDebugInfo(bool bShouldSave);
	float STATIC_GetTargetTrackingStrength(float AssistAmt, float DesiredTurnAmtPerSec, int TargetTrackingStrength, struct FRawDistributionFloat* StrengthByAccuracyCurve, struct FRawDistributionFloat* StrengthByDesiredAngleCurve);
	float STATIC_GetTargetTrackingPercY(float VertAssistAmt, float DesiredTurnAmt, int CurveSetToUse, int TargetTrackingStrength, float DeltaTime);
	float STATIC_GetTargetTrackingPercX(float HorizAssistAmt, float DesiredTurnAmt, int CurveSetToUse, int TargetTrackingStrength, float DeltaTime);
};


// Class TgGame.TgDatabaseIDs
// 0x0000 (0x0060 - 0x0060)
class UTgDatabaseIDs : public UObject
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDatabaseIDs");
		return ptr;
	}

};


// Class TgGame.TgCallbackContainer
// 0x00F8 (0x0158 - 0x0060)
class UTgCallbackContainer : public UObject
{
public:
	struct FMultiMap_Mirror                            m_RegisteredCallbacks;                                    // 0x0060(0x0048) (Const, Native)
	struct FMap_Mirror                                 m_RegisteredCallbacksByHandle;                            // 0x00A8(0x0048) (Const, Native)
	struct FMap_Mirror                                 m_CallbackHandles;                                        // 0x00F0(0x0048) (Const, Native)
	TArray<unsigned char>                              m_IteratingCallbackTypeStack;                             // 0x0138(0x0010) (Const, Native)
	TArray<struct FFunctionWrapperInfo>                m_CallbacksToRemove;                                      // 0x0148(0x0010) (Const, Native)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCallbackContainer");
		return ptr;
	}

};


// Class TgGame.TgCallbackInterface
// 0x0000 (0x0060 - 0x0060)
class UTgCallbackInterface : public UInterface
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCallbackInterface");
		return ptr;
	}

};


// Class TgGame.TgAbyssalEchoSpawnPoint
// 0x0004 (0x0284 - 0x0280)
class ATgAbyssalEchoSpawnPoint : public AActor
{
public:
	int                                                m_nTaskForceId;                                           // 0x0280(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAbyssalEchoSpawnPoint");
		return ptr;
	}

};


// Class TgGame.TgActorFactory_TgStaticMeshActorBoostedTextures
// 0x0000 (0x00B0 - 0x00B0)
class UTgActorFactory_TgStaticMeshActorBoostedTextures : public UActorFactoryStaticMesh
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgActorFactory_TgStaticMeshActorBoostedTextures");
		return ptr;
	}

};


// Class TgGame.TgActorFactory_TgStaticMeshActorCapturePoint
// 0x0000 (0x00B0 - 0x00B0)
class UTgActorFactory_TgStaticMeshActorCapturePoint : public UActorFactoryStaticMesh
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgActorFactory_TgStaticMeshActorCapturePoint");
		return ptr;
	}

};


// Class TgGame.TgActorFactory_TgStaticMeshActorTeamColor
// 0x0000 (0x00B0 - 0x00B0)
class UTgActorFactory_TgStaticMeshActorTeamColor : public UActorFactoryStaticMesh
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgActorFactory_TgStaticMeshActorTeamColor");
		return ptr;
	}

};


// Class TgGame.TgActorFactoryTgEmitter_TeamColor
// 0x0000 (0x00A4 - 0x00A4)
class UTgActorFactoryTgEmitter_TeamColor : public UActorFactoryEmitter
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgActorFactoryTgEmitter_TeamColor");
		return ptr;
	}

};


// Class TgGame.TgEmitterSpawnable_TeamColor
// 0x0000 (0x029C - 0x029C)
class ATgEmitterSpawnable_TeamColor : public ATgEmitter_TeamColor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitterSpawnable_TeamColor");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_SetTaskforce
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_SetTaskforce : public USequenceAction
{
public:
	int                                                TaskForceNumber;                                          // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_SetTaskforce");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_AssignLane
// 0x0004 (0x0098 - 0x0094)
class UTgAIBehaviorAction_AssignLane : public UTgAIBehaviorAction
{
public:
	int                                                LaneIndex;                                                // 0x0094(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_AssignLane");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_CancelFiring
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_CancelFiring : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_CancelFiring");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_ClearCombatTarget
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_ClearCombatTarget : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_ClearCombatTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_ClearLaneMoveTarget
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_ClearLaneMoveTarget : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_ClearLaneMoveTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_ClearLastAttacker
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_ClearLastAttacker : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_ClearLastAttacker");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_ClearLookAtTarget
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_ClearLookAtTarget : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_ClearLookAtTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_ClearNavigationQueue
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_ClearNavigationQueue : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_ClearNavigationQueue");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_ClearRallyPoint
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_ClearRallyPoint : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_ClearRallyPoint");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_ClearSpreadLocation
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_ClearSpreadLocation : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_ClearSpreadLocation");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_MoveBase
// 0x0008 (0x009C - 0x0094)
class UTgAIBehaviorAction_MoveBase : public UTgAIBehaviorAction
{
public:
	unsigned long                                      bSubtractPawnRadius : 1;                                  // 0x0094(0x0004) (Edit)
	unsigned long                                      bSubtractTargetPawnRadius : 1;                            // 0x0094(0x0004) (Edit)
	unsigned long                                      bLookAtTarget : 1;                                        // 0x0094(0x0004) (Edit)
	unsigned long                                      bMustHaveLOS : 1;                                         // 0x0094(0x0004) (Edit)
	float                                              MoveTolerance;                                            // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_MoveBase");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_MoveToTarget
// 0x0000 (0x009C - 0x009C)
class UTgAIBehaviorAction_MoveToTarget : public UTgAIBehaviorAction_MoveBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_MoveToTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_FollowCombatTarget
// 0x0001 (0x009D - 0x009C)
class UTgAIBehaviorAction_FollowCombatTarget : public UTgAIBehaviorAction_MoveToTarget
{
public:
	TEnumAsByte<ETG_EQUIP_POINT>                       DeviceSlot;                                               // 0x009C(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_FollowCombatTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_FollowLane
// 0x0004 (0x0098 - 0x0094)
class UTgAIBehaviorAction_FollowLane : public UTgAIBehaviorAction
{
public:
	unsigned long                                      bUseReverseDirection : 1;                                 // 0x0094(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_FollowLane");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_FollowPatrol
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_FollowPatrol : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_FollowPatrol");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_GroupUp
// 0x000C (0x00A8 - 0x009C)
class UTgAIBehaviorAction_GroupUp : public UTgAIBehaviorAction_MoveToTarget
{
public:
	TEnumAsByte<ETG_EQUIP_POINT>                       DeviceSlot;                                               // 0x009C(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x009D(0x0003) MISSED OFFSET
	float                                              MinDistance;                                              // 0x00A0(0x0004) (Edit)
	float                                              MaxDistance;                                              // 0x00A4(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_GroupUp");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_Juke
// 0x0008 (0x009C - 0x0094)
class UTgAIBehaviorAction_Juke : public UTgAIBehaviorAction
{
public:
	float                                              JukeDist;                                                 // 0x0094(0x0004) (Edit)
	float                                              JukeProbability;                                          // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_Juke");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_Jump
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_Jump : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_Jump");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_Leash
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_Leash : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_Leash");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_LookAtCapturePoint
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_LookAtCapturePoint : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_LookAtCapturePoint");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_LookAtCombatTarget
// 0x0004 (0x0098 - 0x0094)
class UTgAIBehaviorAction_LookAtCombatTarget : public UTgAIBehaviorAction
{
public:
	unsigned long                                      bAllowAimNose : 1;                                        // 0x0094(0x0004) (Edit)
	unsigned long                                      bHeadShot : 1;                                            // 0x0094(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_LookAtCombatTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_LookAtFortress
// 0x0004 (0x0098 - 0x0094)
class UTgAIBehaviorAction_LookAtFortress : public UTgAIBehaviorAction
{
public:
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x0094(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_LookAtFortress");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_LookAtLanepusher
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_LookAtLanepusher : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_LookAtLanepusher");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_LookAtSpawnRotation
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_LookAtSpawnRotation : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_LookAtSpawnRotation");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_LookAtTargetLKL
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_LookAtTargetLKL : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_LookAtTargetLKL");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_MoveAroundLanePusher
// 0x0008 (0x00A4 - 0x009C)
class UTgAIBehaviorAction_MoveAroundLanePusher : public UTgAIBehaviorAction_MoveToTarget
{
public:
	TEnumAsByte<ETG_EQUIP_POINT>                       DeviceSlot;                                               // 0x009C(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x009D(0x0003) MISSED OFFSET
	unsigned long                                      bMoveClockWise : 1;                                       // 0x00A0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_MoveAroundLanePusher");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_MoveToAssaultPosition
// 0x0000 (0x009C - 0x009C)
class UTgAIBehaviorAction_MoveToAssaultPosition : public UTgAIBehaviorAction_MoveToTarget
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_MoveToAssaultPosition");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_MoveToAvoidableProjectile
// 0x0004 (0x00A0 - 0x009C)
class UTgAIBehaviorAction_MoveToAvoidableProjectile : public UTgAIBehaviorAction_MoveToTarget
{
public:
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x009C(0x0004) (Edit)
	unsigned long                                      bIgnoreInsideCollision : 1;                               // 0x009C(0x0004) (Edit)
	unsigned long                                      bMoveAway : 1;                                            // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_MoveToAvoidableProjectile");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_MoveToCapturePoint
// 0x0008 (0x00A4 - 0x009C)
class UTgAIBehaviorAction_MoveToCapturePoint : public UTgAIBehaviorAction_MoveToTarget
{
public:
	TEnumAsByte<ESelectionArbitrator>                  Arbitrator;                                               // 0x009C(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x009D(0x0003) MISSED OFFSET
	unsigned long                                      bTeleport : 1;                                            // 0x00A0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_MoveToCapturePoint");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_MoveToCombatLKL
// 0x0000 (0x009C - 0x009C)
class UTgAIBehaviorAction_MoveToCombatLKL : public UTgAIBehaviorAction_MoveToTarget
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_MoveToCombatLKL");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_MoveToCover
// 0x0004 (0x00A0 - 0x009C)
class UTgAIBehaviorAction_MoveToCover : public UTgAIBehaviorAction_MoveToTarget
{
public:
	unsigned long                                      bAllowPopout : 1;                                         // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_MoveToCover");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_MoveToDamagingDeployable
// 0x0004 (0x00A0 - 0x009C)
class UTgAIBehaviorAction_MoveToDamagingDeployable : public UTgAIBehaviorAction_MoveToTarget
{
public:
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x009C(0x0004) (Edit)
	unsigned long                                      bIgnoreInsideCollision : 1;                               // 0x009C(0x0004) (Edit)
	unsigned long                                      bMoveAway : 1;                                            // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_MoveToDamagingDeployable");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_MoveToDeployable
// 0x0008 (0x00A4 - 0x009C)
class UTgAIBehaviorAction_MoveToDeployable : public UTgAIBehaviorAction_MoveToTarget
{
public:
	int                                                DeployableId;                                             // 0x009C(0x0004) (Edit)
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x00A0(0x0004) (Edit)
	unsigned long                                      bIgnoreInsideCollision : 1;                               // 0x00A0(0x0004) (Edit)
	unsigned long                                      bIgnoreTaskforce : 1;                                     // 0x00A0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_MoveToDeployable");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_MoveToLanePusher
// 0x0001 (0x009D - 0x009C)
class UTgAIBehaviorAction_MoveToLanePusher : public UTgAIBehaviorAction_MoveToTarget
{
public:
	TEnumAsByte<ETG_EQUIP_POINT>                       DeviceSlot;                                               // 0x009C(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_MoveToLanePusher");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_MoveToLanePusherFront
// 0x0001 (0x009D - 0x009C)
class UTgAIBehaviorAction_MoveToLanePusherFront : public UTgAIBehaviorAction_MoveToTarget
{
public:
	TEnumAsByte<ETG_EQUIP_POINT>                       DeviceSlot;                                               // 0x009C(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_MoveToLanePusherFront");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_MoveToLaneTarget
// 0x0000 (0x009C - 0x009C)
class UTgAIBehaviorAction_MoveToLaneTarget : public UTgAIBehaviorAction_MoveToTarget
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_MoveToLaneTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_MoveToLaneVolume
// 0x0004 (0x00A0 - 0x009C)
class UTgAIBehaviorAction_MoveToLaneVolume : public UTgAIBehaviorAction_MoveToTarget
{
public:
	unsigned long                                      bMustBeSameLane : 1;                                      // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_MoveToLaneVolume");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_MoveToRallyPoint
// 0x0008 (0x00A4 - 0x009C)
class UTgAIBehaviorAction_MoveToRallyPoint : public UTgAIBehaviorAction_MoveToTarget
{
public:
	TEnumAsByte<ESelectionArbitrator>                  ArbitratorOnMultipleValid;                                // 0x009C(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x009D(0x0003) MISSED OFFSET
	unsigned long                                      bMustBeSameLane : 1;                                      // 0x00A0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_MoveToRallyPoint");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_MoveToShield
// 0x0004 (0x00A0 - 0x009C)
class UTgAIBehaviorAction_MoveToShield : public UTgAIBehaviorAction_MoveToTarget
{
public:
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x009C(0x0004) (Edit)
	unsigned long                                      bIgnoreInsideCollision : 1;                               // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_MoveToShield");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_PauseAI
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_PauseAI : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_PauseAI");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_GetTeamIndex
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_GetTeamIndex : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_GetTeamIndex");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_GetTaskForceNumber
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_GetTaskForceNumber : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_GetTaskForceNumber");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_SetCrowdControlImmune
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_SetCrowdControlImmune : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_SetCrowdControlImmune");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_KillBots
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_KillBots : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_KillBots");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_Killpawns
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_Killpawns : public UTgSeqAct_KillBots
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_Killpawns");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_DespawnBots
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_DespawnBots : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_DespawnBots");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByFireMode
// 0x0005 (0x016D - 0x0168)
class UTgAnimBlendByFireMode : public UTgAnimNodeBlendList
{
public:
	int                                                m_nDefaultFireMode;                                       // 0x0168(0x0004) (Edit)
	TEnumAsByte<ETG_EQUIP_POINT>                       m_EquipPoint;                                             // 0x016C(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByFireMode");
		return ptr;
	}


	void SetDefaultFiremode();
	void SelectFireMode(int FireMode);
};


// Class TgGame.TgSeqAct_JoinTeam
// 0x0008 (0x0110 - 0x0108)
class UTgSeqAct_JoinTeam : public USequenceAction
{
public:
	class AActor*                                      TeamLeader;                                               // 0x0108(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_JoinTeam");
		return ptr;
	}

};


// Class TgGame.TgDamageType_FallOutOfWorld
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_FallOutOfWorld : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_FallOutOfWorld");
		return ptr;
	}

};


// Class TgGame.TgDamageType_Rider
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_Rider : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_Rider");
		return ptr;
	}

};


// Class TgGame.TgCarriedFlag
// 0x004C (0x02CC - 0x0280)
class ATgCarriedFlag : public AActor
{
public:
	int                                                r_nDefenderTaskForce;                                     // 0x0280(0x0004) (Net, Transient)
	class ATgCTFFlagBase*                              s_FlagBase;                                               // 0x0284(0x0008) (Transient)
	unsigned long                                      r_bIsHome : 1;                                            // 0x028C(0x0004) (Net, Transient)
	class ATgPawn_Character*                           m_Holder;                                                 // 0x0290(0x0008) (Transient)
	class ATgRepInfo_Player*                           r_HolderPRI;                                              // 0x0298(0x0008) (Net, Transient)
	class ATgPawn_Character*                           m_OldHolder;                                              // 0x02A0(0x0008) (Transient)
	class AController*                                 m_FirstTouch;                                             // 0x02A8(0x0008)
	TArray<class AController*>                         m_Assists;                                                // 0x02B0(0x0010) (NeedCtorLink)
	float                                              m_fMaxDropTime;                                           // 0x02C0(0x0004)
	float                                              m_fDefaultRadius;                                         // 0x02C4(0x0004) (Transient)
	float                                              m_fDefaultHeight;                                         // 0x02C8(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCarriedFlag");
		return ptr;
	}


	void ClearOldHolder();
	void STATIC_Drop(class AController* Killer, bool bNoThrow);
	void CheckFit();
	void AutoSendHome();
	void STATIC_Score();
	void SendHome();
	void ClearHolder();
	void SetHolder(class AController* C);
	bool STATIC_ValidHolder(class AActor* Other);
	void CheckTouching();
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void PostBeginPlay();
};


// Class TgGame.TgCameraModule_FallOutOfWorld
// 0x0000 (0x0080 - 0x0080)
class UTgCameraModule_FallOutOfWorld : public UTgCameraModule_Free
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_FallOutOfWorld");
		return ptr;
	}


	struct FVector STATIC_GetCamLocationOffset(class APawn* P);
	void UpdateCamera(class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT);
};


// Class TgGame.TgNearObjectiveVolume
// 0x0000 (0x02BC - 0x02BC)
class ATgNearObjectiveVolume : public AVolume
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgNearObjectiveVolume");
		return ptr;
	}


	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgAIBehaviorAction_PlayEmote
// 0x0001 (0x0095 - 0x0094)
class UTgAIBehaviorAction_PlayEmote : public UTgAIBehaviorAction
{
public:
	TEnumAsByte<EEmote>                                EmoteToPlay;                                              // 0x0094(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_PlayEmote");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_PurchaseBurnCards
// 0x000C (0x00A0 - 0x0094)
class UTgAIBehaviorAction_PurchaseBurnCards : public UTgAIBehaviorAction
{
public:
	int                                                BurnCardId;                                               // 0x0094(0x0004) (Edit)
	int                                                DesiredRank;                                              // 0x0098(0x0004) (Edit)
	unsigned long                                      bDontPay : 1;                                             // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_PurchaseBurnCards");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_PurchaseItems
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_PurchaseItems : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_PurchaseItems");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_PurchaseSkills
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_PurchaseSkills : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_PurchaseSkills");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_Regen
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_Regen : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_Regen");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_ReloadDevice
// 0x0001 (0x0095 - 0x0094)
class UTgAIBehaviorAction_ReloadDevice : public UTgAIBehaviorAction
{
public:
	TEnumAsByte<ETG_EQUIP_POINT>                       DeviceToUse;                                              // 0x0094(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_ReloadDevice");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_RunToOwner
// 0x0000 (0x009C - 0x009C)
class UTgAIBehaviorAction_RunToOwner : public UTgAIBehaviorAction_MoveToTarget
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_RunToOwner");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_RunToSpawn
// 0x0000 (0x009C - 0x009C)
class UTgAIBehaviorAction_RunToSpawn : public UTgAIBehaviorAction_MoveToTarget
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_RunToSpawn");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_RunToSpreadLocation
// 0x0000 (0x009C - 0x009C)
class UTgAIBehaviorAction_RunToSpreadLocation : public UTgAIBehaviorAction_MoveToTarget
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_RunToSpreadLocation");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SelectLaneCombatTarget
// 0x0014 (0x00A8 - 0x0094)
class UTgAIBehaviorAction_SelectLaneCombatTarget : public UTgAIBehaviorAction
{
public:
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x0094(0x0004) (Edit)
	unsigned long                                      bMustBeSameLane : 1;                                      // 0x0094(0x0004) (Edit)
	unsigned long                                      bMustHaveLineOfSight : 1;                                 // 0x0094(0x0004) (Edit)
	unsigned long                                      bMustHaveDamagedGod : 1;                                  // 0x0094(0x0004) (Edit)
	unsigned long                                      bMustNotBeImmune : 1;                                     // 0x0094(0x0004) (Edit)
	unsigned long                                      bMustBeInForwardCone : 1;                                 // 0x0094(0x0004) (Edit)
	unsigned long                                      bEffectGroupCategoryCheckInstigator : 1;                  // 0x0094(0x0004) (Edit)
	unsigned long                                      bMustBeHittable : 1;                                      // 0x0094(0x0004) (Edit)
	unsigned long                                      bMustNotBeNearShield : 1;                                 // 0x0094(0x0004) (Edit)
	TEnumAsByte<ETargetSelector>                       TargetSelector;                                           // 0x0098(0x0001) (Edit)
	TEnumAsByte<ECombatTargetType>                     TargetType;                                               // 0x0099(0x0001) (Edit)
	TEnumAsByte<ECombatTargetType>                     IgnoreTargetType;                                         // 0x009A(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x1];                                       // 0x009B(0x0001) MISSED OFFSET
	int                                                EffectCategoryId;                                         // 0x009C(0x0004) (Edit)
	float                                              DistanceThreshold;                                        // 0x00A0(0x0004) (Edit)
	float                                              ForwardConeAngle;                                         // 0x00A4(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SelectLaneCombatTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SelectAllyAttackerAsTarget
// 0x000C (0x00B4 - 0x00A8)
class UTgAIBehaviorAction_SelectAllyAttackerAsTarget : public UTgAIBehaviorAction_SelectLaneCombatTarget
{
public:
	float                                              TimeThreshold;                                            // 0x00A8(0x0004) (Edit)
	float                                              AllyDistanceThreshold;                                    // 0x00AC(0x0004) (Edit)
	float                                              AttackerDistanceThreshold;                                // 0x00B0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SelectAllyAttackerAsTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SelectCombatTarget_FortressObjective
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_SelectCombatTarget_FortressObjective : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SelectCombatTarget_FortressObjective");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SelectCombatTarget_LanepusherLastAttacker
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_SelectCombatTarget_LanepusherLastAttacker : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SelectCombatTarget_LanepusherLastAttacker");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SelectCombatTarget_OwnerLastAttacker
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_SelectCombatTarget_OwnerLastAttacker : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SelectCombatTarget_OwnerLastAttacker");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SelectCombatTargetsTarget
// 0x0004 (0x0098 - 0x0094)
class UTgAIBehaviorAction_SelectCombatTargetsTarget : public UTgAIBehaviorAction
{
public:
	unsigned long                                      bGodsOnly : 1;                                            // 0x0094(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SelectCombatTargetsTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SelectLaneCombatTarget_Jungle
// 0x0005 (0x0099 - 0x0094)
class UTgAIBehaviorAction_SelectLaneCombatTarget_Jungle : public UTgAIBehaviorAction
{
public:
	unsigned long                                      bMustBeWeakest : 1;                                       // 0x0094(0x0004) (Edit)
	TEnumAsByte<EJungleTargetType>                     TargetType;                                               // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SelectLaneCombatTarget_Jungle");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SelectLaneCombatTarget_LastAttacker
// 0x0005 (0x0099 - 0x0094)
class UTgAIBehaviorAction_SelectLaneCombatTarget_LastAttacker : public UTgAIBehaviorAction
{
public:
	unsigned long                                      bSkipPawnNotify : 1;                                      // 0x0094(0x0004) (Edit)
	unsigned long                                      bMustBeHittable : 1;                                      // 0x0094(0x0004) (Edit)
	TEnumAsByte<ECombatTargetType>                     IgnoreTargetType;                                         // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SelectLaneCombatTarget_LastAttacker");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SelectLaneMoveTarget
// 0x0004 (0x0098 - 0x0094)
class UTgAIBehaviorAction_SelectLaneMoveTarget : public UTgAIBehaviorAction
{
public:
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x0094(0x0004) (Edit)
	unsigned long                                      bMustBePhoenix : 1;                                       // 0x0094(0x0004) (Edit)
	unsigned long                                      bMustBeSameLane : 1;                                      // 0x0094(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SelectLaneMoveTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SelectLaneMoveTarget_Jungle
// 0x0001 (0x0095 - 0x0094)
class UTgAIBehaviorAction_SelectLaneMoveTarget_Jungle : public UTgAIBehaviorAction
{
public:
	TEnumAsByte<EJungleTargetType>                     TargetType;                                               // 0x0094(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SelectLaneMoveTarget_Jungle");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SelectLaneMoveTarget_Minotaur
// 0x0004 (0x0098 - 0x0094)
class UTgAIBehaviorAction_SelectLaneMoveTarget_Minotaur : public UTgAIBehaviorAction
{
public:
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x0094(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SelectLaneMoveTarget_Minotaur");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SelectLaneMoveTargetAsCombatTarget
// 0x0004 (0x0098 - 0x0094)
class UTgAIBehaviorAction_SelectLaneMoveTargetAsCombatTarget : public UTgAIBehaviorAction
{
public:
	unsigned long                                      bSkipPawnNotify : 1;                                      // 0x0094(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SelectLaneMoveTargetAsCombatTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SelectLanepusherCombatTarget
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_SelectLanepusherCombatTarget : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SelectLanepusherCombatTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SelectLeashCombatTarget
// 0x000C (0x00A0 - 0x0094)
class UTgAIBehaviorAction_SelectLeashCombatTarget : public UTgAIBehaviorAction
{
public:
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x0094(0x0004) (Edit)
	unsigned long                                      bMustBeWeakest : 1;                                       // 0x0094(0x0004) (Edit)
	unsigned long                                      bMustHaveLineOfSight : 1;                                 // 0x0094(0x0004) (Edit)
	unsigned long                                      bMustHaveDamagedGod : 1;                                  // 0x0094(0x0004) (Edit)
	unsigned long                                      bMustNotBeImmune : 1;                                     // 0x0094(0x0004) (Edit)
	unsigned long                                      bEffectGroupCategoryCheckInstigator : 1;                  // 0x0094(0x0004) (Edit)
	unsigned long                                      bMustBeHittable : 1;                                      // 0x0094(0x0004) (Edit)
	TEnumAsByte<ECombatTargetType>                     TargetType;                                               // 0x0098(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0099(0x0003) MISSED OFFSET
	int                                                EffectCategoryId;                                         // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SelectLeashCombatTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SelectOwnerCombatTarget
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_SelectOwnerCombatTarget : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SelectOwnerCombatTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SelectSquadCombatTarget
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_SelectSquadCombatTarget : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SelectSquadCombatTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SelectThreatCombatTarget
// 0x000C (0x00A0 - 0x0094)
class UTgAIBehaviorAction_SelectThreatCombatTarget : public UTgAIBehaviorAction
{
public:
	unsigned long                                      bMustBeHighestThreat : 1;                                 // 0x0094(0x0004) (Edit)
	unsigned long                                      bMustBeInLeash : 1;                                       // 0x0094(0x0004) (Edit)
	unsigned long                                      bMustBeInSightRadius : 1;                                 // 0x0094(0x0004) (Edit)
	unsigned long                                      bEffectGroupCategoryCheckInstigator : 1;                  // 0x0094(0x0004) (Edit)
	unsigned long                                      bMustBeHittable : 1;                                      // 0x0094(0x0004) (Edit)
	TEnumAsByte<ECombatTargetType>                     TargetType;                                               // 0x0098(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0099(0x0003) MISSED OFFSET
	int                                                EffectCategoryId;                                         // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SelectThreatCombatTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SetAimDevice
// 0x0001 (0x0095 - 0x0094)
class UTgAIBehaviorAction_SetAimDevice : public UTgAIBehaviorAction
{
public:
	TEnumAsByte<ETG_EQUIP_POINT>                       DeviceToUse;                                              // 0x0094(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SetAimDevice");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SetBotBehaviorState
// 0x0001 (0x0095 - 0x0094)
class UTgAIBehaviorAction_SetBotBehaviorState : public UTgAIBehaviorAction
{
public:
	TEnumAsByte<EBotBehaviorState>                     DesiredBehaviorState;                                     // 0x0094(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SetBotBehaviorState");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SpreadFromSquad
// 0x0004 (0x00A0 - 0x009C)
class UTgAIBehaviorAction_SpreadFromSquad : public UTgAIBehaviorAction_MoveToTarget
{
public:
	float                                              SpreadDistance;                                           // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SpreadFromSquad");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_StopDevice
// 0x0001 (0x0095 - 0x0094)
class UTgAIBehaviorAction_StopDevice : public UTgAIBehaviorAction
{
public:
	TEnumAsByte<ETG_EQUIP_POINT>                       DeviceToUse;                                              // 0x0094(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_StopDevice");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_Strafe
// 0x0008 (0x00A4 - 0x009C)
class UTgAIBehaviorAction_Strafe : public UTgAIBehaviorAction_MoveToTarget
{
public:
	float                                              StrafeUpdateTime;                                         // 0x009C(0x0004) (Edit)
	float                                              DistanceMultiplier;                                       // 0x00A0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_Strafe");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SuggestSquadCombatTarget
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_SuggestSquadCombatTarget : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SuggestSquadCombatTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_UpdateTargetLastKnownLocation
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_UpdateTargetLastKnownLocation : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_UpdateTargetLastKnownLocation");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_UseActive
// 0x0001 (0x0095 - 0x0094)
class UTgAIBehaviorAction_UseActive : public UTgAIBehaviorAction
{
public:
	TEnumAsByte<EActiveType>                           ActiveType;                                               // 0x0094(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_UseActive");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_UseConsumable
// 0x0001 (0x0095 - 0x0094)
class UTgAIBehaviorAction_UseConsumable : public UTgAIBehaviorAction
{
public:
	TEnumAsByte<EConsumableType>                       ConsumableType;                                           // 0x0094(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_UseConsumable");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_UseDevice
// 0x0008 (0x009C - 0x0094)
class UTgAIBehaviorAction_UseDevice : public UTgAIBehaviorAction
{
public:
	TEnumAsByte<ETG_EQUIP_POINT>                       DeviceToUse;                                              // 0x0094(0x0001) (Edit)
	TEnumAsByte<EUseDeviceAimType>                     aimType;                                                  // 0x0095(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x2];                                       // 0x0096(0x0002) MISSED OFFSET
	unsigned long                                      bContinuousFire : 1;                                      // 0x0098(0x0004) (Edit)
	unsigned long                                      bPayNoEnergy : 1;                                         // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_UseDevice");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_Wiggle
// 0x0004 (0x0098 - 0x0094)
class UTgAIBehaviorAction_Wiggle : public UTgAIBehaviorAction
{
public:
	float                                              WiggleIntensity;                                          // 0x0094(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_Wiggle");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorComposite_SequenceAND
// 0x0000 (0x00BC - 0x00BC)
class UTgAIBehaviorComposite_SequenceAND : public UTgAIBehaviorComposite_Sequence
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorComposite_SequenceAND");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorComposite_SequenceOR
// 0x0000 (0x00BC - 0x00BC)
class UTgAIBehaviorComposite_SequenceOR : public UTgAIBehaviorComposite_Sequence
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorComposite_SequenceOR");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_AmmoAfterShot
// 0x000B (0x00A0 - 0x0095)
class UTgAIBehaviorCondition_AmmoAfterShot : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<ETG_EQUIP_POINT>                       DeviceSlot;                                               // 0x0098(0x0001) (Edit)
	unsigned char                                      UnknownData01[0x3];                                       // 0x0099(0x0003) MISSED OFFSET
	int                                                AmmoThreshold;                                            // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_AmmoAfterShot");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_AmmoCostPerShot
// 0x000B (0x00A0 - 0x0095)
class UTgAIBehaviorCondition_AmmoCostPerShot : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<ETG_EQUIP_POINT>                       DeviceSlot;                                               // 0x0098(0x0001) (Edit)
	unsigned char                                      UnknownData01[0x3];                                       // 0x0099(0x0003) MISSED OFFSET
	int                                                AmmoThreshold;                                            // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_AmmoCostPerShot");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_AmmoCount
// 0x000B (0x00A0 - 0x0095)
class UTgAIBehaviorCondition_AmmoCount : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<ETG_EQUIP_POINT>                       DeviceSlot;                                               // 0x0098(0x0001) (Edit)
	unsigned char                                      UnknownData01[0x3];                                       // 0x0099(0x0003) MISSED OFFSET
	int                                                AmmoThreshold;                                            // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_AmmoCount");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_CanPurchaseItems
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_CanPurchaseItems : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_CanPurchaseItems");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_CanPurchaseSkills
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_CanPurchaseSkills : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_CanPurchaseSkills");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_CombatTargetDamageable
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_CombatTargetDamageable : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_CombatTargetDamageable");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_CombatTargetDamageableByDevice
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_CombatTargetDamageableByDevice : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<ETG_EQUIP_POINT>                       DeviceSlot;                                               // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_CombatTargetDamageableByDevice");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_CombatTargetDamagedFriendlyGod
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_CombatTargetDamagedFriendlyGod : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_CombatTargetDamagedFriendlyGod");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_DistanceBase
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_DistanceBase : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	float                                              DistanceThreshold;                                        // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_DistanceBase");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_CombatTargetDistanceFromCapturePoint
// 0x0000 (0x009C - 0x009C)
class UTgAIBehaviorCondition_CombatTargetDistanceFromCapturePoint : public UTgAIBehaviorCondition_DistanceBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_CombatTargetDistanceFromCapturePoint");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_CombatTargetDistanceOwner
// 0x0000 (0x009C - 0x009C)
class UTgAIBehaviorCondition_CombatTargetDistanceOwner : public UTgAIBehaviorCondition_DistanceBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_CombatTargetDistanceOwner");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_CombatTargetDropped
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_CombatTargetDropped : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_CombatTargetDropped");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_CombatTargetHealthPercent
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_CombatTargetHealthPercent : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	float                                              HealthPct;                                                // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_CombatTargetHealthPercent");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_CombatTargetHealthPercentAfterAttack
// 0x000B (0x00A0 - 0x0095)
class UTgAIBehaviorCondition_CombatTargetHealthPercentAfterAttack : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<ETG_EQUIP_POINT>                       DeviceSlot;                                               // 0x0098(0x0001) (Edit)
	unsigned char                                      UnknownData01[0x3];                                       // 0x0099(0x0003) MISSED OFFSET
	float                                              HealthPct;                                                // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_CombatTargetHealthPercentAfterAttack");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_CombatTargetInDeviceVolume
// 0x000B (0x00A0 - 0x0095)
class UTgAIBehaviorCondition_CombatTargetInDeviceVolume : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	int                                                DeviceID;                                                 // 0x0098(0x0004) (Edit)
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_CombatTargetInDeviceVolume");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_CombatTargetIsInMinotaurRadius
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_CombatTargetIsInMinotaurRadius : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_CombatTargetIsInMinotaurRadius");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_CombatTargetIsInTowerRadius
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_CombatTargetIsInTowerRadius : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_CombatTargetIsInTowerRadius");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_CombatTargetIsTargetOfFriendlyTowerOrMinotaur
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_CombatTargetIsTargetOfFriendlyTowerOrMinotaur : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_CombatTargetIsTargetOfFriendlyTowerOrMinotaur");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_CombatTargetPhysicsState
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_CombatTargetPhysicsState : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<EPhysics>                              PhysicsState;                                             // 0x0098(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_CombatTargetPhysicsState");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_CurrentLevel
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_CurrentLevel : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	int                                                LevelThreshold;                                           // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_CurrentLevel");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_DeltaGodsInCapturePoint
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_DeltaGodsInCapturePoint : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	int                                                GodThreshold;                                             // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_DeltaGodsInCapturePoint");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_DeviceIsFiring
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_DeviceIsFiring : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<ETG_EQUIP_POINT>                       DeviceSlot;                                               // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_DeviceIsFiring");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_DeviceReadyToUse
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_DeviceReadyToUse : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<ETG_EQUIP_POINT>                       DeviceSlot;                                               // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_DeviceReadyToUse");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_DifficultyLevel
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_DifficultyLevel : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<EBotDifficultyLevel>                   Difficulty;                                               // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_DifficultyLevel");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_DistanceFromAssaultPoint
// 0x0000 (0x009C - 0x009C)
class UTgAIBehaviorCondition_DistanceFromAssaultPoint : public UTgAIBehaviorCondition_DistanceBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_DistanceFromAssaultPoint");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_DistanceFromAvoidableProjectile
// 0x0004 (0x00A0 - 0x009C)
class UTgAIBehaviorCondition_DistanceFromAvoidableProjectile : public UTgAIBehaviorCondition_DistanceBase
{
public:
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_DistanceFromAvoidableProjectile");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_DistanceFromCapturePoint
// 0x0000 (0x009C - 0x009C)
class UTgAIBehaviorCondition_DistanceFromCapturePoint : public UTgAIBehaviorCondition_DistanceBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_DistanceFromCapturePoint");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_DistanceFromCombatTarget
// 0x0000 (0x009C - 0x009C)
class UTgAIBehaviorCondition_DistanceFromCombatTarget : public UTgAIBehaviorCondition_DistanceBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_DistanceFromCombatTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_DistanceFromDamagingDeployable
// 0x0004 (0x00A0 - 0x009C)
class UTgAIBehaviorCondition_DistanceFromDamagingDeployable : public UTgAIBehaviorCondition_DistanceBase
{
public:
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_DistanceFromDamagingDeployable");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_DistanceFromFortressObjective
// 0x0000 (0x009C - 0x009C)
class UTgAIBehaviorCondition_DistanceFromFortressObjective : public UTgAIBehaviorCondition_DistanceBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_DistanceFromFortressObjective");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_DistanceFromLanePusher
// 0x0000 (0x009C - 0x009C)
class UTgAIBehaviorCondition_DistanceFromLanePusher : public UTgAIBehaviorCondition_DistanceBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_DistanceFromLanePusher");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_DistanceFromLaneTarget
// 0x0000 (0x009C - 0x009C)
class UTgAIBehaviorCondition_DistanceFromLaneTarget : public UTgAIBehaviorCondition_DistanceBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_DistanceFromLaneTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_DistanceFromNavigationDestination
// 0x0000 (0x009C - 0x009C)
class UTgAIBehaviorCondition_DistanceFromNavigationDestination : public UTgAIBehaviorCondition_DistanceBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_DistanceFromNavigationDestination");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_DistanceFromOwner
// 0x0000 (0x009C - 0x009C)
class UTgAIBehaviorCondition_DistanceFromOwner : public UTgAIBehaviorCondition_DistanceBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_DistanceFromOwner");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_DistanceFromSelectedTarget
// 0x000C (0x00A8 - 0x009C)
class UTgAIBehaviorCondition_DistanceFromSelectedTarget : public UTgAIBehaviorCondition_DistanceBase
{
public:
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x009C(0x0004) (Edit)
	unsigned long                                      bIgnoreTaskforce : 1;                                     // 0x009C(0x0004) (Edit)
	TEnumAsByte<ETargetSelector>                       TargetSelector;                                           // 0x00A0(0x0001) (Edit)
	TEnumAsByte<ECombatTargetType>                     TargetType;                                               // 0x00A1(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x2];                                       // 0x00A2(0x0002) MISSED OFFSET
	int                                                DeployableId;                                             // 0x00A4(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_DistanceFromSelectedTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_DistanceFromShield
// 0x0004 (0x00A0 - 0x009C)
class UTgAIBehaviorCondition_DistanceFromShield : public UTgAIBehaviorCondition_DistanceBase
{
public:
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_DistanceFromShield");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_DistanceFromSpawn
// 0x0000 (0x009C - 0x009C)
class UTgAIBehaviorCondition_DistanceFromSpawn : public UTgAIBehaviorCondition_DistanceBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_DistanceFromSpawn");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_DistanceFromSquadTarget
// 0x0000 (0x009C - 0x009C)
class UTgAIBehaviorCondition_DistanceFromSquadTarget : public UTgAIBehaviorCondition_DistanceBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_DistanceFromSquadTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_Energy
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_Energy : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	float                                              energy;                                                   // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_Energy");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_GameType
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_GameType : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<ETG_GAME_TYPE>                         GameType;                                                 // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_GameType");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_HasActive
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_HasActive : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<EActiveType>                           ActiveType;                                               // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_HasActive");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_HasCombatTarget
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_HasCombatTarget : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_HasCombatTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_HasConsumable
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_HasConsumable : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<EConsumableType>                       ConsumableType;                                           // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_HasConsumable");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_HasIncomingDamage
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_HasIncomingDamage : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_HasIncomingDamage");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_HasLaneTarget
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_HasLaneTarget : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_HasLaneTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_HasMoveTarget
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_HasMoveTarget : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_HasMoveTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_HasNavigation
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_HasNavigation : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_HasNavigation");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_HasSpreadLocation
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_HasSpreadLocation : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_HasSpreadLocation");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_HealthPercent
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_HealthPercent : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	float                                              HealthPct;                                                // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_HealthPercent");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_InsideDeviceVolume
// 0x000B (0x00A0 - 0x0095)
class UTgAIBehaviorCondition_InsideDeviceVolume : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	int                                                DeviceID;                                                 // 0x0098(0x0004) (Edit)
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_InsideDeviceVolume");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsActiveCapturePoint
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsActiveCapturePoint : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsActiveCapturePoint");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsActiveReady
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_IsActiveReady : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<EActiveType>                           ActiveType;                                               // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsActiveReady");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsAtCapturePoint
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsAtCapturePoint : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsAtCapturePoint");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsAtRallyPoint
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsAtRallyPoint : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsAtRallyPoint");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsAtSpawn
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsAtSpawn : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsAtSpawn");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsAttackingTaskForce
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsAttackingTaskForce : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsAttackingTaskForce");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsBotBehaviorState
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_IsBotBehaviorState : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<EBotBehaviorState>                     TestBehaviorState;                                        // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsBotBehaviorState");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_VisibilityBase
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_VisibilityBase : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	unsigned long                                      bRestrictFoV : 1;                                         // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_VisibilityBase");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsCapturePointVisible
// 0x0000 (0x009C - 0x009C)
class UTgAIBehaviorCondition_IsCapturePointVisible : public UTgAIBehaviorCondition_VisibilityBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsCapturePointVisible");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsCombatTargetHittable
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsCombatTargetHittable : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsCombatTargetHittable");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsCombatTargetHostile
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsCombatTargetHostile : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsCombatTargetHostile");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsCombatTargetInFountain
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsCombatTargetInFountain : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsCombatTargetInFountain");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsCombatTargetInLeash
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsCombatTargetInLeash : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsCombatTargetInLeash");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsCombatTargetInSightRadius
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsCombatTargetInSightRadius : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsCombatTargetInSightRadius");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsCombatTargetLastAttacker
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsCombatTargetLastAttacker : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsCombatTargetLastAttacker");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsCombatTargetOfType
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_IsCombatTargetOfType : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<ECombatTargetType>                     TargetType;                                               // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsCombatTargetOfType");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsCombatTargetShielded
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsCombatTargetShielded : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsCombatTargetShielded");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsCombatTargetSquadTarget
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsCombatTargetSquadTarget : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsCombatTargetSquadTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsCombatTargetStealthed
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsCombatTargetStealthed : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsCombatTargetStealthed");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsCombatTargetVisible
// 0x0000 (0x009C - 0x009C)
class UTgAIBehaviorCondition_IsCombatTargetVisible : public UTgAIBehaviorCondition_VisibilityBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsCombatTargetVisible");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsDecoyState
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_IsDecoyState : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<EDecoyAIState>                         DecoyState;                                               // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsDecoyState");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsDesiredAimDevice
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_IsDesiredAimDevice : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<ETG_EQUIP_POINT>                       DeviceSlot;                                               // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsDesiredAimDevice");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsFortressObjectiveVulnerable
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsFortressObjectiveVulnerable : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsFortressObjectiveVulnerable");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsInFortress
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_IsInFortress : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsInFortress");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsInHostileAbility
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsInHostileAbility : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsInHostileAbility");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsInMinotaurRadius
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_IsInMinotaurRadius : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsInMinotaurRadius");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsInTowerRadius
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_IsInTowerRadius : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsInTowerRadius");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsLanepusherActive
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsLanepusherActive : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsLanepusherActive");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsLanepusherHostile
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsLanepusherHostile : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsLanepusherHostile");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsLanepusherLastAttackerOfType
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_IsLanepusherLastAttackerOfType : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<ECombatTargetType>                     TargetType;                                               // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsLanepusherLastAttackerOfType");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsLanePusherVisible
// 0x0000 (0x009C - 0x009C)
class UTgAIBehaviorCondition_IsLanePusherVisible : public UTgAIBehaviorCondition_VisibilityBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsLanePusherVisible");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsLastAttackerOfType
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_IsLastAttackerOfType : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<ECombatTargetType>                     TargetType;                                               // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsLastAttackerOfType");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsLookingAtCapturePoint
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_IsLookingAtCapturePoint : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	float                                              VisibilityAngle;                                          // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsLookingAtCapturePoint");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsLookingAtCombatTarget
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_IsLookingAtCombatTarget : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	float                                              VisibilityAngle;                                          // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsLookingAtCombatTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsMetaGameState
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_IsMetaGameState : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<EMetaGameState>                        TestGameState;                                            // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsMetaGameState");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsOutsideLeash
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsOutsideLeash : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsOutsideLeash");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsSafeToRecall
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsSafeToRecall : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsSafeToRecall");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsSpawnGateOpen
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsSpawnGateOpen : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsSpawnGateOpen");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsSquadTargetShielded
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsSquadTargetShielded : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsSquadTargetShielded");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsSquadTargetVisible
// 0x0000 (0x009C - 0x009C)
class UTgAIBehaviorCondition_IsSquadTargetVisible : public UTgAIBehaviorCondition_VisibilityBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsSquadTargetVisible");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsTargetOfEnemyTowerOrMinotaur
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsTargetOfEnemyTowerOrMinotaur : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsTargetOfEnemyTowerOrMinotaur");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsTargetTypeInLeash
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_IsTargetTypeInLeash : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<ECombatTargetType>                     TargetType;                                               // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsTargetTypeInLeash");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsTooFarFromLane
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_IsTooFarFromLane : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<ECombatTargetType>                     TargetType;                                               // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsTooFarFromLane");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsWithinCombatDistance
// 0x000C (0x00A1 - 0x0095)
class UTgAIBehaviorCondition_IsWithinCombatDistance : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	unsigned long                                      bSubtractTargetPawnRadius : 1;                            // 0x0098(0x0004) (Edit)
	float                                              DistanceThresholdPercent;                                 // 0x009C(0x0004) (Edit)
	TEnumAsByte<ETG_EQUIP_POINT>                       DeviceSlot;                                               // 0x00A0(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsWithinCombatDistance");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsWithinDistance
// 0x000B (0x00A0 - 0x0095)
class UTgAIBehaviorCondition_IsWithinDistance : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	unsigned long                                      bIsXYOnly : 1;                                            // 0x0098(0x0004) (Edit)
	float                                              DistanceCheck;                                            // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsWithinDistance");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_LanepusherHealthPercent
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_LanepusherHealthPercent : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	float                                              HealthPct;                                                // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_LanepusherHealthPercent");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_ManaPercent
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_ManaPercent : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	float                                              ManaPct;                                                  // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_ManaPercent");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_NearbyAllyAttacked
// 0x000F (0x00A4 - 0x0095)
class UTgAIBehaviorCondition_NearbyAllyAttacked : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	float                                              TimeThreshold;                                            // 0x0098(0x0004) (Edit)
	float                                              AllyDistanceThreshold;                                    // 0x009C(0x0004) (Edit)
	float                                              AttackerDistanceThreshold;                                // 0x00A0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_NearbyAllyAttacked");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_NearbyGodCount
// 0x000C (0x00A8 - 0x009C)
class UTgAIBehaviorCondition_NearbyGodCount : public UTgAIBehaviorCondition_DistanceBase
{
public:
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x009C(0x0004) (Edit)
	unsigned long                                      bMustBeInForwardCone : 1;                                 // 0x009C(0x0004) (Edit)
	int                                                GodThreshold;                                             // 0x00A0(0x0004) (Edit)
	float                                              ForwardConeAngle;                                         // 0x00A4(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_NearbyGodCount");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_NearbyGodDelta
// 0x000C (0x00A8 - 0x009C)
class UTgAIBehaviorCondition_NearbyGodDelta : public UTgAIBehaviorCondition_DistanceBase
{
public:
	int                                                GodThreshold;                                             // 0x009C(0x0004) (Edit)
	unsigned long                                      bMustBeInForwardCone : 1;                                 // 0x00A0(0x0004) (Edit)
	float                                              ForwardConeAngle;                                         // 0x00A4(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_NearbyGodDelta");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_NearbyTargetTypeCount
// 0x0010 (0x00AC - 0x009C)
class UTgAIBehaviorCondition_NearbyTargetTypeCount : public UTgAIBehaviorCondition_DistanceBase
{
public:
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x009C(0x0004) (Edit)
	unsigned long                                      bMustBeInForwardCone : 1;                                 // 0x009C(0x0004) (Edit)
	int                                                TargetTypeThreshold;                                      // 0x00A0(0x0004) (Edit)
	TEnumAsByte<ECombatTargetType>                     TargetType;                                               // 0x00A4(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x00A5(0x0003) MISSED OFFSET
	float                                              ForwardConeAngle;                                         // 0x00A8(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_NearbyTargetTypeCount");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_NearbyTargetTypeDelta
// 0x0010 (0x00AC - 0x009C)
class UTgAIBehaviorCondition_NearbyTargetTypeDelta : public UTgAIBehaviorCondition_DistanceBase
{
public:
	int                                                TargetTypeThreshold;                                      // 0x009C(0x0004) (Edit)
	TEnumAsByte<ECombatTargetType>                     TargetType;                                               // 0x00A0(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x00A1(0x0003) MISSED OFFSET
	unsigned long                                      bMustBeInForwardCone : 1;                                 // 0x00A4(0x0004) (Edit)
	float                                              ForwardConeAngle;                                         // 0x00A8(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_NearbyTargetTypeDelta");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_NearestTowerHealthPercent
// 0x000B (0x00A0 - 0x0095)
class UTgAIBehaviorCondition_NearestTowerHealthPercent : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x0098(0x0004) (Edit)
	float                                              HealthPct;                                                // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_NearestTowerHealthPercent");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_NumberDevicesFiring
// 0x0013 (0x00A8 - 0x0095)
class UTgAIBehaviorCondition_NumberDevicesFiring : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<ETG_EQUIP_POINT>                       DeviceSlot;                                               // 0x0098(0x0001) (Edit)
	unsigned char                                      UnknownData01[0x3];                                       // 0x0099(0x0003) MISSED OFFSET
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x009C(0x0004) (Edit)
	unsigned long                                      bIsFiring : 1;                                            // 0x009C(0x0004) (Edit)
	int                                                GodThreshold;                                             // 0x00A0(0x0004) (Edit)
	float                                              DistanceThreshold;                                        // 0x00A4(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_NumberDevicesFiring");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_NumDeaths
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_NumDeaths : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	int                                                DeathThreshold;                                           // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_NumDeaths");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_NumGodsInCapturePointRadius
// 0x0008 (0x00A4 - 0x009C)
class UTgAIBehaviorCondition_NumGodsInCapturePointRadius : public UTgAIBehaviorCondition_DistanceBase
{
public:
	unsigned long                                      bGodsMustBeEnemy : 1;                                     // 0x009C(0x0004) (Edit)
	int                                                GodThreshold;                                             // 0x00A0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_NumGodsInCapturePointRadius");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_NumGodsInLanePusherRadius
// 0x0008 (0x00A4 - 0x009C)
class UTgAIBehaviorCondition_NumGodsInLanePusherRadius : public UTgAIBehaviorCondition_DistanceBase
{
public:
	unsigned long                                      bGodsMustBeEnemy : 1;                                     // 0x009C(0x0004) (Edit)
	int                                                GodThreshold;                                             // 0x00A0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_NumGodsInLanePusherRadius");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_NumGodsInTowerRadius
// 0x000B (0x00A0 - 0x0095)
class UTgAIBehaviorCondition_NumGodsInTowerRadius : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	unsigned long                                      bGodsMustBeEnemy : 1;                                     // 0x0098(0x0004) (Edit)
	unsigned long                                      bTowerMustBeEnemy : 1;                                    // 0x0098(0x0004) (Edit)
	int                                                GodThreshold;                                             // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_NumGodsInTowerRadius");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_NumGodsNearDeployable
// 0x000C (0x00A8 - 0x009C)
class UTgAIBehaviorCondition_NumGodsNearDeployable : public UTgAIBehaviorCondition_DistanceBase
{
public:
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x009C(0x0004) (Edit)
	int                                                DeployableId;                                             // 0x00A0(0x0004) (Edit)
	int                                                GodThreshold;                                             // 0x00A4(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_NumGodsNearDeployable");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_NumGodsNearProjectile
// 0x000C (0x00A8 - 0x009C)
class UTgAIBehaviorCondition_NumGodsNearProjectile : public UTgAIBehaviorCondition_DistanceBase
{
public:
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x009C(0x0004) (Edit)
	int                                                ProjectileId;                                             // 0x00A0(0x0004) (Edit)
	int                                                GodThreshold;                                             // 0x00A4(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_NumGodsNearProjectile");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_NumMinionsInTowerRadius
// 0x000B (0x00A0 - 0x0095)
class UTgAIBehaviorCondition_NumMinionsInTowerRadius : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	unsigned long                                      bMinionsMustBeEnemy : 1;                                  // 0x0098(0x0004) (Edit)
	unsigned long                                      bTowerMustBeEnemy : 1;                                    // 0x0098(0x0004) (Edit)
	int                                                MinionThreshold;                                          // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_NumMinionsInTowerRadius");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_NumRallyPoints
// 0x000B (0x00A0 - 0x0095)
class UTgAIBehaviorCondition_NumRallyPoints : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	int                                                nRallyPointsThreshold;                                    // 0x0098(0x0004) (Edit)
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x009C(0x0004) (Edit)
	unsigned long                                      bMustBeSameTaskForce : 1;                                 // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_NumRallyPoints");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_PetPhase
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_PetPhase : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<EPetPhase>                             Phase;                                                    // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_PetPhase");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_PhysicsState
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_PhysicsState : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<EPhysics>                              PhysicsState;                                             // 0x0098(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_PhysicsState");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_ReturnAlways
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_ReturnAlways : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<EBehaviorStatus>                       AlwaysReturn;                                             // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_ReturnAlways");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_SelectedTargetHealthPercent
// 0x0010 (0x00AC - 0x009C)
class UTgAIBehaviorCondition_SelectedTargetHealthPercent : public UTgAIBehaviorCondition_DistanceBase
{
public:
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x009C(0x0004) (Edit)
	unsigned long                                      bIgnoreTaskforce : 1;                                     // 0x009C(0x0004) (Edit)
	TEnumAsByte<ETargetSelector>                       TargetSelector;                                           // 0x00A0(0x0001) (Edit)
	TEnumAsByte<ECombatTargetType>                     TargetType;                                               // 0x00A1(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x2];                                       // 0x00A2(0x0002) MISSED OFFSET
	int                                                TargetId;                                                 // 0x00A4(0x0004) (Edit)
	float                                              HealthPct;                                                // 0x00A8(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_SelectedTargetHealthPercent");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_SiegeScore
// 0x000B (0x00A0 - 0x0095)
class UTgAIBehaviorCondition_SiegeScore : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	int                                                ScoreThreshold;                                           // 0x0098(0x0004) (Edit)
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_SiegeScore");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_SquadAverageDistance
// 0x0000 (0x009C - 0x009C)
class UTgAIBehaviorCondition_SquadAverageDistance : public UTgAIBehaviorCondition_DistanceBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_SquadAverageDistance");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_SquadTargetHealthPercent
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_SquadTargetHealthPercent : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	float                                              HealthPct;                                                // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_SquadTargetHealthPercent");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_Taskforce
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_Taskforce : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	int                                                Taskforce;                                                // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_Taskforce");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_TeamDeathCount
// 0x000B (0x00A0 - 0x0095)
class UTgAIBehaviorCondition_TeamDeathCount : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x0098(0x0004) (Edit)
	int                                                DeathThreshold;                                           // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_TeamDeathCount");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_TimeInPayloadMode
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_TimeInPayloadMode : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	float                                              TimeThreshold;                                            // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_TimeInPayloadMode");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_Timer
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_Timer : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	float                                              TimerLength;                                              // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_Timer");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_TimeSinceLanepusherTookDamage
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_TimeSinceLanepusherTookDamage : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	float                                              TimeThreshold;                                            // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_TimeSinceLanepusherTookDamage");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_TimeSinceLastTookDamage
// 0x000B (0x00A0 - 0x0095)
class UTgAIBehaviorCondition_TimeSinceLastTookDamage : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	float                                              TimeThreshold;                                            // 0x0098(0x0004) (Edit)
	unsigned long                                      bMustBeCombatTarget : 1;                                  // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_TimeSinceLastTookDamage");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_WhatIsCombatTargetTargeting
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_WhatIsCombatTargetTargeting : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<ECombatTargetType>                     TargetType;                                               // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_WhatIsCombatTargetTargeting");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_WhatIsLastAttackerTargeting
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_WhatIsLastAttackerTargeting : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<ECombatTargetType>                     TargetType;                                               // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_WhatIsLastAttackerTargeting");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_WonLastPoint
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_WonLastPoint : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_WonLastPoint");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorSensor_Devices
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorSensor_Devices : public UTgAIBehaviorSensor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorSensor_Devices");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorSensor_Fortress
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorSensor_Fortress : public UTgAIBehaviorSensor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorSensor_Fortress");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorSensor_Gods
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorSensor_Gods : public UTgAIBehaviorSensor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorSensor_Gods");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorSensor_IncomingDamage
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorSensor_IncomingDamage : public UTgAIBehaviorSensor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorSensor_IncomingDamage");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorSensor_InHostileAbility
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorSensor_InHostileAbility : public UTgAIBehaviorSensor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorSensor_InHostileAbility");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorSensor_Lane
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorSensor_Lane : public UTgAIBehaviorSensor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorSensor_Lane");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorSensor_Leash
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorSensor_Leash : public UTgAIBehaviorSensor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorSensor_Leash");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorSensor_PurchaseSkills
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorSensor_PurchaseSkills : public UTgAIBehaviorSensor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorSensor_PurchaseSkills");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorSensor_RallyPoints
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorSensor_RallyPoints : public UTgAIBehaviorSensor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorSensor_RallyPoints");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorSensor_SafeToRecall
// 0x0004 (0x0098 - 0x0094)
class UTgAIBehaviorSensor_SafeToRecall : public UTgAIBehaviorSensor
{
public:
	float                                              SafeRecallDist;                                           // 0x0094(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorSensor_SafeToRecall");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorSensor_SightRadius
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorSensor_SightRadius : public UTgAIBehaviorSensor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorSensor_SightRadius");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorSensor_Towers
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorSensor_Towers : public UTgAIBehaviorSensor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorSensor_Towers");
		return ptr;
	}

};


// Class TgGame.TgAIController_BehaviorAerialDrone
// 0x0000 (0x0930 - 0x0930)
class ATgAIController_BehaviorAerialDrone : public ATgAIController_Behavior
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIController_BehaviorAerialDrone");
		return ptr;
	}

};


// Class TgGame.TgAILocalPositionSolver_God
// 0x0000 (0x00A0 - 0x00A0)
class UTgAILocalPositionSolver_God : public UTgAILocalPositionSolver
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAILocalPositionSolver_God");
		return ptr;
	}

};


// Class TgGame.TgAILocalPositionSolver_Pet
// 0x0000 (0x00A0 - 0x00A0)
class UTgAILocalPositionSolver_Pet : public UTgAILocalPositionSolver
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAILocalPositionSolver_Pet");
		return ptr;
	}

};


// Class TgGame.TgAIScout
// 0x0000 (0x065C - 0x065C)
class ATgAIScout : public AScout
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIScout");
		return ptr;
	}

};


// Class TgGame.TgAIUtilityFilter
// 0x0004 (0x00C0 - 0x00BC)
class UTgAIUtilityFilter : public UTgAIUtility
{
public:
	unsigned long                                      bSoftFilter : 1;                                          // 0x00BC(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIUtilityFilter");
		return ptr;
	}

};


// Class TgGame.TgAIUtilityFilter_AssaultRangeType
// 0x0001 (0x00C1 - 0x00C0)
class UTgAIUtilityFilter_AssaultRangeType : public UTgAIUtilityFilter
{
public:
	TEnumAsByte<ERangeType>                            RangeType;                                                // 0x00C0(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIUtilityFilter_AssaultRangeType");
		return ptr;
	}

};


// Class TgGame.TgAIUtilityFilter_CapturePoint
// 0x0004 (0x00C4 - 0x00C0)
class UTgAIUtilityFilter_CapturePoint : public UTgAIUtilityFilter
{
public:
	float                                              DistanceCutoff;                                           // 0x00C0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIUtilityFilter_CapturePoint");
		return ptr;
	}

};


// Class TgGame.TgAIUtilityFilter_DistanceFromPawn
// 0x0008 (0x00C8 - 0x00C0)
class UTgAIUtilityFilter_DistanceFromPawn : public UTgAIUtilityFilter
{
public:
	float                                              DistanceCutoff;                                           // 0x00C0(0x0004) (Edit)
	unsigned long                                      bInverse : 1;                                             // 0x00C4(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIUtilityFilter_DistanceFromPawn");
		return ptr;
	}

};


// Class TgGame.TgAIUtilityFilter_DistanceFromTarget
// 0x0008 (0x00C8 - 0x00C0)
class UTgAIUtilityFilter_DistanceFromTarget : public UTgAIUtilityFilter
{
public:
	float                                              DistanceCutoff;                                           // 0x00C0(0x0004) (Edit)
	unsigned long                                      bInverse : 1;                                             // 0x00C4(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIUtilityFilter_DistanceFromTarget");
		return ptr;
	}

};


// Class TgGame.TgAIUtilityFilter_GameState
// 0x0000 (0x00C0 - 0x00C0)
class UTgAIUtilityFilter_GameState : public UTgAIUtilityFilter
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIUtilityFilter_GameState");
		return ptr;
	}

};


// Class TgGame.TgAIUtilityFilter_InsideActiveRallyPoint
// 0x0004 (0x00C4 - 0x00C0)
class UTgAIUtilityFilter_InsideActiveRallyPoint : public UTgAIUtilityFilter
{
public:
	unsigned long                                      bAllowEnemyRally : 1;                                     // 0x00C0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIUtilityFilter_InsideActiveRallyPoint");
		return ptr;
	}

};


// Class TgGame.TgAIUtilityFilter_LoSToTarget
// 0x0004 (0x00C4 - 0x00C0)
class UTgAIUtilityFilter_LoSToTarget : public UTgAIUtilityFilter
{
public:
	unsigned long                                      bInverse : 1;                                             // 0x00C0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIUtilityFilter_LoSToTarget");
		return ptr;
	}

};


// Class TgGame.TgAIUtilityFilter_LoSToTargetLastKnownLocation
// 0x0004 (0x00C4 - 0x00C0)
class UTgAIUtilityFilter_LoSToTargetLastKnownLocation : public UTgAIUtilityFilter
{
public:
	unsigned long                                      bInverse : 1;                                             // 0x00C0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIUtilityFilter_LoSToTargetLastKnownLocation");
		return ptr;
	}

};


// Class TgGame.TgAIUtilityFilter_Payload
// 0x0004 (0x00C4 - 0x00C0)
class UTgAIUtilityFilter_Payload : public UTgAIUtilityFilter
{
public:
	float                                              DistanceCutoff;                                           // 0x00C0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIUtilityFilter_Payload");
		return ptr;
	}

};


// Class TgGame.TgAIUtilityFilter_StayInTargetFOV
// 0x0004 (0x00C4 - 0x00C0)
class UTgAIUtilityFilter_StayInTargetFOV : public UTgAIUtilityFilter
{
public:
	unsigned long                                      bInverse : 1;                                             // 0x00C0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIUtilityFilter_StayInTargetFOV");
		return ptr;
	}

};


// Class TgGame.TgAIUtilityFunction
// 0x0018 (0x00D4 - 0x00BC)
class UTgAIUtilityFunction : public UTgAIUtility
{
public:
	float                                              MinInput;                                                 // 0x00BC(0x0004) (Edit)
	float                                              MaxInput;                                                 // 0x00C0(0x0004) (Edit)
	TEnumAsByte<EGraphType>                            FunctionType;                                             // 0x00C4(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x00C5(0x0003) MISSED OFFSET
	float                                              DesiredValue;                                             // 0x00C8(0x0004) (Edit)
	float                                              UtilityScale;                                             // 0x00CC(0x0004) (Edit)
	unsigned long                                      bInvert : 1;                                              // 0x00D0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIUtilityFunction");
		return ptr;
	}

};


// Class TgGame.TgAIUtilityFunction_CombatTargetDistance
// 0x0000 (0x00D4 - 0x00D4)
class UTgAIUtilityFunction_CombatTargetDistance : public UTgAIUtilityFunction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIUtilityFunction_CombatTargetDistance");
		return ptr;
	}

};


// Class TgGame.TgAIUtilityFunction_CombatTargetDistanceToNormal
// 0x0000 (0x00D4 - 0x00D4)
class UTgAIUtilityFunction_CombatTargetDistanceToNormal : public UTgAIUtilityFunction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIUtilityFunction_CombatTargetDistanceToNormal");
		return ptr;
	}

};


// Class TgGame.TgAIUtilityFunction_DistanceToPawn
// 0x0000 (0x00D4 - 0x00D4)
class UTgAIUtilityFunction_DistanceToPawn : public UTgAIUtilityFunction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIUtilityFunction_DistanceToPawn");
		return ptr;
	}

};


// Class TgGame.TgAIUtilityFunction_FortressDistance
// 0x0000 (0x00D4 - 0x00D4)
class UTgAIUtilityFunction_FortressDistance : public UTgAIUtilityFunction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIUtilityFunction_FortressDistance");
		return ptr;
	}

};


// Class TgGame.TgAIUtilityFunction_PawnDistanceToNormal
// 0x0000 (0x00D4 - 0x00D4)
class UTgAIUtilityFunction_PawnDistanceToNormal : public UTgAIUtilityFunction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIUtilityFunction_PawnDistanceToNormal");
		return ptr;
	}

};


// Class TgGame.TgAIUtilityFunction_RandomUtility
// 0x0000 (0x00D4 - 0x00D4)
class UTgAIUtilityFunction_RandomUtility : public UTgAIUtilityFunction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIUtilityFunction_RandomUtility");
		return ptr;
	}

};


// Class TgGame.TgSkeletalMeshActor_Posture
// 0x0014 (0x02FC - 0x02E8)
class ATgSkeletalMeshActor_Posture : public ASkeletalMeshActor
{
public:
	TEnumAsByte<ETG_POSTURE>                           r_CurrentPosture;                                         // 0x02E8(0x0001) (Edit, Net)
	unsigned char                                      UnknownData00[0x3];                                       // 0x02E9(0x0003) MISSED OFFSET
	TArray<class UTgAnimBlendByPosture*>               m_PostureBlendNodes;                                      // 0x02EC(0x0010) (Transient, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkeletalMeshActor_Posture");
		return ptr;
	}


	void OnSetSkelPosture(class UTgSeqAct_SetSkelPosture* Action);
	void InitPostureNodes();
	void PostInitAnimTree(class USkeletalMeshComponent* SkelComp);
	void SetActivePosture(TEnumAsByte<ETG_POSTURE> Posture);
	void ReplicatedEvent(const struct FName& VarName);
	void PostBeginPlay();
};


// Class TgGame.TgAnimBlendByTeleportBeacon
// 0x0004 (0x016C - 0x0168)
class UTgAnimBlendByTeleportBeacon : public UTgAnimNodeBlendList
{
public:
	unsigned long                                      m_bDeployed : 1;                                          // 0x0168(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByTeleportBeacon");
		return ptr;
	}


	void STATIC_Undeploy(float fUndeployTime);
	void Deploy(float fDeployTime);
};


// Class TgGame.TgAnimMetaData_SkelControlKeyFrame
// 0x0000 (0x0098 - 0x0098)
class UTgAnimMetaData_SkelControlKeyFrame : public UTgAnimMetaData_SkelControl_BoneScale_KeyFrame
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimMetaData_SkelControlKeyFrame");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeBlendByAbilityDragChain
// 0x0000 (0x0168 - 0x0168)
class UTgAnimNodeBlendByAbilityDragChain : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByAbilityDragChain");
		return ptr;
	}


	void ChainInvalid();
	void ChainMiss();
	void ChainHit();
	void ChainThrow();
};


// Class TgGame.TgAnimNodeBlendByAbilityDragonSlam
// 0x0000 (0x0168 - 0x0168)
class UTgAnimNodeBlendByAbilityDragonSlam : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByAbilityDragonSlam");
		return ptr;
	}


	void STATIC_EndFlying();
	void STATIC_HitTarget();
	void Fly();
	void ReadyFlightFromAir();
	void ReadyFlightFromGround();
};


// Class TgGame.TgAnimNodeBlendByAbilitySmash
// 0x0000 (0x0168 - 0x0168)
class UTgAnimNodeBlendByAbilitySmash : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByAbilitySmash");
		return ptr;
	}


	void Attack();
	void BeginChargeUp();
};


// Class TgGame.TgDeviceMod_CooldownOverride
// 0x0008 (0x0068 - 0x0060)
class UTgDeviceMod_CooldownOverride : public UObject
{
public:
	unsigned long                                      m_bAlwaysIgnoreCD : 1;                                    // 0x0060(0x0004)
	float                                              m_fChanceToIgnoreCD;                                      // 0x0064(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceMod_CooldownOverride");
		return ptr;
	}


	bool ShouldIgnoreCooldown(class ATgDevice* Device);
};


// Class TgGame.TgAnimNodeBlendNPC
// 0x003C (0x01A4 - 0x0168)
class UTgAnimNodeBlendNPC : public UTgAnimNodeBlendList
{
public:
	float                                              m_NoCustomerPresentBlendInTime;                           // 0x0168(0x0004) (Edit)
	float                                              m_CustomerPresentBlendInTime;                             // 0x016C(0x0004) (Edit)
	float                                              m_GreetingBlendInTime;                                    // 0x0170(0x0004) (Edit)
	float                                              m_NoSaleBlendInTime;                                      // 0x0174(0x0004) (Edit)
	float                                              m_CallOutBlendInTime;                                     // 0x0178(0x0004) (Edit)
	float                                              m_SaleBlendInTime;                                        // 0x017C(0x0004) (Edit)
	float                                              m_TransCustomerPresentToNotPresentBlendInTime;            // 0x0180(0x0004) (Edit)
	TArray<struct FName>                               m_UninterruptibleAnims;                                   // 0x0184(0x0010) (Edit, NeedCtorLink)
	TEnumAsByte<ENPCAnimationStates>                   m_QueuedChild;                                            // 0x0194(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0195(0x0003) MISSED OFFSET
	float                                              m_QueuedBlendTime;                                        // 0x0198(0x0004)
	struct FName                                       m_CurrentAnimPlaying;                                     // 0x019C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendNPC");
		return ptr;
	}


	void OnChildAnimEnd(const struct FAnimationEndInformation& Information);
	void PlaySaleAnimation();
	void PlayNoSaleAnimation();
	void PlayCallOutAnimation();
	void PlayCustomerPresentAnimation();
	void PlayGreetingAnimation();
	void PlayNoCustomerPresentAnimation();
	void QueueActiveChild(TEnumAsByte<ENPCAnimationStates> QueuedChild, float BlendTime);
	bool STATIC_IsAnUninterruptableAnim(const struct FName& AnimName);
};


// Class TgGame.TgAnimNodeBlendPerBone_Bakasura_ConsumeMinion
// 0x0000 (0x0158 - 0x0158)
class UTgAnimNodeBlendPerBone_Bakasura_ConsumeMinion : public UAnimNodeBlendPerBone
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendPerBone_Bakasura_ConsumeMinion");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeSequence_ZhongKui_Exorcism
// 0x0000 (0x01BC - 0x01BC)
class UTgAnimNodeSequence_ZhongKui_Exorcism : public UTgAnimNodeSequence
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeSequence_ZhongKui_Exorcism");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeSequenceByBoneRotation
// 0x001C (0x01C8 - 0x01AC)
class UTgAnimNodeSequenceByBoneRotation : public UAnimNodeSequence
{
public:
	struct FName                                       BoneName;                                                 // 0x01AC(0x0008) (Edit)
	TEnumAsByte<EAxis>                                 BoneAxis;                                                 // 0x01B4(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x01B5(0x0003) MISSED OFFSET
	TArray<struct FAnimByRotation>                     AnimList;                                                 // 0x01B8(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeSequenceByBoneRotation");
		return ptr;
	}


	void OnBecomeRelevant();
};


// Class TgGame.TgHavokNavigationHandleAudio
// 0x0000 (0x01D8 - 0x01D8)
class UTgHavokNavigationHandleAudio : public UHavokNavigationHandle
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgHavokNavigationHandleAudio");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_GetBot
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_GetBot : public USequenceAction
{
public:
	int                                                m_nBotNumber;                                             // 0x0108(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_GetBot");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_KillCurrentSquad
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_KillCurrentSquad : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_KillCurrentSquad");
		return ptr;
	}

};


// Class TgGame.TgBotStart
// 0x0000 (0x037C - 0x037C)
class ATgBotStart : public ATgNavigationPoint
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBotStart");
		return ptr;
	}

};


// Class TgGame.TgCameraModule_Attached
// 0x0000 (0x0068 - 0x0068)
class UTgCameraModule_Attached : public UTgCameraModule
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_Attached");
		return ptr;
	}


	void UpdateCamera(class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT);
	struct FRotator STATIC_GetAttachRotation(class APawn* ViewTarget);
	struct FVector STATIC_GetAttachLocation(class APawn* ViewTarget);
};


// Class TgGame.TgCameraModule_Cinematic
// 0x0000 (0x0068 - 0x0068)
class UTgCameraModule_Cinematic : public UTgCameraModule
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_Cinematic");
		return ptr;
	}

};


// Class TgGame.TgCameraModule_Dead
// 0x0000 (0x0080 - 0x0080)
class UTgCameraModule_Dead : public UTgCameraModule_Free
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_Dead");
		return ptr;
	}


	struct FVector STATIC_GetCamLocationOffset(class APawn* P);
	struct FVector STATIC_GetCamLocationOffsetWS(const struct FRotator& PawnRot, const struct FVector& vInCameraSpaceTranslation);
};


// Class TgGame.TgCameraModule_FrontFacingCamera
// 0x0010 (0x0128 - 0x0118)
class UTgCameraModule_FrontFacingCamera : public UTgCameraModule_ThirdPerson
{
public:
	struct FRotator                                    m_rWorldRotationOffset;                                   // 0x0118(0x000C) (Edit)
	float                                              m_fFOV;                                                   // 0x0124(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_FrontFacingCamera");
		return ptr;
	}


	void UpdateCamera(class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT);
	struct FRotator STATIC_GetWorldRotation(class ATgPlayerCamera* CameraActor);
	void OnBecomeInActive(class UTgCameraModule* NewCamera);
	void OnBecomeActive(class UTgCameraModule* OldCamera);
};


// Class TgGame.TgCameraModule_SpectatorThirdPerson
// 0x0034 (0x014C - 0x0118)
class UTgCameraModule_SpectatorThirdPerson : public UTgCameraModule_ThirdPerson
{
public:
	struct FTPOV                                       OldViewpoint;                                             // 0x0118(0x0024) (Transient)
	float                                              RemainingBlendTime;                                       // 0x013C(0x0004) (Transient)
	float                                              TotalBlendTime;                                           // 0x0140(0x0004) (Transient)
	int                                                nLastUsedViewYawRotation;                                 // 0x0144(0x0004)
	float                                              fYawLockedRotSmoothRate;                                  // 0x0148(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_SpectatorThirdPerson");
		return ptr;
	}


	void BlendToTarget(float BlendTime);
	void UpdateCamera(class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT);
};


// Class TgGame.TgCameraModule_SpectatorFirstPerson
// 0x0000 (0x014C - 0x014C)
class UTgCameraModule_SpectatorFirstPerson : public UTgCameraModule_SpectatorThirdPerson
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_SpectatorFirstPerson");
		return ptr;
	}

};


// Class TgGame.TgCameraModule_SpectatorLockedView
// 0x001C (0x00B8 - 0x009C)
class UTgCameraModule_SpectatorLockedView : public UTgCameraModule_Spectator
{
public:
	struct FRotator                                    WorldViewRotation;                                        // 0x009C(0x000C) (Edit)
	unsigned long                                      bAutoRotate : 1;                                          // 0x00A8(0x0004) (Edit)
	float                                              FOV;                                                      // 0x00AC(0x0004)
	float                                              ZoomIncrement;                                            // 0x00B0(0x0004)
	int                                                CurrentWorldViewTargetIndex;                              // 0x00B4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_SpectatorLockedView");
		return ptr;
	}


	void RotateView();
	void STATIC_ZoomOut();
	void STATIC_ZoomIn();
	void UpdateCamera(class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT);
	void BlendCameraToLocation(const struct FVector& NewLocation, float BlendTime, bool bUseFocalPoint);
	void OnBecomeInActive(class UTgCameraModule* NewCamera);
	void OnBecomeActive(class UTgCameraModule* OldCamera);
};


// Class TgGame.TgCameraModule_ThirdPersonVariableHeight
// 0x0004 (0x011C - 0x0118)
class UTgCameraModule_ThirdPersonVariableHeight : public UTgCameraModule_ThirdPerson
{
public:
	float                                              ZOffset;                                                  // 0x0118(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_ThirdPersonVariableHeight");
		return ptr;
	}


	struct FVector STATIC_GetCamLocationOffset(const struct FRotator& PawnRot, const struct FVector& vInCameraSpaceTranslation);
	void OnBecomeActive(class UTgCameraModule* OldCamera);
};


// Class TgGame.TgSeqEvent_ControlPointOwnershipChange
// 0x0004 (0x012C - 0x0128)
class UTgSeqEvent_ControlPointOwnershipChange : public USequenceEvent
{
public:
	int                                                PointIndex;                                               // 0x0128(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_ControlPointOwnershipChange");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_ControlPointOwnershipChange_Server
// 0x0004 (0x012C - 0x0128)
class UTgSeqEvent_ControlPointOwnershipChange_Server : public USequenceEvent
{
public:
	int                                                PointIndex;                                               // 0x0128(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_ControlPointOwnershipChange_Server");
		return ptr;
	}

};


// Class TgGame.TgCTFFlagBase
// 0x0014 (0x0294 - 0x0280)
class ATgCTFFlagBase : public AActor
{
public:
	int                                                m_nDefenderTaskForce;                                     // 0x0280(0x0004) (Edit, Const)
	class ATgCarriedFlag*                              m_SpawnedFlag;                                            // 0x0284(0x0008) (Transient)
	class ATgGame_CTF*                                 m_CTFGame;                                                // 0x028C(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCTFFlagBase");
		return ptr;
	}


	void DestroyFlag();
	void SpawnFlag();
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void CheckTouching();
	void PostBeginPlay();
};


// Class TgGame.TgSeqEvent_ChaosObjectiveActive
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_ChaosObjectiveActive : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_ChaosObjectiveActive");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_ChaosObjectiveStatus
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_ChaosObjectiveStatus : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_ChaosObjectiveStatus");
		return ptr;
	}


	void UpdateLinkedVars(bool bFriendlyTaskForce);
};


// Class TgGame.TgMobileAmbientSound
// 0x0000 (0x0294 - 0x0294)
class ATgMobileAmbientSound : public AAkAmbientSound
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMobileAmbientSound");
		return ptr;
	}

};


// Class TgGame.TgOnlineGameSettings
// 0x0000 (0x0144 - 0x0144)
class UTgOnlineGameSettings : public UOnlineGameSettings
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgOnlineGameSettings");
		return ptr;
	}

};


// Class TgGame.TgControlModule_Dummy
// 0x0000 (0x006C - 0x006C)
class UTgControlModule_Dummy : public UTgControlModule
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgControlModule_Dummy");
		return ptr;
	}

};


// Class TgGame.TgCreditCache
// 0x0040 (0x02C0 - 0x0280)
class ATgCreditCache : public AActor
{
public:
	unsigned long                                      r_bActive : 1;                                            // 0x0280(0x0004) (Net)
	int                                                m_nValueLevel;                                            // 0x0284(0x0004)
	int                                                m_nCreditValue;                                           // 0x0288(0x0004)
	float                                              m_fCreditCacheGainDuration;                               // 0x028C(0x0004)
	float                                              m_fCollisionProxyRadius;                                  // 0x0290(0x0004)
	float                                              m_fCollisionProxyHeight;                                  // 0x0294(0x0004)
	class ATgPawn*                                     m_currentCaptor;                                          // 0x0298(0x0008)
	class UStaticMeshComponent*                        SMC;                                                      // 0x02A0(0x0008) (Edit, ExportObject, Component, EditInline)
	class ATgCollisionProxy_Cylinder*                  s_CollisionProxy;                                         // 0x02A8(0x0008)
	TArray<class ATgPawn_Character*>                   m_touchingCharacters;                                     // 0x02B0(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCreditCache");
		return ptr;
	}


	void CollisionProxyOnUnTouch(class AActor* Other);
	void GiveCredits();
	void SetCurrentCaptor(class ATgPawn* TgP);
	void ConsiderForCurrentCaptor(class ATgPawn_Character* TgPC);
	void CollisionProxyOnTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void Deactivate();
	void STATIC_Activate();
	void Tick(float DeltaSeconds);
	void STATIC_UpdateVisibility();
	void PostBeginPlay();
	void ReplicatedEvent(const struct FName& VarName);
};


// Class TgGame.TgCTFVolume
// 0x0004 (0x0318 - 0x0314)
class ATgCTFVolume : public APhysicsVolume
{
public:
	int                                                m_nDefenderTeamIndex;                                     // 0x0314(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCTFVolume");
		return ptr;
	}


	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	int SortByTimestamp(class ATgPawn* A, class ATgPawn* B);
	bool STATIC_IsValidToucher(class ATgPawn_Character* TgP);
	void STATIC_TimerPop(class AVolumeTimer* T);
};


// Class TgGame.TgDamageType_PaladinsConcussive
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_PaladinsConcussive : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_PaladinsConcussive");
		return ptr;
	}

};


// Class TgGame.TgDamageType_PaladinsConcussive_Latent
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_PaladinsConcussive_Latent : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_PaladinsConcussive_Latent");
		return ptr;
	}

};


// Class TgGame.TgDamageType_DragonSlam
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_DragonSlam : public UTgDamageType_PaladinsConcussive
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_DragonSlam");
		return ptr;
	}

};


// Class TgGame.TgDamageType_GeneralAfflicted
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_GeneralAfflicted : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_GeneralAfflicted");
		return ptr;
	}

};


// Class TgGame.TgDamageType_GeneralCharred
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_GeneralCharred : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_GeneralCharred");
		return ptr;
	}

};


// Class TgGame.TgDamageType_GeneralConcussion
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_GeneralConcussion : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_GeneralConcussion");
		return ptr;
	}

};


// Class TgGame.TgDamageType_GeneralElectric
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_GeneralElectric : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_GeneralElectric");
		return ptr;
	}

};


// Class TgGame.TgDamageType_GeneralFlattened
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_GeneralFlattened : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_GeneralFlattened");
		return ptr;
	}

};


// Class TgGame.TgDamageType_GeneralImpulseOut
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_GeneralImpulseOut : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_GeneralImpulseOut");
		return ptr;
	}

};


// Class TgGame.TgDamageType_GeneralMidImpulse
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_GeneralMidImpulse : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_GeneralMidImpulse");
		return ptr;
	}

};


// Class TgGame.TgDamageType_GeneralOnFire
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_GeneralOnFire : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_GeneralOnFire");
		return ptr;
	}

};


// Class TgGame.TgDamageType_MeleeBasicAttack
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_MeleeBasicAttack : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_MeleeBasicAttack");
		return ptr;
	}

};


// Class TgGame.TgDamageType_MeleeBasicAttackImpulse
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_MeleeBasicAttackImpulse : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_MeleeBasicAttackImpulse");
		return ptr;
	}

};


// Class TgGame.TgDamageType_PaladinsAcid
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_PaladinsAcid : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_PaladinsAcid");
		return ptr;
	}

};


// Class TgGame.TgDamageType_PaladinsAcid_Latent
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_PaladinsAcid_Latent : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_PaladinsAcid_Latent");
		return ptr;
	}

};


// Class TgGame.TgDamageType_PaladinsBullet
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_PaladinsBullet : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_PaladinsBullet");
		return ptr;
	}

};


// Class TgGame.TgDamageType_PaladinsBullet_Latent
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_PaladinsBullet_Latent : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_PaladinsBullet_Latent");
		return ptr;
	}

};


// Class TgGame.TgDamageType_PaladinsExplosive
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_PaladinsExplosive : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_PaladinsExplosive");
		return ptr;
	}

};


// Class TgGame.TgDamageType_PaladinsExplosive_Latent
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_PaladinsExplosive_Latent : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_PaladinsExplosive_Latent");
		return ptr;
	}

};


// Class TgGame.TgDamageType_PaladinsFire
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_PaladinsFire : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_PaladinsFire");
		return ptr;
	}

};


// Class TgGame.TgDamageType_PaladinsFire_Latent
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_PaladinsFire_Latent : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_PaladinsFire_Latent");
		return ptr;
	}

};


// Class TgGame.TgDamageType_PaladinsIce
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_PaladinsIce : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_PaladinsIce");
		return ptr;
	}

};


// Class TgGame.TgDamageType_PaladinsIce_Latent
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_PaladinsIce_Latent : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_PaladinsIce_Latent");
		return ptr;
	}

};


// Class TgGame.TgDamageType_PaladinsLightning
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_PaladinsLightning : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_PaladinsLightning");
		return ptr;
	}

};


// Class TgGame.TgDamageType_PaladinsLightning_Latent
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_PaladinsLightning_Latent : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_PaladinsLightning_Latent");
		return ptr;
	}

};


// Class TgGame.TgDamageType_PaladinsPiercing
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_PaladinsPiercing : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_PaladinsPiercing");
		return ptr;
	}

};


// Class TgGame.TgDamageType_PaladinsPiercing_Latent
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_PaladinsPiercing_Latent : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_PaladinsPiercing_Latent");
		return ptr;
	}

};


// Class TgGame.TgDamageType_PaladinsPoison
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_PaladinsPoison : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_PaladinsPoison");
		return ptr;
	}

};


// Class TgGame.TgDamageType_PaladinsPoison_Latent
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_PaladinsPoison_Latent : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_PaladinsPoison_Latent");
		return ptr;
	}

};


// Class TgGame.TgDamageType_PaladinsRoyaleLifeDrain
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_PaladinsRoyaleLifeDrain : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_PaladinsRoyaleLifeDrain");
		return ptr;
	}

};


// Class TgGame.TgDamageType_RangedBasicAttack
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_RangedBasicAttack : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_RangedBasicAttack");
		return ptr;
	}

};


// Class TgGame.TgDamageType_RangedBasicAttackImpulse
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_RangedBasicAttackImpulse : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_RangedBasicAttackImpulse");
		return ptr;
	}

};


// Class TgGame.TgDamageType_RangedShot
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_RangedShot : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_RangedShot");
		return ptr;
	}

};


// Class TgGame.TgDebugCameraController
// 0x0000 (0x07C8 - 0x07C8)
class ATgDebugCameraController : public ADebugCameraController
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDebugCameraController");
		return ptr;
	}


	void DisableDebugCamera();
	void Camera(const struct FName& NewMode);
};


// Class TgGame.TgDebugCameraInput
// 0x0000 (0x02D4 - 0x02D4)
class UTgDebugCameraInput : public UDebugCameraInput
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDebugCameraInput");
		return ptr;
	}

};


// Class TgGame.TgDefensePoint
// 0x0024 (0x03A0 - 0x037C)
class ATgDefensePoint : public ATgNavigationPoint
{
public:
	class AController*                                 CurrentUser;                                              // 0x037C(0x0008)
	class ATgDefensePoint*                             NextDefensePoint;                                         // 0x0384(0x0008)
	unsigned long                                      bFirstScript : 1;                                         // 0x038C(0x0004)
	unsigned long                                      bSniping : 1;                                             // 0x038C(0x0004) (Edit)
	unsigned long                                      bDontChangePosition : 1;                                  // 0x038C(0x0004) (Edit)
	unsigned long                                      bAvoid : 1;                                               // 0x038C(0x0004)
	unsigned long                                      bDisabled : 1;                                            // 0x038C(0x0004)
	unsigned long                                      bNotInVehicle : 1;                                        // 0x038C(0x0004) (Edit)
	unsigned char                                      Priority;                                                 // 0x0390(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0391(0x0003) MISSED OFFSET
	class UClass*                                      WeaponPreference;                                         // 0x0394(0x0008) (Edit)
	float                                              NumChecked;                                               // 0x039C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDefensePoint");
		return ptr;
	}


	class AActor* STATIC_GetMoveTarget();
	bool STATIC_HigherPriorityThan(class ATgDefensePoint* S, class ATgAIController* B);
	void PreBeginPlay();
	void STATIC_FreePoint();
	void Reset();
};


// Class TgGame.TgSeqEvent_TimeLapse
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_TimeLapse : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_TimeLapse");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_RestartPlayers
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_RestartPlayers : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_RestartPlayers");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_TgCameraShake
// 0x0010 (0x0118 - 0x0108)
class UTgSeqAct_TgCameraShake : public USequenceAction
{
public:
	class UTgCameraShake*                              m_CameraShake;                                            // 0x0108(0x0008) (Edit)
	class AActor*                                      m_LocationActor;                                          // 0x0110(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_TgCameraShake");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_LogTutorialAction
// 0x0008 (0x0110 - 0x0108)
class UTgSeqAct_LogTutorialAction : public USequenceAction
{
public:
	int                                                PlayerAction;                                             // 0x0108(0x0004) (Edit)
	int                                                EventData;                                                // 0x010C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_LogTutorialAction");
		return ptr;
	}

};


// Class TgGame.TgTutorialAnnouncer
// 0x0030 (0x0090 - 0x0060)
class UTgTutorialAnnouncer : public UObject
{
public:
	TArray<class USoundCue*>                           TutorialSounds;                                           // 0x0060(0x0010) (NeedCtorLink)
	TArray<class USoundCue*>                           QueuedSounds;                                             // 0x0070(0x0010) (Transient, NeedCtorLink)
	class UAudioComponent*                             CurrentSoundAC;                                           // 0x0080(0x0008) (ExportObject, Transient, Component, EditInline)
	class ATgPlayerController*                         OwnerPC;                                                  // 0x0088(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgTutorialAnnouncer");
		return ptr;
	}


	void PlayAnnouncement(int SoundIndex, class USoundCue* OptionalCue, bool bPlayImmediately, bool bFlushOthers);
	void AudioFinishedPlaying(class UAudioComponent* AC);
	void Destroyed();
	void Init();
};


// Class TgGame.TgSeqEvent_CrowdEvent
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_CrowdEvent : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_CrowdEvent");
		return ptr;
	}

};


// Class TgGame.TgFatalityFactory
// 0x000C (0x028C - 0x0280)
class ATgFatalityFactory : public AActor
{
public:
	class ATgFatalityMeshActor*                        m_FatalityMeshActor;                                      // 0x0280(0x0008)
	struct FLightingChannelContainer                   m_LightingChannels;                                       // 0x0288(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgFatalityFactory");
		return ptr;
	}


	void PlayEpicFatality(int MeshAsmId);
};


// Class TgGame.TgSeqEvent_PlayIntro
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_PlayIntro : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_PlayIntro");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_SpectatorReady
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_SpectatorReady : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_SpectatorReady");
		return ptr;
	}


	bool TriggerGlobal(class ATgSpectatorController* InInstigator);
};


// Class TgGame.TgSpectatorTempCam
// 0x0004 (0x0424 - 0x0420)
class ATgSpectatorTempCam : public ADynamicCameraActor
{
public:
	unsigned long                                      bIsViewTarget : 1;                                        // 0x0420(0x0004)
	unsigned long                                      bIsBookmark : 1;                                          // 0x0420(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSpectatorTempCam");
		return ptr;
	}


	void DestroyIfNeeded();
	void SetIsBookmark(bool bBookmark);
	void EndViewTarget(class APlayerController* PC);
	void BecomeViewTarget(class APlayerController* PC);
};


// Class TgGame.TgDevice_BoobyTrap
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_BoobyTrap : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_BoobyTrap");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	bool CheckExplode(class ATgDeployable* Ward, TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgDeploy_FlagballGoalMarker
// 0x0000 (0x046C - 0x046C)
class ATgDeploy_FlagballGoalMarker : public ATgDeployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_FlagballGoalMarker");
		return ptr;
	}

};


// Class TgGame.TgDeploy_GeometryBuck
// 0x0004 (0x0498 - 0x0494)
class ATgDeploy_GeometryBuck : public ATgDeploy_Geometry
{
public:
	unsigned long                                      m_bInteriorEffectApplied : 1;                             // 0x0494(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_GeometryBuck");
		return ptr;
	}


	void Destroyed();
	void Tick(float DeltaSeconds);
};


// Class TgGame.TgMidnightFogVolumeDensityInfo
// 0x0020 (0x02B4 - 0x0294)
class ATgMidnightFogVolumeDensityInfo : public AFogVolumeSphericalDensityInfo
{
public:
	unsigned long                                      m_bFogOn : 1;                                             // 0x0294(0x0004)
	unsigned long                                      m_bFogUpdateNeeded : 1;                                   // 0x0294(0x0004)
	unsigned long                                      m_bIsFadingOut : 1;                                       // 0x0294(0x0004)
	float                                              m_fCurrentStartDistance;                                  // 0x0298(0x0004)
	float                                              m_fFadeOutDuration;                                       // 0x029C(0x0004)
	float                                              m_fFadeOutTimer;                                          // 0x02A0(0x0004)
	float                                              m_fTargetMaxDensity;                                      // 0x02A4(0x0004)
	float                                              m_fDestroyTimer;                                          // 0x02A8(0x0004)
	class UFogVolumeSphericalDensityComponent*         SphericalDensityComponent;                                // 0x02AC(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMidnightFogVolumeDensityInfo");
		return ptr;
	}


	void STATIC_SetAlpha(float fNewAlpha);
	void Tick(float DeltaTime);
	void FadeOut(float fFadeTime);
	void SetStartDistance(float fNewStartDistance);
	void STATIC_SetOrigin(const struct FVector& vOrigin);
	void ToggleFog(bool bOn);
	void PostBeginPlay();
};


// Class TgGame.TgDeploy_SpinningShield
// 0x0004 (0x0474 - 0x0470)
class ATgDeploy_SpinningShield : public ATgDeploy_Shield
{
public:
	float                                              r_fRotationOffset;                                        // 0x0470(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_SpinningShield");
		return ptr;
	}

};


// Class TgGame.TgWeaponMeshActor_AndroxusInhand
// 0x0000 (0x0450 - 0x0450)
class ATgWeaponMeshActor_AndroxusInhand : public ATgWeaponMeshActor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgWeaponMeshActor_AndroxusInhand");
		return ptr;
	}


	void StopFireEffects(int nEquipSlot, int nFireMode);
	void PlayFireEffects(int nEquipSlot, float fRefireTime, int nFireMode);
	void STATIC_FixUpReferencesToWeaponMesh1P(class USkeletalMeshComponent* weaponMesh);
};


// Class TgGame.TgDevice_ApplyCooldownModToChild
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_ApplyCooldownModToChild : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ApplyCooldownModToChild");
		return ptr;
	}


	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
};


// Class TgGame.TgDevice_ApplyHitOnChildGeneric1
// 0x0000 (0x0A14 - 0x0A14)
class ATgDevice_ApplyHitOnChildGeneric1 : public ATgDevice_ActivateOnChildGeneric1
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ApplyHitOnChildGeneric1");
		return ptr;
	}


	void STATIC_Activate();
};


// Class TgGame.TgWeaponMeshActor_GauntletInhand
// 0x0000 (0x0450 - 0x0450)
class ATgWeaponMeshActor_GauntletInhand : public ATgWeaponMeshActor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgWeaponMeshActor_GauntletInhand");
		return ptr;
	}


	void SetBeamTangent(const struct FVector& HitLocation, int nEquipSlot);
	void STATIC_UpdateFireLoopBeamParams(bool bHasEndPoint, const struct FVector& HitLocation, int nEquipSlot);
	void PlayFireFx(int nEquipSlot, int nFireMode);
	bool STATIC_GetAccurateBeamTarget(int nEquipSlot, struct FVector* HitLocation);
	bool STATIC_GetSimulatedBeamTarget(int nEquipSlot, struct FVector* HitLocation);
	void STATIC_UpdateTransform(float DeltaTime, bool bFromCameraUpdate);
};


// Class TgGame.TgWeaponMeshActor_AstroInhand
// 0x0000 (0x0450 - 0x0450)
class ATgWeaponMeshActor_AstroInhand : public ATgWeaponMeshActor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgWeaponMeshActor_AstroInhand");
		return ptr;
	}


	void StopFireEffects(int nEquipSlot, int nFireMode);
	void PlayFireFx(int nEquipSlot, int nFireMode);
	void STATIC_Hide3PWeaponMesh();
	void STATIC_Unhide3PWeaponMesh();
	void STATIC_Initialize3P(unsigned char EquipPoint, int DeviceID);
	void STATIC_Initialize1P(unsigned char EquipPoint, int DeviceID, int MeshAsmId1P);
};


// Class TgGame.TgDevice_BarikInhand
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_BarikInhand : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_BarikInhand");
		return ptr;
	}


	void STATIC_InterruptOtherDevices(class ATgPawn* TgP);
};


// Class TgGame.TgDevice_Barrier
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_Barrier : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Barrier");
		return ptr;
	}


	void STATIC_InterruptOtherDevices(class ATgPawn* TgP);
	void STATIC_InitMaxHealth();
};


// Class TgGame.TgWeaponMeshActor_BarrierTankInhand
// 0x0000 (0x0450 - 0x0450)
class ATgWeaponMeshActor_BarrierTankInhand : public ATgWeaponMeshActor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgWeaponMeshActor_BarrierTankInhand");
		return ptr;
	}


	void PlayFireAnimation(int nEquipSlot, float fRefireTime);
};


// Class TgGame.TgDevice_IceBlock
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_IceBlock : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_IceBlock");
		return ptr;
	}


	bool CanBeCanceled();
};


// Class TgGame.TgWeaponMeshActor_BuckInhand
// 0x0020 (0x0470 - 0x0450)
class ATgWeaponMeshActor_BuckInhand : public ATgWeaponMeshActor
{
public:
	TArray<class UTgAnimBlendByProgressiveReload*>     m_PawnMeshProgressiveReloadNodes;                         // 0x0450(0x0010) (NeedCtorLink)
	TArray<class UTgAnimBlendByProgressiveReload*>     m_ProgressiveReloadNodes;                                 // 0x0460(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgWeaponMeshActor_BuckInhand");
		return ptr;
	}


	void PlayReload(int nEquipPoint, float reloadTime, int AmmoRemainingInClip, int ReloadType);
	void STATIC_FixUpReferencesToPawnMesh(class USkeletalMeshComponent* PawnMesh);
	void STATIC_FixUpReferencesToWeaponMesh1P(class USkeletalMeshComponent* weaponMesh);
};


// Class TgGame.TgDevice_Burninate
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_Burninate : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Burninate");
		return ptr;
	}

};


// Class TgGame.TgDevice_CassieInhand
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_CassieInhand : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CassieInhand");
		return ptr;
	}

};


// Class TgGame.TgDevice_ChainLightning
// 0x0008 (0x0A2C - 0x0A24)
class ATgDevice_ChainLightning : public ATgDevice_ArcingBeam
{
public:
	class ATgDevice*                                   m_CachedInhand;                                           // 0x0A24(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ChainLightning");
		return ptr;
	}

};


// Class TgGame.TgDevice_ChurchillTurret
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_ChurchillTurret : public ATgDevice
{
public:
	class ATgPawn_Churchill*                           m_CachedChurchill;                                        // 0x0A0C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ChurchillTurret");
		return ptr;
	}


	bool CanDeviceStartFiringNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDebugRelevant, bool bIgnoreCachedValue, TEnumAsByte<EDeviceFailType>* failType);
	bool ShouldConsumePowerPoolAfterFire();
	bool ShouldConsumePowerPoolOnStartFire();
};


// Class TgGame.TgDevice_ChurchillWard
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_ChurchillWard : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ChurchillWard");
		return ptr;
	}

};


// Class TgGame.TgDevice_Compensator
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_Compensator : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Compensator");
		return ptr;
	}


	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
	void ApplyRecoilReduction(class ATgDevice* Dev, bool bShouldApply);
};


// Class TgGame.TgDevice_DarkBargain
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_DarkBargain : public ATgDevice
{
public:
	class ATgDevice_DredgeF*                           m_CachedDredgeF;                                          // 0x0A0C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DarkBargain");
		return ptr;
	}


	void ApplyHeal();
	void CheckHeal();
	void LinkedDeviceEquipped(class ATgDevice* Dev);
	void LinkedDeviceUnequipped(class ATgDevice* Dev);
};


// Class TgGame.TgDevice_DredgeF
// 0x0028 (0x0A34 - 0x0A0C)
class ATgDevice_DredgeF : public ATgDevice
{
public:
	class ATgDeploy_DredgeF*                           r_Portals[0x2];                                           // 0x0A0C(0x0008) (Net)
	int                                                r_nNextDeployable;                                        // 0x0A1C(0x0004) (Net)
	struct FVector                                     s_vTeleportTarget;                                        // 0x0A20(0x000C)
	class ATgPawn*                                     m_CachedTgP;                                              // 0x0A2C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DredgeF");
		return ptr;
	}


	void CheckPortalsActive();
	void OnDeployableSpawned(class ATgDeployable* deployable);
	void OnDeployableDestroyed(class ATgDeployable* deployable);
	void ReplicatedEvent(const struct FName& VarName);
	bool CanDeviceStartFiringNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDebugRelevant, bool bIgnoreCachedValue, TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgDevice_DeepRoots
// 0x0000 (0x0A24 - 0x0A24)
class ATgDevice_DeepRoots : public ATgDevice_ArcingBeam
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DeepRoots");
		return ptr;
	}


	void STATIC_ApplyCustomFireToInitial(class AActor* InitialTarget, class UTgDeviceFire* FireMode);
	void TriggerArc(int Index);
};


// Class TgGame.TgWeaponMeshActor_DemonInhand
// 0x0000 (0x0450 - 0x0450)
class ATgWeaponMeshActor_DemonInhand : public ATgWeaponMeshActor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgWeaponMeshActor_DemonInhand");
		return ptr;
	}


	void OverrideTracerFireLoc(int nIndex, struct FVector* FireLoc);
};


// Class TgGame.TgDevice_Devastation
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_Devastation : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Devastation");
		return ptr;
	}


	void STATIC_FireAmmunition();
};


// Class TgGame.TgDevice_Rewind
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_Rewind : public ATgDevice
{
public:
	class ATgDevice_Illusion*                          m_CachedIllusionDevice;                                   // 0x0A0C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Rewind");
		return ptr;
	}


	void LinkedDeviceEquipped(class ATgDevice* Dev);
	void STATIC_DoRewindCardLogic(class ATgDevice_DimensionalLink* dimensionalLinkDevice);
};


// Class TgGame.TgDevice_Disengage
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_Disengage : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Disengage");
		return ptr;
	}

};


// Class TgGame.TgDevice_DrogozLeg1
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_DrogozLeg1 : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DrogozLeg1");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_DrogozLeg1
// 0x0004 (0x026C - 0x0268)
class UTgDeviceFire_DrogozLeg1 : public UTgDeviceFire
{
public:
	float                                              m_DamageAmount;                                           // 0x0268(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_DrogozLeg1");
		return ptr;
	}


	void SubmitEffect(const struct FImpactInfo& Impact, class UTgEffectGroup* effectGroup, bool bRemove, int StackCount, class AActor* InstigatorOverride);
	void SetDamageAmount(class AActor* pHitTarget);
};


// Class TgGame.TgWeaponMeshActor_DredgeInhand
// 0x0000 (0x0450 - 0x0450)
class ATgWeaponMeshActor_DredgeInhand : public ATgWeaponMeshActor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgWeaponMeshActor_DredgeInhand");
		return ptr;
	}


	void PlayFireAnimation(int nEquipSlot, float fRefireTime);
};


// Class TgGame.TgDevice_DredgeReload
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_DredgeReload : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DredgeReload");
		return ptr;
	}


	void LinkedDeviceEquipped(class ATgDevice* Dev);
	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void STATIC_UseNow();
	bool ShouldInterruptReloadOnFire();
};


// Class TgGame.TgDevice_SpyGlass
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_SpyGlass : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_SpyGlass");
		return ptr;
	}


	void TriggerReveal(class ATgProjectile* Source);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
	void LinkedDeviceUnequipped(class ATgDevice* Dev);
};


// Class TgGame.TgDevice_DredgeTeleportAllies
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_DredgeTeleportAllies : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DredgeTeleportAllies");
		return ptr;
	}

};


// Class TgGame.TgDevice_DrogozLeg2
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_DrogozLeg2 : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DrogozLeg2");
		return ptr;
	}

};


// Class TgGame.TgDevice_DualFire
// 0x0010 (0x0A28 - 0x0A18)
class ATgDevice_DualFire : public ATgDevice_ToggleWithLockout
{
public:
	struct FScriptDelegate                             __InterruptFiringDelegate__Delegate;                      // 0x0A18(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData00[0x4];                                       // 0x0A18(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DualFire");
		return ptr;
	}


	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
	void InterruptFiringDelegate();
};


// Class TgGame.TgPawn_Princess
// 0x0100 (0x33D8 - 0x32D8)
class ATgPawn_Princess : public ATgPawn_Character
{
public:
	class ATgDevice_Enlightenment*                     m_CachedEnlightenment;                                    // 0x32D8(0x0008)
	class ATgDevice_EnlightenmentGun*                  m_CachedEnlightenmentGun;                                 // 0x32E0(0x0008)
	TScriptInterface<class UTgCombatActor>             r_GraceTargets[0xF];                                      // 0x32E8(0x0010)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Princess");
		return ptr;
	}


	void ToggleEnlightenmentGun(bool bEnabled);
	bool STATIC_HasCachedEnlightenmentGun();
	bool STATIC_HasCachedEnlightenment();
	void ManageGraceTracers();
	void ReplicatedEvent(const struct FName& VarName);
};


// Class TgGame.TgDevice_EvieInhand
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_EvieInhand : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_EvieInhand");
		return ptr;
	}


	void STATIC_InterruptOtherDevices(class ATgPawn* TgP);
};


// Class TgGame.TgWeaponMeshActor_IceStaff
// 0x0000 (0x0450 - 0x0450)
class ATgWeaponMeshActor_IceStaff : public ATgWeaponMeshActor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgWeaponMeshActor_IceStaff");
		return ptr;
	}

};


// Class TgGame.TgDevice_EvilMojo
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_EvilMojo : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_EvilMojo");
		return ptr;
	}

};


// Class TgGame.TgDevice_ExitStrategy
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_ExitStrategy : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ExitStrategy");
		return ptr;
	}

};


// Class TgGame.TgDevice_ExpansiveVault
// 0x0000 (0x0A14 - 0x0A14)
class ATgDevice_ExpansiveVault : public ATgDevice_ActivateOnChildGeneric1
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ExpansiveVault");
		return ptr;
	}


	float GetCustomTimerBarMaxTime();
	float GetCustomTimerBarCurrentTime();
	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	void Deactivate();
	void ClientActivate();
	void STATIC_Activate();
};


// Class TgGame.TgDevice_ExplosiveFlask
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_ExplosiveFlask : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ExplosiveFlask");
		return ptr;
	}

};


// Class TgGame.TgDevice_Exterminate
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_Exterminate : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Exterminate");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
};


// Class TgGame.TgDevice_EyesOnThePrize
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_EyesOnThePrize : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_EyesOnThePrize");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
};


// Class TgGame.TgWeaponMeshActor_Lance
// 0x0000 (0x0450 - 0x0450)
class ATgWeaponMeshActor_Lance : public ATgWeaponMeshActor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgWeaponMeshActor_Lance");
		return ptr;
	}

};


// Class TgGame.TgDevice_Fireball
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_Fireball : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Fireball");
		return ptr;
	}

};


// Class TgGame.TgDevice_FlamethrowerTurret
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_FlamethrowerTurret : public ATgDevice
{
public:
	class ATgPawn_Barik*                               m_CachedBarik;                                            // 0x0A0C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_FlamethrowerTurret");
		return ptr;
	}


	float GetRange();
	bool STATIC_HasCachedBarik();
};


// Class TgGame.TgDevice_FragGrenadeModWhileCook
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_FragGrenadeModWhileCook : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_FragGrenadeModWhileCook");
		return ptr;
	}


	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
	void RemoveHitSpecial();
	void ApplyHitSpecial();
};


// Class TgGame.TgDevice_FuriaF
// 0x0000 (0x0A80 - 0x0A80)
class ATgDevice_FuriaF : public ATgDevice_ChargeBackward
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_FuriaF");
		return ptr;
	}


	void StartProjectileSpawns();
};


// Class TgGame.TgWeaponMeshActor_FuriaInhand
// 0x0024 (0x0474 - 0x0450)
class ATgWeaponMeshActor_FuriaInhand : public ATgWeaponMeshActor
{
public:
	unsigned long                                      m_bFiredAltBarrel : 1;                                    // 0x0450(0x0004)
	TArray<class UTgAnimNodeStanceDualFire*>           m_stanceNodes3p;                                          // 0x0454(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeStanceDualFire*>           m_stanceNodes1p;                                          // 0x0464(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgWeaponMeshActor_FuriaInhand");
		return ptr;
	}


	void PlayReload(int nEqpPoint, float reloadTime, int AmmoRemainingInClip, int ReloadType);
	void PlayFireEffects(int nEquipSlot, float fRefireTime, int nFireMode);
	void PlayFireFx(int nEquipSlot, int nFireMode);
	void OverrideTracerFireLoc(int nIndex, struct FVector* FireLoc);
	void OnBehindViewUpdated(bool bNewBehindView);
	void STATIC_FixUpReferencesToPawnMesh(class USkeletalMeshComponent* PawnMesh);
	void STATIC_FixUpReferencesToWeaponMesh1P(class USkeletalMeshComponent* weaponMesh);
};


// Class TgGame.TgDevice_FuriaUlt
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_FuriaUlt : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_FuriaUlt");
		return ptr;
	}

};


// Class TgGame.TgDevice_GaeBolg
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_GaeBolg : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_GaeBolg");
		return ptr;
	}

};


// Class TgGame.TgDevice_GhostWalk
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_GhostWalk : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_GhostWalk");
		return ptr;
	}


	bool ShouldInterruptReloadOnFire();
	bool CanBeCanceled();
};


// Class TgGame.TgDevice_GreaterGood
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_GreaterGood : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_GreaterGood");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
};


// Class TgGame.TgWeaponMeshActor_Orb
// 0x0008 (0x0458 - 0x0450)
class ATgWeaponMeshActor_Orb : public ATgWeaponMeshActor
{
public:
	float                                              m_fFireGlowFadeTime;                                      // 0x0450(0x0004) (Edit)
	float                                              m_fRemainingGlowFadeTime;                                 // 0x0454(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgWeaponMeshActor_Orb");
		return ptr;
	}


	bool STATIC_GetSimulatedBeamTarget(int nEquipSlot, struct FVector* HitLocation);
	void Tick(float DeltaTime);
	void StopFireEffects(int nEquipSlot, int nFireMode);
	void PlayFireEffects(int nEquipSlot, float fRefireTime, int nFireMode);
};


// Class TgGame.TgDevice_GroverInhandAxe
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_GroverInhandAxe : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_GroverInhandAxe");
		return ptr;
	}

};


// Class TgGame.TgWeaponMeshActor_GroverInhandAxe
// 0x0008 (0x0458 - 0x0450)
class ATgWeaponMeshActor_GroverInhandAxe : public ATgWeaponMeshActor
{
public:
	class UTgAnimNodeStanceTransitionerSynchronized*   StanceNode;                                               // 0x0450(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgWeaponMeshActor_GroverInhandAxe");
		return ptr;
	}


	void Play3pFireAimedFX();
	void STATIC_FixUpReferencesToPawnMesh(class USkeletalMeshComponent* PawnMesh);
};


// Class TgGame.TgDevice_Gunnery
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_Gunnery : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Gunnery");
		return ptr;
	}


	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
};


// Class TgGame.TgDevice_Headhunter
// 0x0014 (0x0A20 - 0x0A0C)
class ATgDevice_Headhunter : public ATgDevice_Stim
{
public:
	class ATgDevice_KinessaInhand*                     m_CachedInhandDevice;                                     // 0x0A0C(0x0008)
	class ATgDevice_SniperMode*                        m_CachedSniperModeDevice;                                 // 0x0A14(0x0008)
	unsigned long                                      m_bCamFXEnabled : 1;                                      // 0x0A1C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Headhunter");
		return ptr;
	}


	bool STATIC_HasCachedSniperDevice();
	bool STATIC_HasCachedInhandDevice();
	void ToggleCamFX(bool bEnable);
	void Tick(float DeltaTime);
	void OnStartFireRequestSent();
};


// Class TgGame.TgDevice_LegDay
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_LegDay : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_LegDay");
		return ptr;
	}


	void ModifyLeapParams(float* scaleLateral, float* scaleVertical, float* additiveLateral, float* additiveVertical);
};


// Class TgGame.TgDevice_HiddenReserves
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_HiddenReserves : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_HiddenReserves");
		return ptr;
	}


	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
};


// Class TgGame.TgDevice_HunterRoll
// 0x0000 (0x0A80 - 0x0A80)
class ATgDevice_HunterRoll : public ATgDevice_Charge
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_HunterRoll");
		return ptr;
	}

};


// Class TgGame.TgDevice_IceStorm
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_IceStorm : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_IceStorm");
		return ptr;
	}

};


// Class TgGame.TgWeaponMeshActor_Sniper
// 0x0000 (0x0450 - 0x0450)
class ATgWeaponMeshActor_Sniper : public ATgWeaponMeshActor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgWeaponMeshActor_Sniper");
		return ptr;
	}


	void SetLoopingMuzzleEffects(bool bSetActive, int nEquipSlot, int nFireMode);
};


// Class TgGame.TgDevice_Lockdown
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_Lockdown : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Lockdown");
		return ptr;
	}

};


// Class TgGame.TgWeaponMeshActor_LongbowInhand
// 0x000C (0x045C - 0x0450)
class ATgWeaponMeshActor_LongbowInhand : public ATgWeaponMeshActor
{
public:
	class ATgPawn_Longbow*                             m_CachedLongbow;                                          // 0x0450(0x0008)
	unsigned long                                      m_bPlayingPlantedFireSFX : 1;                             // 0x0458(0x0004)
	unsigned long                                      m_bPlayingUltimateFireSFX : 1;                            // 0x0458(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgWeaponMeshActor_LongbowInhand");
		return ptr;
	}


	void STATIC_UseUltimateFireSounds(bool bShouldUse);
	void STATIC_UsePlantedFireSounds(bool bShouldUse);
	void PlayFireEffects(int nEquipSlot, float fRefireTime, int nFireMode);
	bool HasCachedLongbow();
};


// Class TgGame.TgDevice_MakoaInhand
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_MakoaInhand : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_MakoaInhand");
		return ptr;
	}

};


// Class TgGame.TgDevice_MarkAndRecall
// 0x001C (0x0A28 - 0x0A0C)
class ATgDevice_MarkAndRecall : public ATgDevice
{
public:
	struct FVector                                     m_markedLocation;                                         // 0x0A0C(0x000C)
	struct FRotator                                    m_markedRotation;                                         // 0x0A18(0x000C)
	unsigned long                                      m_bMarked : 1;                                            // 0x0A24(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_MarkAndRecall");
		return ptr;
	}


	void STATIC_FireAmmunition();
};


// Class TgGame.TgDevice_Molotov
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_Molotov : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Molotov");
		return ptr;
	}

};


// Class TgGame.TgDevice_MountMorph
// 0x0000 (0x0A2C - 0x0A2C)
class ATgDevice_MountMorph : public ATgDevice_Mount
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_MountMorph");
		return ptr;
	}

};


// Class TgGame.TgDevice_MountNoHorse
// 0x0000 (0x0A2C - 0x0A2C)
class ATgDevice_MountNoHorse : public ATgDevice_Mount
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_MountNoHorse");
		return ptr;
	}

};


// Class TgGame.TgDevice_NetShot
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_NetShot : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_NetShot");
		return ptr;
	}

};


// Class TgGame.TgWeaponMeshActor_NinjaInhand
// 0x0004 (0x0454 - 0x0450)
class ATgWeaponMeshActor_NinjaInhand : public ATgWeaponMeshActor
{
public:
	unsigned long                                      c_bSwapTracerIndices : 1;                                 // 0x0450(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgWeaponMeshActor_NinjaInhand");
		return ptr;
	}


	void OverrideTracerFireLoc(int nIndex, struct FVector* FireLoc);
	void OverrideTracerEndLocation(const struct FVector& FireLoc, int nIndex, bool bSyntheticShot, struct FVector* endLocation);
};


// Class TgGame.TgWeaponMeshActor_OracleInhand
// 0x0008 (0x0458 - 0x0450)
class ATgWeaponMeshActor_OracleInhand : public ATgWeaponMeshActor
{
public:
	class AActor*                                      m_LastRestoreSoulTarget;                                  // 0x0450(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgWeaponMeshActor_OracleInhand");
		return ptr;
	}


	void SetBeamTangent(const struct FVector& HitLocation, int nEquipSlot);
	void STATIC_UpdateFireLoopBeamParams(bool bHasEndPoint, const struct FVector& HitLocation, int nEquipSlot);
	void ActivateFireLoopFailed(bool bIsActive);
	void StopFireEffects(int nEquipSlot, int nFireMode);
	void PlayFireFx(int nEquipSlot, int nFireMode);
	bool STATIC_GetAccurateBeamTarget(int nEquipSlot, struct FVector* HitLocation);
	bool STATIC_GetSimulatedBeamTarget(int nEquipSlot, struct FVector* HitLocation);
	void STATIC_UpdateTransform(float DeltaTime, bool bFromCameraUpdate);
};


// Class TgGame.TgDevice_OverTheMoon
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_OverTheMoon : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_OverTheMoon");
		return ptr;
	}

};


// Class TgGame.TgDevice_OwlFlare
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_OwlFlare : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_OwlFlare");
		return ptr;
	}

};


// Class TgGame.TgDevice_OwlFlashbang
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_OwlFlashbang : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_OwlFlashbang");
		return ptr;
	}

};


// Class TgGame.TgWeaponMeshActor_OwlInhand
// 0x0008 (0x0458 - 0x0450)
class ATgWeaponMeshActor_OwlInhand : public ATgWeaponMeshActor
{
public:
	class ATgPawn_Owl*                                 m_CachedOwl;                                              // 0x0450(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgWeaponMeshActor_OwlInhand");
		return ptr;
	}


	bool STATIC_HasCachedOwl();
	void PlayTracerEffects(const struct FVector& endLocation, int nEquipSlot, bool bSyntheticShot);
	void PlayInstantHitImpactEffects(const struct FVector& HitLocation, bool bSuccessfulHit, class AActor* HitActor, const struct FVector& HitNormal, const struct FVector& FireOrigin, int nEquipSlot);
};


// Class TgGame.TgDevice_PipInhand
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_PipInhand : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_PipInhand");
		return ptr;
	}


	bool AltFireDetonate();
};


// Class TgGame.TgWeaponMeshActor_PotionLauncher
// 0x0000 (0x0450 - 0x0450)
class ATgWeaponMeshActor_PotionLauncher : public ATgWeaponMeshActor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgWeaponMeshActor_PotionLauncher");
		return ptr;
	}

};


// Class TgGame.TgDevice_PoisonBolts
// 0x0008 (0x0A14 - 0x0A0C)
class ATgDevice_PoisonBolts : public ATgDevice
{
public:
	class ATgDevice_SkyeInhand*                        m_CachedInhand;                                           // 0x0A0C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_PoisonBolts");
		return ptr;
	}


	bool CanBeInterrupted();
	bool CanBeCanceled();
};


// Class TgGame.TgDevice_PostFireTimerBar
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_PostFireTimerBar : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_PostFireTimerBar");
		return ptr;
	}

};


// Class TgGame.TgDevice_PrincessF
// 0x0010 (0x0A90 - 0x0A80)
class ATgDevice_PrincessF : public ATgDevice_Charge
{
public:
	class ATgDevice*                                   m_cachedSupportDevice;                                    // 0x0A80(0x0008)
	int                                                m_nEyeheightAdjustmentWhileSliding;                       // 0x0A88(0x0004) (Edit)
	float                                              m_fEyeHeightSmoothFactor;                                 // 0x0A8C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_PrincessF");
		return ptr;
	}


	bool STATIC_HasCachedSupportDevice();
};


// Class TgGame.TgProj_Reversal
// 0x0004 (0x0530 - 0x052C)
class ATgProj_Reversal : public ATgProj_Simulated
{
public:
	float                                              m_fDamageOverride;                                        // 0x052C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Reversal");
		return ptr;
	}

};


// Class TgGame.TgWeaponMeshActor_RiderInhand
// 0x000C (0x045C - 0x0450)
class ATgWeaponMeshActor_RiderInhand : public ATgWeaponMeshActor
{
public:
	class UTgSpecialFx*                                m_AltFireFx;                                              // 0x0450(0x0008)
	unsigned long                                      m_b3pFireShouldBeActive : 1;                              // 0x0458(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgWeaponMeshActor_RiderInhand");
		return ptr;
	}


	void ActivateFireAimed(bool bSetActive);
	void SetLoopingMuzzleEffects(bool bSetActive, int nEquipSlot, int nFireMode);
	void OnBehindViewUpdated(bool bNewBehindView);
	void STATIC_UpdateFireAimedFX();
	void Tick(float DeltaTime);
};


// Class TgGame.TgDevice_RiderLegUltBonus
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_RiderLegUltBonus : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_RiderLegUltBonus");
		return ptr;
	}


	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
	void ApplyExtraEatEffects();
};


// Class TgGame.TgDevice_RiderShield
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_RiderShield : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_RiderShield");
		return ptr;
	}

};


// Class TgGame.TgWeaponMeshActor_RuckusInhand
// 0x0008 (0x0458 - 0x0450)
class ATgWeaponMeshActor_RuckusInhand : public ATgWeaponMeshActor
{
public:
	class UTgMuzzleFlash*                              m_SecondaryMuzzleFlashLight;                              // 0x0450(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgWeaponMeshActor_RuckusInhand");
		return ptr;
	}


	void OverrideTracerFireLoc(int nIndex, struct FVector* FireLoc);
	void StopFireEffects(int nEquipSlot, int nFireMode);
	void PlayFireEffects(int nEquipSlot, float fRefireTime, int nFireMode);
	void STATIC_InitializeForWeapon(unsigned char EquipPoint, int DeviceID, bool bClearEquipPoint);
};


// Class TgGame.TgWeaponMeshActor_SkyeInHand
// 0x0000 (0x0450 - 0x0450)
class ATgWeaponMeshActor_SkyeInHand : public ATgWeaponMeshActor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgWeaponMeshActor_SkyeInHand");
		return ptr;
	}

};


// Class TgGame.TgDevice_SolarBlessing
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_SolarBlessing : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_SolarBlessing");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
};


// Class TgGame.TgDevice_Tinkerin
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_Tinkerin : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Tinkerin");
		return ptr;
	}

};


// Class TgGame.TgDevice_ToxicTimeBomb
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_ToxicTimeBomb : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ToxicTimeBomb");
		return ptr;
	}

};


// Class TgGame.TgDevice_TurretShot
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_TurretShot : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_TurretShot");
		return ptr;
	}

};


// Class TgGame.TgDevice_TyraAltFire
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_TyraAltFire : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_TyraAltFire");
		return ptr;
	}

};


// Class TgGame.TgWeaponMeshActor_TyraInhand
// 0x0000 (0x0450 - 0x0450)
class ATgWeaponMeshActor_TyraInhand : public ATgWeaponMeshActor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgWeaponMeshActor_TyraInhand");
		return ptr;
	}

};


// Class TgGame.TgDevice_UncheckedAmbition
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_UncheckedAmbition : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_UncheckedAmbition");
		return ptr;
	}


	void LinkedDeviceUnequipped(class ATgDevice* Dev);
	void LinkedDeviceEquipped(class ATgDevice* Dev);
};


// Class TgGame.TgDevice_Uppercut
// 0x0000 (0x0A80 - 0x0A80)
class ATgDevice_Uppercut : public ATgDevice_Charge
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Uppercut");
		return ptr;
	}


	void STATIC_UpdateOutroLockoutTime();
	bool CanBeInterrupted();
	void DeliverHit(const struct FImpactInfo& Impact);
	bool STATIC_IsUltActive();
};


// Class TgGame.TgDevice_VanguardInhand
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_VanguardInhand : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_VanguardInhand");
		return ptr;
	}

};


// Class TgGame.TgDevice_VenomousGourd
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_VenomousGourd : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_VenomousGourd");
		return ptr;
	}

};


// Class TgGame.TgDevice_ViktorAmmoRefill
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_ViktorAmmoRefill : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ViktorAmmoRefill");
		return ptr;
	}


	void STATIC_FireAmmunition();
};


// Class TgGame.TgDevice_Whirl
// 0x0000 (0x0A80 - 0x0A80)
class ATgDevice_Whirl : public ATgDevice_Charge
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Whirl");
		return ptr;
	}

};


// Class TgGame.TgWeaponMeshActor_YingInhand
// 0x0000 (0x0450 - 0x0450)
class ATgWeaponMeshActor_YingInhand : public ATgWeaponMeshActor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgWeaponMeshActor_YingInhand");
		return ptr;
	}


	void STATIC_EndYingLoopingBeam();
	void PlayFireAnimation(int nEquipSlot, float fRefireTime);
	bool STATIC_GetSimulatedBeamTarget(int nEquipSlot, struct FVector* HitLocation);
	void STATIC_InitializeForWeapon(unsigned char EquipPoint, int DeviceID, bool bClearEquipPoint);
};


// Class TgGame.TgDeviceFire_DarklordInhandChain1
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_DarklordInhandChain1 : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_DarklordInhandChain1");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_DarklordInhandChain2
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_DarklordInhandChain2 : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_DarklordInhandChain2");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_DarklordInhandChain3
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_DarklordInhandChain3 : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_DarklordInhandChain3");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_Emitter
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_Emitter : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Emitter");
		return ptr;
	}


	void SubmitEffect(const struct FImpactInfo& Impact, class UTgEffectGroup* effectGroup, bool bRemove, int StackCount, class AActor* InstigatorOverride);
};


// Class TgGame.TgDeviceFire_EmitterEffect
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_EmitterEffect : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_EmitterEffect");
		return ptr;
	}


	void SubmitEffect(const struct FImpactInfo& Impact, class UTgEffectGroup* effectGroup, bool bRemove, int StackCount, class AActor* InstigatorOverride);
};


// Class TgGame.TgDeviceFire_FernandoInhand
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_FernandoInhand : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_FernandoInhand");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_FlameTurret
// 0x0000 (0x0278 - 0x0278)
class UTgDeviceFire_FlameTurret : public UTgDeviceFire_EncroachmentFireCone
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_FlameTurret");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_GeometryInara
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_GeometryInara : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_GeometryInara");
		return ptr;
	}


	float GetMinCooldownTime();
	float GetCooldownTime();
};


// Class TgGame.TgDeviceFire_GroverInhandAxe
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_GroverInhandAxe : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_GroverInhandAxe");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_HeatHaze
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_HeatHaze : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_HeatHaze");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_IgnoreDeployableForBlocking
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_IgnoreDeployableForBlocking : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_IgnoreDeployableForBlocking");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_IgnoreDeployablesCannotCounter
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_IgnoreDeployablesCannotCounter : public UTgDeviceFire_IgnoreDeployableForBlocking
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_IgnoreDeployablesCannotCounter");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_HuntersMark
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_HuntersMark : public UTgDeviceFire_IgnoreDeployablesCannotCounter
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_HuntersMark");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_KinessaInhand
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_KinessaInhand : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_KinessaInhand");
		return ptr;
	}


	void SubmitEffect(const struct FImpactInfo& Impact, class UTgEffectGroup* effectGroup, bool bRemove, int StackCount, class AActor* InstigatorOverride);
};


// Class TgGame.TgDeviceFire_PoppyBomb
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_PoppyBomb : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_PoppyBomb");
		return ptr;
	}


	void SubmitEffect(const struct FImpactInfo& Impact, class UTgEffectGroup* effectGroup, bool bRemove, int StackCount, class AActor* InstigatorOverride);
};


// Class TgGame.TgDeviceFire_PotionLauncherHealingTalent
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_PotionLauncherHealingTalent : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_PotionLauncherHealingTalent");
		return ptr;
	}


	float STATIC_GetHealingFalloff();
	void SubmitEffect(const struct FImpactInfo& Impact, class UTgEffectGroup* effectGroup, bool bRemove, int StackCount, class AActor* InstigatorOverride);
};


// Class TgGame.TgDeviceFire_Reversal
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_Reversal : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Reversal");
		return ptr;
	}


	void SubmitEffect(const struct FImpactInfo& Impact, class UTgEffectGroup* effectGroup, bool bRemove, int StackCount, class AActor* InstigatorOverride);
};


// Class TgGame.TgDeviceFire_SelfResurrection
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_SelfResurrection : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_SelfResurrection");
		return ptr;
	}


	void SubmitEffect(const struct FImpactInfo& Impact, class UTgEffectGroup* effectGroup, bool bRemove, int StackCount, class AActor* InstigatorOverride);
};


// Class TgGame.TgDeviceFire_ShellShield
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_ShellShield : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_ShellShield");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_ShieldFernando
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_ShieldFernando : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_ShieldFernando");
		return ptr;
	}


	float GetCooldownTime();
};


// Class TgGame.TgDeviceFire_Soar
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_Soar : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Soar");
		return ptr;
	}


	float GetMinCooldownTime();
};


// Class TgGame.TgDeviceFire_SpawnAtOwnerLocation
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_SpawnAtOwnerLocation : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_SpawnAtOwnerLocation");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_TurtlePower
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_TurtlePower : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_TurtlePower");
		return ptr;
	}


	void SubmitEffect(const struct FImpactInfo& Impact, class UTgEffectGroup* effectGroup, bool bRemove, int StackCount, class AActor* InstigatorOverride);
};


// Class TgGame.TgDeviceFire_Valor
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_Valor : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Valor");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_VanguardUlt
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_VanguardUlt : public UTgDeviceFire_IgnoreCCImmune
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_VanguardUlt");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_Whirlwind
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_Whirlwind : public UTgDeviceFire_Cylinder
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Whirlwind");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_AccursedArmGun
// 0x0000 (0x028C - 0x028C)
class UTgDeviceForm_AccursedArmGun : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_AccursedArmGun");
		return ptr;
	}


	void Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
};


// Class TgGame.TgDeviceForm_Advance
// 0x0000 (0x028C - 0x028C)
class UTgDeviceForm_Advance : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Advance");
		return ptr;
	}


	void Generic2(unsigned char byExtraData);
	void Generic1(unsigned char byExtraData);
};


// Class TgGame.TgDeviceForm_AstroInhand
// 0x0000 (0x02B8 - 0x02B8)
class UTgDeviceForm_AstroInhand : public UTgDeviceForm_SpinnerWhileFiring
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_AstroInhand");
		return ptr;
	}


	void SetSpinStates(class UTgSkelCon_Spinner* pSpinner, int nState);
	void SetSpinnersRotationSpeedState(int nState);
	void StopFire(int nFireModeNum);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
};


// Class TgGame.TgDeviceForm_BarikInhand
// 0x0000 (0x028C - 0x028C)
class UTgDeviceForm_BarikInhand : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_BarikInhand");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Barrage
// 0x0008 (0x0294 - 0x028C)
class UTgDeviceForm_Barrage : public UTgDeviceForm
{
public:
	class ATgPlayerController*                         m_CachedActiveOverlayController;                          // 0x028C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Barrage");
		return ptr;
	}


	void StopFire(int nFireModeNum);
	void Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
};


// Class TgGame.TgDeviceForm_Booster
// 0x0020 (0x02AC - 0x028C)
class UTgDeviceForm_Booster : public UTgDeviceForm
{
public:
	TArray<class UTgAnimNodeBlendByDrogozFlying*>      m_FlyingBlendList1P;                                      // 0x028C(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeBlendByDrogozFlying*>      m_FlyingBlendList3P;                                      // 0x029C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Booster");
		return ptr;
	}


	void StopFire(int nFireModeNum);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	void CacheAnimNode(class UAnimNode* Node, bool bIs3p);
	void ClearAnimNodes(bool bIs3p);
};


// Class TgGame.TgDeviceForm_BuckInhand
// 0x0000 (0x028C - 0x028C)
class UTgDeviceForm_BuckInhand : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_BuckInhand");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_CombatSlide
// 0x0004 (0x0290 - 0x028C)
class UTgDeviceForm_CombatSlide : public UTgDeviceForm
{
public:
	float                                              m_fTransitionTime;                                        // 0x028C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_CombatSlide");
		return ptr;
	}


	void StopFire(int nFireModeNum);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
};


// Class TgGame.TgDeviceForm_DarkConvergenceSub
// 0x0000 (0x028C - 0x028C)
class UTgDeviceForm_DarkConvergenceSub : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_DarkConvergenceSub");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_DeepRoots
// 0x0000 (0x02AC - 0x02AC)
class UTgDeviceForm_DeepRoots : public UTgDeviceForm_ArcingBeam
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_DeepRoots");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_DemonStim
// 0x0004 (0x0290 - 0x028C)
class UTgDeviceForm_DemonStim : public UTgDeviceForm
{
public:
	float                                              m_fTransitionTime;                                        // 0x028C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_DemonStim");
		return ptr;
	}


	void StopFire(int nFireModeNum);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
};


// Class TgGame.TgDeviceForm_DimensionalLink
// 0x0008 (0x0294 - 0x028C)
class UTgDeviceForm_DimensionalLink : public UTgDeviceForm
{
public:
	class ATgPawn_Ying*                                m_CachedYingPawn;                                         // 0x028C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_DimensionalLink");
		return ptr;
	}


	bool STATIC_HasCachedYingPawn();
	void Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
};


// Class TgGame.TgDeviceForm_Disengage
// 0x0000 (0x028C - 0x028C)
class UTgDeviceForm_Disengage : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Disengage");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_DragonSlam
// 0x0024 (0x02B0 - 0x028C)
class UTgDeviceForm_DragonSlam : public UTgDeviceForm
{
public:
	unsigned long                                      m_bStartFireInAir : 1;                                    // 0x028C(0x0004)
	TArray<class UTgAnimNodeBlendByAbilityDragonSlam*> m_DragonSlamBlendList1P;                                  // 0x0290(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeBlendByAbilityDragonSlam*> m_DragonSlamBlendList3P;                                  // 0x02A0(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_DragonSlam");
		return ptr;
	}


	void RecoverDeviceState(TEnumAsByte<ETG_REP_DEVICE_STATE> DesiredState);
	void Cleanup();
	void DoInterrupt();
	void StopFire(int nFireModeNum);
	void Hit(int nFireMode, class AActor* Target, float fDamageAmount, const struct FVector& HitLocation, const struct FVector& HitNormal, struct FExtraDamageInfo* ExtraInfo);
	void STATIC_OnFly();
	void Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	void BuildUp(int nFireMode, int nEquipSlot, int nSocketIndex, float fBuildupTime);
	void CacheAnimNode(class UAnimNode* Node, bool bIs3p);
	void ClearAnimNodes(bool bIs3p);
};


// Class TgGame.TgDeviceForm_FernandoInhand
// 0x0000 (0x028C - 0x028C)
class UTgDeviceForm_FernandoInhand : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_FernandoInhand");
		return ptr;
	}


	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
};


// Class TgGame.TgDeviceForm_FragGrenade
// 0x0020 (0x02AC - 0x028C)
class UTgDeviceForm_FragGrenade : public UTgDeviceForm
{
public:
	TArray<class UTgAnimNodeBlendByAbilityFragGrenade*> m_FragGrenadeBlendList1P;                                 // 0x028C(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeBlendByAbilityFragGrenade*> m_FragGrenadeBlendList3P;                                 // 0x029C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_FragGrenade");
		return ptr;
	}


	void DoInterrupt();
	void Generic1(unsigned char byExtraData);
	void CacheAnimNode(class UAnimNode* Node, bool bIs3p);
	void ClearAnimNodes(bool bIs3p);
};


// Class TgGame.TgDeviceForm_GaeBolg
// 0x0000 (0x028C - 0x028C)
class UTgDeviceForm_GaeBolg : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_GaeBolg");
		return ptr;
	}


	void DoInterrupt();
	void Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
};


// Class TgGame.TgDeviceForm_GauntletInhand
// 0x0000 (0x02A8 - 0x02A8)
class UTgDeviceForm_GauntletInhand : public UTgDeviceForm_ArcaneMissilesInhand
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_GauntletInhand");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_GraceSupport
// 0x0008 (0x0294 - 0x028C)
class UTgDeviceForm_GraceSupport : public UTgDeviceForm
{
public:
	class ATgWeaponMeshActor_LianInhand*               m_CachedWMA;                                              // 0x028C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_GraceSupport");
		return ptr;
	}


	void Hit(int nFireMode, class AActor* Target, float fDamageAmount, const struct FVector& HitLocation, const struct FVector& HitNormal, struct FExtraDamageInfo* ExtraInfo);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	bool STATIC_HasCachedWMA();
};


// Class TgGame.TgDeviceForm_GrohkInhand
// 0x0008 (0x0294 - 0x028C)
class UTgDeviceForm_GrohkInhand : public UTgDeviceForm
{
public:
	class UTgSkelCon_Spinner*                          m_SpinnerSkelControl;                                     // 0x028C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_GrohkInhand");
		return ptr;
	}


	void Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	void StopFire(int nFireModeNum);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	void Cache1PAnimNodes(class UTgSkeletalMeshComponent* SkelComp);
	void SetBeamFXForHit(bool DidHit);
};


// Class TgGame.TgDeviceForm_GrumpyBomb
// 0x0000 (0x028C - 0x028C)
class UTgDeviceForm_GrumpyBomb : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_GrumpyBomb");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_HeadHunter
// 0x0000 (0x028C - 0x028C)
class UTgDeviceForm_HeadHunter : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_HeadHunter");
		return ptr;
	}


	void StopFire(int nFireModeNum);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
};


// Class TgGame.TgDeviceForm_HeroicLeap
// 0x0000 (0x028C - 0x028C)
class UTgDeviceForm_HeroicLeap : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_HeroicLeap");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_HexaFire
// 0x0024 (0x02B0 - 0x028C)
class UTgDeviceForm_HexaFire : public UTgDeviceForm
{
public:
	class UTgAnimNodeBlendList*                        m_LeftRocket1p;                                           // 0x028C(0x0008)
	class UTgAnimNodeBlendList*                        m_LeftRocket3p;                                           // 0x0294(0x0008)
	class UTgAnimNodeBlendList*                        m_RightRocket1p;                                          // 0x029C(0x0008)
	class UTgAnimNodeBlendList*                        m_RightRocket3p;                                          // 0x02A4(0x0008)
	unsigned long                                      m_bFiringRightRocket : 1;                                 // 0x02AC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_HexaFire");
		return ptr;
	}


	void StopFire(int nFireModeNum);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	void DoInterrupt();
	void SetAllInactive();
	void Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	void CacheAnimNode(class UAnimNode* Node, bool bIs3p);
	void ClearAnimNodes(bool bIs3p);
};


// Class TgGame.TgDeviceForm_HexaFireGuns
// 0x0074 (0x0300 - 0x028C)
class UTgDeviceForm_HexaFireGuns : public UTgDeviceForm
{
public:
	class UTgSkelCon_Spinner*                          m_SpinnerSkelControl1P;                                   // 0x028C(0x0008)
	class UTgSkelCon_Spinner*                          m_SpinnerSkelControl3P;                                   // 0x0294(0x0008)
	int                                                m_nNextGunFired;                                          // 0x029C(0x0004)
	struct FName                                       c_nmSocket1;                                              // 0x02A0(0x0008)
	struct FName                                       c_nmSocket2;                                              // 0x02A8(0x0008)
	struct FName                                       c_nmSocket3;                                              // 0x02B0(0x0008)
	struct FName                                       c_nmSocket4;                                              // 0x02B8(0x0008)
	class UTgSkelControlSingleBone_PistonBarrel*       m_LowerRightBarrel1P;                                     // 0x02C0(0x0008)
	class UTgSkelControlSingleBone_PistonBarrel*       m_UpperRightBarrel1P;                                     // 0x02C8(0x0008)
	class UTgSkelControlSingleBone_PistonBarrel*       m_LowerLeftBarrel1P;                                      // 0x02D0(0x0008)
	class UTgSkelControlSingleBone_PistonBarrel*       m_UpperLeftBarrel1P;                                      // 0x02D8(0x0008)
	class UTgSkelControlSingleBone_PistonBarrel*       m_LowerRightBarrel3P;                                     // 0x02E0(0x0008)
	class UTgSkelControlSingleBone_PistonBarrel*       m_UpperRightBarrel3P;                                     // 0x02E8(0x0008)
	class UTgSkelControlSingleBone_PistonBarrel*       m_LowerLeftBarrel3P;                                      // 0x02F0(0x0008)
	class UTgSkelControlSingleBone_PistonBarrel*       m_UpperLeftBarrel3P;                                      // 0x02F8(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_HexaFireGuns");
		return ptr;
	}


	struct FVector GetTracerSocketLocation();
	void Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	void StopFire(int nFireModeNum);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	void CacheAnimNodesHelper(class UTgSkeletalMeshComponent* SkelComp, class UTgSkelControlSingleBone_PistonBarrel** LowerRightBarrel, class UTgSkelControlSingleBone_PistonBarrel** UpperRightBarrel, class UTgSkelControlSingleBone_PistonBarrel** LowerLeftBarrel, class UTgSkelControlSingleBone_PistonBarrel** UpperLeftBarrel, class UTgSkelCon_Spinner** spinner);
	void Cache3PAnimNodes(class UTgSkeletalMeshComponent* SkelComp);
	void Cache1PAnimNodes(class UTgSkeletalMeshComponent* SkelComp);
};


// Class TgGame.TgDeviceForm_Hover
// 0x0000 (0x028C - 0x028C)
class UTgDeviceForm_Hover : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Hover");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Hustle
// 0x0000 (0x028C - 0x028C)
class UTgDeviceForm_Hustle : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Hustle");
		return ptr;
	}


	void StopFire(int nFireModeNum);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
};


// Class TgGame.TgDeviceForm_HyperBeam
// 0x0000 (0x02B8 - 0x02B8)
class UTgDeviceForm_HyperBeam : public UTgDeviceForm_SpinnerWhileFiring
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_HyperBeam");
		return ptr;
	}


	void SetSpinnersActive(bool bActive);
	void Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
};


// Class TgGame.TgDeviceForm_KinessaInhand
// 0x0000 (0x028C - 0x028C)
class UTgDeviceForm_KinessaInhand : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_KinessaInhand");
		return ptr;
	}


	void Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
};


// Class TgGame.TgDeviceForm_KingBomb
// 0x0004 (0x0290 - 0x028C)
class UTgDeviceForm_KingBomb : public UTgDeviceForm
{
public:
	unsigned long                                      m_bKingBombActive : 1;                                    // 0x028C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_KingBomb");
		return ptr;
	}


	void CleanUpKingBomb();
	void SetUpKingBomb();
	void Generic1(unsigned char byExtraData);
	void DoInterrupt();
	void StopFire(int nFireModeNum);
	void Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	void BuildUp(int nFireMode, int nEquipSlot, int nSocketIndex, float fBuildupTime);
	void RecoverDeviceState(TEnumAsByte<ETG_REP_DEVICE_STATE> DesiredState);
};


// Class TgGame.TgDeviceForm_Lockdown
// 0x0000 (0x028C - 0x028C)
class UTgDeviceForm_Lockdown : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Lockdown");
		return ptr;
	}


	void StopFire(int nFireModeNum);
	void Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
};


// Class TgGame.TgDeviceForm_LongbowPlanted
// 0x0000 (0x028C - 0x028C)
class UTgDeviceForm_LongbowPlanted : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_LongbowPlanted");
		return ptr;
	}


	void DoInterrupt();
	void StopFire(int nFireModeNum);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
};


// Class TgGame.TgDeviceForm_MendingSpirits
// 0x0000 (0x028C - 0x028C)
class UTgDeviceForm_MendingSpirits : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_MendingSpirits");
		return ptr;
	}


	void Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
};


// Class TgGame.TgDeviceForm_MinigunSpinUp
// 0x0010 (0x029C - 0x028C)
class UTgDeviceForm_MinigunSpinUp : public UTgDeviceForm
{
public:
	class UTgSkelCon_Spinner*                          m_SpinnerSkelControl1P;                                   // 0x028C(0x0008)
	class UTgSkelCon_Spinner*                          m_SpinnerSkelControl3P;                                   // 0x0294(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_MinigunSpinUp");
		return ptr;
	}


	void StopFire(int nFireModeNum);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	void Cache1PAnimNodes(class UTgSkeletalMeshComponent* SkelComp);
	void Cache3PAnimNodes(class UTgSkeletalMeshComponent* SkelComp);
};


// Class TgGame.TgDeviceForm_MountMorph
// 0x0000 (0x029C - 0x029C)
class UTgDeviceForm_MountMorph : public UTgDeviceForm_Mount
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_MountMorph");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_MountNoHorse
// 0x000C (0x02A8 - 0x029C)
class UTgDeviceForm_MountNoHorse : public UTgDeviceForm_Mount
{
public:
	int                                                c_SparkleFXID;                                            // 0x029C(0x0004)
	class UTgSpecialFx*                                c_SparkleFX;                                              // 0x02A0(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_MountNoHorse");
		return ptr;
	}


	void GetAnimSetStringsForBot(int PlayerBotId, TArray<struct FString>* sPaths);
	void StopFire(int nFireModeNum);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
};


// Class TgGame.TgDeviceForm_NetherStep
// 0x0020 (0x02AC - 0x028C)
class UTgDeviceForm_NetherStep : public UTgDeviceForm
{
public:
	TArray<class UAnimNodeBlendList*>                  m_stanceNodes1p;                                          // 0x028C(0x0010) (NeedCtorLink)
	TArray<class UAnimNodeBlendList*>                  m_stanceNodes3p;                                          // 0x029C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_NetherStep");
		return ptr;
	}


	void CooldownComplete();
	void StopFire(int nFireModeNum);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	void CacheAnimNode(class UAnimNode* Node, bool bIs3p);
	void ClearAnimNodes(bool bIs3p);
};


// Class TgGame.TgDeviceForm_PoppyBomb
// 0x0000 (0x028C - 0x028C)
class UTgDeviceForm_PoppyBomb : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_PoppyBomb");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Presence
// 0x0000 (0x028C - 0x028C)
class UTgDeviceForm_Presence : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Presence");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Pursuit
// 0x0054 (0x02E0 - 0x028C)
class UTgDeviceForm_Pursuit : public UTgDeviceForm
{
public:
	class ATgPawn_Lex*                                 m_CachedLex;                                              // 0x028C(0x0008)
	struct FName                                       m_LeftSlideSkelControlName1P;                             // 0x0294(0x0008)
	struct FName                                       m_RightSlideSkelControlName1P;                            // 0x029C(0x0008)
	struct FName                                       m_LeftSlideSkelControlName3P;                             // 0x02A4(0x0008)
	struct FName                                       m_RightSlideSkelControlName3P;                            // 0x02AC(0x0008)
	class USkelControlBase*                            m_LeftSlideSkelControl1P;                                 // 0x02B4(0x0008)
	class USkelControlBase*                            m_RightSlideSkelControl1P;                                // 0x02BC(0x0008)
	class USkelControlBase*                            m_LeftSlideSkelControl3P;                                 // 0x02C4(0x0008)
	class USkelControlBase*                            m_RightSlideSkelControl3P;                                // 0x02CC(0x0008)
	float                                              c_fPreviousLeftSlideStrength;                             // 0x02D4(0x0004)
	float                                              c_fPreviousRightSlideStrength;                            // 0x02D8(0x0004)
	unsigned long                                      m_bCachedDualFireParity : 1;                              // 0x02DC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Pursuit");
		return ptr;
	}


	void StopFire(int nFireModeNum);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	void Cache3PAnimNodes(class UTgSkeletalMeshComponent* SkelComp);
	void Cache1PAnimNodes(class UTgSkeletalMeshComponent* SkelComp);
	bool STATIC_HasCachedLex();
};


// Class TgGame.TgDeviceForm_Recharge
// 0x0000 (0x02B8 - 0x02B8)
class UTgDeviceForm_Recharge : public UTgDeviceForm_SpinnerWhileFiring
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Recharge");
		return ptr;
	}


	void SetLockedForBlendNodes(bool bLocked);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	void Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
};


// Class TgGame.TgDeviceForm_RendSoul
// 0x0000 (0x028C - 0x028C)
class UTgDeviceForm_RendSoul : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_RendSoul");
		return ptr;
	}


	void Generic1(unsigned char byExtraData);
	void ActivateFx(class UTgSpecialFx* Fx, float fHealStacks);
};


// Class TgGame.TgDeviceForm_RestoreSoul
// 0x0008 (0x0294 - 0x028C)
class UTgDeviceForm_RestoreSoul : public UTgDeviceForm
{
public:
	class ATgPawn_Oracle*                              m_CachedOracle;                                           // 0x028C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_RestoreSoul");
		return ptr;
	}


	void RecoverDeviceState(TEnumAsByte<ETG_REP_DEVICE_STATE> DesiredState);
	bool STATIC_HasCachedOracle();
};


// Class TgGame.TgDeviceForm_RiderMovement
// 0x0014 (0x02A0 - 0x028C)
class UTgDeviceForm_RiderMovement : public UTgDeviceForm
{
public:
	struct FVector                                     m_vActiveCameraOffset;                                    // 0x028C(0x000C)
	class ATgPawn_Rider*                               m_CachedRider;                                            // 0x0298(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_RiderMovement");
		return ptr;
	}


	bool STATIC_HasCachedRider();
	void StopFire(int nFireModeNum);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
};


// Class TgGame.TgDeviceForm_RocketLauncher
// 0x0000 (0x028C - 0x028C)
class UTgDeviceForm_RocketLauncher : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_RocketLauncher");
		return ptr;
	}


	void Generic1(unsigned char byExtraData);
};


// Class TgGame.TgDeviceForm_Scout
// 0x0008 (0x0294 - 0x028C)
class UTgDeviceForm_Scout : public UTgDeviceForm
{
public:
	class USkelControlBase*                            m_SKCBirdScale;                                           // 0x028C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Scout");
		return ptr;
	}


	void StopFire(int nFireModeNum);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	void Cache3PAnimNodes(class UTgSkeletalMeshComponent* SkelComp);
};


// Class TgGame.TgDeviceForm_ShadowTravel
// 0x0000 (0x028C - 0x028C)
class UTgDeviceForm_ShadowTravel : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_ShadowTravel");
		return ptr;
	}


	void StopFire(int nFireModeNum);
};


// Class TgGame.TgDeviceForm_Shatter
// 0x0000 (0x028C - 0x028C)
class UTgDeviceForm_Shatter : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Shatter");
		return ptr;
	}


	void Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
};


// Class TgGame.TgDeviceForm_Shatterfall
// 0x0000 (0x028C - 0x028C)
class UTgDeviceForm_Shatterfall : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Shatterfall");
		return ptr;
	}


	void Generic1(unsigned char byExtraData);
};


// Class TgGame.TgDeviceForm_ShockPulseSubdevice
// 0x0000 (0x02AC - 0x02AC)
class UTgDeviceForm_ShockPulseSubdevice : public UTgDeviceForm_ArcingBeam
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_ShockPulseSubdevice");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_SilenceBeam
// 0x0008 (0x02C0 - 0x02B8)
class UTgDeviceForm_SilenceBeam : public UTgDeviceForm_SpinnerWhileFiring
{
public:
	class ATgPawn_Gauntlet*                            m_pCachedGauntlet;                                        // 0x02B8(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_SilenceBeam");
		return ptr;
	}


	void SetLockedForBlendNodes(bool bLocked);
	void Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	class ATgPawn_Gauntlet* STATIC_GetCachedGauntlet();
};


// Class TgGame.TgDeviceForm_Smash
// 0x0020 (0x02AC - 0x028C)
class UTgDeviceForm_Smash : public UTgDeviceForm
{
public:
	TArray<class UTgAnimNodeBlendByAbilitySmash*>      m_SmashBlendList1P;                                       // 0x028C(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeBlendByAbilitySmash*>      m_SmashBlendList3P;                                       // 0x029C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Smash");
		return ptr;
	}


	void Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	void CacheAnimNode(class UAnimNode* Node, bool bIs3p);
	void ClearAnimNodes(bool bIs3p);
};


// Class TgGame.TgDeviceForm_SniperMode
// 0x0000 (0x028C - 0x028C)
class UTgDeviceForm_SniperMode : public UTgDeviceForm_ToggleWithLockout
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_SniperMode");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_SpaceTime
// 0x0000 (0x028C - 0x028C)
class UTgDeviceForm_SpaceTime : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_SpaceTime");
		return ptr;
	}


	void PlayBeamEffect(bool bUseBuildupBeam);
	void Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
};


// Class TgGame.TgDeviceForm_StormOfBullets
// 0x0000 (0x028C - 0x028C)
class UTgDeviceForm_StormOfBullets : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_StormOfBullets");
		return ptr;
	}


	void OnDestroyed();
	void OnCreated();
};


// Class TgGame.TgDeviceForm_TheLaw
// 0x0058 (0x02E4 - 0x028C)
class UTgDeviceForm_TheLaw : public UTgDeviceForm
{
public:
	class ATgPawn_Lex*                                 m_CachedLex;                                              // 0x028C(0x0008)
	class ATgWeaponMeshActor_LexInhand*                m_CachedWMA;                                              // 0x0294(0x0008)
	struct FName                                       m_LeftSlideSkelControlName1P;                             // 0x029C(0x0008)
	struct FName                                       m_RightSlideSkelControlName1P;                            // 0x02A4(0x0008)
	struct FName                                       m_LeftSlideSkelControlName3P;                             // 0x02AC(0x0008)
	struct FName                                       m_RightSlideSkelControlName3P;                            // 0x02B4(0x0008)
	class USkelControlBase*                            m_LeftSlideSkelControl1P;                                 // 0x02BC(0x0008)
	class USkelControlBase*                            m_RightSlideSkelControl1P;                                // 0x02C4(0x0008)
	class USkelControlBase*                            m_LeftSlideSkelControl3P;                                 // 0x02CC(0x0008)
	class USkelControlBase*                            m_RightSlideSkelControl3P;                                // 0x02D4(0x0008)
	float                                              c_fPreviousLeftSlideStrength;                             // 0x02DC(0x0004)
	float                                              c_fPreviousRightSlideStrength;                            // 0x02E0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_TheLaw");
		return ptr;
	}


	void StopFire(int nFireModeNum);
	void Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	void Cache3PAnimNodes(class UTgSkeletalMeshComponent* SkelComp);
	void Cache1PAnimNodes(class UTgSkeletalMeshComponent* SkelComp);
	bool STATIC_HasCachedWMA();
	bool STATIC_HasCachedLex();
};


// Class TgGame.TgDeviceForm_Thrust
// 0x0020 (0x02AC - 0x028C)
class UTgDeviceForm_Thrust : public UTgDeviceForm
{
public:
	TArray<class UTgAnimNodeBlendByDrogozFlying*>      m_FlyingBlendList1P;                                      // 0x028C(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeBlendByDrogozFlying*>      m_FlyingBlendList3P;                                      // 0x029C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Thrust");
		return ptr;
	}


	void StopFire(int nFireModeNum);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	void CacheAnimNode(class UAnimNode* Node, bool bIs3p);
	void ClearAnimNodes(bool bIs3p);
};


// Class TgGame.TgDeviceForm_Turret
// 0x0008 (0x0294 - 0x028C)
class UTgDeviceForm_Turret : public UTgDeviceForm
{
public:
	class USkelControlBase*                            m_SKCTurretScale;                                         // 0x028C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Turret");
		return ptr;
	}


	void CooldownComplete();
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	void Cache3PAnimNodes(class UTgSkeletalMeshComponent* SkelComp);
};


// Class TgGame.TgDeviceForm_TyraInhand
// 0x0000 (0x028C - 0x028C)
class UTgDeviceForm_TyraInhand : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_TyraInhand");
		return ptr;
	}


	void Hit(int nFireMode, class AActor* Target, float fDamageAmount, const struct FVector& HitLocation, const struct FVector& HitNormal, struct FExtraDamageInfo* ExtraInfo);
};


// Class TgGame.TgDeviceForm_TyraUlt
// 0x0000 (0x028C - 0x028C)
class UTgDeviceForm_TyraUlt : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_TyraUlt");
		return ptr;
	}


	void StopFire(int nFireModeNum);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
};


// Class TgGame.TgDeviceForm_Valor
// 0x0000 (0x028C - 0x028C)
class UTgDeviceForm_Valor : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Valor");
		return ptr;
	}


	void Hit(int nFireMode, class AActor* Target, float fDamageAmount, const struct FVector& HitLocation, const struct FVector& HitNormal, struct FExtraDamageInfo* ExtraInfo);
};


// Class TgGame.TgDeviceForm_VanguardGrab
// 0x001C (0x02A8 - 0x028C)
class UTgDeviceForm_VanguardGrab : public UTgDeviceForm
{
public:
	TArray<class UTgAnimNodeBlendByAbilityVanguardGrab*> m_VanguardGrabNodes3p;                                    // 0x028C(0x0010) (NeedCtorLink)
	class ATgPawn_Character*                           m_Target;                                                 // 0x029C(0x0008)
	int                                                m_nPosture;                                               // 0x02A4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_VanguardGrab");
		return ptr;
	}


	void SetPostureOnTarget(TEnumAsByte<ETG_POSTURE> Posture);
	void RecoverDeviceState(TEnumAsByte<ETG_REP_DEVICE_STATE> DesiredState);
	void STATIC_UpdateVanguardGrabAnim(TEnumAsByte<EVanguardGrabAnimUpdate> eState);
	void StopFire(int nFireModeNum);
	void DoInterrupt();
	void Generic1(unsigned char byExtraData);
	void Hit(int nFireMode, class AActor* Target, float fDamageAmount, const struct FVector& HitLocation, const struct FVector& HitNormal, struct FExtraDamageInfo* ExtraInfo);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	void CacheAnimNode(class UAnimNode* Node, bool bIs3p);
	void ClearAnimNodes(bool bIs3p);
};


// Class TgGame.TgDeviceForm_ViktorInhand
// 0x0000 (0x028C - 0x028C)
class UTgDeviceForm_ViktorInhand : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_ViktorInhand");
		return ptr;
	}


	void Generic1(unsigned char byExtraData);
	void SetAmmoBlendNodesAmount(int nAmmoAmt, bool bTickOnly);
};


// Class TgGame.TgDeviceForm_Whirlwind
// 0x0000 (0x028C - 0x028C)
class UTgDeviceForm_Whirlwind : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Whirlwind");
		return ptr;
	}


	void StopFire(int nFireModeNum);
	void Generic1(unsigned char byExtraData);
	void DoInterrupt();
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
};


// Class TgGame.TgDeviceForm_Whirlwind2
// 0x0000 (0x028C - 0x028C)
class UTgDeviceForm_Whirlwind2 : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Whirlwind2");
		return ptr;
	}


	void StopFire(int nFireModeNum);
	void DoInterrupt();
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
};


// Class TgGame.TgDeviceVolumeInfo
// 0x0008 (0x0288 - 0x0280)
class ATgDeviceVolumeInfo : public AInfo
{
public:
	class ATgDeviceVolume*                             V;                                                        // 0x0280(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceVolumeInfo");
		return ptr;
	}


	void Timer();
	void PostBeginPlay();
};


// Class TgGame.TgGame_Paladins_Payload_Practice
// 0x0000 (0x0AE0 - 0x0AE0)
class ATgGame_Paladins_Payload_Practice : public ATgGame_Paladins_Payload
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Paladins_Payload_Practice");
		return ptr;
	}

};


// Class TgGame.TgEffectDamage_NoLifeSteal
// 0x0000 (0x00C4 - 0x00C4)
class UTgEffectDamage_NoLifeSteal : public UTgEffectDamage
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectDamage_NoLifeSteal");
		return ptr;
	}

};


// Class TgGame.TgEffectModifyProperty_EnergyCharge
// 0x0000 (0x00BC - 0x00BC)
class UTgEffectModifyProperty_EnergyCharge : public UTgEffectModifyProperty
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectModifyProperty_EnergyCharge");
		return ptr;
	}

};


// Class TgGame.TgEffectModifyProperty_Movement
// 0x0000 (0x00BC - 0x00BC)
class UTgEffectModifyProperty_Movement : public UTgEffectModifyProperty
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectModifyProperty_Movement");
		return ptr;
	}

};


// Class TgGame.TgElevatingVolume
// 0x0000 (0x0314 - 0x0314)
class ATgElevatingVolume : public APhysicsVolume
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgElevatingVolume");
		return ptr;
	}

};


// Class TgGame.TgEmitter_CameraEffect_Bleed
// 0x0000 (0x02C0 - 0x02C0)
class ATgEmitter_CameraEffect_Bleed : public ATgEmitter_CameraEffect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter_CameraEffect_Bleed");
		return ptr;
	}

};


// Class TgGame.TgEmitter_CameraEffect_CCImmune
// 0x0000 (0x02C0 - 0x02C0)
class ATgEmitter_CameraEffect_CCImmune : public ATgEmitter_CameraEffect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter_CameraEffect_CCImmune");
		return ptr;
	}

};


// Class TgGame.TgEmitter_CameraEffect_Cripple
// 0x0000 (0x02C0 - 0x02C0)
class ATgEmitter_CameraEffect_Cripple : public ATgEmitter_CameraEffect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter_CameraEffect_Cripple");
		return ptr;
	}

};


// Class TgGame.TgEmitter_CameraEffect_DamageBottom
// 0x0003 (0x02C4 - 0x02C1)
class ATgEmitter_CameraEffect_DamageBottom : public ATgEmitter_CameraEffect_DamageBase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x02C1(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter_CameraEffect_DamageBottom");
		return ptr;
	}

};


// Class TgGame.TgEmitter_CameraEffect_DamageBottomLeft
// 0x0003 (0x02C4 - 0x02C1)
class ATgEmitter_CameraEffect_DamageBottomLeft : public ATgEmitter_CameraEffect_DamageBase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x02C1(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter_CameraEffect_DamageBottomLeft");
		return ptr;
	}

};


// Class TgGame.TgEmitter_CameraEffect_DamageBottomRight
// 0x0003 (0x02C4 - 0x02C1)
class ATgEmitter_CameraEffect_DamageBottomRight : public ATgEmitter_CameraEffect_DamageBase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x02C1(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter_CameraEffect_DamageBottomRight");
		return ptr;
	}

};


// Class TgGame.TgEmitter_CameraEffect_DamageLeft
// 0x0003 (0x02C4 - 0x02C1)
class ATgEmitter_CameraEffect_DamageLeft : public ATgEmitter_CameraEffect_DamageBase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x02C1(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter_CameraEffect_DamageLeft");
		return ptr;
	}

};


// Class TgGame.TgEmitter_CameraEffect_DamageRight
// 0x0003 (0x02C4 - 0x02C1)
class ATgEmitter_CameraEffect_DamageRight : public ATgEmitter_CameraEffect_DamageBase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x02C1(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter_CameraEffect_DamageRight");
		return ptr;
	}

};


// Class TgGame.TgEmitter_CameraEffect_DamageTop
// 0x0003 (0x02C4 - 0x02C1)
class ATgEmitter_CameraEffect_DamageTop : public ATgEmitter_CameraEffect_DamageBase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x02C1(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter_CameraEffect_DamageTop");
		return ptr;
	}

};


// Class TgGame.TgEmitter_CameraEffect_DamageTopLeft
// 0x0003 (0x02C4 - 0x02C1)
class ATgEmitter_CameraEffect_DamageTopLeft : public ATgEmitter_CameraEffect_DamageBase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x02C1(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter_CameraEffect_DamageTopLeft");
		return ptr;
	}

};


// Class TgGame.TgEmitter_CameraEffect_DamageTopRight
// 0x0003 (0x02C4 - 0x02C1)
class ATgEmitter_CameraEffect_DamageTopRight : public ATgEmitter_CameraEffect_DamageBase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x02C1(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter_CameraEffect_DamageTopRight");
		return ptr;
	}

};


// Class TgGame.TgEmitter_CameraEffect_Daze
// 0x0000 (0x02C0 - 0x02C0)
class ATgEmitter_CameraEffect_Daze : public ATgEmitter_CameraEffect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter_CameraEffect_Daze");
		return ptr;
	}

};


// Class TgGame.TgEmitter_CameraEffect_Fire
// 0x0000 (0x02C0 - 0x02C0)
class ATgEmitter_CameraEffect_Fire : public ATgEmitter_CameraEffect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter_CameraEffect_Fire");
		return ptr;
	}

};


// Class TgGame.TgEmitter_CameraEffect_Freeze
// 0x0000 (0x02C0 - 0x02C0)
class ATgEmitter_CameraEffect_Freeze : public ATgEmitter_CameraEffect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter_CameraEffect_Freeze");
		return ptr;
	}

};


// Class TgGame.TgEmitter_CameraEffect_Heal
// 0x0000 (0x02C0 - 0x02C0)
class ATgEmitter_CameraEffect_Heal : public ATgEmitter_CameraEffect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter_CameraEffect_Heal");
		return ptr;
	}


	void SetHealIntensity(float fHealIntensity, bool bCritical);
};


// Class TgGame.TgEmitter_CameraEffect_Hidden
// 0x0000 (0x02C0 - 0x02C0)
class ATgEmitter_CameraEffect_Hidden : public ATgEmitter_CameraEffect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter_CameraEffect_Hidden");
		return ptr;
	}


	void ChangeTemplate(class UParticleSystem* NewTemplate);
};


// Class TgGame.TgEmitter_CameraEffect_Knockback
// 0x0000 (0x02C0 - 0x02C0)
class ATgEmitter_CameraEffect_Knockback : public ATgEmitter_CameraEffect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter_CameraEffect_Knockback");
		return ptr;
	}

};


// Class TgGame.TgEmitter_CameraEffect_Mark
// 0x0000 (0x02C0 - 0x02C0)
class ATgEmitter_CameraEffect_Mark : public ATgEmitter_CameraEffect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter_CameraEffect_Mark");
		return ptr;
	}

};


// Class TgGame.TgEmitter_CameraEffect_Poison
// 0x0000 (0x02C0 - 0x02C0)
class ATgEmitter_CameraEffect_Poison : public ATgEmitter_CameraEffect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter_CameraEffect_Poison");
		return ptr;
	}

};


// Class TgGame.TgEmitter_CameraEffect_PreTeleport
// 0x0000 (0x02C0 - 0x02C0)
class ATgEmitter_CameraEffect_PreTeleport : public ATgEmitter_CameraEffect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter_CameraEffect_PreTeleport");
		return ptr;
	}

};


// Class TgGame.TgEmitter_CameraEffect_Revealed
// 0x0000 (0x02C0 - 0x02C0)
class ATgEmitter_CameraEffect_Revealed : public ATgEmitter_CameraEffect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter_CameraEffect_Revealed");
		return ptr;
	}

};


// Class TgGame.TgEmitter_CameraEffect_Root
// 0x0000 (0x02C0 - 0x02C0)
class ATgEmitter_CameraEffect_Root : public ATgEmitter_CameraEffect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter_CameraEffect_Root");
		return ptr;
	}

};


// Class TgGame.TgEmitter_CameraEffect_Slow
// 0x0000 (0x02C0 - 0x02C0)
class ATgEmitter_CameraEffect_Slow : public ATgEmitter_CameraEffect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter_CameraEffect_Slow");
		return ptr;
	}

};


// Class TgGame.TgEmitter_CameraEffect_Stun
// 0x0000 (0x02C0 - 0x02C0)
class ATgEmitter_CameraEffect_Stun : public ATgEmitter_CameraEffect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter_CameraEffect_Stun");
		return ptr;
	}

};


// Class TgGame.TgEmitter_CameraEffect_Teleport
// 0x0000 (0x02C0 - 0x02C0)
class ATgEmitter_CameraEffect_Teleport : public ATgEmitter_CameraEffect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter_CameraEffect_Teleport");
		return ptr;
	}

};


// Class TgGame.TgEmitter_CameraEffect_Venom
// 0x0000 (0x02C0 - 0x02C0)
class ATgEmitter_CameraEffect_Venom : public ATgEmitter_CameraEffect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter_CameraEffect_Venom");
		return ptr;
	}

};


// Class TgGame.TgEmitterCrashlanding
// 0x0024 (0x02B8 - 0x0294)
class ATgEmitterCrashlanding : public ATgEmitterSpawnable
{
public:
	class UStaticMeshComponent*                        m_PrimaryMesh;                                            // 0x0294(0x0008) (ExportObject, Component, EditInline)
	class UStaticMeshComponent*                        m_SecondaryMesh;                                          // 0x029C(0x0008) (ExportObject, Component, EditInline)
	float                                              ParticleDurationAfterImpact;                              // 0x02A4(0x0004)
	class ULensFlareComponent*                         m_LensFlare;                                              // 0x02A8(0x0008) (ExportObject, Component, EditInline)
	class UAudioComponent*                             m_AudioComponent;                                         // 0x02B0(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitterCrashlanding");
		return ptr;
	}


	void PostImpactComplete();
	void OnImpact();
	void SetAudio(class USoundCue* SoundCueToSet);
	void SetSecondaryMesh(class UStaticMesh* StaticMeshToSet);
	void SetPrimaryMesh(class UStaticMesh* StaticMeshToSet);
};


// Class TgGame.TgFlagballGoal
// 0x0024 (0x02A4 - 0x0280)
class ATgFlagballGoal : public AActor
{
public:
	class ATgCollisionProxy_Cylinder*                  s_CollisionProxy;                                         // 0x0280(0x0008)
	float                                              m_fCollisionProxyRadius;                                  // 0x0288(0x0004) (Edit, Const)
	float                                              m_fCollisionProxyHeight;                                  // 0x028C(0x0004) (Edit, Const)
	int                                                m_nTaskForceId;                                           // 0x0290(0x0004) (Edit)
	TArray<class AVolume*>                             m_Volumes;                                                // 0x0294(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgFlagballGoal");
		return ptr;
	}


	void CollisionProxyOnTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_HandleTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void PostBeginPlay();
	void PreBeginPlay();
};


// Class TgGame.TgSeqEvent_CaptureAndPayloadSuccessfulPushTF1
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_CaptureAndPayloadSuccessfulPushTF1 : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_CaptureAndPayloadSuccessfulPushTF1");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_CaptureAndPayloadSuccessfulPushTF2
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_CaptureAndPayloadSuccessfulPushTF2 : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_CaptureAndPayloadSuccessfulPushTF2");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_CaptureAndPayloadSuccessfulDefenseTF1
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_CaptureAndPayloadSuccessfulDefenseTF1 : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_CaptureAndPayloadSuccessfulDefenseTF1");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_CaptureAndPayloadSuccessfulDefenseTF2
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_CaptureAndPayloadSuccessfulDefenseTF2 : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_CaptureAndPayloadSuccessfulDefenseTF2");
		return ptr;
	}

};


// Class TgGame.TgGamePhase_AutoBuyOnRespawn
// 0x0000 (0x00B8 - 0x00B8)
class UTgGamePhase_AutoBuyOnRespawn : public UTgGamePhase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_AutoBuyOnRespawn");
		return ptr;
	}


	void STATIC_EndPhase();
	void BeginPhase();
};


// Class TgGame.TgGamePhase_Capture
// 0x0018 (0x00D0 - 0x00B8)
class UTgGamePhase_Capture : public UTgGamePhase
{
public:
	class ATgChaosCapturePoint*                        m_currentActiveCapturePoint;                              // 0x00B8(0x0008)
	float                                              m_fCaptureGoal;                                           // 0x00C0(0x0004)
	float                                              m_fCapturePointsPerSecond;                                // 0x00C4(0x0004)
	int                                                m_nCreditsForCapturingPoint;                              // 0x00C8(0x0004)
	float                                              m_fSecondTracker;                                         // 0x00CC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_Capture");
		return ptr;
	}


	void STATIC_EndPhase();
	void ScoreObjectiveHold(class ATgPawn* ScorerPawn, int NumContested);
	void ContestPoint();
	void PointCaptured(int nTaskForce);
	void NotifyPlayersOfPointCapture();
	void RewardPointCapture(int nTaskForce);
	void CheckReachCaptureGoal(class ATgChaosCapturePoint* CapturePoint);
	void CheckAwardObjectiveScore(unsigned char TaskForceNum, class ATgChaosCapturePoint* CapturePoint, int NumOnPoint, int NumContested);
	void ManageCurrentCapturePoint();
	void OnTick(float DeltaSeconds);
	void SetCapturePointActive(class ATgChaosCapturePoint* Objective);
	void BeginPhase();
};


// Class TgGame.TgGamePhase_ChangeRespawnTime
// 0x0004 (0x00BC - 0x00B8)
class UTgGamePhase_ChangeRespawnTime : public UTgGamePhase
{
public:
	float                                              m_fRespawnDuration;                                       // 0x00B8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_ChangeRespawnTime");
		return ptr;
	}


	void STATIC_EndPhase();
	float ModifyRespawnTime(float fRespawnTime);
};


// Class TgGame.TgGamePhase_ConquestRoundTracking
// 0x0000 (0x00B8 - 0x00B8)
class UTgGamePhase_ConquestRoundTracking : public UTgGamePhase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_ConquestRoundTracking");
		return ptr;
	}


	void BeginPhase();
};


// Class TgGame.TgGamePhase_CooldownReduction
// 0x0004 (0x00BC - 0x00B8)
class UTgGamePhase_CooldownReduction : public UTgGamePhase
{
public:
	float                                              m_fCooldownReduction;                                     // 0x00B8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_CooldownReduction");
		return ptr;
	}


	void STATIC_EndPhase();
	void BeginPhase();
};


// Class TgGame.TgGamePhase_CrazyKingInitialPoint
// 0x0000 (0x00B8 - 0x00B8)
class UTgGamePhase_CrazyKingInitialPoint : public UTgGamePhase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_CrazyKingInitialPoint");
		return ptr;
	}


	void BeginPhase();
};


// Class TgGame.TgGamePhase_CrazyKingRandomPoint
// 0x0000 (0x00B8 - 0x00B8)
class UTgGamePhase_CrazyKingRandomPoint : public UTgGamePhase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_CrazyKingRandomPoint");
		return ptr;
	}


	void BeginPhase();
};


// Class TgGame.TgGamePhase_CrazyKingPointChangeAlert
// 0x0000 (0x00B8 - 0x00B8)
class UTgGamePhase_CrazyKingPointChangeAlert : public UTgGamePhase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_CrazyKingPointChangeAlert");
		return ptr;
	}


	void BeginPhase();
};


// Class TgGame.TgGamePhase_CreditsOnPointTick
// 0x0004 (0x00BC - 0x00B8)
class UTgGamePhase_CreditsOnPointTick : public UTgGamePhase
{
public:
	int                                                m_nCreditsPerTick;                                        // 0x00B8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_CreditsOnPointTick");
		return ptr;
	}


	void STATIC_OnCapturePointTick(class ATgChaosCapturePoint* CapturePoint, int nControllingTaskforce);
};


// Class TgGame.TgGamePhase_DisableAI
// 0x0000 (0x00B8 - 0x00B8)
class UTgGamePhase_DisableAI : public UTgGamePhase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_DisableAI");
		return ptr;
	}


	void STATIC_EndPhase();
	void BeginPhase();
};


// Class TgGame.TgGamePhase_DisableAimAssist
// 0x0000 (0x00B8 - 0x00B8)
class UTgGamePhase_DisableAimAssist : public UTgGamePhase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_DisableAimAssist");
		return ptr;
	}


	void STATIC_EndPhase();
	void BeginPhase();
};


// Class TgGame.TgGamePhase_DisableAutoHealing
// 0x0000 (0x00B8 - 0x00B8)
class UTgGamePhase_DisableAutoHealing : public UTgGamePhase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_DisableAutoHealing");
		return ptr;
	}


	void STATIC_EndPhase();
	void BeginPhase();
};


// Class TgGame.TgGamePhase_DisableCreditSpooling
// 0x0000 (0x00B8 - 0x00B8)
class UTgGamePhase_DisableCreditSpooling : public UTgGamePhase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_DisableCreditSpooling");
		return ptr;
	}


	void STATIC_EndPhase();
	void BeginPhase();
};


// Class TgGame.TgGamePhase_DisableEnergyChargeDevices
// 0x0000 (0x00B8 - 0x00B8)
class UTgGamePhase_DisableEnergyChargeDevices : public UTgGamePhase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_DisableEnergyChargeDevices");
		return ptr;
	}


	void STATIC_EndPhase();
	void BeginPhase();
};


// Class TgGame.TgGamePhase_DisablePassiveUltCharge
// 0x0000 (0x00B8 - 0x00B8)
class UTgGamePhase_DisablePassiveUltCharge : public UTgGamePhase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_DisablePassiveUltCharge");
		return ptr;
	}


	void STATIC_EndPhase();
	void BeginPhase();
};


// Class TgGame.TgGamePhase_DisableLoadoutChanging
// 0x0000 (0x00B8 - 0x00B8)
class UTgGamePhase_DisableLoadoutChanging : public UTgGamePhase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_DisableLoadoutChanging");
		return ptr;
	}


	void STATIC_EndPhase();
	void BeginPhase();
};


// Class TgGame.TgGamePhase_EnableAI
// 0x0000 (0x00B8 - 0x00B8)
class UTgGamePhase_EnableAI : public UTgGamePhase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_EnableAI");
		return ptr;
	}


	void STATIC_EndPhase();
	void BeginPhase();
};


// Class TgGame.TgGamePhase_EnableAimAssist
// 0x0000 (0x00B8 - 0x00B8)
class UTgGamePhase_EnableAimAssist : public UTgGamePhase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_EnableAimAssist");
		return ptr;
	}


	void STATIC_EndPhase();
	void BeginPhase();
};


// Class TgGame.TgGamePhase_EnableCreditSpooling
// 0x0000 (0x00B8 - 0x00B8)
class UTgGamePhase_EnableCreditSpooling : public UTgGamePhase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_EnableCreditSpooling");
		return ptr;
	}


	void STATIC_EndPhase();
	void BeginPhase();
};


// Class TgGame.TgGamePhase_EnableGlobalMounting
// 0x0000 (0x00B8 - 0x00B8)
class UTgGamePhase_EnableGlobalMounting : public UTgGamePhase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_EnableGlobalMounting");
		return ptr;
	}


	void STATIC_EndPhase();
	void BeginPhase();
};


// Class TgGame.TgGamePhase_EndGame
// 0x0000 (0x00B8 - 0x00B8)
class UTgGamePhase_EndGame : public UTgGamePhase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_EndGame");
		return ptr;
	}


	void BeginPhase();
};


// Class TgGame.TgGamePhase_EndTicketGame
// 0x0000 (0x00B8 - 0x00B8)
class UTgGamePhase_EndTicketGame : public UTgGamePhase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_EndTicketGame");
		return ptr;
	}


	void BeginPhase();
};


// Class TgGame.TgGamePhase_EndWhenScoreReached
// 0x0004 (0x00BC - 0x00B8)
class UTgGamePhase_EndWhenScoreReached : public UTgGamePhase
{
public:
	int                                                m_nScore;                                                 // 0x00B8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_EndWhenScoreReached");
		return ptr;
	}


	void OnScoreChanged(int nTaskForce, int nCurrentScore);
};


// Class TgGame.TgGamePhase_EquipDevice
// 0x0005 (0x00BD - 0x00B8)
class UTgGamePhase_EquipDevice : public UTgGamePhase
{
public:
	int                                                m_nDeviceId;                                              // 0x00B8(0x0004)
	TEnumAsByte<ETG_EQUIP_POINT>                       m_eEquipSlotID;                                           // 0x00BC(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_EquipDevice");
		return ptr;
	}


	void BeginPhase();
};


// Class TgGame.TgGamePhase_FlagballActive
// 0x0008 (0x00C0 - 0x00B8)
class UTgGamePhase_FlagballActive : public UTgGamePhase
{
public:
	float                                              m_fFlagballCorrectInterval;                               // 0x00B8(0x0004)
	float                                              m_fFlagballCorrectTimer;                                  // 0x00BC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_FlagballActive");
		return ptr;
	}


	void STATIC_EndPhase();
	void OnTick(float DeltaSeconds);
	void BeginPhase();
};


// Class TgGame.TgGamePhase_Force3P
// 0x0000 (0x00B8 - 0x00B8)
class UTgGamePhase_Force3P : public UTgGamePhase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_Force3P");
		return ptr;
	}


	void STATIC_EndPhase();
	void BeginPhase();
};


// Class TgGame.TgGamePhase_FreezePlayers
// 0x0000 (0x00B8 - 0x00B8)
class UTgGamePhase_FreezePlayers : public UTgGamePhase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_FreezePlayers");
		return ptr;
	}


	void STATIC_EndPhase();
	void BeginPhase();
};


// Class TgGame.TgGamePhase_Gather
// 0x0000 (0x00B8 - 0x00B8)
class UTgGamePhase_Gather : public UTgGamePhase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_Gather");
		return ptr;
	}


	void OnPawnDied(class ATgPawn* Victim, class AController* Killer, class UClass* dmgType);
	void STATIC_DivideCredits();
	void STATIC_EndPhase();
	void BeginPhase();
};


// Class TgGame.TgGamePhase_GlobalItemPurchasing
// 0x0000 (0x00B8 - 0x00B8)
class UTgGamePhase_GlobalItemPurchasing : public UTgGamePhase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_GlobalItemPurchasing");
		return ptr;
	}


	void STATIC_EndPhase();
	void BeginPhase();
};


// Class TgGame.TgGamePhase_GlobalLoadoutChanging
// 0x0000 (0x00B8 - 0x00B8)
class UTgGamePhase_GlobalLoadoutChanging : public UTgGamePhase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_GlobalLoadoutChanging");
		return ptr;
	}


	void STATIC_EndPhase();
	void BeginPhase();
};


// Class TgGame.TgGamePhase_KismetNotify
// 0x0000 (0x00B8 - 0x00B8)
class UTgGamePhase_KismetNotify : public UTgGamePhase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_KismetNotify");
		return ptr;
	}


	void BeginPhase();
};


// Class TgGame.TgGamePhase_Loop
// 0x0000 (0x00B8 - 0x00B8)
class UTgGamePhase_Loop : public UTgGamePhase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_Loop");
		return ptr;
	}


	void STATIC_EndPhase();
	void BeginPhase();
};


// Class TgGame.TgGamePhase_NoRespawn
// 0x0000 (0x00B8 - 0x00B8)
class UTgGamePhase_NoRespawn : public UTgGamePhase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_NoRespawn");
		return ptr;
	}


	void STATIC_EndPhase();
	float ModifyRespawnTime(float fRespawnTime);
};


// Class TgGame.TgGamePhase_Parallel
// 0x0000 (0x00B8 - 0x00B8)
class UTgGamePhase_Parallel : public UTgGamePhase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_Parallel");
		return ptr;
	}


	struct FString GetPhaseValueText();
	bool STATIC_GoToNextPhase();
	bool ShouldYield();
	void STATIC_EndPhase();
	void BeginPhase();
};


// Class TgGame.TgGamePhase_PlayMovie
// 0x0008 (0x00C0 - 0x00B8)
class UTgGamePhase_PlayMovie : public UTgGamePhase
{
public:
	int                                                m_nVideoPathId;                                           // 0x00B8(0x0004)
	unsigned long                                      m_bYieldOnlyWhenFinished : 1;                             // 0x00BC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_PlayMovie");
		return ptr;
	}


	void PlayMovie();
	void BeginPhase();
};


// Class TgGame.TgGamePhase_PlayMusic
// 0x0001 (0x00B9 - 0x00B8)
class UTgGamePhase_PlayMusic : public UTgGamePhase
{
public:
	TEnumAsByte<ENotifySound>                          m_eMusicID;                                               // 0x00B8(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_PlayMusic");
		return ptr;
	}


	void PlayMusic();
	void BeginPhase();
};


// Class TgGame.TgGamePhase_PlaySound
// 0x0001 (0x00B9 - 0x00B8)
class UTgGamePhase_PlaySound : public UTgGamePhase
{
public:
	TEnumAsByte<ENotifySound>                          m_eSoundID;                                               // 0x00B8(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_PlaySound");
		return ptr;
	}


	void STATIC_PlaySound();
	void BeginPhase();
};


// Class TgGame.TgGamePhase_Push
// 0x0000 (0x00B8 - 0x00B8)
class UTgGamePhase_Push : public UTgGamePhase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_Push");
		return ptr;
	}


	void STATIC_EndPhase();
	void CleanupPayload();
	void SuccessfulPush();
	void LanePusherReachedOuterWall(class ATgPawn_LanePusher* Lanepusher);
	void OnDurationEnd();
	void BeginPhase();
};


// Class TgGame.TgGamePhase_RandomChild
// 0x0008 (0x00C0 - 0x00B8)
class UTgGamePhase_RandomChild : public UTgGamePhase
{
public:
	unsigned long                                      m_bSequentiallyUnique : 1;                                // 0x00B8(0x0004)
	int                                                m_nPreviousChildIndex;                                    // 0x00BC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_RandomChild");
		return ptr;
	}


	void StartFirstPhase();
	struct FString GetPhaseValueText();
	void STATIC_EndPhase();
	void BeginPhase();
};


// Class TgGame.TgGamePhase_ResetUltCharge
// 0x0000 (0x00B8 - 0x00B8)
class UTgGamePhase_ResetUltCharge : public UTgGamePhase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_ResetUltCharge");
		return ptr;
	}


	void BeginPhase();
};


// Class TgGame.TgGamePhase_RespawnAllOnBegin
// 0x0000 (0x00B8 - 0x00B8)
class UTgGamePhase_RespawnAllOnBegin : public UTgGamePhase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_RespawnAllOnBegin");
		return ptr;
	}


	void BeginPhase();
};


// Class TgGame.TgGamePhase_RespawnDeadOnBegin
// 0x0000 (0x00B8 - 0x00B8)
class UTgGamePhase_RespawnDeadOnBegin : public UTgGamePhase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_RespawnDeadOnBegin");
		return ptr;
	}


	void BeginPhase();
};


// Class TgGame.TgGamePhase_RoundEnd
// 0x0000 (0x00B8 - 0x00B8)
class UTgGamePhase_RoundEnd : public UTgGamePhase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_RoundEnd");
		return ptr;
	}


	void STATIC_EndPhase();
	void BeginPhase();
};


// Class TgGame.TgGamePhase_RoundReset
// 0x0004 (0x00BC - 0x00B8)
class UTgGamePhase_RoundReset : public UTgGamePhase
{
public:
	unsigned long                                      m_bAutoMountAtEnd : 1;                                    // 0x00B8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_RoundReset");
		return ptr;
	}


	void STATIC_EndPhase();
	void BeginPhase();
};


// Class TgGame.TgGamePhase_ScoreOnKill
// 0x0004 (0x00BC - 0x00B8)
class UTgGamePhase_ScoreOnKill : public UTgGamePhase
{
public:
	int                                                m_nPointsPerKill;                                         // 0x00B8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_ScoreOnKill");
		return ptr;
	}


	void OnPawnDied(class ATgPawn* Victim, class AController* Killer, class UClass* dmgType);
};


// Class TgGame.TgGamePhase_SetHUD
// 0x0001 (0x00B9 - 0x00B8)
class UTgGamePhase_SetHUD : public UTgGamePhase
{
public:
	TEnumAsByte<EHUDType>                              m_eHUDType;                                               // 0x00B8(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_SetHUD");
		return ptr;
	}


	void BeginPhase();
};


// Class TgGame.TgGamePhase_Setup
// 0x0004 (0x00BC - 0x00B8)
class UTgGamePhase_Setup : public UTgGamePhase
{
public:
	unsigned long                                      m_bAutoMountAtEnd : 1;                                    // 0x00B8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_Setup");
		return ptr;
	}


	void STATIC_EndPhase();
	void STATIC_EndBroadcastTimer();
	void BroadcastTimer();
	void BeginPhase();
};


// Class TgGame.TgGamePhase_SetupStasis
// 0x0000 (0x00B8 - 0x00B8)
class UTgGamePhase_SetupStasis : public UTgGamePhase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_SetupStasis");
		return ptr;
	}


	void STATIC_EndPhase();
	void BeginPhase();
};


// Class TgGame.TgGamePhase_SpawnFlagball
// 0x0000 (0x00B8 - 0x00B8)
class UTgGamePhase_SpawnFlagball : public UTgGamePhase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_SpawnFlagball");
		return ptr;
	}


	void BeginPhase();
};


// Class TgGame.TgGamePhase_Ticket
// 0x0010 (0x00C8 - 0x00B8)
class UTgGamePhase_Ticket : public UTgGamePhase
{
public:
	int                                                m_nWinningTickets;                                        // 0x00B8(0x0004)
	int                                                m_nScoreForTicketLimitReached;                            // 0x00BC(0x0004)
	int                                                m_nTF1Tickets;                                            // 0x00C0(0x0004)
	int                                                m_nTF2Tickets;                                            // 0x00C4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_Ticket");
		return ptr;
	}


	void ReachTicketLimit(int nTaskForce, TEnumAsByte<EVictoryType> VictoryType);
	bool STATIC_GainTickets(int nTaskForce, int nNumTickets, TEnumAsByte<EVictoryType> VictoryType);
	void SetTickets(int nTaskForce, int nNumTickets);
	void BeginPhase();
};


// Class TgGame.TgGamePhase_TicketsOnKill
// 0x0004 (0x00BC - 0x00B8)
class UTgGamePhase_TicketsOnKill : public UTgGamePhase
{
public:
	int                                                m_nTicketsPerKill;                                        // 0x00B8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_TicketsOnKill");
		return ptr;
	}


	void OnPawnDied(class ATgPawn* Victim, class AController* Killer, class UClass* dmgType);
};


// Class TgGame.TgGamePhase_TicketsOnPointTick
// 0x0004 (0x00BC - 0x00B8)
class UTgGamePhase_TicketsOnPointTick : public UTgGamePhase
{
public:
	int                                                m_nTicketsPerTick;                                        // 0x00B8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_TicketsOnPointTick");
		return ptr;
	}


	void STATIC_OnCapturePointTick(class ATgChaosCapturePoint* CapturePoint, int nControllingTaskforce);
};


// Class TgGame.TgGamePhase_Branch
// 0x0004 (0x00BC - 0x00B8)
class UTgGamePhase_Branch : public UTgGamePhase
{
public:
	unsigned long                                      m_bConditionMet : 1;                                      // 0x00B8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_Branch");
		return ptr;
	}


	bool Condition();
	void StartFirstPhase();
	void STATIC_EndPhase();
	void BeginPhase();
};


// Class TgGame.TgGamePhase_TieBranch
// 0x0000 (0x00BC - 0x00BC)
class UTgGamePhase_TieBranch : public UTgGamePhase_Branch
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_TieBranch");
		return ptr;
	}


	bool Condition();
};


// Class TgGame.TgGamePhase_TDMMain
// 0x0000 (0x00B8 - 0x00B8)
class UTgGamePhase_TDMMain : public UTgGamePhase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_TDMMain");
		return ptr;
	}


	void OnTick(float DeltaSeconds);
};


// Class TgGame.TgGamePhase_TieBreaker
// 0x0000 (0x00B8 - 0x00B8)
class UTgGamePhase_TieBreaker : public UTgGamePhase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_TieBreaker");
		return ptr;
	}


	void BeginPhase();
};


// Class TgGame.TgGamePhase_ToggleAttackingTeam
// 0x0000 (0x00B8 - 0x00B8)
class UTgGamePhase_ToggleAttackingTeam : public UTgGamePhase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_ToggleAttackingTeam");
		return ptr;
	}


	void BeginPhase();
};


// Class TgGame.TgGamePhase_UltAcceleration
// 0x0004 (0x00BC - 0x00B8)
class UTgGamePhase_UltAcceleration : public UTgGamePhase
{
public:
	float                                              m_fUltChargeRate;                                         // 0x00B8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGamePhase_UltAcceleration");
		return ptr;
	}


	void STATIC_EndPhase();
	void BeginPhase();
};


// Class TgGame.TgSeqEvent_SpawnGateDeactivate
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_SpawnGateDeactivate : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_SpawnGateDeactivate");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_SpawnGateActivate
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_SpawnGateActivate : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_SpawnGateActivate");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_TF1Win
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_TF1Win : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_TF1Win");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_TF2Win
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_TF2Win : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_TF2Win");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_SurvivalGameBegin
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_SurvivalGameBegin : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_SurvivalGameBegin");
		return ptr;
	}

};


// Class TgGame.TgSplineActor_Payload
// 0x0008 (0x02F8 - 0x02F0)
class ATgSplineActor_Payload : public ATgSplineActor
{
public:
	unsigned long                                      m_bReached : 1;                                           // 0x02F0(0x0004)
	float                                              m_fSecondsToAdd;                                          // 0x02F4(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSplineActor_Payload");
		return ptr;
	}


	void OnSplineActorReached(class ATgPawn_LanePusherBase* Payload);
};


// Class TgGame.TgSeqEvent_SurvivalGameEnd
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_SurvivalGameEnd : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_SurvivalGameEnd");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_SpawnGateDeactivate_Attackers
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_SpawnGateDeactivate_Attackers : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_SpawnGateDeactivate_Attackers");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_SpawnGateDeactivate_Defenders
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_SpawnGateDeactivate_Defenders : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_SpawnGateDeactivate_Defenders");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_CaptureAndPayloadRoundEnd
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_CaptureAndPayloadRoundEnd : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_CaptureAndPayloadRoundEnd");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_CaptureAndPayloadRoundBegin
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_CaptureAndPayloadRoundBegin : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_CaptureAndPayloadRoundBegin");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_CaptureAndPayloadCapturePointVictory
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_CaptureAndPayloadCapturePointVictory : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_CaptureAndPayloadCapturePointVictory");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_CaptureAndPayloadWinTF1
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_CaptureAndPayloadWinTF1 : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_CaptureAndPayloadWinTF1");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_CaptureAndPayloadWinTF2
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_CaptureAndPayloadWinTF2 : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_CaptureAndPayloadWinTF2");
		return ptr;
	}

};


// Class TgGame.TgGame_JeffPrototype
// 0x0000 (0x0A90 - 0x0A90)
class ATgGame_JeffPrototype : public ATgGame_Paladins_Siege
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_JeffPrototype");
		return ptr;
	}

};


// Class TgGame.TgGame_Paladins_AscendedAssault
// 0x0004 (0x0A94 - 0x0A90)
class ATgGame_Paladins_AscendedAssault : public ATgGame_Paladins_Onslaught
{
public:
	float                                              m_fSetupDuration;                                         // 0x0A90(0x0004) (Config)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Paladins_AscendedAssault");
		return ptr;
	}


	void SetupPhases();
};


// Class TgGame.TgGame_Paladins_Assault_Practice
// 0x0000 (0x0AAC - 0x0AAC)
class ATgGame_Paladins_Assault_Practice : public ATgGame_Paladins_Assault
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Paladins_Assault_Practice");
		return ptr;
	}

};


// Class TgGame.TgGame_Paladins_Assault_Ranked
// 0x0000 (0x0AAC - 0x0AAC)
class ATgGame_Paladins_Assault_Ranked : public ATgGame_Paladins_Assault
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Paladins_Assault_Ranked");
		return ptr;
	}

};


// Class TgGame.TgGame_Paladins_CaptureOnly
// 0x0000 (0x0A90 - 0x0A90)
class ATgGame_Paladins_CaptureOnly : public ATgGame_Paladins_Siege
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Paladins_CaptureOnly");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_FlagballTF1Score
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_FlagballTF1Score : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_FlagballTF1Score");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_FlagballTF1Win
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_FlagballTF1Win : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_FlagballTF1Win");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_FlagballTF2Score
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_FlagballTF2Score : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_FlagballTF2Score");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_FlagballTF2Win
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_FlagballTF2Win : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_FlagballTF2Win");
		return ptr;
	}

};


// Class TgGame.TgGame_Paladins_Halloween2017
// 0x0000 (0x0A90 - 0x0A90)
class ATgGame_Paladins_Halloween2017 : public ATgGame_Paladins_Siege
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Paladins_Halloween2017");
		return ptr;
	}


	void STATIC_UpdateSilhouetteRendering();
	void AllPlayersReady();
};


// Class TgGame.TgGame_Paladins_LightingTest
// 0x0000 (0x086C - 0x086C)
class ATgGame_Paladins_LightingTest : public ATgGame_Paladins
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Paladins_LightingTest");
		return ptr;
	}


	void SetupPhases();
};


// Class TgGame.TgGame_Paladins_Onslaught_Practice
// 0x0000 (0x0A90 - 0x0A90)
class ATgGame_Paladins_Onslaught_Practice : public ATgGame_Paladins_Onslaught
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Paladins_Onslaught_Practice");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_PayloadCP1Reached
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_PayloadCP1Reached : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_PayloadCP1Reached");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_PayloadCP2Reached
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_PayloadCP2Reached : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_PayloadCP2Reached");
		return ptr;
	}

};


// Class TgGame.TgGame_Paladins_Prototype1
// 0x0000 (0x0A90 - 0x0A90)
class ATgGame_Paladins_Prototype1 : public ATgGame_Paladins_Siege
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Paladins_Prototype1");
		return ptr;
	}

};


// Class TgGame.TgGame_Paladins_Prototype2
// 0x0000 (0x0A90 - 0x0A90)
class ATgGame_Paladins_Prototype2 : public ATgGame_Paladins_Siege
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Paladins_Prototype2");
		return ptr;
	}

};


// Class TgGame.TgGame_Paladins_Prototype3
// 0x0000 (0x0A90 - 0x0A90)
class ATgGame_Paladins_Prototype3 : public ATgGame_Paladins_Siege
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Paladins_Prototype3");
		return ptr;
	}

};


// Class TgGame.TgGame_Paladins_Prototype4
// 0x0000 (0x0A90 - 0x0A90)
class ATgGame_Paladins_Prototype4 : public ATgGame_Paladins_Siege
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Paladins_Prototype4");
		return ptr;
	}

};


// Class TgGame.TgGame_Paladins_Prototype5
// 0x0000 (0x0A90 - 0x0A90)
class ATgGame_Paladins_Prototype5 : public ATgGame_Paladins_Siege
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Paladins_Prototype5");
		return ptr;
	}

};


// Class TgGame.TgGame_Paladins_PvE
// 0x0000 (0x0A90 - 0x0A90)
class ATgGame_Paladins_PvE : public ATgGame_Paladins_Siege
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Paladins_PvE");
		return ptr;
	}

};


// Class TgGame.TgGame_Paladins_PvE_Survival
// 0x0000 (0x0A98 - 0x0A98)
class ATgGame_Paladins_PvE_Survival : public ATgGame_Paladins_Survival
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Paladins_PvE_Survival");
		return ptr;
	}

};


// Class TgGame.TgGame_Paladins_SearchAndDestroy
// 0x0000 (0x086C - 0x086C)
class ATgGame_Paladins_SearchAndDestroy : public ATgGame_Paladins
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Paladins_SearchAndDestroy");
		return ptr;
	}


	void SetupPhases();
};


// Class TgGame.TgGame_Paladins_Siege_Practice
// 0x0000 (0x0A90 - 0x0A90)
class ATgGame_Paladins_Siege_Practice : public ATgGame_Paladins_Siege
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Paladins_Siege_Practice");
		return ptr;
	}

};


// Class TgGame.TgGame_Paladins_Siege_Ranked
// 0x0000 (0x0A90 - 0x0A90)
class ATgGame_Paladins_Siege_Ranked : public ATgGame_Paladins_Siege
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Paladins_Siege_Ranked");
		return ptr;
	}

};


// Class TgGame.TgGame_Paladins_Survival_Practice
// 0x0000 (0x0A98 - 0x0A98)
class ATgGame_Paladins_Survival_Practice : public ATgGame_Paladins_Survival
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Paladins_Survival_Practice");
		return ptr;
	}

};


// Class TgGame.TgGameInfo
// 0x0000 (0x0280 - 0x0280)
class ATgGameInfo : public AInfo
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameInfo");
		return ptr;
	}

};


// Class TgGame.TgGameInfo_TeamDeathMatch
// 0x0004 (0x0284 - 0x0280)
class ATgGameInfo_TeamDeathMatch : public ATgGameInfo
{
public:
	unsigned long                                      m_bSpawnInputLock : 1;                                    // 0x0280(0x0004) (Edit)
	unsigned long                                      m_bAllowSpawnGuardDuringDeviceFire : 1;                   // 0x0280(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameInfo_TeamDeathMatch");
		return ptr;
	}

};


// Class TgGame.TgGame_Paladins_TeamDeathMatch_Practice
// 0x0003 (0x0880 - 0x087D)
class ATgGame_Paladins_TeamDeathMatch_Practice : public ATgGame_Paladins_TeamDeathMatch
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x087D(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Paladins_TeamDeathMatch_Practice");
		return ptr;
	}

};


// Class TgGame.TgTutorialInfo
// 0x00CC (0x034C - 0x0280)
class ATgTutorialInfo : public AActor
{
public:
	float                                              fButtonHoldTime;                                          // 0x0280(0x0004) (Edit)
	float                                              fVolumeStandTime;                                         // 0x0284(0x0004) (Edit)
	float                                              fBotRespawnTime;                                          // 0x0288(0x0004) (Edit)
	float                                              fBotTargetsKilledWaitTime;                                // 0x028C(0x0004) (Edit)
	float                                              fPlayerTeamCaptureMultiplier;                             // 0x0290(0x0004) (Edit)
	float                                              fRepeatInstructionTime;                                   // 0x0294(0x0004) (Edit)
	float                                              fExtendedRepeatInstructionTime;                           // 0x0298(0x0004) (Edit)
	float                                              fIntroExtensionTime;                                      // 0x029C(0x0004) (Edit)
	float                                              fBotDelayTravelToMovementTime;                            // 0x02A0(0x0004) (Edit)
	float                                              fBotDelayTravelToUltRangeTime;                            // 0x02A4(0x0004) (Edit)
	float                                              fPayloadContestPercent;                                   // 0x02A8(0x0004) (Edit)
	float                                              fLanePusherGroundSpeed;                                   // 0x02AC(0x0004) (Edit)
	float                                              fEnergyChargeMultiplier;                                  // 0x02B0(0x0004) (Edit)
	class ATgTutorialVolume*                           ApproachHelperArea;                                       // 0x02B4(0x0008) (Edit)
	class ATgTutorialVolume*                           AutoShootingRangeStandingTargetArea;                      // 0x02BC(0x0008) (Edit)
	class ATgTutorialVolume*                           UltimateShootingRangeStandingTargetArea;                  // 0x02C4(0x0008) (Edit)
	class ATgTutorialVolume*                           JumpLowerArea;                                            // 0x02CC(0x0008) (Edit)
	class ATgTutorialVolume*                           JumpUpperArea;                                            // 0x02D4(0x0008) (Edit)
	class ATgBotFactory*                               HelperBotFactory;                                         // 0x02DC(0x0008) (Edit)
	class ATgBotFactory*                               AutoBotFactory;                                           // 0x02E4(0x0008) (Edit)
	class ATgBotFactory*                               MultipleAutoBotFactory;                                   // 0x02EC(0x0008) (Edit)
	class ATgBotFactory*                               BattleAbilityBotFactory;                                  // 0x02F4(0x0008) (Edit)
	class ATgBotFactory*                               AltAbilityBotFactory;                                     // 0x02FC(0x0008) (Edit)
	class ATgBotFactory*                               UltimateChargeBotFactory;                                 // 0x0304(0x0008) (Edit)
	class ATgBotFactory*                               UltimateAbilityBotFactory;                                // 0x030C(0x0008) (Edit)
	class ATgBotFactory*                               ContestCapturePointBotFactory;                            // 0x0314(0x0008) (Edit)
	class ATgBotFactory*                               ContestPayloadBotsFactory;                                // 0x031C(0x0008) (Edit)
	class AActor*                                      HelperMoveTargetAutoRange;                                // 0x0324(0x0008) (Edit)
	class AActor*                                      HelperMoveTargetMovementAbility;                          // 0x032C(0x0008) (Edit)
	class AActor*                                      HelperMoveTargetUltRange;                                 // 0x0334(0x0008) (Edit)
	class AActor*                                      EndGameFocus;                                             // 0x033C(0x0008) (Edit)
	class ATgAIController_Behavior*                    HelperBotController;                                      // 0x0344(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgTutorialInfo");
		return ptr;
	}


	void TeleportHelperToActor(class AActor* Destination);
	void MoveHelperToActor(class AActor* Destination);
	bool STATIC_HelperIsNavigatingToOrAtDestination(class AActor* Destination);
	void DestroyHelperBot();
	void SpawnHelperBot();
};


// Class TgGame.TgSeqEvent_Tutorial
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_Tutorial : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_Tutorial");
		return ptr;
	}


	bool TriggerGlobal(class AActor* InInstigator, TEnumAsByte<EPaladinsTutorialEvent> TutEvent);
};


// Class TgGame.TgTutorialVolume
// 0x0004 (0x02C0 - 0x02BC)
class ATgTutorialVolume : public AVolume
{
public:
	unsigned long                                      m_bHasLocalPawn : 1;                                      // 0x02BC(0x0004)
	unsigned long                                      m_bHasSeenLocalPawnBefore : 1;                            // 0x02BC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgTutorialVolume");
		return ptr;
	}


	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgSeqEvent_PhaseNotify
// 0x0010 (0x0138 - 0x0128)
class UTgSeqEvent_PhaseNotify : public USequenceEvent
{
public:
	struct FString                                     m_PhaseName;                                              // 0x0128(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_PhaseNotify");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_Accuracy
// 0x0000 (0x0098 - 0x0098)
class UTgGameplayCurvesSet_Accuracy : public UTgGameplayCurvesSet_Simple
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_Accuracy");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_AimAssistBoundsByFOV
// 0x0000 (0x0098 - 0x0098)
class UTgGameplayCurvesSet_AimAssistBoundsByFOV : public UTgGameplayCurvesSet_Simple
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_AimAssistBoundsByFOV");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_AirControlFromZVelocity
// 0x0000 (0x0098 - 0x0098)
class UTgGameplayCurvesSet_AirControlFromZVelocity : public UTgGameplayCurvesSet_Simple
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_AirControlFromZVelocity");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_DamagePerShotHit
// 0x0000 (0x0098 - 0x0098)
class UTgGameplayCurvesSet_DamagePerShotHit : public UTgGameplayCurvesSet_Simple
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_DamagePerShotHit");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_FlakInhandKnockback
// 0x0000 (0x0098 - 0x0098)
class UTgGameplayCurvesSet_FlakInhandKnockback : public UTgGameplayCurvesSet_Simple
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_FlakInhandKnockback");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_FlakInhandSlow
// 0x0000 (0x0098 - 0x0098)
class UTgGameplayCurvesSet_FlakInhandSlow : public UTgGameplayCurvesSet_Simple
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_FlakInhandSlow");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_GravityFromCustom
// 0x0000 (0x0098 - 0x0098)
class UTgGameplayCurvesSet_GravityFromCustom : public UTgGameplayCurvesSet_Simple
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_GravityFromCustom");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_GravityFromZVelocity
// 0x0000 (0x0098 - 0x0098)
class UTgGameplayCurvesSet_GravityFromZVelocity : public UTgGameplayCurvesSet_Simple
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_GravityFromZVelocity");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_GyroSensitivity
// 0x0000 (0x0098 - 0x0098)
class UTgGameplayCurvesSet_GyroSensitivity : public UTgGameplayCurvesSet_Simple
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_GyroSensitivity");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_HitMarkerScaleByDamage
// 0x0000 (0x0098 - 0x0098)
class UTgGameplayCurvesSet_HitMarkerScaleByDamage : public UTgGameplayCurvesSet_Simple
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_HitMarkerScaleByDamage");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_MoveSpeedOverTime
// 0x0000 (0x0098 - 0x0098)
class UTgGameplayCurvesSet_MoveSpeedOverTime : public UTgGameplayCurvesSet_Simple
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_MoveSpeedOverTime");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_ProjectileSpeedOverTime
// 0x0000 (0x0098 - 0x0098)
class UTgGameplayCurvesSet_ProjectileSpeedOverTime : public UTgGameplayCurvesSet_Simple
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_ProjectileSpeedOverTime");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_ProjFrictionOverTime
// 0x0000 (0x0098 - 0x0098)
class UTgGameplayCurvesSet_ProjFrictionOverTime : public UTgGameplayCurvesSet_Simple
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_ProjFrictionOverTime");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_ProjGravityOverTime
// 0x0000 (0x0098 - 0x0098)
class UTgGameplayCurvesSet_ProjGravityOverTime : public UTgGameplayCurvesSet_Simple
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_ProjGravityOverTime");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_RuckusSpinUpControl
// 0x0000 (0x0098 - 0x0098)
class UTgGameplayCurvesSet_RuckusSpinUpControl : public UTgGameplayCurvesSet_Simple
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_RuckusSpinUpControl");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_ScopeWeaponFOV
// 0x0000 (0x0098 - 0x0098)
class UTgGameplayCurvesSet_ScopeWeaponFOV : public UTgGameplayCurvesSet_Simple
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_ScopeWeaponFOV");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_ScopeWorldFOV
// 0x0000 (0x0098 - 0x0098)
class UTgGameplayCurvesSet_ScopeWorldFOV : public UTgGameplayCurvesSet_Simple
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_ScopeWorldFOV");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_SpeedOverDistance
// 0x0000 (0x0098 - 0x0098)
class UTgGameplayCurvesSet_SpeedOverDistance : public UTgGameplayCurvesSet_Simple
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_SpeedOverDistance");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_SpreadTendency
// 0x0000 (0x0098 - 0x0098)
class UTgGameplayCurvesSet_SpreadTendency : public UTgGameplayCurvesSet_Simple
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_SpreadTendency");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_StackDamageMultiplier
// 0x0000 (0x0098 - 0x0098)
class UTgGameplayCurvesSet_StackDamageMultiplier : public UTgGameplayCurvesSet_Simple
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_StackDamageMultiplier");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_ThreatLevelByRange
// 0x0000 (0x0098 - 0x0098)
class UTgGameplayCurvesSet_ThreatLevelByRange : public UTgGameplayCurvesSet_Simple
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_ThreatLevelByRange");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_WallRunVerticalMovement
// 0x0000 (0x0098 - 0x0098)
class UTgGameplayCurvesSet_WallRunVerticalMovement : public UTgGameplayCurvesSet_Simple
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_WallRunVerticalMovement");
		return ptr;
	}

};


// Class TgGame.TgHoldSpot
// 0x0008 (0x03A8 - 0x03A0)
class ATgHoldSpot : public ATgDefensePoint
{
public:
	class AVehicle*                                    HoldVehicle;                                              // 0x03A0(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgHoldSpot");
		return ptr;
	}


	void STATIC_FreePoint();
	class AActor* STATIC_GetMoveTarget();
};


// Class TgGame.TgIdol
// 0x001C (0x029C - 0x0280)
class ATgIdol : public AActor
{
public:
	int                                                r_nDefenderTaskForce;                                     // 0x0280(0x0004) (Net, Transient)
	class ATgPawn_Character*                           m_Holder;                                                 // 0x0284(0x0008) (Transient)
	class ATgRepInfo_Player*                           r_HolderPRI;                                              // 0x028C(0x0008) (Net, Transient)
	class ATgPawn_Character*                           m_OldHolder;                                              // 0x0294(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgIdol");
		return ptr;
	}

};


// Class TgGame.TgInterpolatingCameraActor
// 0x001C (0x043C - 0x0420)
class ATgInterpolatingCameraActor : public ACameraActor
{
public:
	TArray<struct FInterpolatingCameraInfo>            m_CameraArray;                                            // 0x0420(0x0010) (Edit, NeedCtorLink)
	int                                                m_nCurrentCameraIndex;                                    // 0x0430(0x0004) (Edit)
	float                                              m_fCurrentInterpValue;                                    // 0x0434(0x0004)
	float                                              m_fTargetInterpValue;                                     // 0x0438(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInterpolatingCameraActor");
		return ptr;
	}


	void Tick(float DeltaTime);
	void GetCameraView(float DeltaTime, bool bOnlyFOV, struct FTPOV* OutPOV);
	void GetActorEyesViewPoint(struct FVector* out_Location, struct FRotator* out_Rotation);
};


// Class TgGame.TgInventoryObject_Listen_ActiveDuringPassive
// 0x0000 (0x00D4 - 0x00D4)
class UTgInventoryObject_Listen_ActiveDuringPassive : public UTgInventoryObject_Listen_ActiveDuringAbility
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ActiveDuringPassive");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ActiveDuringPassive_WhileOutOfCombat
// 0x0000 (0x00D8 - 0x00D8)
class UTgInventoryObject_Listen_ActiveDuringPassive_WhileOutOfCombat : public UTgInventoryObject_Listen_ActiveDuringAbility_WhileOutOfCombat
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ActiveDuringPassive_WhileOutOfCombat");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ActiveDuringPostFire
// 0x0000 (0x00D4 - 0x00D4)
class UTgInventoryObject_Listen_ActiveDuringPostFire : public UTgInventoryObject_Listen_ActiveDuringAbility
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ActiveDuringPostFire");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ActiveDuringPreFire
// 0x0000 (0x00D4 - 0x00D4)
class UTgInventoryObject_Listen_ActiveDuringPreFire : public UTgInventoryObject_Listen_ActiveDuringAbility
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ActiveDuringPreFire");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_BlastShotHitSelfEffect
// 0x0000 (0x00D8 - 0x00D8)
class UTgInventoryObject_Listen_BlastShotHitSelfEffect : public UTgInventoryObject_Listen_BlastShotHitEffect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_BlastShotHitSelfEffect");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_DeployedWhileMounted
// 0x0000 (0x00D4 - 0x00D4)
class UTgInventoryObject_Listen_DeployedWhileMounted : public UTgInventoryObject_Listen_DeployedDuringAbility
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_DeployedWhileMounted");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_DeployOnAbilityEnd
// 0x0003 (0x00D0 - 0x00CD)
class UTgInventoryObject_Listen_DeployOnAbilityEnd : public UTgInventoryObject_Listen_DeployOnAbility
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x00CD(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_DeployOnAbilityEnd");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_DeployOnAbilityStart
// 0x0003 (0x00D0 - 0x00CD)
class UTgInventoryObject_Listen_DeployOnAbilityStart : public UTgInventoryObject_Listen_DeployOnAbility
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x00CD(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_DeployOnAbilityStart");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_HitWithDeviceAllyTarget
// 0x0000 (0x00D8 - 0x00D8)
class UTgInventoryObject_Listen_HitWithDeviceAllyTarget : public UTgInventoryObject_Listen_HitWithDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_HitWithDeviceAllyTarget");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_HitWithDeviceInhand
// 0x0000 (0x00D8 - 0x00D8)
class UTgInventoryObject_Listen_HitWithDeviceInhand : public UTgInventoryObject_Listen_HitWithDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_HitWithDeviceInhand");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_HitWithDeviceAsIfInhand
// 0x0000 (0x00D8 - 0x00D8)
class UTgInventoryObject_Listen_HitWithDeviceAsIfInhand : public UTgInventoryObject_Listen_HitWithDeviceInhand
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_HitWithDeviceAsIfInhand");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_HitWithDeviceInhandOnly
// 0x0000 (0x00D8 - 0x00D8)
class UTgInventoryObject_Listen_HitWithDeviceInhandOnly : public UTgInventoryObject_Listen_HitWithDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_HitWithDeviceInhandOnly");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_MountEnd
// 0x0000 (0x00CC - 0x00CC)
class UTgInventoryObject_Listen_MountEnd : public UTgInventoryObject_Listen_AbilityEnd
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_MountEnd");
		return ptr;
	}

};


// Class TgGame.TgJumpPad
// 0x0030 (0x02B0 - 0x0280)
class ATgJumpPad : public AActor
{
public:
	float                                              m_fAccelRate;                                             // 0x0280(0x0004) (Edit)
	struct FVector                                     m_vTargetVelocity;                                        // 0x0284(0x000C) (Edit)
	class UStaticMeshComponent*                        m_Mesh;                                                   // 0x0290(0x0008) (Edit, ExportObject, Component, EditInline)
	class UAkEvent*                                    m_ActivationEvent;                                        // 0x0298(0x0008) (Edit)
	TArray<class ATgPawn_Character*>                   m_TouchingChars;                                          // 0x02A0(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgJumpPad");
		return ptr;
	}


	void Tick(float DeltaTime);
	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgKismetTestActor
// 0x0040 (0x0310 - 0x02D0)
class ATgKismetTestActor : public ADynamicSMActor
{
public:
	int                                                m_nTestCount;                                             // 0x02D0(0x0004) (Edit)
	int                                                r_nCurrentTest;                                           // 0x02D4(0x0004) (Edit, Net)
	int                                                r_nPassCount;                                             // 0x02D8(0x0004) (Net)
	int                                                r_nFailCount;                                             // 0x02DC(0x0004) (Net)
	TArray<class UTexture2D*>                          c_aTextures;                                              // 0x02E0(0x0010) (Edit, NeedCtorLink)
	class USoundCue*                                   c_PassSound;                                              // 0x02F0(0x0008) (Edit)
	class USoundCue*                                   c_FailSound;                                              // 0x02F8(0x0008) (Edit)
	TArray<class AInterpActor*>                        c_aResultActors;                                          // 0x0300(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgKismetTestActor");
		return ptr;
	}


	void ReplicatedEvent(const struct FName& VarName);
	void StartTest(int Num);
	void STATIC_FailTest(int Num);
	void PassTest(int Num);
	void PostBeginPlay();
	void SetTestColor(int Num, const struct FLinearColor& Col);
	class APlayerController* GetLocalPlayer();
	void OnTestResult(class UTgSeqAct_TestResult* Action);
};


// Class TgGame.TgSeqAct_TestResult
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_TestResult : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_TestResult");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_LobbyCameraSetActive
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_LobbyCameraSetActive : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_LobbyCameraSetActive");
		return ptr;
	}

};


// Class TgGame.TgMuzzleFlash
// 0x0000 (0x0274 - 0x0274)
class UTgMuzzleFlash : public UTgExplosionLight
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMuzzleFlash");
		return ptr;
	}

};


// Class TgGame.TgMuzzleFlash_Bow
// 0x0000 (0x0274 - 0x0274)
class UTgMuzzleFlash_Bow : public UTgMuzzleFlash
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMuzzleFlash_Bow");
		return ptr;
	}

};


// Class TgGame.TgMuzzleFlash_IceStaff
// 0x0000 (0x0274 - 0x0274)
class UTgMuzzleFlash_IceStaff : public UTgMuzzleFlash
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMuzzleFlash_IceStaff");
		return ptr;
	}

};


// Class TgGame.TgMuzzleFlash_Lance
// 0x0000 (0x0274 - 0x0274)
class UTgMuzzleFlash_Lance : public UTgMuzzleFlash
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMuzzleFlash_Lance");
		return ptr;
	}

};


// Class TgGame.TgMuzzleFlash_Orb
// 0x0000 (0x0274 - 0x0274)
class UTgMuzzleFlash_Orb : public UTgMuzzleFlash
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMuzzleFlash_Orb");
		return ptr;
	}

};


// Class TgGame.TgMuzzleFlash_PotionLauncher
// 0x0000 (0x0274 - 0x0274)
class UTgMuzzleFlash_PotionLauncher : public UTgMuzzleFlash
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMuzzleFlash_PotionLauncher");
		return ptr;
	}

};


// Class TgGame.TgMuzzleFlash_SkyeInHand
// 0x0000 (0x0274 - 0x0274)
class UTgMuzzleFlash_SkyeInHand : public UTgMuzzleFlash
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMuzzleFlash_SkyeInHand");
		return ptr;
	}

};


// Class TgGame.TgMuzzleFlash_Sniper
// 0x0000 (0x0274 - 0x0274)
class UTgMuzzleFlash_Sniper : public UTgMuzzleFlash
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMuzzleFlash_Sniper");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_ParentAnimComponent
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_ParentAnimComponent : public USequenceAction
{
public:
	unsigned long                                      bDetach : 1;                                              // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_ParentAnimComponent");
		return ptr;
	}

};


// Class TgGame.TgPawn_Halloween_Vivian
// 0x0020 (0x334C - 0x332C)
class ATgPawn_Halloween_Vivian : public ATgPawn_Churchill
{
public:
	float                                              r_fShieldRotation;                                        // 0x332C(0x0004) (Net)
	float                                              m_fShieldOffset;                                          // 0x3330(0x0004)
	float                                              m_fShieldRotation;                                        // 0x3334(0x0004)
	float                                              m_fShieldRotationRate;                                    // 0x3338(0x0004)
	float                                              c_fShieldRotationError;                                   // 0x333C(0x0004)
	float                                              c_fShieldRotationErrorCorrectionRate;                     // 0x3340(0x0004)
	class ATgDevice*                                   m_CachedShieldDevice;                                     // 0x3344(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Halloween_Vivian");
		return ptr;
	}


	void TickRotatingShields(float DeltaSeconds);
	void Tick(float DeltaSeconds);
	void ReplicatedEvent(const struct FName& VarName);
};


// Class TgGame.TgPawn_SiegeEngine_ImmuneWhileTraveling
// 0x0000 (0x308C - 0x308C)
class ATgPawn_SiegeEngine_ImmuneWhileTraveling : public ATgPawn_Juggernaut
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_SiegeEngine_ImmuneWhileTraveling");
		return ptr;
	}

};


// Class TgGame.TgSkeletalMeshActor_DestructibleTowerChunk
// 0x0008 (0x0334 - 0x032C)
class ATgSkeletalMeshActor_DestructibleTowerChunk : public ATgSkeletalMeshActorSpawnable
{
public:
	class UTgSkeletalMeshComponent*                    TgSkeletalMeshComp;                                       // 0x032C(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkeletalMeshActor_DestructibleTowerChunk");
		return ptr;
	}


	bool PlayParticleEffect(class UAnimNotify_PlayParticleEffect* AnimNotifyData);
	void PlayDestruction(int MeshId, class ATgPawn_Tower* OwningTower);
};


// Class TgGame.TgPawn_Tower_Inner
// 0x0000 (0x2F70 - 0x2F70)
class ATgPawn_Tower_Inner : public ATgPawn_Tower_FA
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Tower_Inner");
		return ptr;
	}

};


// Class TgGame.TgPawn_Tower_Outer
// 0x0000 (0x2F70 - 0x2F70)
class ATgPawn_Tower_Outer : public ATgPawn_Tower_FA
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Tower_Outer");
		return ptr;
	}

};


// Class TgGame.TgPawn_Tower_Upper
// 0x0000 (0x2F70 - 0x2F70)
class ATgPawn_Tower_Upper : public ATgPawn_Tower_FA
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Tower_Upper");
		return ptr;
	}

};


// Class TgGame.TgPawn_Turret_DefaultCone
// 0x0000 (0x2F48 - 0x2F48)
class ATgPawn_Turret_DefaultCone : public ATgPawn_Turret
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Turret_DefaultCone");
		return ptr;
	}

};


// Class TgGame.TgPhysAnimTestActor
// 0x00A8 (0x0328 - 0x0280)
class ATgPhysAnimTestActor : public AActor
{
public:
	TArray<struct FName>                               LowerBoneNames;                                           // 0x0280(0x0010) (Edit, NeedCtorLink)
	TArray<struct FName>                               LinearBoneSpringNames;                                    // 0x0290(0x0010) (Edit, NeedCtorLink)
	TArray<struct FName>                               AngularBoneSpringNames;                                   // 0x02A0(0x0010) (Edit, NeedCtorLink)
	class USkeletalMeshComponent*                      SkeletalMeshComponent;                                    // 0x02B0(0x0008) (Edit, ExportObject, Component, EditInline)
	TEnumAsByte<EPATAState>                            CurrentState;                                             // 0x02B8(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x02B9(0x0003) MISSED OFFSET
	unsigned long                                      bBlendToGetUp : 1;                                        // 0x02BC(0x0004)
	unsigned long                                      bBlendingBack : 1;                                        // 0x02BC(0x0004)
	unsigned long                                      bRampingDownMotors : 1;                                   // 0x02BC(0x0004)
	unsigned long                                      bNextPokeKnocksDown : 1;                                  // 0x02BC(0x0004)
	float                                              GetUpBlendStartTime;                                      // 0x02C0(0x0004)
	float                                              GetUpBlendTime;                                           // 0x02C4(0x0004) (Edit)
	float                                              GetUpToIdleTime;                                          // 0x02C8(0x0004) (Edit)
	float                                              ActorOriginHeight;                                        // 0x02CC(0x0004) (Edit)
	float                                              PokePauseTime;                                            // 0x02D0(0x0004) (Edit)
	float                                              PokeBlendTime;                                            // 0x02D4(0x0004) (Edit)
	float                                              BlendBackStartTime;                                       // 0x02D8(0x0004)
	float                                              MotorDownStartTime;                                       // 0x02DC(0x0004)
	float                                              MotorDownTime;                                            // 0x02E0(0x0004) (Edit)
	float                                              MotorDownAnimTime;                                        // 0x02E4(0x0004) (Edit)
	float                                              BlendStaggerAnimTime;                                     // 0x02E8(0x0004) (Edit)
	float                                              StaggerSpeedAdj;                                          // 0x02EC(0x0004) (Edit)
	float                                              StaggerVel;                                               // 0x02F0(0x0004) (Edit)
	struct FVector                                     MoveDir;                                                  // 0x02F4(0x000C)
	float                                              AngularHipDriveScale;                                     // 0x0300(0x0004) (Edit)
	float                                              StaggerMuscleScale;                                       // 0x0304(0x0004) (Edit)
	class UAnimNodeBlend*                              BlendNode;                                                // 0x0308(0x0008)
	class UAnimNodeSequence*                           GetUpNode;                                                // 0x0310(0x0008)
	class UAnimNodeSequence*                           RunNode;                                                  // 0x0318(0x0008)
	class URB_BodyInstance*                            HipBody;                                                  // 0x0320(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPhysAnimTestActor");
		return ptr;
	}


	void OnAnimEnd(class UAnimNodeSequence* SeqNode, float PlayedTime, float ExcessTime);
	void Tick(float DeltaSeconds);
	void SetAllMotorsAngularDriveStrength(float InAngularSpringStrength, float InAngularDampingStrength, float InAngularForceLimitStrength, class USkeletalMeshComponent* SkelMeshComp);
	void RecoverFromRagdoll();
	void SetBoneSprings(bool bEnabled);
	bool STATIC_IsAngularBoneSpringName(const struct FName& InName);
	bool STATIC_IsLinearBoneSpringName(const struct FName& InName);
	void SetLowerFixed();
	void DetachAttachments();
	bool STATIC_IsLowerBodyName(const struct FName& InName);
	void SetBodiesFixed(bool InFixed);
	void STATIC_EnableMotors(bool InEnabled);
	void SetPATAState(TEnumAsByte<EPATAState> NewState);
	void STATIC_EndGrab();
	bool PreGrab();
	bool PrePokeActor(const struct FVector& PokeDir);
	void BoneImpulse(const struct FVector& Impulse, const struct FName& BoneName);
	void PostBeginPlay();
};


// Class TgGame.TgPickupFactory_Item
// 0x001C (0x03F0 - 0x03D4)
class ATgPickupFactory_Item : public ATgPickupFactory
{
public:
	class USoundCue*                                   PickupSound;                                              // 0x03D4(0x0008)
	struct FString                                     PickupMessage;                                            // 0x03DC(0x0010) (Const, Localized, NeedCtorLink)
	float                                              RespawnTime;                                              // 0x03EC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPickupFactory_Item");
		return ptr;
	}


	float BotDesireability(class APawn* P);
	float GetRespawnTime();
	void STATIC_SetRespawn();
	void STATIC_SpawnCopyFor(class APawn* Recipient);
	struct FString GetLocalString(int Switch, class APlayerReplicationInfo* RelatedPRI_2, class APlayerReplicationInfo* RelatedPRI_3);
	void InitializePickup();
};


// Class TgGame.TgWeatherVolume
// 0x0008 (0x02C4 - 0x02BC)
class ATgWeatherVolume : public AVolume
{
public:
	class UParticleSystem*                             m_Template;                                               // 0x02BC(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgWeatherVolume");
		return ptr;
	}


	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgProj_Bombardment_Fire
// 0x0000 (0x053C - 0x053C)
class ATgProj_Bombardment_Fire : public ATgProj_Bombardment
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Bombardment_Fire");
		return ptr;
	}

};


// Class TgGame.TgProj_DreadSerpent
// 0x0000 (0x052C - 0x052C)
class ATgProj_DreadSerpent : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_DreadSerpent");
		return ptr;
	}

};


// Class TgGame.TgProj_Enlightenment
// 0x0000 (0x052C - 0x052C)
class ATgProj_Enlightenment : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Enlightenment");
		return ptr;
	}

};


// Class TgGame.TgProj_EvilMojo
// 0x0000 (0x0580 - 0x0580)
class ATgProj_EvilMojo : public ATgProj_FreeGrenade
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_EvilMojo");
		return ptr;
	}


	bool CheckTeamPassThrough(class AActor* Other);
};


// Class TgGame.TgProj_ExplodeAtMaxRange
// 0x0000 (0x052C - 0x052C)
class ATgProj_ExplodeAtMaxRange : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_ExplodeAtMaxRange");
		return ptr;
	}

};


// Class TgGame.TgProj_ExplosiveFlask
// 0x0000 (0x0580 - 0x0580)
class ATgProj_ExplosiveFlask : public ATgProj_FreeGrenade
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_ExplosiveFlask");
		return ptr;
	}

};


// Class TgGame.TgProj_Fireball
// 0x0000 (0x052C - 0x052C)
class ATgProj_Fireball : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Fireball");
		return ptr;
	}

};


// Class TgGame.TgProj_FlakRocket
// 0x0000 (0x052C - 0x052C)
class ATgProj_FlakRocket : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_FlakRocket");
		return ptr;
	}


	bool ShouldExplodeAtMaxRange();
	struct FName STATIC_GetHitWallFxGroup();
	struct FName STATIC_GetHitTargetFxGroup();
};


// Class TgGame.TgProj_FuriaF
// 0x0008 (0x0534 - 0x052C)
class ATgProj_FuriaF : public ATgProj_Simulated
{
public:
	float                                              m_fRetargetingTimer;                                      // 0x052C(0x0004)
	float                                              m_fRetargetTime;                                          // 0x0530(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_FuriaF");
		return ptr;
	}


	void STATIC_UpdateTrackingTargetActor();
	void Tick(float DeltaSeconds);
};


// Class TgGame.TgProj_GaeBolg
// 0x0000 (0x052C - 0x052C)
class ATgProj_GaeBolg : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_GaeBolg");
		return ptr;
	}

};


// Class TgGame.TgProj_HHEventRocket
// 0x0000 (0x052C - 0x052C)
class ATgProj_HHEventRocket : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_HHEventRocket");
		return ptr;
	}

};


// Class TgGame.TgProj_IceStorm
// 0x0004 (0x0530 - 0x052C)
class ATgProj_IceStorm : public ATgProj_Simulated
{
public:
	unsigned long                                      m_bStopped : 1;                                           // 0x052C(0x0004)
	unsigned long                                      m_bCheckLOSForHit : 1;                                    // 0x052C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_IceStorm");
		return ptr;
	}


	float STATIC_GetRemainingTime();
	void ExplodeOnTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void Tick(float DeltaSeconds);
	void STATIC_HandleTick();
	void CompleteInitialization(unsigned char ExtraInfo);
};


// Class TgGame.TgProj_KnifeLongRange
// 0x0000 (0x052C - 0x052C)
class ATgProj_KnifeLongRange : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_KnifeLongRange");
		return ptr;
	}

};


// Class TgGame.TgProj_KnifeShortRange
// 0x0000 (0x0580 - 0x0580)
class ATgProj_KnifeShortRange : public ATgProj_FreeGrenade
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_KnifeShortRange");
		return ptr;
	}

};


// Class TgGame.TgProj_LanepusherCannon
// 0x0000 (0x052C - 0x052C)
class ATgProj_LanepusherCannon : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_LanepusherCannon");
		return ptr;
	}


	void Tick(float fDeltaTime);
	struct FVector GetSeekLocation();
};


// Class TgGame.TgProj_MalDambaInhand
// 0x0000 (0x0580 - 0x0580)
class ATgProj_MalDambaInhand : public ATgProj_FreeGrenade
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_MalDambaInhand");
		return ptr;
	}

};


// Class TgGame.TgProj_PotionLauncherProjectile
// 0x0000 (0x0580 - 0x0580)
class ATgProj_PotionLauncherProjectile : public ATgProj_FreeGrenade
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_PotionLauncherProjectile");
		return ptr;
	}


	void PlayAdditionalHitFX(class AActor* HitActor, const struct FVector& FXLocation, const struct FVector& HitNormal, const struct FVector& ProjDir, TArray<struct FParticleSysParam>* ExplosionParams);
};


// Class TgGame.TgProj_PotionLauncherProjectile_CombatMedic
// 0x0000 (0x0580 - 0x0580)
class ATgProj_PotionLauncherProjectile_CombatMedic : public ATgProj_PotionLauncherProjectile
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_PotionLauncherProjectile_CombatMedic");
		return ptr;
	}

};


// Class TgGame.TgProj_PotionLauncherProjectile_HighFireAngleTest
// 0x0000 (0x0580 - 0x0580)
class ATgProj_PotionLauncherProjectile_HighFireAngleTest : public ATgProj_PotionLauncherProjectile
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_PotionLauncherProjectile_HighFireAngleTest");
		return ptr;
	}

};


// Class TgGame.TgProj_SmokeScreen
// 0x0000 (0x0580 - 0x0580)
class ATgProj_SmokeScreen : public ATgProj_FreeGrenade
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_SmokeScreen");
		return ptr;
	}

};


// Class TgGame.TgProj_SnakeToss
// 0x0000 (0x0580 - 0x0580)
class ATgProj_SnakeToss : public ATgProj_FreeGrenade
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_SnakeToss");
		return ptr;
	}

};


// Class TgGame.TgProj_SoulOrb
// 0x0000 (0x052C - 0x052C)
class ATgProj_SoulOrb : public ATgProj_Fireball
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_SoulOrb");
		return ptr;
	}

};


// Class TgGame.TgProj_TimeBomb
// 0x0000 (0x0580 - 0x0580)
class ATgProj_TimeBomb : public ATgProj_FreeGrenade
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_TimeBomb");
		return ptr;
	}

};


// Class TgGame.TgProj_Tracer
// 0x0008 (0x0458 - 0x0450)
class ATgProj_Tracer : public ATgProjectile
{
public:
	class UTgParticleSystemComponent*                  PSC;                                                      // 0x0450(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Tracer");
		return ptr;
	}


	void ShutDown();
	bool CheckProjectileRange(const struct FVector& vLocOverride);
	void Tick(float DeltaSeconds);
	void STATIC_InitTracer(class UTgSpecialFx* Fx, bool bIsEnemy, bool bConfused);
};


// Class TgGame.TgProj_VenomousGourd
// 0x0000 (0x0580 - 0x0580)
class ATgProj_VenomousGourd : public ATgProj_FreeGrenade
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_VenomousGourd");
		return ptr;
	}

};


// Class TgGame.TgProj_WilloInHand
// 0x0000 (0x052C - 0x052C)
class ATgProj_WilloInHand : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_WilloInHand");
		return ptr;
	}


	struct FName STATIC_GetHitWallFxGroup();
	struct FName STATIC_GetHitTargetFxGroup();
};


// Class TgGame.TgSeqEvent_ControlPointOwnershipPercent
// 0x0008 (0x0130 - 0x0128)
class UTgSeqEvent_ControlPointOwnershipPercent : public USequenceEvent
{
public:
	float                                              OwnershipPercent;                                         // 0x0128(0x0004) (Edit)
	int                                                PointIndex;                                               // 0x012C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_ControlPointOwnershipPercent");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_TaskForceScoreUpdated
// 0x0008 (0x0130 - 0x0128)
class UTgSeqEvent_TaskForceScoreUpdated : public USequenceEvent
{
public:
	int                                                DefenderTaskForce;                                        // 0x0128(0x0004) (Edit)
	int                                                currentScore;                                             // 0x012C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_TaskForceScoreUpdated");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_BeaconEntranceSetActive
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_BeaconEntranceSetActive : public USequenceAction
{
public:
	unsigned long                                      m_bSetActive : 1;                                         // 0x0108(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_BeaconEntranceSetActive");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_BeaconExitSetRespawn
// 0x000C (0x0114 - 0x0108)
class UTgSeqAct_BeaconExitSetRespawn : public USequenceAction
{
public:
	class AActor*                                      m_RespawnPoint;                                           // 0x0108(0x0008)
	unsigned long                                      m_bRespawnImmediately : 1;                                // 0x0110(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_BeaconExitSetRespawn");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_AddAnimSets
// 0x0024 (0x012C - 0x0108)
class UTgSeqAct_AddAnimSets : public USequenceAction
{
public:
	TArray<class UAnimSet*>                            m_MaleAnimSets;                                           // 0x0108(0x0010) (Edit, NeedCtorLink)
	TArray<class UAnimSet*>                            m_FemaleAnimSets;                                         // 0x0118(0x0010) (Edit, NeedCtorLink)
	unsigned long                                      m_bAppendToExisting : 1;                                  // 0x0128(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_AddAnimSets");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_AIStartFireAt
// 0x0001 (0x0109 - 0x0108)
class UTgSeqAct_AIStartFireAt : public USequenceAction
{
public:
	unsigned char                                      ForcedFireMode;                                           // 0x0108(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_AIStartFireAt");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_AIStopFire
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_AIStopFire : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_AIStopFire");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_ChangeScale
// 0x0014 (0x011C - 0x0108)
class UTgSeqAct_ChangeScale : public USequenceAction
{
public:
	float                                              TargetScale;                                              // 0x0108(0x0004) (Edit)
	struct FVector                                     TargetScale3D;                                            // 0x010C(0x000C) (Edit)
	float                                              TransitionTime;                                           // 0x0118(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_ChangeScale");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_DisplaySlamText
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_DisplaySlamText : public USequenceAction
{
public:
	int                                                m_nMessageId;                                             // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_DisplaySlamText");
		return ptr;
	}


	void Activated();
};


// Class TgGame.TgSeqAct_FadeIn
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_FadeIn : public USequenceAction
{
public:
	float                                              m_fDuration;                                              // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_FadeIn");
		return ptr;
	}


	void Activated();
};


// Class TgGame.TgSeqAct_FadeOut
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_FadeOut : public USequenceAction
{
public:
	float                                              m_fDuration;                                              // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_FadeOut");
		return ptr;
	}


	void Activated();
};


// Class TgGame.TgSeqAct_GetCharClass
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_GetCharClass : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_GetCharClass");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_HackBot
// 0x0008 (0x0110 - 0x0108)
class UTgSeqAct_HackBot : public USequenceAction
{
public:
	class AActor*                                      m_ControlPawn;                                            // 0x0108(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_HackBot");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_HideHUD
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_HideHUD : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_HideHUD");
		return ptr;
	}


	void Activated();
};


// Class TgGame.TgSeqAct_HideSilhouettes
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_HideSilhouettes : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_HideSilhouettes");
		return ptr;
	}


	void Activated();
};


// Class TgGame.TgSeqAct_LaunchHomeInstance
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_LaunchHomeInstance : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_LaunchHomeInstance");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_MarkSpawnReturn
// 0x0008 (0x0110 - 0x0108)
class UTgSeqAct_MarkSpawnReturn : public USequenceAction
{
public:
	class ATeleporter*                                 m_Teleporter;                                             // 0x0108(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_MarkSpawnReturn");
		return ptr;
	}


	void Activated();
};


// Class TgGame.TgSeqAct_NextGamePhase
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_NextGamePhase : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_NextGamePhase");
		return ptr;
	}


	void Activated();
};


// Class TgGame.TgSeqAct_PauseSetupTimer
// 0x0008 (0x0110 - 0x0108)
class UTgSeqAct_PauseSetupTimer : public USequenceAction
{
public:
	unsigned long                                      PauseImmediately : 1;                                     // 0x0108(0x0004) (Edit)
	float                                              PauseAtTimeRemaining;                                     // 0x010C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_PauseSetupTimer");
		return ptr;
	}


	void Activated();
};


// Class TgGame.TgSeqAct_PlayAnnouncement
// 0x0010 (0x0118 - 0x0108)
class UTgSeqAct_PlayAnnouncement : public USequenceAction
{
public:
	unsigned long                                      bPlayImmediately : 1;                                     // 0x0108(0x0004) (Edit)
	unsigned long                                      bFlushOthers : 1;                                         // 0x0108(0x0004) (Edit)
	int                                                SoundIndex;                                               // 0x010C(0x0004) (Edit)
	class USoundCue*                                   OptionalCue;                                              // 0x0110(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_PlayAnnouncement");
		return ptr;
	}


	int GetObjClassVersion();
	void Activated();
};


// Class TgGame.TgSeqAct_PlayCameraAnim
// 0x0018 (0x0120 - 0x0108)
class UTgSeqAct_PlayCameraAnim : public USequenceAction
{
public:
	class UCameraAnim*                                 AnimToPlay;                                               // 0x0108(0x0008) (Edit)
	float                                              BlendInTime;                                              // 0x0110(0x0004) (Edit)
	float                                              BlendOutTime;                                             // 0x0114(0x0004) (Edit)
	float                                              Rate;                                                     // 0x0118(0x0004) (Edit)
	float                                              IntensityScale;                                           // 0x011C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_PlayCameraAnim");
		return ptr;
	}


	int GetObjClassVersion();
};


// Class TgGame.TgSeqAct_SelectBestSpawnPoint
// 0x0018 (0x0120 - 0x0108)
class UTgSeqAct_SelectBestSpawnPoint : public USequenceAction
{
public:
	TArray<class UObject*>                             Points;                                                   // 0x0108(0x0010) (Edit, NeedCtorLink)
	class AActor*                                      PlayerReceived;                                           // 0x0118(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_SelectBestSpawnPoint");
		return ptr;
	}


	void Activated();
};


// Class TgGame.TgSeqAct_SetSkelPosture
// 0x0001 (0x0109 - 0x0108)
class UTgSeqAct_SetSkelPosture : public USequenceAction
{
public:
	TEnumAsByte<ETG_POSTURE>                           m_Posture;                                                // 0x0108(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_SetSkelPosture");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_SetUltimateEnergy
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_SetUltimateEnergy : public USequenceAction
{
public:
	float                                              fChargePercent;                                           // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_SetUltimateEnergy");
		return ptr;
	}


	void Activated();
};


// Class TgGame.TgSeqAct_ShowGameTip
// 0x000C (0x0114 - 0x0108)
class UTgSeqAct_ShowGameTip : public USequenceAction
{
public:
	int                                                GameTipId;                                                // 0x0108(0x0004) (Edit)
	class ATgPlayerController*                         TargetPlayer;                                             // 0x010C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_ShowGameTip");
		return ptr;
	}


	void Activated();
};


// Class TgGame.TgSeqAct_ShowHUD
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_ShowHUD : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_ShowHUD");
		return ptr;
	}


	void Activated();
};


// Class TgGame.TgSeqAct_ShowLoadoutMenu
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_ShowLoadoutMenu : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_ShowLoadoutMenu");
		return ptr;
	}


	void Activated();
};


// Class TgGame.TgSeqAct_ShowSilhouettes
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_ShowSilhouettes : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_ShowSilhouettes");
		return ptr;
	}


	void Activated();
};


// Class TgGame.TgSeqAct_TriggerInterpActor
// 0x0010 (0x0118 - 0x0108)
class UTgSeqAct_TriggerInterpActor : public USequenceAction
{
public:
	struct FString                                     m_sStateName;                                             // 0x0108(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_TriggerInterpActor");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_UnpauseSetupTimer
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_UnpauseSetupTimer : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_UnpauseSetupTimer");
		return ptr;
	}


	void Activated();
};


// Class TgGame.TgSeqEvent_PayloadAttackersWin
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_PayloadAttackersWin : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_PayloadAttackersWin");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_PayloadBeginTF1
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_PayloadBeginTF1 : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_PayloadBeginTF1");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_PayloadBeginTF2
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_PayloadBeginTF2 : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_PayloadBeginTF2");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_PayloadDefendersWin
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_PayloadDefendersWin : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_PayloadDefendersWin");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_PayloadEndTF1
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_PayloadEndTF1 : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_PayloadEndTF1");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_PayloadEndTF2
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_PayloadEndTF2 : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_PayloadEndTF2");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_SetupTimeEnded
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_SetupTimeEnded : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_SetupTimeEnded");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_SiegePush
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_SiegePush : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_SiegePush");
		return ptr;
	}

};


// Class TgGame.TgSiegePushActor
// 0x0034 (0x02B4 - 0x0280)
class ATgSiegePushActor : public AActor
{
public:
	class ATgCollisionProxy_Cylinder*                  s_CollisionProxy;                                         // 0x0280(0x0008)
	float                                              m_fCollisionProxyRadius;                                  // 0x0288(0x0004) (Edit, Const)
	float                                              m_fCollisionProxyHeight;                                  // 0x028C(0x0004) (Edit, Const)
	class USkeletalMeshComponent*                      m_SkelMesh;                                               // 0x0290(0x0008) (Edit, ExportObject, Component, EditInline)
	class UStaticMeshComponent*                        m_RadiusMesh;                                             // 0x0298(0x0008) (Edit, ExportObject, Component, EditInline)
	int                                                m_nTF1Count;                                              // 0x02A0(0x0004) (Transient)
	int                                                m_nTF2Count;                                              // 0x02A4(0x0004) (Transient)
	int                                                m_nDefenderTaskForce;                                     // 0x02A8(0x0004) (Edit)
	TEnumAsByte<EPushState>                            m_CurrentPushState;                                       // 0x02AC(0x0001) (Transient)
	unsigned char                                      UnknownData00[0x3];                                       // 0x02AD(0x0003) MISSED OFFSET
	float                                              m_fPendingReverseTime;                                    // 0x02B0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSiegePushActor");
		return ptr;
	}


	void SetCurrentPushState(TEnumAsByte<EPushState> NewPushState);
	void SetReversePushState();
	void NearbyPawnsUpdated();
	void CollisionProxyOnUnTouch(class AActor* Other);
	void CollisionProxyOnTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void PostBeginPlay();
};


// Class TgGame.TgSeqAct_SetLobbyMeshSkin
// 0x0010 (0x0118 - 0x0108)
class UTgSeqAct_SetLobbyMeshSkin : public USequenceAction
{
public:
	int                                                m_nMessageSkinId;                                         // 0x0108(0x0004) (Edit)
	int                                                m_nMessageDeviceSkinId;                                   // 0x010C(0x0004) (Edit)
	int                                                m_nSkinId;                                                // 0x0110(0x0004) (Edit)
	int                                                m_nDeviceSkinId;                                          // 0x0114(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_SetLobbyMeshSkin");
		return ptr;
	}

};


// Class TgGame.TgSkeletalMeshComponent_WeaponFirstPerson
// 0x0000 (0x0898 - 0x0898)
class UTgSkeletalMeshComponent_WeaponFirstPerson : public UTgSkeletalMeshComponent_Weapon
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkeletalMeshComponent_WeaponFirstPerson");
		return ptr;
	}

};


// Class TgGame.TgSkeletalMeshComponent_WeaponFirstPersonLance
// 0x0000 (0x0898 - 0x0898)
class UTgSkeletalMeshComponent_WeaponFirstPersonLance : public UTgSkeletalMeshComponent_WeaponFirstPerson
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkeletalMeshComponent_WeaponFirstPersonLance");
		return ptr;
	}

};


// Class TgGame.TgSoundInsulationVolume
// 0x0000 (0x0320 - 0x0320)
class ATgSoundInsulationVolume : public AReverbVolume
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSoundInsulationVolume");
		return ptr;
	}

};


// Class TgGame.TgStaticMeshActorGrass
// 0x0014 (0x02B8 - 0x02A4)
class ATgStaticMeshActorGrass : public AStaticMeshActor
{
public:
	float                                              m_fTargetScale;                                           // 0x02A4(0x0004)
	struct FVector                                     m_TargetScale3D;                                          // 0x02A8(0x000C)
	float                                              m_fScaleTransitionTime;                                   // 0x02B4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgStaticMeshActorGrass");
		return ptr;
	}


	void Tick(float DeltaTime);
	void OnChangeScale(class UTgSeqAct_ChangeScale* SeqAct_ChangeScale);
};


// Class TgGame.TgTimeDilationVolume
// 0x0028 (0x033C - 0x0314)
class ATgTimeDilationVolume : public APhysicsVolume
{
public:
	float                                              m_fTimeMultiplier;                                        // 0x0314(0x0004)
	unsigned long                                      m_bAffectInstigator : 1;                                  // 0x0318(0x0004)
	TArray<class AActor*>                              m_AffectedActors;                                         // 0x031C(0x0010) (NeedCtorLink)
	TArray<class APawn*>                               m_AffectedPawns;                                          // 0x032C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgTimeDilationVolume");
		return ptr;
	}


	void Destroyed();
	void PawnLeavingVolume(class APawn* Other);
	void PawnEnteredVolume(class APawn* Other);
	void ActorLeavingVolume(class AActor* Other);
	void ActorEnteredVolume(class AActor* Other);
	void PostBeginPlay();
};


// Class TgGame.TgVolume
// 0x0000 (0x02BC - 0x02BC)
class ATgVolume : public AVolume
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgVolume");
		return ptr;
	}

};


// Class TgGame.TgWaterVolume
// 0x0000 (0x0334 - 0x0334)
class ATgWaterVolume : public AWaterVolume
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgWaterVolume");
		return ptr;
	}

};


// Class TgGame.TgWeaponMeshActor_Rider
// 0x00BC (0x050C - 0x0450)
class ATgWeaponMeshActor_Rider : public ATgWeaponMeshActor
{
public:
	class UTgSkeletalMeshComponent*                    m_LeftHead;                                               // 0x0450(0x0008) (Edit, ExportObject, Component, EditInline)
	class UTgSkeletalMeshComponent*                    m_RightHead;                                              // 0x0458(0x0008) (Edit, ExportObject, Component, EditInline)
	struct FVector                                     m_vLeftHeadTranslation;                                   // 0x0460(0x000C) (Edit)
	struct FVector                                     m_vRightHeadTranslation;                                  // 0x046C(0x000C) (Edit)
	struct FVector                                     m_vLookDownTranslation;                                   // 0x0478(0x000C) (Edit)
	struct FVector                                     m_vLookUpTranslation;                                     // 0x0484(0x000C) (Edit)
	struct FRotator                                    m_rLeftHeadRotation;                                      // 0x0490(0x000C) (Edit)
	struct FRotator                                    m_rRightHeadRotation;                                     // 0x049C(0x000C) (Edit)
	struct FRotator                                    m_rLookDownRotation;                                      // 0x04A8(0x000C) (Edit)
	struct FRotator                                    m_rLookUpRotation;                                        // 0x04B4(0x000C) (Edit)
	float                                              m_fHeadFOV;                                               // 0x04C0(0x0004) (Edit)
	class UStaticMeshComponent*                        m_BodyMesh;                                               // 0x04C4(0x0008) (Edit, ExportObject, Component, EditInline)
	class UMaterialInstanceConstant*                   m_BodyMeshMat;                                            // 0x04CC(0x0008) (Edit)
	unsigned long                                      m_bBodyMeshMatApplied : 1;                                // 0x04D4(0x0004) (Edit)
	struct FVector                                     m_vBodyScale;                                             // 0x04D8(0x000C) (Edit)
	struct FVector                                     m_vBodyTranslation;                                       // 0x04E4(0x000C) (Edit)
	struct FVector                                     m_vLookDownBodyTranslation;                               // 0x04F0(0x000C) (Edit)
	float                                              m_fLastRotation;                                          // 0x04FC(0x0004) (Edit)
	float                                              m_fMaxRotationLag;                                        // 0x0500(0x0004) (Edit)
	float                                              m_fRotationLag;                                           // 0x0504(0x0004) (Edit)
	float                                              m_fRotationLagRecoveryRate;                               // 0x0508(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgWeaponMeshActor_Rider");
		return ptr;
	}


	void Tick(float DeltaTime);
};


// Class TgGame.TgAIBehaviorAction_PurchaseCards
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_PurchaseCards : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_PurchaseCards");
		return ptr;
	}

};


// Class TgGame.TgDeploy_ProxyMineAdvanced
// 0x0005 (0x0471 - 0x046C)
class ATgDeploy_ProxyMineAdvanced : public ATgDeployable
{
public:
	unsigned long                                      m_bInProximityRange : 1;                                  // 0x046C(0x0004)
	unsigned char                                      r_nExplosionCount;                                        // 0x0470(0x0001) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_ProxyMineAdvanced");
		return ptr;
	}


	void STATIC_FlashFireCountUpdated();
	void STATIC_FireExplosionVFX();
	void STATIC_CheckRemainingExplosions();
	void CheckExplode();
	void DeployComplete();
	void ReplicatedEvent(const struct FName& VarName);
};


// Class TgGame.TgDevice_AsymmetricWarfare
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_AsymmetricWarfare : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_AsymmetricWarfare");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
};


// Class TgGame.TgWeaponMeshActor_AtlasInhand
// 0x0000 (0x0450 - 0x0450)
class ATgWeaponMeshActor_AtlasInhand : public ATgWeaponMeshActor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgWeaponMeshActor_AtlasInhand");
		return ptr;
	}


	void Tick(float DeltaTime);
	void PlayFireAnimation(int nEquipSlot, float fRefireTime);
};


// Class TgGame.TgDevice_AtlasQ
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_AtlasQ : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_AtlasQ");
		return ptr;
	}


	bool CanBeCanceled();
};


// Class TgGame.TgDevice_BombQueenRangeCard
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_BombQueenRangeCard : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_BombQueenRangeCard");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
};


// Class TgGame.TgDevice_BombQueenTalent1
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_BombQueenTalent1 : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_BombQueenTalent1");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
};


// Class TgGame.TgDevice_BombQueenTalent3
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_BombQueenTalent3 : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_BombQueenTalent3");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
};


// Class TgGame.TgDevice_CaspianBonusProjectileTalent
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_CaspianBonusProjectileTalent : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CaspianBonusProjectileTalent");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
};


// Class TgGame.TgDevice_CaspianTalentTwo
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_CaspianTalentTwo : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CaspianTalentTwo");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
};


// Class TgGame.TgDevice_GaeBolg_Test
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_GaeBolg_Test : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_GaeBolg_Test");
		return ptr;
	}

};


// Class TgGame.TgWeaponMeshActor_ImaniInhand
// 0x0024 (0x0474 - 0x0450)
class ATgWeaponMeshActor_ImaniInhand : public ATgWeaponMeshActor
{
public:
	unsigned long                                      m_bUsingSecondaryStance : 1;                              // 0x0450(0x0004)
	TArray<class UTgAnimNodeBlendBySimpleStance*>      m_stanceNodes3p;                                          // 0x0454(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeBlendBySimpleStance*>      m_stanceNodes1p;                                          // 0x0464(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgWeaponMeshActor_ImaniInhand");
		return ptr;
	}


	void STATIC_UpdateTransform(float DeltaTime, bool bFromCameraUpdate);
	bool STATIC_GetSimulatedBeamTarget(int nEquipSlot, struct FVector* HitLocation);
	void STATIC_UpdateCurrentStance(bool bSecondaryStance);
	void STATIC_FixUpReferencesToPawnMesh(class USkeletalMeshComponent* PawnMesh);
	void STATIC_FixUpReferencesToWeaponMesh1P(class USkeletalMeshComponent* weaponMesh);
};


// Class TgGame.TgDevice_InnerStrength
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_InnerStrength : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_InnerStrength");
		return ptr;
	}


	bool CanBeFiredWhileTweening();
};


// Class TgGame.TgDevice_OppressorMineTalent
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_OppressorMineTalent : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_OppressorMineTalent");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
};


// Class TgGame.TgDevice_RampantBlooming
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_RampantBlooming : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_RampantBlooming");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
};


// Class TgGame.TgDevice_SaatiDecoyTalent
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_SaatiDecoyTalent : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_SaatiDecoyTalent");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
};


// Class TgGame.TgDevice_SevenDoubleDropTalent
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_SevenDoubleDropTalent : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_SevenDoubleDropTalent");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
};


// Class TgGame.TgDevice_SevenElementalSwitch
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_SevenElementalSwitch : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_SevenElementalSwitch");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
};


// Class TgGame.TgDevice_SevenExplosiveUltTalent
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_SevenExplosiveUltTalent : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_SevenExplosiveUltTalent");
		return ptr;
	}


	void OnUnlinkDevice(class ATgPawn* TgP);
	void OnLinkDevice(class ATgPawn* TgP);
};


// Class TgGame.TgDevice_Slither
// 0x0000 (0x0A80 - 0x0A80)
class ATgDevice_Slither : public ATgDevice_Charge
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Slither");
		return ptr;
	}

};


// Class TgGame.TgDevice_UnstableRift
// 0x0000 (0x0A0C - 0x0A0C)
class ATgDevice_UnstableRift : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_UnstableRift");
		return ptr;
	}

};


// Class TgGame.TgWeaponMeshActor_YagorathInhand
// 0x0000 (0x0450 - 0x0450)
class ATgWeaponMeshActor_YagorathInhand : public ATgWeaponMeshActor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgWeaponMeshActor_YagorathInhand");
		return ptr;
	}


	void OnBehindViewUpdated(bool bNewBehindView);
	void Play3pFireAimedFX();
};


// Class TgGame.TgDeviceFire_DropAndRoll
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_DropAndRoll : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_DropAndRoll");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_DruidFKnockback
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_DruidFKnockback : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_DruidFKnockback");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_IgnoreShields
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_IgnoreShields : public UTgDeviceFire_WorldLOSOnly
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_IgnoreShields");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_ImaniDragonInhand
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_ImaniDragonInhand : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_ImaniDragonInhand");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_ImaniUlt
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_ImaniUlt : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_ImaniUlt");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_YagoAcidDeploy
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_YagoAcidDeploy : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_YagoAcidDeploy");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_YagorathUlt
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceFire_YagorathUlt : public UTgDeviceFire_IgnoreCCImmune
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_YagorathUlt");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_AtlasBarrage
// 0x0008 (0x0294 - 0x028C)
class UTgDeviceForm_AtlasBarrage : public UTgDeviceForm
{
public:
	class ATgPlayerController*                         m_CachedActiveOverlayController;                          // 0x028C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_AtlasBarrage");
		return ptr;
	}


	void StopFire(int nFireModeNum);
	void Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
};


// Class TgGame.TgDeviceForm_AtlasBarrageFire
// 0x0000 (0x028C - 0x028C)
class UTgDeviceForm_AtlasBarrageFire : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_AtlasBarrageFire");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_AtlasF
// 0x0020 (0x02AC - 0x028C)
class UTgDeviceForm_AtlasF : public UTgDeviceForm
{
public:
	TArray<class UTgAnimNodeBlendByAbilityAtlasF*>     m_AnimNodeAtlasF1P;                                       // 0x028C(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeBlendByAbilityAtlasF*>     m_AnimNodeAtlasF3P;                                       // 0x029C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_AtlasF");
		return ptr;
	}


	void Generic3(unsigned char byExtraData);
	void Generic2(unsigned char byExtraData);
	void Generic1(unsigned char byExtraData);
	void CacheAnimNode(class UAnimNode* Node, bool bIs3p);
	void ClearAnimNodes(bool bIs3p);
};


// Class TgGame.TgDeviceForm_BettyInhand
// 0x0000 (0x028C - 0x028C)
class UTgDeviceForm_BettyInhand : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_BettyInhand");
		return ptr;
	}


	void Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	bool STATIC_SetAmmoNodesOnStartFire();
};


// Class TgGame.TgDeviceForm_BettyUlt
// 0x0000 (0x028C - 0x028C)
class UTgDeviceForm_BettyUlt : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_BettyUlt");
		return ptr;
	}


	void Generic2(unsigned char byExtraData);
	void Generic1(unsigned char byExtraData);
};


// Class TgGame.TgDeviceForm_ImaniRMB1
// 0x0000 (0x028C - 0x028C)
class UTgDeviceForm_ImaniRMB1 : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_ImaniRMB1");
		return ptr;
	}


	void Generic1(unsigned char byExtraData);
};


// Class TgGame.TgDeviceForm_ImaniRMB2
// 0x0004 (0x0290 - 0x028C)
class UTgDeviceForm_ImaniRMB2 : public UTgDeviceForm
{
public:
	unsigned long                                      m_bInFireLoop : 1;                                        // 0x028C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_ImaniRMB2");
		return ptr;
	}


	void StopFire(int nFireModeNum);
	void DoInterrupt();
	void Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	void STATIC_SetFireloopState(bool bFiring);
};


// Class TgGame.TgDeviceForm_ImaniUlt
// 0x0000 (0x028C - 0x028C)
class UTgDeviceForm_ImaniUlt : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_ImaniUlt");
		return ptr;
	}


	void Generic1(unsigned char byExtraData);
	void StopFire(int nFireModeNum);
};


// Class TgGame.TgDeviceForm_LillithMovement
// 0x0020 (0x02AC - 0x028C)
class UTgDeviceForm_LillithMovement : public UTgDeviceForm
{
public:
	TArray<class UTgAnimNodeBlendByVampireMovement*>   m_VampMoveNodes3p;                                        // 0x028C(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeBlendByVampireMovement*>   m_VampMoveNodes1p;                                        // 0x029C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_LillithMovement");
		return ptr;
	}


	void Generic2(unsigned char byExtraData);
	void Generic1(unsigned char byExtraData);
	void CacheAnimNode(class UAnimNode* Node, bool bIs3p);
	void ClearAnimNodes(bool bIs3p);
};


// Class TgGame.TgDeviceForm_SaatiDecoyInhand
// 0x0000 (0x028C - 0x028C)
class UTgDeviceForm_SaatiDecoyInhand : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_SaatiDecoyInhand");
		return ptr;
	}


	void PlayTracerEffects(const struct FVector& endLocation, const struct FName& nmFxName, int nEquipSlot, int nFireMode);
	void Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
};


// Class TgGame.TgDeviceForm_SplittingIce
// 0x0000 (0x02AC - 0x02AC)
class UTgDeviceForm_SplittingIce : public UTgDeviceForm_ArcingBeam
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_SplittingIce");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Stealth
// 0x0000 (0x028C - 0x028C)
class UTgDeviceForm_Stealth : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Stealth");
		return ptr;
	}


	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
};


// Class TgGame.TgDeviceForm_VampireQ
// 0x0000 (0x028C - 0x028C)
class UTgDeviceForm_VampireQ : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_VampireQ");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_WallBang
// 0x0000 (0x028C - 0x028C)
class UTgDeviceForm_WallBang : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_WallBang");
		return ptr;
	}


	void STATIC_PlayUltActiveEffect(bool bActive);
	void Generic1(unsigned char byExtraData);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
};


// Class TgGame.TgDeviceForm_WallBangFire
// 0x0038 (0x02C4 - 0x028C)
class UTgDeviceForm_WallBangFire : public UTgDeviceForm
{
public:
	struct FSaatiAimInfo                               s_CachedAimInfo;                                          // 0x028C(0x0018)
	TArray<class UTgAnimNodeBlendByAbilitySaatiUlt*>   m_SaatiUltNodes3p;                                        // 0x02A4(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeBlendByAbilitySaatiUlt*>   m_SaatiUltNodes1p;                                        // 0x02B4(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_WallBangFire");
		return ptr;
	}


	void Generic1(unsigned char byExtraData);
	void CacheAnimNode(class UAnimNode* Node, bool bIs3p);
	void ClearAnimNodes(bool bIs3p);
};


// Class TgGame.TgDeviceForm_YagoSpray
// 0x0000 (0x028C - 0x028C)
class UTgDeviceForm_YagoSpray : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_YagoSpray");
		return ptr;
	}


	void StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
};


// Class TgGame.TgGame_Paladins_CrazyKing
// 0x002C (0x0898 - 0x086C)
class ATgGame_Paladins_CrazyKing : public ATgGame_Paladins
{
public:
	float                                              m_fSetupDuration;                                         // 0x086C(0x0004) (Config)
	float                                              m_fRoundDuration;                                         // 0x0870(0x0004) (Config)
	TArray<class ATgChaosCapturePoint*>                m_CapturePoints;                                          // 0x0874(0x0010) (NeedCtorLink)
	int                                                m_nCurrentActivePointIndex;                               // 0x0884(0x0004)
	int                                                m_nLastActivePointIndex;                                  // 0x0888(0x0004)
	class ATgChaosCapturePoint*                        m_currentActiveCapturePoint;                              // 0x088C(0x0008)
	float                                              m_fMaxDistanceBetweenConsecutivePoints;                   // 0x0894(0x0004) (Config)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Paladins_CrazyKing");
		return ptr;
	}


	bool STATIC_HasCaptureObjectives();
	void STATIC_PointSwapAlert();
	void STATIC_SelectCapturePoint(int nCapturePointIndex);
	void STATIC_SelectRandomCapturePoint();
	void STATIC_SelectInitialCapturePoint();
	void SetupPhases();
	void PostBeginPlay();
};


// Class TgGame.TgGame_Paladins_EndTimes
// 0x0000 (0x0898 - 0x0898)
class ATgGame_Paladins_EndTimes : public ATgGame_Paladins_CrazyKing
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Paladins_EndTimes");
		return ptr;
	}


	void SetupPhases();
};


// Class TgGame.TgGame_Paladins_PVETDM
// 0x0004 (0x0870 - 0x086C)
class ATgGame_Paladins_PVETDM : public ATgGame_Paladins
{
public:
	float                                              m_fSetupDuration;                                         // 0x086C(0x0004) (Config)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Paladins_PVETDM");
		return ptr;
	}


	void SetupPhases();
};


// Class TgGame.TgGame_Paladins_SiegeBeyond
// 0x0000 (0x0A90 - 0x0A90)
class ATgGame_Paladins_SiegeBeyond : public ATgGame_Paladins_Siege
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Paladins_SiegeBeyond");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_DamageFromCharge
// 0x0000 (0x0098 - 0x0098)
class UTgGameplayCurvesSet_DamageFromCharge : public UTgGameplayCurvesSet_Simple
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_DamageFromCharge");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_DamageFromDistance
// 0x0000 (0x0098 - 0x0098)
class UTgGameplayCurvesSet_DamageFromDistance : public UTgGameplayCurvesSet_Simple
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_DamageFromDistance");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_DamageOverTime
// 0x0000 (0x0098 - 0x0098)
class UTgGameplayCurvesSet_DamageOverTime : public UTgGameplayCurvesSet_Simple
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_DamageOverTime");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_ResistanceFromDeviation
// 0x0000 (0x0098 - 0x0098)
class UTgGameplayCurvesSet_ResistanceFromDeviation : public UTgGameplayCurvesSet_Simple
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_ResistanceFromDeviation");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_SpinUpScaling
// 0x0000 (0x0098 - 0x0098)
class UTgGameplayCurvesSet_SpinUpScaling : public UTgGameplayCurvesSet_Simple
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_SpinUpScaling");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_YagorathMovementAcceleration
// 0x0000 (0x0098 - 0x0098)
class UTgGameplayCurvesSet_YagorathMovementAcceleration : public UTgGameplayCurvesSet_Simple
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_YagorathMovementAcceleration");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_YagorathmovementDeceleration
// 0x0000 (0x0098 - 0x0098)
class UTgGameplayCurvesSet_YagorathmovementDeceleration : public UTgGameplayCurvesSet_Simple
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_YagorathmovementDeceleration");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_YagorathmovementPassiveDeceleration
// 0x0000 (0x0098 - 0x0098)
class UTgGameplayCurvesSet_YagorathmovementPassiveDeceleration : public UTgGameplayCurvesSet_Simple
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_YagorathmovementPassiveDeceleration");
		return ptr;
	}

};


// Class TgGame.TgMenuTransitionActor_Chest
// 0x0000 (0x029C - 0x029C)
class ATgMenuTransitionActor_Chest : public ATgMenuTransitionActor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMenuTransitionActor_Chest");
		return ptr;
	}

};


// Class TgGame.TgProj_DistortionField
// 0x0000 (0x0580 - 0x0580)
class ATgProj_DistortionField : public ATgProj_FreeGrenade
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_DistortionField");
		return ptr;
	}

};


// Class TgGame.TgProj_Frostbolt
// 0x0000 (0x052C - 0x052C)
class ATgProj_Frostbolt : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Frostbolt");
		return ptr;
	}

};


// Class TgGame.TgProj_SaatiUlt
// 0x0000 (0x052C - 0x052C)
class ATgProj_SaatiUlt : public ATgProj_SpeedOverTime
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_SaatiUlt");
		return ptr;
	}

};


}

#ifdef _MSC_VER
	#pragma pack(pop)
#endif
